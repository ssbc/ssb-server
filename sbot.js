#! /usr/bin/env node
(function prelude(content, deps, entry) {
  var cache = {}

  function load (file) {
    var d = deps[file]
    if(cache[file]) return cache[d]
    if(!d) return require(file)
    var fn = content[d[0]] //the actual module
    var module = {exports: {}, parent: file !== entry}
    return cache[file] = fn(
      function (m) {
        if(!deps[file][m]) return require(m)
        else               return load (deps[file][m])
      },
      module,
      module.exports,
      file.substring(file.lastIndexOf('/')),
      file
    )
  }

  return load(entry)
})({
"+02qUDKpzxY2anObpV8cxH7eZB6epx5qWv6WyvcAvcY=":
function (require, module, exports, __dirname, __filename) {
var encodings = require('./lib/encodings');

module.exports = Codec;

function Codec(opts){
  this.opts = opts || {};
  this.encodings = encodings;
}

Codec.prototype._encoding = function(encoding){
  if (typeof encoding == 'string') encoding = encodings[encoding];
  if (!encoding) encoding = encodings.id;
  return encoding;
};

Codec.prototype._keyEncoding = function(opts, batchOpts){
  return this._encoding(batchOpts && batchOpts.keyEncoding
    || opts && opts.keyEncoding
    || this.opts.keyEncoding);
};

Codec.prototype._valueEncoding = function(opts, batchOpts){
  return this._encoding(
    batchOpts && (batchOpts.valueEncoding || batchOpts.encoding)
    || opts && (opts.valueEncoding || opts.encoding)
    || (this.opts.valueEncoding || this.opts.encoding));
};

Codec.prototype.encodeKey = function(key, opts, batchOpts){
  return this._keyEncoding(opts, batchOpts).encode(key);
};

Codec.prototype.encodeValue = function(value, opts, batchOpts){
  return this._valueEncoding(opts, batchOpts).encode(value);
};

Codec.prototype.decodeKey = function(key, opts){
  return this._keyEncoding(opts).decode(key);
};

Codec.prototype.decodeValue = function(value, opts){
  return this._valueEncoding(opts).decode(value);
};

Codec.prototype.encodeBatch = function(ops, opts){
  var self = this;

  return ops.map(function(_op){
    var op = {
      type: _op.type,
      key: self.encodeKey(_op.key, opts, _op)
    };
    if (self.keyAsBuffer(opts, _op)) op.keyEncoding = 'binary';
    if (_op.prefix) op.prefix = _op.prefix;
    if ('value' in _op) {
      op.value = self.encodeValue(_op.value, opts, _op);
      if (self.valueAsBuffer(opts, _op)) op.valueEncoding = 'binary';
    }
    return op;
  });
};

var ltgtKeys = ['lt', 'gt', 'lte', 'gte', 'start', 'end'];

Codec.prototype.encodeLtgt = function(ltgt){
  var self = this;
  var ret = {};
  Object.keys(ltgt).forEach(function(key){
    ret[key] = ltgtKeys.indexOf(key) > -1
      ? self.encodeKey(ltgt[key], ltgt)
      : ltgt[key]
  });
  return ret;
};

Codec.prototype.createStreamDecoder = function(opts){
  var self = this;

  if (opts.keys && opts.values) {
    return function(key, value){
      return {
        key: self.decodeKey(key, opts),
        value: self.decodeValue(value, opts)
      };
    };
  } else if (opts.keys) {
    return function(key) {
      return self.decodeKey(key, opts);
    }; 
  } else if (opts.values) {
    return function(_, value){
      return self.decodeValue(value, opts);
    }
  } else {
    return function(){};
  }
};

Codec.prototype.keyAsBuffer = function(opts){
  return this._keyEncoding(opts).buffer;
};

Codec.prototype.valueAsBuffer = function(opts){
  return this._valueEncoding(opts).buffer;
};


},
"+4mXwdNKLdyzt4FrUCluwPtl/j1FxhZM1EnsfQFKGeI=":
function (require, module, exports, __dirname, __filename) {
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('repeat-string expects a string.');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  }

  while (max > res.length && num > 0) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    if (!num) break;
    str += str;
  }

  return res.substr(0, max);
}


},
"+GY0CaPCoELxgYaGnEBnCvJdrzBdN+ubns7nsax+Zjs=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractChainedBatch (db) {
  this._db         = db
  this._operations = []
  this._written    = false
}

AbstractChainedBatch.prototype._checkWritten = function () {
  if (this._written)
    throw new Error('write() already called on this batch')
}

AbstractChainedBatch.prototype.put = function (key, value) {
  this._checkWritten()

  var err = this._db._checkKey(key, 'key', this._db._isBuffer)
  if (err)
    throw err

  if (!this._db._isBuffer(key)) key = String(key)
  if (!this._db._isBuffer(value)) value = String(value)

  if (typeof this._put == 'function' )
    this._put(key, value)
  else
    this._operations.push({ type: 'put', key: key, value: value })

  return this
}

AbstractChainedBatch.prototype.del = function (key) {
  this._checkWritten()

  var err = this._db._checkKey(key, 'key', this._db._isBuffer)
  if (err) throw err

  if (!this._db._isBuffer(key)) key = String(key)

  if (typeof this._del == 'function' )
    this._del(key)
  else
    this._operations.push({ type: 'del', key: key })

  return this
}

AbstractChainedBatch.prototype.clear = function () {
  this._checkWritten()

  this._operations = []

  if (typeof this._clear == 'function' )
    this._clear()

  return this
}

AbstractChainedBatch.prototype.write = function (options, callback) {
  this._checkWritten()

  if (typeof options == 'function')
    callback = options
  if (typeof callback != 'function')
    throw new Error('write() requires a callback argument')
  if (typeof options != 'object')
    options = {}

  this._written = true

  if (typeof this._write == 'function' )
    return this._write(callback)

  if (typeof this._db._batch == 'function')
    return this._db._batch(this._operations, options, callback)

  process.nextTick(callback)
}

module.exports = AbstractChainedBatch
},
"+VQA95D4MRv//xKDq/6L6SzDVQfX46dZxXN/C8E0JhY=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "_args": [
    [
      "level-sublevel@^6.5.2",
      "/home/dominic/c/scuttlebot/node_modules/secure-scuttlebutt"
    ]
  ],
  "_from": "level-sublevel@>=6.5.2 <7.0.0",
  "_id": "level-sublevel@6.5.4",
  "_inCache": true,
  "_installable": true,
  "_location": "/secure-scuttlebutt/level-sublevel",
  "_nodeVersion": "5.3.0",
  "_npmUser": {
    "email": "dominic.tarr@gmail.com",
    "name": "dominictarr"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {
    "pull-core": "1.0.0"
  },
  "_requested": {
    "name": "level-sublevel",
    "raw": "level-sublevel@^6.5.2",
    "rawSpec": "^6.5.2",
    "scope": null,
    "spec": ">=6.5.2 <7.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/secure-scuttlebutt"
  ],
  "_shasum": "92e6534e7ac3fa35c8bdb121b8a8094a8d1c0826",
  "_shrinkwrap": null,
  "_spec": "level-sublevel@^6.5.2",
  "_where": "/home/dominic/c/scuttlebot/node_modules/secure-scuttlebutt",
  "author": {
    "email": "dominic.tarr@gmail.com",
    "name": "Dominic Tarr",
    "url": "http://dominictarr.com"
  },
  "bugs": {
    "url": "https://github.com/dominictarr/level-sublevel/issues"
  },
  "dependencies": {
    "bytewise": "~1.1.0",
    "levelup": "~0.19.0",
    "ltgt": "~2.1.1",
    "pull-stream": "~2.21.0",
    "typewiselite": "~1.0.0",
    "xtend": "~4.0.0"
  },
  "description": "partition levelup databases",
  "devDependencies": {
    "level": "^1.4.0",
    "level-test": "^2.0.1",
    "monotonic-timestamp": "0.0.8",
    "pull-level": "~1.1.1",
    "rimraf": "~2.1.4",
    "shasum": "0.0.2",
    "stream-to-pull-stream": "~1.2.0",
    "tape": "~2.14.0",
    "through": "~2.3.4"
  },
  "directories": {},
  "dist": {
    "shasum": "92e6534e7ac3fa35c8bdb121b8a8094a8d1c0826",
    "tarball": "http://registry.npmjs.org/level-sublevel/-/level-sublevel-6.5.4.tgz"
  },
  "gitHead": "fa1b7121f9632b637e650cc1ec9b1723b60df864",
  "homepage": "https://github.com/dominictarr/level-sublevel",
  "license": "MIT",
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    }
  ],
  "name": "level-sublevel",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/level-sublevel.git"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "stability": "unstable",
  "testling": {
    "browsers": [
      "android-browser/4.2..latest",
      "chrome/22..latest",
      "chrome/canary",
      "firefox/17..latest",
      "firefox/nightly",
      "ie/8..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest"
    ],
    "files": "test/*.js"
  },
  "version": "6.5.4"
}

},
"+eH9RChpQsBjv3By+lqFL3GP9hPkFjCAAoDQOfTF1Rs=":
function (require, module, exports, __dirname, __filename) {
var ref = require('ssb-ref')

function isObject (o) { return o && 'object' === typeof o }
function isBool (o) { return 'boolean' === typeof o }
function isString (s) { return 'string' === typeof s }

function traverse (obj, each) {
  for (var k in obj) {
    if (!obj[k])
      continue
    if (Array.isArray(obj[k])) {
      obj[k].forEach(function (v) {
        each(v, k)
      })
    } else
      each(obj[k], k)
  }
}

exports.indexLinks = function (message, opts, each) {
  if (typeof opts == 'function') {
    each = opts
    opts = null
  }
  if (typeof opts == 'string')
    opts = { rel: opts }
  if (!opts)
    opts = {}
  var msg  = opts.msg
  var feed = opts.feed
  var blob = opts.blob
  var any  = !(msg || feed || blob)

  traverse(message, function (obj, rel) {
    if (opts.rel && rel !== opts.rel) return

    var r = (typeof obj == 'string') ? obj : obj.link
    if (any) {
      if (!ref.isLink(r)) return
    } else {
      if (msg) {
        if (isBool(msg) && ref.type(r) != 'msg') return 
        if (!isBool(msg) && r != msg) return
      }

      if (feed) {
        if (isBool(feed) && ref.type(r) != 'feed') return 
        if (!isBool(feed) && r != feed) return
      }

      if (blob) {
        if (isBool(blob) && ref.type(r) != 'blob') return 
        if (!isBool(blob) && r != blob) return
      }
    }

    each((typeof obj == 'string') ? { link: obj } : obj, rel)
  })
}

exports.link =
exports.asLink = function (obj, type) {
  if (!obj)
    return null
  if (isString(obj))
    obj = { link: obj }
  return isLink(obj, type) ? obj : null
}

exports.links =
exports.asLinks = function (obj, type) {
  if (!obj)
    return []
  var arr = Array.isArray(obj) ? obj : [obj]
  return arr
    .filter(function (l) { return isLink(l, type) })
    .map(function (o) { return (typeof o == 'string') ? { link: o } : o })
}

var isLink =
exports.isLink = function (obj, type) {
  if (!obj)
    return false
  var r = (isString(obj)) ? obj : obj.link
  return (type) ? (ref.type(r) == type) : ref.isLink(r)
}

},
"+tykN+nmNVsfl/5OqjVYt+sxLnNmg7FfBJFL7Clou+Y=":
function (require, module, exports, __dirname, __filename) {
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn) {
  var args = new Array(arguments.length - 1);
  var i = 0;
  while (i < args.length) {
    args[i++] = arguments[i];
  }
  process.nextTick(function afterTick() {
    fn.apply(null, args);
  });
}

},
"+wzpVyYMDn/9oAcjPgmjsmgzPwwnNlQheOn95A5CntY=":
function (require, module, exports, __dirname, __filename) {
var fs = require('fs')
var path = require('path')
module.exports = {
  _: fs.readFileSync(path.join(__dirname, '../api.md'), 'utf-8'),
  blobs: fs.readFileSync(path.join(__dirname, '../plugins/blobs.md'), 'utf-8'),
  block: fs.readFileSync(path.join(__dirname, '../plugins/block.md'), 'utf-8'),
  friends: fs.readFileSync(path.join(__dirname, '../plugins/friends.md'), 'utf-8'),
  gossip: fs.readFileSync(path.join(__dirname, '../plugins/gossip.md'), 'utf-8'),
  invite: fs.readFileSync(path.join(__dirname, '../plugins/invite.md'), 'utf-8'),
  'private': fs.readFileSync(path.join(__dirname, '../plugins/private.md'), 'utf-8'),
  replicate: fs.readFileSync(path.join(__dirname, '../plugins/replicate.md'), 'utf-8')
}
},
"//LMwiTrBMm6Jh3IKHJrhBmroGwRCec1qby8gwJqBNs=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module character-entities-legacy
 * @fileoverview HTML legacy character entity information.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Expose.
 */

module.exports = require('./index.json');

},
"/DGy1muQpyr4d4O3oag8dsE6CDHRiBeH/B+qRvYKFZ4=":
function (require, module, exports, __dirname, __filename) {
/**
 * Module Dependencies
 */

var noop = function(){};
var co = require('co');

/**
 * Export `wrap-fn`
 */

module.exports = wrap;

/**
 * Wrap a function to support
 * sync, async, and gen functions.
 *
 * @param {Function} fn
 * @param {Function} done
 * @return {Function}
 * @api public
 */

function wrap(fn, done) {
  done = once(done || noop);

  return function() {
    // prevents arguments leakage
    // see https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) args[i] = arguments[i];

    var ctx = this;

    // done
    if (!fn) {
      return done.apply(ctx, [null].concat(args));
    }

    // async
    if (fn.length > args.length) {
      // NOTE: this only handles uncaught synchronous errors
      try {
        return fn.apply(ctx, args.concat(done));
      } catch (e) {
        return done(e);
      }
    }

    // generator
    if (generator(fn)) {
      return co(fn).apply(ctx, args.concat(done));
    }

    // sync
    return sync(fn, done).apply(ctx, args);
  }
}

/**
 * Wrap a synchronous function execution.
 *
 * @param {Function} fn
 * @param {Function} done
 * @return {Function}
 * @api private
 */

function sync(fn, done) {
  return function () {
    var ret;

    try {
      ret = fn.apply(this, arguments);
    } catch (err) {
      return done(err);
    }

    if (promise(ret)) {
      ret.then(function (value) { done(null, value); }, done);
    } else {
      ret instanceof Error ? done(ret) : done(null, ret);
    }
  }
}

/**
 * Is `value` a generator?
 *
 * @param {Mixed} value
 * @return {Boolean}
 * @api private
 */

function generator(value) {
  return value
    && value.constructor
    && 'GeneratorFunction' == value.constructor.name;
}


/**
 * Is `value` a promise?
 *
 * @param {Mixed} value
 * @return {Boolean}
 * @api private
 */

function promise(value) {
  return value && 'function' == typeof value.then;
}

/**
 * Once
 */

function once(fn) {
  return function() {
    var ret = fn.apply(this, arguments);
    fn = noop;
    return ret;
  };
}

},
"/QrpZ6kratD60EWF/gunkTu9GlUc3W4+orm8S0F3OGc=":
function (require, module, exports, __dirname, __filename) {
var cont = require('cont')
var util = require('./util')

var ssbKeys = require('ssb-keys')

function isFunction (f) {
  return 'function' === typeof f
}

function isObject (o) {
  return (
    o && 'object' === typeof o
    && !Buffer.isBuffer(o)
    && !Array.isArray(o)
  )
}

module.exports = function (ssb, keys) {

  if(!ssb.add)
    throw new Error('*must* install feeds on this ssb instance')

  function getPrev(next) {
    ssb.getLatest(keys.id, next)
  }
  function noop (err) {
    if (err) throw err
  }

  var queue = null
  var prev = null
  var writing = false
  var publish =
    cont(function (type, message, cb) {
      // argument variations
      if (isFunction(message))    { cb = message; message = type } // add(msgObj, cbFn)
      else if (isObject(message)) { message.type = type } // add(typeStr, mgObj, cbFn)
      else                        { message = { type: type, value: message } } // add(typeStr, msgStr, cbFn)

      var err = util.isInvalidContent(message)
      if(err) return cb(err)

      return ssb.add.queue(keys.id, function (key, value) {
        return util.create(keys, null, message, value, key)
      }, cb)

      return this
    })

  return {
    id: keys.id,
    keys: keys,
    add: publish,
    publish: publish
  }
}



},
"/U3+Qt2iBQEZft5c8aotkHMNJgoM0ZiyuAoO5GqGUt0=":
function (require, module, exports, __dirname, __filename) {
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = require('path')
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new Error('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var plType
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        plType = stateChar
        patternListStack.push({
          type: plType,
          start: i - 1,
          reStart: re.length
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        re += ')'
        var pl = patternListStack.pop()
        plType = pl.type
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        switch (plType) {
          case '!':
            negativeLists.push(pl)
            re += ')[^/]*?)'
            pl.reEnd = re.length
            break
          case '?':
          case '+':
          case '*':
            re += plType
            break
          case '@': break // the default anyway
        }
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  var regExp = new RegExp('^' + re + '$', flags)

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

},
"/jE9RYl/ubsAARvJ0XhP6UB08/r8UReouf6eyg58vuo=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var State = require('./bl-state')

function isInteger (i) {
  return Number.isFinite(i)
}

function isFunction (f) {
  return 'function' === typeof f
}

function maxDelay(fn, delay) {
  if(!delay) return fn
  return function (a, cb) {
    var timer = setTimeout(function () {
      fn(new Error('pull-reader: read exceeded timeout'), cb)
    }, delay)
    fn(a, function (err, value) {
      clearTimeout(timer)
      cb(err, value)
    })

  }

}

module.exports = function (timeout) {

  var queue = [], read, readTimed, reading = false
  var state = State(), ended, streaming, abort

  function drain () {
    while (queue.length) {
      if(null == queue[0].length && state.has(1)) {
        queue.shift().cb(null, state.get())
      }
      else if(state.has(queue[0].length)) {
        var next = queue.shift()
        next.cb(null, state.get(next.length))
      }
      else if(ended)
        queue.shift().cb(ended)
      else
        return !!queue.length
    }
    //always read a little data
    return queue.length || !state.has(1) || abort
  }

  function more () {
    var d = drain()
    if(d && !reading)
    if(read && !reading && !streaming) {
      reading = true
      readTimed (null, function (err, data) {
        reading = false
        if(err) {
          ended = err
          return drain()
        }
        state.add(data)
        more()
      })
    }
  }

  function reader (_read) {
    if(abort) {
      while(queue.length) queue.shift().cb(abort)
      return cb && cb(abort)
    }
    readTimed = maxDelay(_read, timeout)
    read = _read
    more()
  }

  reader.abort = function (err, cb) {
    abort = err || true
    if(read) {
      reading = true
      read(abort, function () {
        while(queue.length) queue.shift().cb(abort)
        cb && cb(abort)
      })
    }
    else
      cb()
  }

  reader.read = function (len, timeout, cb) {
    if(isFunction(timeout))
      cb = timeout, timeout = 0
    if(isFunction(cb)) {
      queue.push({length: isInteger(len) ? len : null, cb: cb})
      more()
    }
    else {
      //switch into streaming mode for the rest of the stream.
      streaming = true
      //wait for the current read to complete
      return function (abort, cb) {
        //if there is anything still in the queue,
        if(reading || state.has(1)) {
          if(abort) return read(abort, cb)
          queue.push({length: null, cb: cb})
          more()
        }
        else
          maxDelay(read, timeout)(abort, function (err, data) {
            cb(err, data)
          })
      }
    }
  }

  return reader
}




},
"0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=":
function (require, module, exports, __dirname, __filename) {
var drain = exports.drain = function (read, op, done) {

  ;(function next() {
    var loop = true, cbed = false
    while(loop) {
      cbed = false
      read(null, function (end, data) {
        cbed = true
        if(end) {
          loop = false
          done && done(end === true ? null : end)
        }
        else if(op && false === op(data)) {
          loop = false
          read(true, done || function () {})
        }
        else if(!loop){
          next()
        }
      })
      if(!cbed) {
        loop = false
        return
      }
    }
  })()
}

var onEnd = exports.onEnd = function (read, done) {
  return drain(read, null, done)
}

var log = exports.log = function (read, done) {
  return drain(read, function (data) {
    console.log(data)
  }, done)
}


},
"0ctY+ep4+F5/Kvk7cLkYlpHMnljPFrV5iNuugfJJSU0=":
function (require, module, exports, __dirname, __filename) {
// If `Date.now()` is invoked twice quickly, it's possible to get two
// identical time stamps. To avoid generation duplications, subsequent
// calls are manually ordered to force uniqueness.

var _last = 0
var _count = 1
var adjusted = 0
var _adjusted = 0

module.exports =
function timestamp() {
  /**
  Returns NOT an accurate representation of the current time.
  Since js only measures time as ms, if you call `Date.now()`
  twice quickly, it's possible to get two identical time stamps.
  This function guarantees unique but maybe inaccurate results
  on each call.
  **/
  //uncomment this wen
  var time = Date.now()
  //time = ~~ (time / 1000) 
  //^^^uncomment when testing...

  /**
  If time returned is same as in last call, adjust it by
  adding a number based on the counter. 
  Counter is incremented so that next call get's adjusted properly.
  Because floats have restricted precision, 
  may need to step past some values...
  **/
  if (_last === time)  {
    do {
      adjusted = time + ((_count++) / (_count + 999))
    } while (adjusted === _adjusted)
    _adjusted = adjusted
  }
  // If last time was different reset timer back to `1`.
  else {
    _count = 1
    adjusted = time
  }
  _adjusted = adjusted
  _last = time
  return adjusted
}

},
"1NMiF4d3VSn1vGR25TOPKP81tu9/9wUCv/qXPAlCNdA=":
function (require, module, exports, __dirname, __filename) {
const levelup = require('levelup')

function packager (leveldown) {
  function Level (location, options, callback) {
    if (typeof options === 'function')
      callback = options
    if (!(typeof options === 'object' && options !== null))
      options  = {}

    options.db = leveldown

    return levelup(location, options, callback)
  }

  [ 'destroy', 'repair' ].forEach(function (m) {
    if (typeof leveldown[m] === 'function') {
      Level[m] = function (location, callback) {
        leveldown[m](location, callback || function () {})
      }
    }
  })

  return Level
}

module.exports = packager

},
"1UZqa40nXIniHtC2j0Slwvi8ss2NOs9Hm0wDzIMRZOI=":
function (require, module, exports, __dirname, __filename) {

var Through = require('pull-through')
var Reader = require('pull-reader')

var BUFFER = 0, STRING = 1, OBJECT = 2

var GOODBYE = 'GOODBYE'
var isBuffer = Buffer.isBuffer

function isString (s) {
  return 'string' === typeof s
}

function encodePair (msg) {

  var head = new Buffer(9)
  var flags = 0
  var value = msg.value !== undefined ? msg.value : msg.end

  //final packet
  if(isString(msg) && msg === GOODBYE) {
    head.fill(0)
    return [head, null]
  }

  if(isString(value)) {
    flags = STRING
    value = new Buffer(value)
  }
  else if(isBuffer(value)) {
    flags = BUFFER
  }
  else {
    flags = OBJECT
    value = new Buffer(JSON.stringify(value))
  }

  // does this frame represent a msg, a req, or a stream?

  //end, stream

  flags = msg.stream << 3 | msg.end << 2 | flags

  head[0] = flags

  head.writeUInt32BE(value.length, 1)
  head.writeInt32BE(msg.req || 0, 5)

  return [head, value]
}

function decodeHead (bytes) {
  if(bytes.length != 9)
    throw new Error('expected header to be 9 bytes long')
  var flags = bytes[0]
  var length = bytes.readUInt32BE(1)
  var req = bytes.readInt32BE(5)

  return {
    req    : req,
    stream : !!(flags & 8),
    end    : !!(flags & 4),
    value  : null,
    length : length,
    type   : flags & 3
  }
}

function decodeBody (bytes, msg) {
  if(bytes.length !== msg.length)
    throw new Error('incorrect length, expected:'+msg.length+' found:'+bytes.length)
  if(BUFFER === msg.type) msg.value = bytes
  else if(STRING === msg.type) msg.value = bytes.toString()
  else if(OBJECT === msg.type) msg.value = JSON.parse(bytes.toString())
  else throw new Error('unknown message type')
  return msg
}

function encode () {
  return Through(function (d) {
    var c = encodePair(d)
    this.queue(c[0])
    if(c[1] !== null)
      this.queue(c[1])
  })
}

function decode () {
  var reader = Reader(), ended = false

  return function (read) {
    reader(read)

    return function (abort, cb) {
      if(ended) return cb(true)
      if(abort) return reader.abort(abort, cb)
      reader.read(9, function (err, head) {
        if(err) return cb(err)
        var msg = decodeHead(head)
        if(msg.length === 0) { //final packet
          ended = true
          return cb(null, GOODBYE)
        }
        reader.read(msg.length, function (err, body) {
          if(err) return cb(err)
          decodeBody(body, msg)
          cb(null, msg)
        })
      })
    }
  }
}

exports = module.exports = function (stream) {
  return {
    source: encode()(stream.source),
    sink: function (read) { return stream.sink(decode()(read)) }
  }
}

exports.encodePair = encodePair
exports.decodeHead = decodeHead
exports.decodeBody = decodeBody

exports.encode = encode
exports.decode = decode


},
"20LcHqLoZj06jjCwfxhvw4Gc6XjQwAQJLol4KLZ+X8M=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var pull = require('pull-stream')

function isString (s) {
  return 'string' === typeof s
}

var isArray = Array.isArray

function isObject (o) {
  return o && 'object' === typeof o && !isArray(o)
}

function isEmpty (obj) {
  for(var k in obj) return false;
  return true
}

//I wrote set as part of permissions.js
//and then later mount, they do nearly the same thing
//but not quite. this should be refactored sometime.
//what differs is that set updates the last key in the path
//to the new value, but mount merges the last value
//which makes sense if it's an object, and set makes sense if it's
//a string/number/boolean.

exports.set = function (obj, path, value) {
  var _obj, _k
  for(var i = 0; i < path.length; i++) {
    var k = path[i]
    obj[k] = obj[k] || {}
    _obj = obj; _k = k
    obj = obj[k]
  }
  _obj[_k] = value
}

exports.get = function (obj, path) {
  if(isString(path)) return obj[path]
  var value
  for(var i = 0; i < path.length; i++) {
    var k = path[i]
    value = obj = obj[k]
    if(null == obj) return obj
  }
  return value
}

exports.prefix = function (obj, path) {
  var value, parent = obj

  for(var i = 0; i < path.length; i++) {
    var k = path[i]
    value = obj = obj[k]
    if('object' !== typeof obj) {
      return obj
    }
    parent = obj
  }
  return 'object' !== typeof value ? !!value : false
}


function mkPath(obj, path) {
  for(var i in path) {
    var key = path[i]
    if(!obj[key]) obj[key]={}
    obj = obj[key]
  }

  return obj
}

function rmPath (obj, path) {
  (function r (obj, i) {
    var key = path[i]
    if(!obj) return
    else if(path.length - 1 === i)
      delete obj[key]
    else if(i < path.length) r(obj[key], i+1)
    if(isEmpty(obj[key])) delete obj[key]
  })(obj, 0)
}

function merge (obj, _obj) {
  for(var k in _obj)
    obj[k] = _obj[k]
  return obj
}

var mount = exports.mount = function (obj, path, _obj) {
  if(!Array.isArray(path))
    throw new Error('path must be array of strings')
  return merge(mkPath(obj, path), _obj)
}
var unmount = exports.unmount = function (obj, path) {
  return rmPath(obj, path)
}

function isSource    (t) { return 'source' === t }
function isSink      (t) { return 'sink'   === t }
function isDuplex    (t) { return 'duplex' === t }
function isSync      (t) { return 'sync'  === t }
function isAsync     (t) { return 'async'  === t }
function isRequest   (t) { return isSync(t) || isAsync(t) }
function isStream    (t) { return isSource(t) || isSink(t) || isDuplex(t) }

function abortSink (err) {
  return function (read) {
    read(err || true, function () {})
  }
}

function abortDuplex (err) {
  return {source: pull.error(err), sink: abortSink(err)}
}

exports.errorAsStream = function (type, err) {
  return (
      isSource(type)  ? pull.error(err)
    : isSink(type)    ? abortSink(err)
    :                   abortDuplex(err)
  )
}


exports.errorAsStreamOrCb = function (type, err, cb) {
  return (
      isRequest(type) ? cb(err)
    : isSource(type)  ? pull.error(err)
    : isSink(type)    ? abortSink(err)
    :                   cb(err), abortDuplex(err)
  )
}

exports.pipeToStream = function (type, _stream, stream) {
  if(isSource(type))
    _stream(stream)
  else if (isSink(type))
    stream(_stream)
  else if (isDuplex(type))
    pull(_stream, stream, _stream)
}


},
"2HyRSyRfLvbUskSdeq07Yj83d3wHbC/HYHhgVkKHaY4=":
function (require, module, exports, __dirname, __filename) {
// TODO: standard bytewise encoding constructor
// TODO: enhance binary encoding with optional hex helpers
module.exports = require('./binary')
},
"2RC/elF2uATerE/39k8kB6DW5ppOJNq4dpc23HhSNRE=":
function (require, module, exports, __dirname, __filename) {
var path = require('path')
var home = require('osenv').home
var nonPrivate = require('non-private-ip')
var merge = require('deep-extend')

var RC = require('rc')

var SEC = 1e3
var MIN = 60*SEC

module.exports = function (name, override) {
  name = name || 'ssb'
  return RC(name || 'ssb', merge({
    //just use an ipv4 address by default.
    //there have been some reports of seemingly non-private
    //ipv6 addresses being returned and not working.
    //https://github.com/ssbc/scuttlebot/pull/102
    party: true,
    host: nonPrivate.v4 || '',
    port: 8008,
    timeout: 0,
    pub: true,
    local: true,
    friends: {
      dunbar: 150,
      hops: 3
    },
    gossip: {
      connections: 3
    },
    path: path.join(home(), '.' + name),
    timers: {
      connection: 0,
      reconnect: 5*SEC,
      ping: 5*MIN,
      handshake: 5*SEC
    },
    path: path.join(home(), '.' + name),
    master: [],
    logging: { level: 'notice' },
    party: true //disable quotas
  }, override || {}))
}





},
"2UFIiuKkR2dNc7RiBRWVKGn/sBVzPDkoOR8f6XiEoAM=":
function (require, module, exports, __dirname, __filename) {

exports.utf8 = exports['utf-8'] = {
  encode: function(data){
    return isBinary(data)
      ? data
      : String(data);
  },
  decode: identity,
  buffer: false,
  type: 'utf8'
};

exports.json = {
  encode: JSON.stringify,
  decode: JSON.parse,
  buffer: false,
  type: 'json'
};

exports.binary = {
  encode: function(data){
    return isBinary(data)
      ? data
      : new Buffer(data);      
  },
  decode: identity,
  buffer: true,
  type: 'binary'
};

exports.id = {
  encode: function(data){
    return data;
  },
  decode: function(data){
    return data;
  },
  buffer: false,
  type: 'id'
};

var bufferEncodings = [
  'hex',
  'ascii',
  'base64',
  'ucs2',
  'ucs-2',
  'utf16le',
  'utf-16le'
];

bufferEncodings.forEach(function(type){
  exports[type] = {
    encode: function(data){
      return isBinary(data)
        ? data
        : new Buffer(data, type);
    },
    decode: function(buffer){
      return buffer.toString(type);
    },
    buffer: true,
    type: type
  };
});

function identity(value){
  return value;
}

function isBinary(data){
  return data === undefined
    || data === null
    || Buffer.isBuffer(data);
}


},
"2XXXxab8wU2/aMB8qUaXjM5eMitPzHYrOm/liKVXJcE=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var util = require('../util')
var pull = require('pull-stream')
//var BSS = require('binary-sorted-set')
//var deepEqual = require('deep-equal')
//var ltgt = require('ltgt')

var createMemIndex = require('../indexes/memory')

var LO = null, HI = undefined

module.exports = function (db, query, opts) {

  var filter = util.createFilter(query)

  //set opts.index = false to disable indexing
  var enabled = !(opts && opts.index === false)

  //get indexes to be built.
  var indexes = query.map(function (q) {
    return db.getIndex([q.path]) ? null : createMemIndex([q.path])
  }).filter(Boolean)

  return {
    query: query,
    exec: function () {
      return pull(
        db.scan(),
        pull.filter(function (data) {
          if(enabled)
            indexes.forEach(function (index) {
              if(index.post) index.post(data)
            })
          return filter(data.value)
        }),
        function (read) {
          return function (abort, cb) {
            read(abort, function (end, data) {
              if(enabled && end === true && !abort)
                indexes.forEach(function (index) {
                  if(!db.getIndex(index.path))
                    db.indexes.push(index)
                })
              cb(end, data)
            })
          }
        }
      )
    }
  }
}

},
"2dZpnXaBuFy0yVSQdKMtPSMDtfIh2XYk0nENBqp17Zg=":
function (require, module, exports, __dirname, __filename) {
var broadcast = require('broadcast-stream')

// local plugin
// broadcasts the address:port:pubkey triple of the sbot server
// on the LAN, using multicast UDP

function isFunction (f) {
  return 'function' === typeof f
}

module.exports = {
  name: 'local',
  version: '2.0.0',
  init: function (sbot, config) {

    var local = broadcast(config.port)

    local.on('data', function (buf) {
      if(buf.loopback) return
      var data = buf.toString()
      sbot.gossip.add(data, 'local')
    })

    setInterval(function () {
      // broadcast self
      // TODO: sign beacons, so that receipient can be confidant
      // that is really your id.
      // (which means they can update their peer table)
      // Oh if this includes your local address,
      // then it becomes unforgeable.
      local.write(sbot.getAddress())
    }, 1000)
  }
}


},
"2eoijFIkYbFr3sV8Z/yKK6KysVsx4ka5ds4pJWR528M=":
function (require, module, exports, __dirname, __filename) {
module.exports = require("./lib/_stream_duplex.js")

},
"2lrTeDMPE2OHV8KOq9nAutm2aCTJ2KK63rGPVfPqEk4=":
function (require, module, exports, __dirname, __filename) {
exports.id = 
function (item) {
  return item
}

exports.prop = 
function (map) {  
  if('string' == typeof map) {
    var key = map
    return function (data) { return data[key] }
  }
  return map
}

exports.tester = function (test) {
  if(!test) return exports.id
  if('object' === typeof test
    && 'function' === typeof test.test)
      return test.test.bind(test)
  return exports.prop(test) || exports.id
}

exports.addPipe = addPipe

function addPipe(read) {
  if('function' !== typeof read)
    return read

  read.pipe = read.pipe || function (reader) {
    if('function' != typeof reader)
      throw new Error('must pipe to reader')
    return addPipe(reader(read))
  }
  read.type = 'Source'
  return read
}

var Source =
exports.Source =
function Source (createRead) {
  function s() {
    var args = [].slice.call(arguments)
    return addPipe(createRead.apply(null, args))
  }
  s.type = 'Source'
  return s
}


var Through =
exports.Through = 
function (createRead) {
  return function () {
    var args = [].slice.call(arguments)
    var piped = []
    function reader (read) {
      args.unshift(read)
      read = createRead.apply(null, args)
      while(piped.length)
        read = piped.shift()(read)
      return read
      //pipeing to from this reader should compose...
    }
    reader.pipe = function (read) {
      piped.push(read) 
      if(read.type === 'Source')
        throw new Error('cannot pipe ' + reader.type + ' to Source')
      reader.type = read.type === 'Sink' ? 'Sink' : 'Through'
      return reader
    }
    reader.type = 'Through'
    return reader
  }
}

var Sink =
exports.Sink = 
function Sink(createReader) {
  return function () {
    var args = [].slice.call(arguments)
    if(!createReader)
      throw new Error('must be createReader function')
    function s (read) {
      args.unshift(read)
      return createReader.apply(null, args)
    }
    s.type = 'Sink'
    return s
  }
}


exports.maybeSink = 
exports.maybeDrain = 
function (createSink, cb) {
  if(!cb)
    return Through(function (read) {
      var ended
      return function (close, cb) {
        if(close) return read(close, cb)
        if(ended) return cb(ended)

        createSink(function (err, data) {
          ended = err || true
          if(!err) cb(null, data)
          else     cb(ended)
        }) (read)
      }
    })()

  return Sink(function (read) {
    return createSink(cb) (read)
  })()
}


},
"3/c/dHGL7b5sk6QLh7JdsthKwZLs/wQLgrqjVp8kVIA=":
function (require, module, exports, __dirname, __filename) {
var assert = require('./util').assert
var base = require('./base')
var codecs = require('./codecs')

var bytewise = exports

//
// expose type information
//
var sorts = bytewise.sorts = base.sorts
bytewise.bound = base.bound
bytewise.compare = base.compare
bytewise.equal = base.equal

//
// generate a buffer with type's byte prefix from source value
//
function serialize(type, source, options) {
  var codec = type.codec
  if (!codec)
    return postEncode(new Buffer([ type.byte ]), options)

  var buffer = codec.encode(source, bytewise)

  if (options && options.nested && codec.escape)
    buffer = codec.escape(buffer)

  var hint = typeof codec.length === 'number' ? (codec.length + 1) : void 0 
  var buffers = [ new Buffer([ type.byte ]), buffer ]
  return postEncode(Buffer.concat(buffers, hint), options)
}

//
// core encode logic
//
bytewise.encode = function(source, options) {

  // check for invalid/incomparable values
  assert(!base.invalid(source), 'Invalid value')

  // encode bound types (ranges)
  var boundary = base.bound.getBoundary(source)
  if (boundary)
    return boundary.encode(source, bytewise)

  // encode standard value-typed sorts
  var order = base.order
  var sort
  for (var i = 0, length = order.length; i < length; ++i) {
    sort = sorts[order[i]]

    if (sort.is(source)) {

      // loop over any subsorts defined on sort
      // TODO: clean up
      var subsorts = sort.sorts ||  { '': sort }
      for (key in subsorts) {
        var subsort = subsorts[key]
        if (subsort.is(source)) 
          return serialize(subsort, source, options)
      }

      // source is an unsupported subsort
      assert(false, 'Unsupported sort value')
    }
  }

  // no type descriptor found
  assert(false, 'Unknown value')
}

//
// core decode logic
//
bytewise.decode = function (buffer, options) {
  // attempt to decode string input using configurable codec
  if (typeof buffer === 'string') {
    buffer = bytewise.stringCodec.encode(buffer)
  }

  assert(!buffer || !buffer.undecodable, 'Encoded value not decodable')

  var byte = buffer[0]
  var type = bytewise.getType(byte)
  assert(type, 'Invalid encoding: ' + buffer)

  // if type provides a decoder it is passed the base type system as second arg
  var codec = type.codec
  if (codec) {
    var decoded = codec.decode(buffer.slice(1), bytewise)

    if (options && options.nested && codec.unescape)
      decoded = codec.unescape(decoded)

    return postDecode(decoded, options)
  }

  // nullary types without a codec must provide a value for their decoded form
  assert('value' in type, 'Unsupported encoding: ' + buffer)
  return postDecode(type.value, options)
}

//
// process top level
//
function postEncode(encoded, options) {
  if (options === null)
    return encoded

  return bytewise.postEncode(encoded, options)
}

//
// invoked after encoding with encoded buffer instance
//
bytewise.postEncode = function (encoded, options) {

  // override buffer toString method to default to hex to help coercion issues
  // TODO: just return pure buffer, do this toString hackery in bytewise
  encoded.toString = function (encoding) {
    if (!encoding)
      return bytewise.stringCodec.decode(encoded)

    return Buffer.prototype.toString.apply(encoded, arguments)
  }

  return encoded
}

function postDecode(decoded, options) {
  if (options === null)
    return decoded

  return bytewise.postDecode(decoded, options)
}

//
// invoked after decoding with decoded value
//
bytewise.postDecode = function (decoded, options) {
  return decoded
}


//
// registry mapping byte prefixes to type descriptors
//
var PREFIX_REGISTRY

function registerType(type) {
  var byte = type && type.byte
  if (byte == null)
    return

  if (byte in PREFIX_REGISTRY)
    assert.deepEqual(type, PREFIX_REGISTRY[byte], 'Duplicate prefix: ' + byte)

  PREFIX_REGISTRY[type.byte] = type
}

function registerTypes(types) {
  for (var key in types) {
    registerType(types[key])
  }
}

//
// look up type descriptor associated with a given byte prefix
//
bytewise.getType = function (byte) {

  // construct and memoize byte prefix registry on first run
  if (!PREFIX_REGISTRY) {
    PREFIX_REGISTRY = {}

    // register sorts
    var sort
    for (var key in sorts) {
      sort = sorts[key]

      // if sort has subsorts register these instead
      sort.sorts ? registerTypes(sort.sorts) : registerType(sort)
    }
  }

  return PREFIX_REGISTRY[byte]
}

bytewise.buffer = true
bytewise.stringCodec = codecs.HEX
bytewise.type = 'bytewise-core'


},
"30c9v2utt2sCEhl0MtgnsAkPPbR0Lx8gzVQCLhit4o4=":
function (require, module, exports, __dirname, __filename) {

module.exports = function () {
  var _read, cbs = [], _end

  var read = function (end, cb) {
    if(!_read) {
      _end = end
      cbs.push(cb)
    } 
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    while(cbs.length)
      _read(_end, cbs.shift())
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}


},
"3TZB2m/ZDk8f7T/1Yp66wuhMydajJoY6l2d0tEc5axk=":
function (require, module, exports, __dirname, __filename) {
function inequality (a, b) {
  return a === b ? 0 : a < b ? -1 : 1
}

function buffercmp (a, b) {
  var l = Math.min(a.length, b.length)
  for(var i = 0; i < l; i++)
    if(a[i] !== b[i]) return inequality(a[i], b[i])
  return a.length - b.length
}

function arraycmp (a, b) {
  var l = Math.min(a.length, b.length)
  for(var i = 0; i < l; i++) {
    var c = compare(a[i], b[i])
    if(c) return c
  }

  return inequality(a.length, b.length)

}

var comparators = [
  inequality, // null
  inequality, // boolean
  inequality, // number
  buffercmp,  // buffer
  inequality, // string
  ,           // object
  arraycmp,   // array
  inequality  // undefined
]

function getType (v) {
  if(v === null)         return 0
  var t = typeof v
  if(t === 'boolean')    return 1
  if(t === 'number')     return 2
  if(Buffer.isBuffer(v)) return 3
  if(Array.isArray(v))   return 6
  if(t === 'string')     return 4
  if(t === 'undefined')  return 7

  throw new Error('comparing objects or functions is not supported')
  //                     return 5
}

function compare (a, b) {
  var t = getType(a)
  return inequality(t, getType(b)) || comparators[t](a, b)
}

module.exports = compare

module.exports.equal = function (a, b) {
  return compare(a, b) === 0
}

},
"3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=":
function (require, module, exports, __dirname, __filename) {
var drain = exports.drain = function (read, op, done) {

  ;(function next() {
    var loop = true, cbed = false
    while(loop) {
      cbed = false
      read(null, function (end, data) {
        cbed = true
        if(end) {
          loop = false
          if(done) done(end === true ? null : end)
          else if(end && end !== true)
            throw end
        }
        else if(op && false === op(data)) {
          loop = false
          read(true, done || function () {})
        }
        else if(!loop){
          next()
        }
      })
      if(!cbed) {
        loop = false
        return
      }
    }
  })()
}

var onEnd = exports.onEnd = function (read, done) {
  return drain(read, null, done)
}

var log = exports.log = function (read, done) {
  return drain(read, function (data) {
    console.log(data)
  }, done)
}


},
"3YcQRTxLx5px2zYMUwTwuDOEkyyIkPrrvxfWVLimIB4=":
function (require, module, exports, __dirname, __filename) {
var path        = require('path')
var ssbKeys     = require('ssb-keys')
var config      = require('ssb-config')
var SecretStack = require('secret-stack')
var explain     = require('explain-error')
var path        = require('path')
var fs          = require('fs')

var cap =
  new Buffer('1KHLiKZvAvjbY1ziZEHMXawbCEIM6qwjCDm3VYRan/s=', 'base64')


module.exports = function (keys, opts, cb) {
  if (typeof keys == 'function') {
    cb = keys
    keys = null
    opts = null
  }  
  if (typeof opts == 'function') {
    cb = opts
    opts = null
  }

  keys = keys || ssbKeys.loadOrCreateSync(path.join(config.path, 'secret'))
  opts = opts || {}
  opts.host = opts.host || 'localhost'
  opts.port = opts.port || config.port
  opts.key  = opts.key  || keys.id

  var createNode = SecretStack({appKey: cap})

  var manifest = opts.manifest || (function () {
    try {
      return JSON.parse(fs.readFileSync(
        path.join(config.path, 'manifest.json')
      ))
    } catch (err) {
      throw explain(err, 'could not load manifest file')
    }
  })()

  createNode.createClient({keys: keys, manifest: manifest})(opts, function (err, sbot) {
    if(err) err = explain(err, 'could not connect to sbot')
    cb(err, sbot)
  })
}

},
"3lJwn25LRrm78pI+sFAifvDAzp/AqgWWJN9GdwiVHmE=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},
"3mp3S4LZnwPDKcUo4Q7bYe7pSb5qqd0S0t2xDcwqTLY=":
function (require, module, exports, __dirname, __filename) {


var EventEmitter = require('events').EventEmitter

var inherits = require('util').inherits

inherits(Graphmitter, EventEmitter)

module.exports = Graphmitter

function each(obj, iter) {
  for(var k in obj) iter(k, obj[k])
}

//
// Node / Vertice
//

function Node () {
  this.edges = {}
}

var nproto = Node.prototype

//returns the old data for this edge..
nproto.edge = function (to, data) {
  var _data = this.edges[to]
  this.edges[to] = (data == null ? true : data)
  return _data
}

nproto.has = function (to) {
  return this.edges[to]
}

//also returns the old data for this edge..
nproto.del = function (to, data) {
  var _data = this.edges[to]
  delete this.edges[to]
  return _data
}

nproto.each = function (iter) {
  each(this.edges, iter)
  return this
}

//
// the whole graph
//

function Graphmitter () {
  if(!(this instanceof Graphmitter)) return new Graphmitter()
  this.nodes = {}
}

var proto = Graphmitter.prototype

proto.hasNode = function (n) {
  return !!this.nodes[n]
}

proto.hasEdge = function (f, t) {
  return this.hasNode(f) && !!this.nodes[f].edges[t] != null
}

proto.node = function (n) {
  return this.nodes[n] = this.nodes[n] || new Node(n)
}

proto.get = function (f, t) {
  if(t == null) return this.nodes[f]
  return this.hasNode(f) ? this.nodes[f].edges[t] : null
}

proto.edge = function (from, to, data) {
  data = (data == null ? true : data)
  var f = this.node(from)
  this.node(to)
  var _data = f.edge(to, data)

  if(_data !== data)
    this.emit('edge', from, to, data, _data)
  return this
}

proto.del = function (from, to) {
  var data = this.node(from).del(to)
  if (typeof data !== 'undefined')
    this.emit('del', from, to, data)
  return this
}

proto.each = function (iter) {
  each(this.nodes, iter)
  return this
}

proto.eachEdge = function (iter) {
  each(this.nodes, function (from, n) {
    each(n.edges, function (to, data) {
      iter(from, to, data)
    })
  })
  return this
}

//get a random node
proto.random = function () {
  var keys = Object.keys(this.nodes)
  return keys[~~(keys.length*Math.random())]
}

//add another subgraph
proto.add = function (g2) {
  var g1 = this
  g2.eachEdge(function (from, to, data) {
    g1.edge(from, to, data)
  })
  return this
}

proto.toJSON = function (iter) {
  var g = {}
  this.each(function (k, v) {
    var e = {}
    v.each(function (k, v) {
      e[k] = v
    })
    g[k] = e
  })
  return g
}

//
// graph generators
//

Graphmitter.random = function (nodes, edges, prefix) {
  prefix = prefix || '#'
  if(isNaN(+nodes)) throw new Error('nodes must be a number')
  if(isNaN(+edges)) throw new Error('edges must be a number')

  var n = 0, g = new Graphmitter()

  function rand(n) {
    return prefix+~~(Math.random()*n)
  }

  for(var i = 0; i < nodes; i++)
    g.node(prefix+i)

  for(var i = 0; i < edges; i++) {
    var a = rand(nodes), b = rand(nodes)
    g.edge(a, b).edge(b, a)
  }

  return g
}


var algorithms = require('./algorithms')

for(var k in algorithms) proto[k] = algorithms[k]


},
"41/ZYVYna/Ec5ezAO+/dB5wM4KDiJjL6BiioOb6HNgw=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/*
 * Dependencies.
 */

var repeat = require('repeat-string');

/*
 * Constants.
 */

var TAB = '\t';
var NEWLINE = '\n';
var SPACE = ' ';

/**
 * Replace tabs with spaces, being smart about which
 * column the tab is at and which size should be used.
 *
 * @example
 *   detab('\tfoo\nbar\tbaz'); // '    foo\nbar baz'
 *   detab('\tfoo\nbar\tbaz', 2); // '  foo\nbar baz'
 *   detab('\tfoo\nbar\tbaz', 8); // '        foo\nbar     baz'
 *
 * @param {string} value - Value with tabs.
 * @param {number?} [size=4] - Tab-size.
 * @return {string} - Value without tabs.
 */
function detab(value, size) {
    var string = typeof value === 'string';
    var length = string && value.length;
    var index = -1;
    var column = -1;
    var tabSize = size || 4;
    var result = '';
    var character;
    var add;

    if (!string) {
        throw new Error('detab expected string');
    }

    while (++index < length) {
        character = value.charAt(index);

        if (character === TAB) {
            add = tabSize - ((column + 1) % tabSize);
            result += repeat(SPACE, add);
            column += add;
            continue;
        }

        if (character === NEWLINE) {
            column = -1;
        } else {
            column++;
        }

        result += character;
    }

    return result;
}

/*
 * Expose.
 */

module.exports = detab;

},
"4bpPETYxNRvzB824hWbizJm5WTmXgTLgC1jaLakjLkw=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/*
 * Useful expressions.
 */

var EXPRESSION_DOT = /\./;
var EXPRESSION_LAST_DOT = /\.[^.]*$/;

/*
 * Allowed alignment values.
 */

var LEFT = 'l';
var RIGHT = 'r';
var CENTER = 'c';
var DOT = '.';
var NULL = '';

var ALLIGNMENT = [LEFT, RIGHT, CENTER, DOT, NULL];

/*
 * Characters.
 */

var COLON = ':';
var DASH = '-';
var PIPE = '|';
var SPACE = ' ';
var NEW_LINE = '\n';

/**
 * Get the length of `value`.
 *
 * @param {string} value
 * @return {number}
 */
function lengthNoop(value) {
    return String(value).length;
}

/**
 * Get a string consisting of `length` `character`s.
 *
 * @param {number} length
 * @param {string} [character=' ']
 * @return {string}
 */
function pad(length, character) {
    return Array(length + 1).join(character || SPACE);
}

/**
 * Get the position of the last dot in `value`.
 *
 * @param {string} value
 * @return {number}
 */
function dotindex(value) {
    var match = EXPRESSION_LAST_DOT.exec(value);

    return match ? match.index + 1 : value.length;
}

/**
 * Create a table from a matrix of strings.
 *
 * @param {Array.<Array.<string>>} table
 * @param {Object?} options
 * @param {boolean?} [options.rule=true]
 * @param {string?} [options.delimiter=" | "]
 * @param {string?} [options.start="| "]
 * @param {string?} [options.end=" |"]
 * @param {Array.<string>?} options.align
 * @param {function(string)?} options.stringLength
 * @return {string} Pretty table
 */
function markdownTable(table, options) {
    var settings = options || {};
    var delimiter = settings.delimiter;
    var start = settings.start;
    var end = settings.end;
    var alignment = settings.align;
    var calculateStringLength = settings.stringLength || lengthNoop;
    var cellCount = 0;
    var rowIndex = -1;
    var rowLength = table.length;
    var sizes = [];
    var align;
    var rule;
    var rows;
    var row;
    var cells;
    var index;
    var position;
    var size;
    var value;
    var spacing;
    var before;
    var after;

    alignment = alignment ? alignment.concat() : [];

    if (delimiter === null || delimiter === undefined) {
        delimiter = SPACE + PIPE + SPACE;
    }

    if (start === null || start === undefined) {
        start = PIPE + SPACE;
    }

    if (end === null || end === undefined) {
        end = SPACE + PIPE;
    }

    while (++rowIndex < rowLength) {
        row = table[rowIndex];

        index = -1;

        if (row.length > cellCount) {
            cellCount = row.length;
        }

        while (++index < cellCount) {
            position = row[index] ? dotindex(row[index]) : null;

            if (!sizes[index]) {
                sizes[index] = 3;
            }

            if (position > sizes[index]) {
                sizes[index] = position;
            }
        }
    }

    if (typeof alignment === 'string') {
        alignment = pad(cellCount, alignment).split('');
    }

    /*
     * Make sure only valid alignments are used.
     */

    index = -1;

    while (++index < cellCount) {
        align = alignment[index];

        if (typeof align === 'string') {
            align = align.charAt(0).toLowerCase();
        }

        if (ALLIGNMENT.indexOf(align) === -1) {
            align = NULL;
        }

        alignment[index] = align;
    }

    rowIndex = -1;
    rows = [];

    while (++rowIndex < rowLength) {
        row = table[rowIndex];

        index = -1;
        cells = [];

        while (++index < cellCount) {
            value = row[index];

            if (value === null || value === undefined) {
                value = '';
            } else {
                value = String(value);
            }

            if (alignment[index] !== DOT) {
                cells[index] = value;
            } else {
                position = dotindex(value);

                size = sizes[index] +
                    (EXPRESSION_DOT.test(value) ? 0 : 1) -
                    (calculateStringLength(value) - position);

                cells[index] = value + pad(size - 1);
            }
        }

        rows[rowIndex] = cells;
    }

    sizes = [];
    rowIndex = -1;

    while (++rowIndex < rowLength) {
        cells = rows[rowIndex];

        index = -1;

        while (++index < cellCount) {
            value = cells[index];

            if (!sizes[index]) {
                sizes[index] = 3;
            }

            size = calculateStringLength(value);

            if (size > sizes[index]) {
                sizes[index] = size;
            }
        }
    }

    rowIndex = -1;

    while (++rowIndex < rowLength) {
        cells = rows[rowIndex];

        index = -1;

        while (++index < cellCount) {
            value = cells[index];

            position = sizes[index] - (calculateStringLength(value) || 0);
            spacing = pad(position);

            if (alignment[index] === RIGHT || alignment[index] === DOT) {
                value = spacing + value;
            } else if (alignment[index] !== CENTER) {
                value = value + spacing;
            } else {
                position = position / 2;

                if (position % 1 === 0) {
                    before = position;
                    after = position;
                } else {
                    before = position + 0.5;
                    after = position - 0.5;
                }

                value = pad(before) + value + pad(after);
            }

            cells[index] = value;
        }

        rows[rowIndex] = cells.join(delimiter);
    }

    if (settings.rule !== false) {
        index = -1;
        rule = [];

        while (++index < cellCount) {
            align = alignment[index];

            /*
             * When `align` is left, don't add colons.
             */

            value = align === RIGHT || align === NULL ? DASH : COLON;
            value += pad(sizes[index] - 2, DASH);
            value += align !== LEFT && align !== NULL ? COLON : DASH;

            rule[index] = value;
        }

        rows.splice(1, 0, rule.join(delimiter));
    }

    return start + rows.join(end + NEW_LINE + start) + end;
}

/*
 * Expose `markdownTable`.
 */

module.exports = markdownTable;

},
"4zZh2+OQI3I7yONWheo4F2moOtVJQSUZfVPZRC4BdrE=":
function (require, module, exports, __dirname, __filename) {
var util              = require('util')
  , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
  , DeferredIterator  = require('./deferred-iterator')

function DeferredLevelDOWN (location) {
  AbstractLevelDOWN.call(this, typeof location == 'string' ? location : '') // optional location, who cares?
  this._db         = undefined
  this._operations = []
  this._iterators  = []
}

util.inherits(DeferredLevelDOWN, AbstractLevelDOWN)

// called by LevelUP when we have a real DB to take its place
DeferredLevelDOWN.prototype.setDb = function (db) {
  this._db = db
  this._operations.forEach(function (op) {
    db[op.method].apply(db, op.args)
  })
  this._iterators.forEach(function (it) {
    it.setDb(db)
  })
}

DeferredLevelDOWN.prototype._open = function (options, callback) {
  return process.nextTick(callback)
}

// queue a new deferred operation
DeferredLevelDOWN.prototype._operation = function (method, args) {
  if (this._db)
    return this._db[method].apply(this._db, args)
  this._operations.push({ method: method, args: args })
}

// deferrables
'put get del batch approximateSize'.split(' ').forEach(function (m) {
  DeferredLevelDOWN.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

DeferredLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

DeferredLevelDOWN.prototype._iterator = function (options) {
  if (this._db)
    return this._db.iterator.apply(this._db, arguments)
  var it = new DeferredIterator(options)
  this._iterators.push(it)
  return it
}

module.exports                  = DeferredLevelDOWN
module.exports.DeferredIterator = DeferredIterator

},
"5X5j7KPAcgFaVohmaU/64/2n+E9hM1rokDb3tZfWKxQ=":
function (require, module, exports, __dirname, __filename) {

module.exports = function split (data, max) {

  if(max <= 0) throw new Error('cannot split into zero (or smaller) length buffers')

  if(data.length <= max)
    return [data]
  var out = [], len = 0

  while(len < data.length) {
    out.push(data.slice(len, Math.min(len + max, data.length)))
    len += max
  }

  return out
}


},
"5a1nO6vLB7FxjnzEAWFmNITSM/FiOQy22MEJS+/lCNw=":
function (require, module, exports, __dirname, __filename) {
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},
"5b630ED8lltBkoqSjEh5Aq7a+rWC0OXkntvOcJy7Ago=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module character-entities
 * @fileoverview HTML character entity information.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Expose.
 */

module.exports = require('./index.json');

},
"5cfvpgW0NF9XIpq727oLs8A9i4N5lZiBMtgMuvj2Ijk=":
function (require, module, exports, __dirname, __filename) {
var list = require('continuable-list')
var hash = require('continuable-hash')

module.exports = function (obj, cb) {
  if(Array.isArray(obj))
    return list(obj, cb)
  else if('object' === typeof obj)
    return hash(obj, cb)
  else
    return list([].slice.call(arguments))
}

},
"5kHPgK8/97AW2PCk9SYhRqPIw/ftwmbjaTS/FM500Vw=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var util          = require('./util')
  , WriteError    = require('level-errors').WriteError

  , getOptions    = util.getOptions
  , dispatchError = util.dispatchError

function Batch (levelup, codec) {
  this._levelup = levelup
  this._codec = codec
  this.batch = levelup.db.batch()
  this.ops = []
  this.length = 0
}

Batch.prototype.put = function (key_, value_, options) {
  options = getOptions(options)

  var key   = this._codec.encodeKey(key_, options)
    , value = this._codec.encodeValue(value_, options)

  try {
    this.batch.put(key, value)
  } catch (e) {
    throw new WriteError(e)
  }
  this.ops.push({ type : 'put', key : key, value : value })
  this.length++

  return this
}

Batch.prototype.del = function (key_, options) {
  options = getOptions(options)

  var key = this._codec.encodeKey(key_, options)

  try {
    this.batch.del(key)
  } catch (err) {
    throw new WriteError(err)
  }
  this.ops.push({ type : 'del', key : key })
  this.length++

  return this
}

Batch.prototype.clear = function () {
  try {
    this.batch.clear()
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops = []
  this.length = 0
  return this
}

Batch.prototype.write = function (callback) {
  var levelup = this._levelup
    , ops     = this.ops

  try {
    this.batch.write(function (err) {
      if (err)
        return dispatchError(levelup, new WriteError(err), callback)
      levelup.emit('batch', ops)
      if (callback)
        callback()
    })
  } catch (err) {
    throw new WriteError(err)
  }
}

module.exports = Batch

},
"5peXoNCgcMbQWXYWQsF8BBWmR11ctKOVpxL/IDyfubg=":
function (require, module, exports, __dirname, __filename) {
'use strict';

function posix(path) {
	return path.charAt(0) === '/';
};

function win32(path) {
	// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = !!device && device.charAt(1) !== ':';

	// UNC paths are always absolute
	return !!result[2] || isUnc;
};

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;

},
"5yGyriLdISAp9467ucTTENN7k3wvCwjPOjKh5ZKExkE=":
function (require, module, exports, __dirname, __filename) {
var inherits = require('inherits');
var Readable = require('readable-stream').Readable;
var extend = require('xtend');
var EncodingError = require('level-errors').EncodingError;

module.exports = ReadStream;
inherits(ReadStream, Readable);

function ReadStream(iterator, options){
  if (!(this instanceof ReadStream)) return new ReadStream(iterator, options);
  Readable.call(this, extend(options, {
    objectMode: true
  }));
  this._iterator = iterator;
  this._destroyed = false;
  this._decoder = null;
  if (options && options.decoder) this._decoder = options.decoder;
  this.on('end', this._cleanup.bind(this));
}

ReadStream.prototype._read = function(){
  var self = this;
  if (this._destroyed) return;

  this._iterator.next(function(err, key, value){
    if (self._destroyed) return;
    if (err) return self.emit('error', err);
    if (key === undefined && value === undefined) {
      self.push(null);
    } else {
      if (!self._decoder) return self.push({ key: key, value: value });

      try {
        var value = self._decoder(key, value);
      } catch (err) {
        self.emit('error', new EncodingError(err));
        self.push(null);
        return;
      }
      self.push(value);
    }
  });
};

ReadStream.prototype.destroy =
ReadStream.prototype._cleanup = function(){
  var self = this;
  if (this._destroyed) return;
  this._destroyed = true;

  this._iterator.end(function(err){
    if (err) return self.emit('error', err);
    self.emit('close');
  });
};


},
"6+0EJUY6cZ+zYs2V8FcjxPdpC0MQXyTWQqJ40hix9aU=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var os = require('os');

function homedir() {
	var env = process.env;
	var home = env.HOME;
	var user = env.LOGNAME || env.USER || env.LNAME || env.USERNAME;

	if (process.platform === 'win32') {
		return env.USERPROFILE || env.HOMEDRIVE + env.HOMEPATH || home || null;
	}

	if (process.platform === 'darwin') {
		return home || (user ? '/Users/' + user : null);
	}

	if (process.platform === 'linux') {
		return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null));
	}

	return home || null;
}

module.exports = typeof os.homedir === 'function' ? os.homedir : homedir;

},
"6Cg83+tLiKtzu8++RwJc5ldk4w9G0yFc9U3W5YhJBXI=":
function (require, module, exports, __dirname, __filename) {

var sodium = require('chloride')
var crypto = require('crypto')

module.exports = {

  curves: ['ed25519'],

  generate: function (seed) {
    var keys = sodium.crypto_sign_seed_keypair(seed || crypto.randomBytes(32))
    return {
      curve: 'ed25519',
      public: keys.publicKey,

      //so that this works with either sodium
      //or libsodium-wrappers (in browser)
      private: keys.privateKey || keys.secretKey
    }
  },

  sign: function (private, message) {
    return sodium.crypto_sign_detached(message, private)
  },

  verify: function (public, sig, message) {
    return sodium.crypto_sign_verify_detached(sig, message, public)
  }

}

},
"6MFG4hJ+gurDRhTfiWy0fpUjAPLgUD4DV8gUNVmWlGo=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  decode: function (string) {
    return JSON.parse(string)
  },
  encode: function (obj) {
    return JSON.stringify(obj, null, 2)
  },
  buffer: false
}


},
"6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=":
function (require, module, exports, __dirname, __filename) {
var u = require('pull-core')
var prop = u.prop
var id   = u.id
var maybeSink = u.maybeSink

module.exports = function (pull) {

  var exports = {}
  var drain = pull.drain

  var find =
  exports.find = function (test, cb) {
    return maybeSink(function (cb) {
      var ended = false
      if(!cb)
        cb = test, test = id
      else
        test = prop(test) || id

      return drain(function (data) {
        if(test(data)) {
          ended = true
          cb(null, data)
        return false
        }
      }, function (err) {
        if(ended) return //already called back
        cb(err === true ? null : err, null)
      })

    }, cb)
  }

  var reduce = exports.reduce =
  function (reduce, acc, cb) {

    return maybeSink(function (cb) {
      return drain(function (data) {
        acc = reduce(acc, data)
      }, function (err) {
        cb(err, acc)
      })

    }, cb)
  }

  var collect = exports.collect = exports.writeArray =
  function (cb) {
    return reduce(function (arr, item) {
      arr.push(item)
      return arr
    }, [], cb)
  }

  var concat = exports.concat =
  function (cb) {
    return reduce(function (a, b) {
      return a + b
    }, '', cb)
  }

  return exports
}

},
"6SOB1EXRn1YZyG1xe1IcfW4hTT6etRjZZ6ugaBu+rEs=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module vfile
 * @fileoverview Virtual file format to attach additional
 *   information related to processed input.  Similar to
 *   `wearefractal/vinyl`.  Additionally, `VFile` can be
 *   passed directly to ESLint formatters to visualise
 *   warnings and errors relating to a file.
 * @example
 *   var VFile = require('vfile');
 *
 *   var file = new VFile({
 *     'directory': '~',
 *     'filename': 'example',
 *     'extension': 'txt',
 *     'contents': 'Foo *bar* baz'
 *   });
 *
 *   file.toString(); // 'Foo *bar* baz'
 *   file.filePath(); // '~/example.txt'
 *
 *   file.move({'extension': 'md'});
 *   file.filePath(); // '~/example.md'
 *
 *   file.warn('Something went wrong', {'line': 2, 'column': 3});
 *   // { [~/example.md:2:3: Something went wrong]
 *   //   name: '~/example.md:2:3',
 *   //   file: '~/example.md',
 *   //   reason: 'Something went wrong',
 *   //   line: 2,
 *   //   column: 3,
 *   //   fatal: false }
 */

'use strict';

/* eslint-env commonjs */

var SEPARATOR = '/';

try {
    SEPARATOR = require('pa' + 'th').sep;
} catch (e) { /* empty */ }

/**
 * Construct a new file message.
 *
 * Note: We cannot invoke `Error` on the created context,
 * as that adds readonly `line` and `column` attributes on
 * Safari 9, thus throwing and failing the data.
 *
 * @example
 *   var message = new VFileMessage('Whoops!');
 *
 *   message instanceof Error // true
 *
 * @constructor
 * @class {VFileMessage}
 * @param {string} reason - Reason for messaging.
 * @property {boolean} [fatal=null] - Whether the message
 *   is fatal.
 * @property {string} [name=''] - File-name and positional
 *   information.
 * @property {string} [file=''] - File-path.
 * @property {string} [reason=''] - Reason for messaging.
 * @property {number} [line=null] - Start of message.
 * @property {number} [column=null] - Start of message.
 * @property {Position|Location} [location=null] - Place of
 *   message.
 * @property {string} [stack] - Stack-trace of warning.
 */
function VFileMessage(reason) {
    this.message = reason;
}

/**
 * Inherit from `Error#`.
 */
function VFileMessagePrototype() {}

VFileMessagePrototype.prototype = Error.prototype;

var proto = new VFileMessagePrototype();

VFileMessage.prototype = proto;

/*
 * Expose defaults.
 */

proto.file = proto.name = proto.reason = proto.message = proto.stack = '';
proto.fatal = proto.column = proto.line = null;

/**
 * File-related message with location information.
 *
 * @typedef {Error} VFileMessage
 * @property {string} name - (Starting) location of the
 *   message, preceded by its file-path when available,
 *   and joined by `:`. Used internally by the native
 *   `Error#toString()`.
 * @property {string} file - File-path.
 * @property {string} reason - Reason for message.
 * @property {number?} line - Line of message, when
 *   available.
 * @property {number?} column - Column of message, when
 *   available.
 * @property {string?} stack - Stack of message, when
 *   available.
 * @property {boolean?} fatal - Whether the associated file
 *   is still processable.
 */

/**
 * Stringify a position.
 *
 * @example
 *   stringify({'line': 1, 'column': 3}) // '1:3'
 *   stringify({'line': 1}) // '1:1'
 *   stringify({'column': 3}) // '1:3'
 *   stringify() // '1:1'
 *
 * @private
 * @param {Object?} [position] - Single position, like
 *   those available at `node.position.start`.
 * @return {string} - Compiled location.
 */
function stringify(position) {
    if (!position) {
        position = {};
    }

    return (position.line || 1) + ':' + (position.column || 1);
}

/**
 * ESLint's formatter API expects `filePath` to be a
 * string.  This hack supports invocation as well as
 * implicit coercion.
 *
 * @example
 *   var file = new VFile({
 *     'filename': 'example',
 *     'extension': 'txt'
 *   });
 *
 *   filePath = filePathFactory(file);
 *
 *   String(filePath); // 'example.txt'
 *   filePath(); // 'example.txt'
 *
 * @private
 * @param {VFile} file - Virtual file.
 * @return {Function} - `filePath` getter.
 */
function filePathFactory(file) {
    /**
     * Get the filename, with extension and directory, if applicable.
     *
     * @example
     *   var file = new VFile({
     *     'directory': '~',
     *     'filename': 'example',
     *     'extension': 'txt'
     *   });
     *
     *   String(file.filePath); // ~/example.txt
     *   file.filePath() // ~/example.txt
     *
     * @memberof {VFile}
     * @property {Function} toString - Itself. ESLint's
     *   formatter API expects `filePath` to be `string`.
     *   This hack supports invocation as well as implicit
     *   coercion.
     * @return {string} - If the `vFile` has a `filename`,
     *   it will be prefixed with the directory (slashed),
     *   if applicable, and suffixed with the (dotted)
     *   extension (if applicable).  Otherwise, an empty
     *   string is returned.
     */
    function filePath() {
        var directory = file.directory;
        var separator;

        if (file.filename || file.extension) {
            separator = directory.charAt(directory.length - 1);

            if (separator === '/' || separator === '\\') {
                directory = directory.slice(0, -1);
            }

            if (directory === '.') {
                directory = '';
            }

            return (directory ? directory + SEPARATOR : '') +
                file.filename +
                (file.extension ? '.' + file.extension : '');
        }

        return '';
    }

    filePath.toString = filePath;

    return filePath;
}

/**
* Get the filename with extantion.
*
* @example
*   var file = new VFile({
*     'directory': '~/foo/bar'
*     'filename': 'example',
*     'extension': 'txt'
*   });
*
*   file.basename() // example.txt
*
* @memberof {VFile}
* @return {string} - name of file with extantion.
*/
function basename() {
    var self = this;
    var extension = self.extension;

    if (self.filename || extension) {
        return self.filename + (extension ? '.' + extension : '');
    }

    return '';
}

/**
 * Construct a new file.
 *
 * @example
 *   var file = new VFile({
 *     'directory': '~',
 *     'filename': 'example',
 *     'extension': 'txt',
 *     'contents': 'Foo *bar* baz'
 *   });
 *
 *   file === VFile(file) // true
 *   file === new VFile(file) // true
 *   VFile('foo') instanceof VFile // true
 *
 * @constructor
 * @class {VFile}
 * @param {Object|VFile|string} [options] - either an
 *   options object, or the value of `contents` (both
 *   optional).  When a `file` is passed in, it's
 *   immediately returned.
 * @property {string} [contents=''] - Content of file.
 * @property {string} [directory=''] - Path to parent
 *   directory.
 * @property {string} [filename=''] - Filename.
 *   A file-path can still be generated when no filename
 *   exists.
 * @property {string} [extension=''] - Extension.
 *   A file-path can still be generated when no extension
 *   exists.
 * @property {boolean?} quiet - Whether an error created by
 *   `VFile#fail()` is returned (when truthy) or thrown
 *   (when falsey). Ensure all `messages` associated with
 *   a file are handled properly when setting this to
 *   `true`.
 * @property {Array.<VFileMessage>} messages - List of associated
 *   messages.
 */
function VFile(options) {
    var self = this;

    /*
     * No `new` operator.
     */

    if (!(self instanceof VFile)) {
        return new VFile(options);
    }

    /*
     * Given file.
     */

    if (
        options &&
        typeof options.message === 'function' &&
        typeof options.hasFailed === 'function'
    ) {
        return options;
    }

    if (!options) {
        options = {};
    } else if (typeof options === 'string') {
        options = {
            'contents': options
        };
    }

    self.contents = options.contents || '';

    self.messages = [];

    /*
     * Make sure eslints formatters stringify `filePath`
     * properly.
     */

    self.filePath = filePathFactory(self);

    self.history = [];

    self.move({
        'filename': options.filename,
        'directory': options.directory,
        'extension': options.extension
    });
}

/**
 * Get the value of the file.
 *
 * @example
 *   var vFile = new VFile('Foo');
 *   String(vFile); // 'Foo'
 *
 * @this {VFile}
 * @memberof {VFile}
 * @return {string} - value at the `contents` property
 *   in context.
 */
function toString() {
    return this.contents;
}

/**
 * Move a file by passing a new directory, filename,
 * and extension.  When these are not given, the default
 * values are kept.
 *
 * @example
 *   var file = new VFile({
 *     'directory': '~',
 *     'filename': 'example',
 *     'extension': 'txt',
 *     'contents': 'Foo *bar* baz'
 *   });
 *
 *   file.move({'directory': '/var/www'});
 *   file.filePath(); // '/var/www/example.txt'
 *
 *   file.move({'extension': 'md'});
 *   file.filePath(); // '/var/www/example.md'
 *
 * @this {VFile}
 * @memberof {VFile}
 * @param {Object?} [options] - Configuration.
 * @return {VFile} - Context object.
 */
function move(options) {
    var self = this;
    var before = self.filePath();
    var after;

    if (!options) {
        options = {};
    }

    self.directory = options.directory || self.directory || '';
    self.filename = options.filename || self.filename || '';
    self.extension = options.extension || self.extension || '';

    after = self.filePath();

    if (after && before !== after) {
        self.history.push(after);
    }

    return self;
}

/**
 * Create a message with `reason` at `position`.
 * When an error is passed in as `reason`, copies the
 * stack.  This does not add a message to `messages`.
 *
 * @example
 *   var file = new VFile();
 *
 *   file.message('Something went wrong');
 *   // { [1:1: Something went wrong]
 *   //   name: '1:1',
 *   //   file: '',
 *   //   reason: 'Something went wrong',
 *   //   line: null,
 *   //   column: null }
 *
 * @this {VFile}
 * @memberof {VFile}
 * @param {string|Error} reason - Reason for message.
 * @param {Node|Location|Position} [position] - Location
 *   of message in file.
 * @return {VFileMessage} - File-related message with
 *   location information.
 */
function message(reason, position) {
    var filePath = this.filePath();
    var range;
    var err;
    var location = {
        'start': {
            'line': null,
            'column': null
        },
        'end': {
            'line': null,
            'column': null
        }
    };

    /*
     * Node / location / position.
     */

    if (position && position.position) {
        position = position.position;
    }

    if (position && position.start) {
        range = stringify(position.start) + '-' + stringify(position.end);
        location = position;
        position = position.start;
    } else {
        range = stringify(position);

        if (position) {
            location.start = position;
            location.end.line = null;
            location.end.column = null;
        }
    }

    err = new VFileMessage(reason.message || reason);

    err.name = (filePath ? filePath + ':' : '') + range;
    err.file = filePath;
    err.reason = reason.message || reason;
    err.line = position ? position.line : null;
    err.column = position ? position.column : null;
    err.location = location;

    if (reason.stack) {
        err.stack = reason.stack;
    }

    return err;
}

/**
 * Warn. Creates a non-fatal message (see `VFile#message()`),
 * and adds it to the file's `messages` list.
 *
 * @example
 *   var file = new VFile();
 *
 *   file.warn('Something went wrong');
 *   // { [1:1: Something went wrong]
 *   //   name: '1:1',
 *   //   file: '',
 *   //   reason: 'Something went wrong',
 *   //   line: null,
 *   //   column: null,
 *   //   fatal: false }
 *
 * @see VFile#message
 * @this {VFile}
 * @memberof {VFile}
 */
function warn() {
    var err = this.message.apply(this, arguments);

    err.fatal = false;

    this.messages.push(err);

    return err;
}

/**
 * Fail. Creates a fatal message (see `VFile#message()`),
 * sets `fatal: true`, adds it to the file's
 * `messages` list.
 *
 * If `quiet` is not `true`, throws the error.
 *
 * @example
 *   var file = new VFile();
 *
 *   file.fail('Something went wrong');
 *   // 1:1: Something went wrong
 *   //     at VFile.exception (vfile/index.js:296:11)
 *   //     at VFile.fail (vfile/index.js:360:20)
 *   //     at repl:1:6
 *
 *   file.quiet = true;
 *   file.fail('Something went wrong');
 *   // { [1:1: Something went wrong]
 *   //   name: '1:1',
 *   //   file: '',
 *   //   reason: 'Something went wrong',
 *   //   line: null,
 *   //   column: null,
 *   //   fatal: true }
 *
 * @this {VFile}
 * @memberof {VFile}
 * @throws {VFileMessage} - When not `quiet: true`.
 * @param {string|Error} reason - Reason for failure.
 * @param {Node|Location|Position} [position] - Place
 *   of failure in file.
 * @return {VFileMessage} - Unless thrown, of course.
 */
function fail(reason, position) {
    var err = this.message(reason, position);

    err.fatal = true;

    this.messages.push(err);

    if (!this.quiet) {
        throw err;
    }

    return err;
}

/**
 * Check if a fatal message occurred making the file no
 * longer processable.
 *
 * @example
 *   var file = new VFile();
 *   file.quiet = true;
 *
 *   file.hasFailed(); // false
 *
 *   file.fail('Something went wrong');
 *   file.hasFailed(); // true
 *
 * @this {VFile}
 * @memberof {VFile}
 * @return {boolean} - `true` if at least one of file's
 *   `messages` has a `fatal` property set to `true`
 */
function hasFailed() {
    var messages = this.messages;
    var index = -1;
    var length = messages.length;

    while (++index < length) {
        if (messages[index].fatal) {
            return true;
        }
    }

    return false;
}

/**
 * Access metadata.
 *
 * @example
 *   var file = new VFile('Foo');
 *
 *   file.namespace('foo').bar = 'baz';
 *
 *   console.log(file.namespace('foo').bar) // 'baz';
 *
 * @this {VFile}
 * @memberof {VFile}
 * @param {string} key - Namespace key.
 * @return {Object} - Private space.
 */
function namespace(key) {
    var self = this;
    var space = self.data;

    if (!space) {
        space = self.data = {};
    }

    if (!space[key]) {
        space[key] = {};
    }

    return space[key];
}

/*
 * Methods.
 */

var vFilePrototype = VFile.prototype;

vFilePrototype.basename = basename;
vFilePrototype.move = move;
vFilePrototype.toString = toString;
vFilePrototype.message = message;
vFilePrototype.warn = warn;
vFilePrototype.fail = fail;
vFilePrototype.hasFailed = hasFailed;
vFilePrototype.namespace = namespace;

/*
 * Expose.
 */

module.exports = VFile;

},
"6mN7qg2JTTHuyVf5+ktg0HZ1NoNM7Y1FIsSbo/vFEA0=":
function (require, module, exports, __dirname, __filename) {


var cc   = require('./lib/utils')
var join = require('path').join
var deepExtend = require('deep-extend')
var etc = '/etc'
var win = process.platform === "win32"
var home = win
           ? process.env.USERPROFILE
           : process.env.HOME

module.exports = function (name, defaults, argv, parse) {
  if('string' !== typeof name)
    throw new Error('rc(name): name *must* be string')
  if(!argv)
    argv = require('minimist')(process.argv.slice(2))
  defaults = (
      'string' === typeof defaults
    ? cc.json(defaults) : defaults
    ) || {}

  parse = parse || cc.parse

  function file () {
    var content = cc.file.apply(null, arguments)
    return content ? parse(content) : null
  }

  var local = cc.find('.'+name+'rc')

  var env = cc.env(name + '_')

  return deepExtend.apply(null, [
    defaults,
    win ? {} : file(join(etc, name, 'config')),
    win ? {} : file(join(etc, name + 'rc')),
    home ? file(join(home, '.config', name, 'config')) : {},
    home ? file(join(home, '.config', name)) : {},
    home ? file(join(home, '.' + name, 'config')) : {},
    home ? file(join(home, '.' + name + 'rc')) : {},
    file(local),
    local ? {config: local} : null,
    env.config ? file(env.config) : null,
    argv.config ? file(argv.config) : null,
    env,
    argv
  ])
}

if(!module.parent) {
  console.log(
    JSON.stringify(module.exports(process.argv[2]), false, 2)
  )
}

},
"72XVPy+VsgaBUFvX4hmVSkng1lKVA5wGIBkU87syh+U=":
function (require, module, exports, __dirname, __filename) {

module.exports = function () {
  var _read, _cb, abortCb, _end

  var read = function (end, cb) {
    if(!_read) {
      if(end) {
        _end = end
        abortCb = cb
      }
      else
        _cb = cb
    }
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    if(_cb) read(null, _cb)
    if(abortCb) read(_end, abortCb)
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}


},
"7AG6LenLiaAQo3pWlVjhtoxeri4Fsohwfw54YAtJhKo=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module unified
 * @fileoverview Parse / Transform / Compile / Repeat.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var bail = require('bail');
var ware = require('ware');
var AttachWare = require('attach-ware')(ware);
var VFile = require('vfile');
var unherit = require('unherit');
var extend;

try {
    extend = require('node-extend');
} catch (e) {
    extend = require('extend');
}

/*
 * Processing pipeline.
 */

var pipeline = ware()
    .use(function (ctx) {
        ctx.tree = ctx.context.parse(ctx.file, ctx.settings);
    })
    .use(function (ctx, next) {
        ctx.context.run(ctx.tree, ctx.file, next);
    })
    .use(function (ctx) {
        ctx.result = ctx.context.stringify(ctx.tree, ctx.file, ctx.settings);
    });

/**
 * Construct a new Processor class based on the
 * given options.
 *
 * @param {Object} options - Configuration.
 * @param {string} options.name - Private storage.
 * @param {Function} options.Parser - Class to turn a
 *   virtual file into a syntax tree.
 * @param {Function} options.Compiler - Class to turn a
 *   syntax tree into a string.
 * @return {Processor} - A new constructor.
 */
function unified(options) {
    var name = options.name;
    var Parser = options.Parser;
    var Compiler = options.Compiler;
    var data = options.data;

    /**
     * Construct a Processor instance.
     *
     * @constructor
     * @class {Processor}
     */
    function Processor(processor) {
        var self = this;

        if (!(self instanceof Processor)) {
            return new Processor(processor);
        }

        self.ware = new AttachWare(processor && processor.ware);
        self.ware.context = self;

        self.Parser = unherit(Parser);
        self.Compiler = unherit(Compiler);

        if (self.data) {
            self.data = extend(true, {}, self.data);
        }
    }

    /**
     * Either return `context` if its an instance
     * of `Processor` or construct a new `Processor`
     * instance.
     *
     * @private
     * @param {Processor?} [context] - Context object.
     * @return {Processor} - Either `context` or a new
     *   Processor instance.
     */
    function instance(context) {
        return context instanceof Processor ? context : new Processor();
    }

    /**
     * Attach a plugin.
     *
     * @this {Processor?} - Either a Processor instance or
     *   the Processor constructor.
     * @return {Processor} - Either `context` or a new
     *   Processor instance.
     */
    function use() {
        var self = instance(this);

        self.ware.use.apply(self.ware, arguments);

        return self;
    }

    /**
     * Transform.
     *
     * @this {Processor?} - Either a Processor instance or
     *   the Processor constructor.
     * @param {Node} [node] - Syntax tree.
     * @param {VFile?} [file] - Virtual file.
     * @param {Function?} [done] - Callback.
     * @return {Node} - `node`.
     */
    function run(node, file, done) {
        var self = this;
        var space;

        if (typeof file === 'function') {
            done = file;
            file = null;
        }

        if (!file && node && !node.type) {
            file = node;
            node = null;
        }

        file = new VFile(file);
        space = file.namespace(name);

        if (!node) {
            node = space.tree || node;
        } else if (!space.tree) {
            space.tree = node;
        }

        if (!node) {
            throw new Error('Expected node, got ' + node);
        }

        done = typeof done === 'function' ? done : bail;

        /*
         * Only run when this is an instance of Processor,
         * and when there are transformers.
         */

        if (self.ware && self.ware.fns) {
            self.ware.run(node, file, done);
        } else {
            done(null, node, file);
        }

        return node;
    }

    /**
     * Parse a file.
     *
     * Patches the parsed node onto the `name`
     * namespace on the `type` property.
     *
     * @this {Processor?} - Either a Processor instance or
     *   the Processor constructor.
     * @param {string|VFile} value - Input to parse.
     * @param {Object?} [settings] - Configuration.
     * @return {Node} - `node`.
     */
    function parse(value, settings) {
        var file = new VFile(value);
        var CustomParser = (this && this.Parser) || Parser;
        var node = new CustomParser(file, settings, instance(this)).parse();

        file.namespace(name).tree = node;

        return node;
    }

    /**
     * Compile a file.
     *
     * Used the parsed node at the `name`
     * namespace at `'tree'` when no node was given.
     *
     * @this {Processor?} - Either a Processor instance or
     *   the Processor constructor.
     * @param {Object} [node] - Syntax tree.
     * @param {VFile} [file] - File with syntax tree.
     * @param {Object?} [settings] - Configuration.
     * @return {string} - Compiled `file`.
     */
    function stringify(node, file, settings) {
        var CustomCompiler = (this && this.Compiler) || Compiler;
        var space;

        if (settings === null || settings === undefined) {
            settings = file;
            file = null;
        }

        if (!file && node && !node.type) {
            file = node;
            node = null;
        }

        file = new VFile(file);
        space = file.namespace(name);

        if (!node) {
            node = space.tree || node;
        } else if (!space.tree) {
            space.tree = node;
        }

        if (!node) {
            throw new Error('Expected node, got ' + node);
        }

        return new CustomCompiler(file, settings, instance(this)).compile();
    }

    /**
     * Parse / Transform / Compile.
     *
     * @this {Processor?} - Either a Processor instance or
     *   the Processor constructor.
     * @param {string|VFile} value - Input to process.
     * @param {Object?} [settings] - Configuration.
     * @param {Function?} [done] - Callback.
     * @return {string?} - Parsed document, when
     *   transformation was async.
     */
    function process(value, settings, done) {
        var self = instance(this);
        var file = new VFile(value);
        var result = null;

        if (typeof settings === 'function') {
            done = settings;
            settings = null;
        }

        pipeline.run({
            'context': self,
            'file': file,
            'settings': settings || {}
        }, function (err, res) {
            result = res && res.result;

            if (done) {
                done(err, file, result);
            } else if (err) {
                bail(err);
            }
        });

        return result;
    }

    /*
     * Methods / functions.
     */

    var proto = Processor.prototype;

    Processor.use = proto.use = use;
    Processor.parse = proto.parse = parse;
    Processor.run = proto.run = run;
    Processor.stringify = proto.stringify = stringify;
    Processor.process = proto.process = process;
    Processor.data = proto.data = data || null;

    return Processor;
}

/*
 * Expose.
 */

module.exports = unified;

},
"7RgQFGvTEv51ozIRCNYwjLryaoOVTXdszxkjzCRcOXw=":
function (require, module, exports, __dirname, __filename) {
var hooks = require('./hooks')
var ltgt = require('ltgt')

function isFunction (f) {
  return 'function' === typeof f
}

function getPrefix (db) {
  if(db == null) return db
  if(isFunction(db.prefix)) return db.prefix()
  return db
}

function has(obj, name) {
  return Object.hasOwnProperty.call(obj, name)
}

function clone (_obj) {
  var obj = {}
  for(var k in _obj)
    obj[k] = _obj[k]
  return obj
}

module.exports = function (db, precodec, codec, compare) {
  var prehooks = hooks(compare)
  var posthooks = hooks(compare)
  var waiting = [], ready = false

  function encodePrefix(prefix, key, opts1, opts2) {
    return precodec.encode([ prefix, codec.encodeKey(key, opts1, opts2 ) ])
  }

  function decodePrefix(data) {
    return precodec.decode(data)
  }

  function addEncodings(op, prefix) {
    if(prefix && prefix.options) {
      op.keyEncoding =
        op.keyEncoding || prefix.options.keyEncoding
      op.valueEncoding =
        op.valueEncoding || prefix.options.valueEncoding
    }
    return op
  }

  function start () {
    ready = true
    while(waiting.length)
      waiting.shift()()
  }

  if(isFunction(db.isOpen)) {
    if(db.isOpen())
      ready = true
    else
      db.open(start)
  } else {
    db.open(start)
  }

  return {
    apply: function (ops, opts, cb) {
      //apply prehooks here.
      for(var i = 0; i < ops.length; i++) {
        var op = ops[i]
        addEncodings(op, op.prefix)
        op.prefix = getPrefix(op.prefix)
        prehooks.trigger([op.prefix, op.key], [op, add, ops])

        function add(op) {
          if(op === false) return delete ops[i]
          ops.push(op)
        }
      }

      opts = opts || {}

      if('object' !== typeof opts) throw new Error('opts must be object, was:'+ opts) 

      if('function' === typeof opts) cb = opts, opts = {}

      if(ops.length)
        (db.db || db).batch(
          ops.map(function (op) {
            return {
              key: encodePrefix(op.prefix, op.key, opts, op),
              value:
                  op.type !== 'del'
                ? codec.encodeValue(
                    op.value,
                    opts,
                    op
                  )
                : undefined,
              type:
                op.type || (op.value === undefined ? 'del' : 'put')
            }
          }),
          opts,
          function (err) {
              if(err) return cb(err)
            ops.forEach(function (op) {
              posthooks.trigger([op.prefix, op.key], [op])
            })
            cb()
          }
        )
      else
        cb()
    },
    get: function (key, prefix, opts, cb) {
      opts.asBuffer = codec.isValueAsBuffer(opts)
      return (db.db || db).get(
        encodePrefix(prefix, key, opts),
        opts,
        function (err, value) {
          if(err) cb(err)
          else    cb(null, codec.decodeValue(value, opts || options))
        }
      )
    },
    pre: prehooks.add,
    post: posthooks.add,
    createDecoder: function (opts) {
      if(opts.keys !== false && opts.values !== false)
        return function (key, value) {
          return {
            key: codec.decodeKey(precodec.decode(key)[1], opts),
            value: codec.decodeValue(value, opts)
          }
        }
      if(opts.values !== false)
        return function (_, value) {
          return codec.decodeValue(value, opts)
        }
      if(opts.keys !== false)
        return function (key) {
          return codec.decodeKey(precodec.decode(key)[1], opts)
        }
      return function () {}
    },
    iterator: function (_opts, cb) {
      var opts = clone(_opts || {})
      var prefix = opts.prefix || []

      function encodeKey(key) {
        return encodePrefix(prefix, key, opts, {})
      }

      ltgt.toLtgt(opts, opts, encodeKey, precodec.lowerBound, precodec.upperBound)

      opts.prefix = null

      //************************************************
      //hard coded defaults, for now...
      //TODO: pull defaults and encoding out of levelup.
      opts.keyAsBuffer = opts.valueAsBuffer = false
      //************************************************


      //this is vital, otherwise limit: undefined will
      //create an empty stream.
      if ('number' !== typeof opts.limit)
        opts.limit = -1

      opts.keyAsBuffer = precodec.buffer
      opts.valueAsBuffer = codec.isValueAsBuffer(opts)

      function wrapIterator (iterator) {
        return {
          next: function (cb) {
            return iterator.next(cb)
          },
          end: function (cb) {
            iterator.end(cb)
          }
        }
      }

      if(ready)
        return wrapIterator((db.db || db).iterator(opts))
      else
        waiting.push(function () {
          cb(null, wrapIterator((db.db || db).iterator(opts)))
        })

    }
  }

}

},
"7UsKlENzswR8cwTI8PFKkhEi8//PslbP4O7DAr9pKpQ=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')
var para = require('pull-paramap')
var Notify = require('pull-notify')
var many = require('pull-many')
var cat = require('pull-cat')
var Abort = require('pull-abortable')
var Debounce = require('observ-debounce')
var Observ = require('observ')
var mdm = require('mdmanifest')
var apidoc = require('../lib/apidocs').replicate

var DAY = 1000*60*60*24
var LIMIT = [-1, -1, 100] // default rate-limits, by hops out

var notify = Notify()

function last (a) { return a[a.length - 1] }

// main log-replication behavior
function replicate(sbot, config, rpc, cb) {

  // rate limiter:
  // calculate how many messages we're willing to receive for a user
  // - works by number of "hops" away from the local user, in the follow graph
  function calcLimit (upto) {

    var limit = config.replication && config.replication.limit
    if(!Array.isArray(limit)) limit = LIMIT

    var hopLimit = (upto.hops < limit.length) ? limit[upto.hops] : last(limit)
    if(hopLimit <=0) return hopLimit

    return (
        !upto.ts
      ? hopLimit
      : Math.ceil((Date.now() - upto.ts)/DAY * hopLimit)
    )
  }

  // TODO
  // is `initial` and `to_recv` the same thing? do we need both?
  // -prf
  var aborter = Abort()
  var sources = many()
  var to_send = {} // { feedId => their latest seq } map for feeds requested by the peer
  var to_recv = {} // { feedId => our latest seq } map for feeds we request
  var initial = {} // { feedId => initial seq } map for feeds request, remembers what seq each feed was initially at
  var replicated = {} // { feedId => final seq } map for feeds request, tracks the final seq for each received feed
  var debounce = Debounce(100)

  // track progress, and emit update events periodically
  debounce(function () {
    // HACK
    // This uses the information produced by normal replication 
    // to get a rough approximation for a progress-bar.
    // When the peer requests feeds, they'll tell us what sequence they have for each feed.
    // We track that in `to_send`.
    // We also track the sequence we have, for the feeds we're requesting, in `to_recv`.
    // If it so happens they have a higher sequence for a feed than we do, then
    // `to_send` will be higher than `to_recv`.
    // This means they have to request a feed for us to track that feed's progress, which is
    // often the case, but not always.
    // Works for now.
    // -prf (but code by dominic, blame him)
    var total = 0, progress = 0, feeds = 0
    for(var id in to_recv) {
      var feed_to_send    = to_send[id]    || 0
      var feed_to_recv    = to_recv[id]    || 0
      var feed_replicated = replicated[id] || 0
      if(to_send[id] != null && to_recv[id] != null) {
        feeds++
        if(feed_to_send > feed_to_recv) {
          total    += (feed_to_send    - feed_to_recv)
          progress += (feed_replicated - feed_to_recv)
        }
      }
    }

    // emit progress event
    notify({
      type: 'progress',
      peerid: rpc.id,
      total: total,
      progress: progress,
      feeds: feeds,
      sync: !!(feeds && (progress >= total))
    })
  })

  rpc.on('call:createHistoryStream', function (opts) {
    // track what sequence the peer has for each feed
    to_send[opts.id] = (opts.sequence || opts.seq) - 1
    debounce.set()
  })

  // compatibility function for old implementations of `latestSequence`
  function toSeq (s) {
    return 'number' === typeof s ? s : s.sequence
  }

  // collect the IDs of feeds we want to request
  var opts = config.replication || {}
  opts.hops = opts.hops || 3
  opts.dunbar = opts.dunbar || 150
  opts.live = true
  opts.meta = true
  var userSources = [sbot.friends.createFriendStream(opts)]
  if (sbot.gossip) {
    // if we have the gossip plugin active, then include new local peers
    // so that you can put a name to someone on your local network.
    userSources.unshift(pull.values(
      sbot.gossip.peers()
        .filter(function (e) { return e.source === 'local' })
        .map(function (e) { return {id: e.key, hops: 6} })
    ))
  }

  // create read-streams for the desired feeds
  pull(
    cat(userSources),
    aborter,
    // filter out duplicates, and also keep track of what we expect to receive
    pull.filter(function (s) {
      var id = 'string' === typeof s ? s  : s.id
      if(to_recv[id] == null) { to_recv[id] = 0; return true }
    }),
    // lookup the latest sequence from each user
    para(function (data, cb) {
      if(data.sync) return cb(null, data)
      var id = data.id || data
      sbot.latestSequence(id, function (err, seq) {
        cb(null, {
          id: id,
          sequence: err ? 0 : toSeq(seq),
          ts: err ? null : seq.ts,
          hops: data.hops
        })
      })
    }, 32),
    pull.drain(function (upto) {
      to_recv[upto.id] = upto.sequence
      initial[upto.id] = replicated[upto.id] = upto.sequence

      var limit = config.party ? null : calcLimit(upto)

      sources.add(
        pull(

          // TODO
          // how do `limit` and `live` interact, here?
          // what if only the first 100 messages, of 200, were requested? 
          // would you start getting live updates, starting at sequence 201?
          // -prf
          rpc.createHistoryStream({
            id: upto.id,
            seq: upto.sequence + 1,
            limit: limit,
            live: true,
            keys: false
          }),
          pull.through(function () {
            if(limit === null || limit--) return
            //REPLICATIOAN BACK PRESSURE
            rpc.close(true)

            // TODO
            // do we want to close the entire RPC connection when the limit is hit?
            // the limit is per feed ... it should just close the feed's history stream
            // -prf
          })
        )
      )

      debounce.set()
    }, function (err) {
      if(err)
        sbot.emit('log:error', ['replication', rep.id, 'error', err])
      sources.cap()
    })
  )

  // create the read -> write stream
  pull(
    sources,
    pull.through(function (msg) {
      // track progress
      replicated[msg.author] = Math.max(
        replicated[msg.author]||0,
        msg.sequence
      )
      debounce.set()
    }),
    sbot.createWriteStream(function (err) {
      aborter.abort()
      debounce.immediate()

      // done!
      cb(err, replicated, initial)
    })
  )
}

module.exports = {
  name: 'replicate',
  version: '1.0.0',
  manifest: mdm.manifest(apidoc),
  replicate: replicate,
  init: function (sbot, config) {
    sbot.createHistoryStream.hook(function (fn, args) {
      if(this._emit)
        this._emit('call:createHistoryStream', args[0])
      return fn.apply(this, args)
    })

    // watch for new connections and replicate on creation
    sbot.on('rpc:connect', function(rpc) {
      // this is the cli client, just ignore.
      if(rpc.id === sbot.id) return

      sbot.emit('log:info', ['replicate', rpc.id, 'start'])
      sbot.emit('replicate:start', rpc)
      replicate(sbot, config, rpc, function (err, final, initial) {
        if(err) {
          sbot.emit('replicate:fail', err)
          sbot.emit('log:warning', ['replicate', rpc.id, 'error', err])
        } else {
          var progress = {}
          // subtract `initial` from `final` so `progress` represents a delta
          for (var author in final)
            progress[author] = final[author] - (initial[author] || 0)

          var progressSummary = summarizeProgress(progress)
          if (progressSummary)
            sbot.emit('log:notice', ['replicate', rpc.id, 'success', progressSummary])
          sbot.emit('replicate:finish', final)
        }
      })
    })

    return {
      changes: function () {
        return notify.listen()
      }
    }
  }
}

function summarizeProgress (progress) {
  // count the number of feeds updated, and the number of new messages
  var updatedFeeds = 0, newMessages = 0
  for (var author in progress) {
    if (progress[author] > 0) {
      updatedFeeds++
      newMessages += progress[author]
    }
  }
  // no message if no updates
  if (updatedFeeds === 0)
    return false
  return 'Feeds updated: '+updatedFeeds+', New messages: '+newMessages
}







},
"7XUAtdaqCviCG2r8jXp3s7GOQFmR9KBSMGQSdKEmmcA=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},
"8It9l0trLHjLwFy+Qv3oPWTAEoErwSDL9wH5UIDmgGE=":
function (require, module, exports, __dirname, __filename) {
'use strict'

//a pair of pull streams where one drains from the other
module.exports = function () {
  var _read, waiting
  function sink (read) {
    if('function' !== typeof read)
      throw new Error('read must be function')

    if(_read)
      throw new Error('already piped')
    _read = read
    if(waiting) {
      var _waiting = waiting
      waiting = null
      _read.apply(null, _waiting)
    }
  }
  function source (abort, cb) {
    if(_read)
      _read(abort, cb)
    else
      waiting = [abort, cb]
  }

  return {
    source: source, sink: sink
  }
}


},
"8K0wmtTFpEUACT5MxG6aQmwzk4ybG5nDuPEusbcZkfc=":
function (require, module, exports, __dirname, __filename) {
'use strict';

var v4 = '(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}';
var v6 = '(?:(?:[0-9a-fA-F:]){1,4}(?:(?::(?:[0-9a-fA-F]){1,4}|:)){2,7})+';

var ip = module.exports = function (opts) {
	opts = opts || {};
	return opts.exact ? new RegExp('(?:^' + v4 + '$)|(?:^' + v6 + '$)') :
	                    new RegExp('(?:' + v4 + ')|(?:' + v6 + ')', 'g');
};

ip.v4 = function (opts) {
	opts = opts || {};
	return opts.exact ? new RegExp('^' + v4 + '$') : new RegExp(v4, 'g');
};

ip.v6 = function (opts) {
	opts = opts || {};
	return opts.exact ? new RegExp('^' + v6 + '$') : new RegExp(v6, 'g');
};

},
"8Ka+H0jT7owC0PUrgH54c1zPT66jkxs9uvoHT7hxpA4=":
function (require, module, exports, __dirname, __filename) {
module.exports = intersect;

function many (sets) {
  var o = {};
  var l = sets.length - 1;
  var first = sets[0];
  var last = sets[l];
  
  for(var i in first) o[first[i]] = 0;
  
  for(var i = 1; i <= l; i++) {
    var row = sets[i];
    for(var j in row) {
      var key = row[j];
      if(o[key] === i - 1) o[key] = i;
    }
  }
  
  var a = [];
  for(var i in last) {
    var key = last[i];
    if(o[key] === l) a.push(key);
  }
  
  return a;
}

function intersect (a, b) {
  if (!b) return many(a);

  var res = [];
  for (var i = 0; i < a.length; i++) {
    if (indexOf(b, a[i]) > -1) res.push(a[i]);
  }
  return res;
}

intersect.big = function(a, b) {
  if (!b) return many(a);
  
  var ret = [];
  var temp = {};
  
  for (var i = 0; i < b.length; i++) {
    temp[b[i]] = true;
  }
  for (var i = 0; i < a.length; i++) {
    if (temp[a[i]]) ret.push(a[i]);
  }
  
  return ret;
}

function indexOf(arr, el) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === el) return i;
  }
  return -1;
}

},
"8SbFn01DiCcXOS01iCTY9gKj+vtWJ+X735dTPvOcT/8=":
function (require, module, exports, __dirname, __filename) {
(function(root) {

  function isValidDomain(v) {
    if (!v) return false;
    var re = /^(?!:\/\/)([a-zA-Z0-9-]+\.){0,5}[a-zA-Z0-9-][a-zA-Z0-9-]+\.[a-zA-Z]{2,64}?$/gi;
    return re.test(v);
  }

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = isValidDomain;
    }
    exports.isValidDomain = isValidDomain;
  } else if (typeof define === 'function' && define.amd) {
    define([], function() {
      return isValidDomain;
    });
  } else {
    root.isValidDomain = isValidDomain;
  }

})(this);
},
"8awuKc7pKqrk8gvE3q1Yl+IrB12AY+YJoKIyW9haNcI=":
function (require, module, exports, __dirname, __filename) {
function abortable(onEnd) {
  var aborted = false, reading = false, ended = false, _cb, _read

  function terminate (err) {
    if(onEnd) onEnd(ended === true ? null :  ended)
    var cb = _cb; _cb = null
    if(cb) cb(ended)
  }

  function cancel () {
    ended = ended || true
    terminate(aborted || ended)
    _read(aborted, function (err) {
      if(_cb) _cb(err)
    })
  }

  function reader (read) {
    _read = read
    return function (abort, cb) {
      _cb = cb
      if(abort)   aborted = abort
      if(ended)   return cb(ended)
      if(aborted) return
      reading = true
      read(abort, function (end, data) {
        reading = false
        if(aborted) return !abort && read(aborted, function () {})
        if(!_cb) return
        var cb = _cb
        _cb = null
        if(end) {
          ended = end
          onEnd && onEnd(ended === true ? null :  ended)
          cb(end)
        }
        else {
          cb(end, data)
        }
      })
    }
  }

  reader.abort = function () {
    aborted = true
    if(ended) return
    cancel()
  }

  return reader
}

module.exports = abortable


},
"8k8b5Uur+hOKD6B9zaLgcJYLm0jb3tRM/zhQ9DlfpYY=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var extend        = require('xtend')
  , LevelUPError  = require('./errors').LevelUPError
  , encodings     = require('./encodings')
  , defaultOptions = {
        createIfMissing : true
      , errorIfExists   : false
      , keyEncoding     : 'utf8'
      , valueEncoding   : 'utf8'
      , compression     : true
    }

  , leveldown
  , encodingOpts = (function () {
      var eo = {}
      for(var e in encodings)
        eo[e] = {valueEncoding: encodings[e]}
      return eo
    }())

function copy (srcdb, dstdb, callback) {
  srcdb.readStream()
    .pipe(dstdb.writeStream())
    .on('close', callback ? callback : function () {})
    .on('error', callback ? callback : function (err) { throw err })
}

function getOptions (levelup, options) {
  var s = typeof options == 'string' // just an encoding
  if (!s && options && options.encoding && !options.valueEncoding)
    options.valueEncoding = options.encoding
  return extend(
      (levelup && levelup.options) || {}
    , s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding]
        : options
  )
}

function getLevelDOWN () {
  if (leveldown)
    return leveldown

  var requiredVersion       = require('../package.json').devDependencies.leveldown
    , missingLevelDOWNError = 'Could not locate LevelDOWN, try `npm install leveldown`'
    , leveldownVersion

  try {
    leveldownVersion = require('leveldown/package').version
  } catch (e) {
    throw new LevelUPError(missingLevelDOWNError)
  }

  if (!require('semver').satisfies(leveldownVersion, requiredVersion)) {
    throw new LevelUPError(
        'Installed version of LevelDOWN ('
      + leveldownVersion
      + ') does not match required version ('
      + requiredVersion
      + ')'
    )
  }

  try {
    return leveldown = require('leveldown')
  } catch (e) {
    throw new LevelUPError(missingLevelDOWNError)
  }
}

function dispatchError (levelup, error, callback) {
  return typeof callback == 'function'
    ? callback(error)
    : levelup.emit('error', error)
}

function isDefined (v) {
  return typeof v !== 'undefined'
}

module.exports = {
    defaultOptions  : defaultOptions
  , copy            : copy
  , getOptions      : getOptions
  , getLevelDOWN    : getLevelDOWN
  , dispatchError   : dispatchError
  , isDefined       : isDefined
}

},
"8oVQAh3PHo5mQo4nNZARZxbXyIiufUbrNzi1vx0D53w=":
function (require, module, exports, __dirname, __filename) {
module.exports = map

// map := (Continuable<A>, (A) => B) => Continuable<B>
function map(source, lambda) {
    return function continuable(callback) {
        source(function continuation(err, value) {
            if (err) {
                return callback(err)
            }

            callback(null, lambda(value))
        })
    }
}

},
"93bxujWOHqlWY3OdEKlVwvXxfFNRK92GepJN7l+Mfg4=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "AElig": "",
  "AMP": "&",
  "Aacute": "",
  "Acirc": "",
  "Agrave": "",
  "Aring": "",
  "Atilde": "",
  "Auml": "",
  "COPY": "",
  "Ccedil": "",
  "ETH": "",
  "Eacute": "",
  "Ecirc": "",
  "Egrave": "",
  "Euml": "",
  "GT": ">",
  "Iacute": "",
  "Icirc": "",
  "Igrave": "",
  "Iuml": "",
  "LT": "<",
  "Ntilde": "",
  "Oacute": "",
  "Ocirc": "",
  "Ograve": "",
  "Oslash": "",
  "Otilde": "",
  "Ouml": "",
  "QUOT": "\"",
  "REG": "",
  "THORN": "",
  "Uacute": "",
  "Ucirc": "",
  "Ugrave": "",
  "Uuml": "",
  "Yacute": "",
  "aacute": "",
  "acirc": "",
  "acute": "",
  "aelig": "",
  "agrave": "",
  "amp": "&",
  "aring": "",
  "atilde": "",
  "auml": "",
  "brvbar": "",
  "ccedil": "",
  "cedil": "",
  "cent": "",
  "copy": "",
  "curren": "",
  "deg": "",
  "divide": "",
  "eacute": "",
  "ecirc": "",
  "egrave": "",
  "eth": "",
  "euml": "",
  "frac12": "",
  "frac14": "",
  "frac34": "",
  "gt": ">",
  "iacute": "",
  "icirc": "",
  "iexcl": "",
  "igrave": "",
  "iquest": "",
  "iuml": "",
  "laquo": "",
  "lt": "<",
  "macr": "",
  "micro": "",
  "middot": "",
  "nbsp": "",
  "not": "",
  "ntilde": "",
  "oacute": "",
  "ocirc": "",
  "ograve": "",
  "ordf": "",
  "ordm": "",
  "oslash": "",
  "otilde": "",
  "ouml": "",
  "para": "",
  "plusmn": "",
  "pound": "",
  "quot": "\"",
  "raquo": "",
  "reg": "",
  "sect": "",
  "shy": "",
  "sup1": "",
  "sup2": "",
  "sup3": "",
  "szlig": "",
  "thorn": "",
  "times": "",
  "uacute": "",
  "ucirc": "",
  "ugrave": "",
  "uml": "",
  "uuml": "",
  "yacute": "",
  "yen": "",
  "yuml": ""
}

},
"9dGszbFmGhoAFuEBf9blmEOvPXNqI+M7op9HRB2B7Mo=":
function (require, module, exports, __dirname, __filename) {
var nut     = require('./nut')
var shell   = require('./shell') //the shell surrounds the nut
var codec   = require('levelup/lib/codec')
var merge   = require('xtend')
var compare = require('typewiselite')
var ReadStream = require('levelup/lib/read-stream')

var precodec = require('./codec/bytewise')

function id (e) {
  return e
}

module.exports = function (db, opts) {

  opts = merge(db.options, {
    keyEncoding: {
      encode: id,
      decode: id,
      buffer: true
    }
  }, opts)

  return shell (
    nut ( db, precodec, codec, compare ),
    [], ReadStream, opts
  )
}



},
"ABaqhxFHJZH1xI5+X4BnUWT81p3KpwRS6/RYR4GxkX8=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var PacketStream = require('packet-stream')
var pull         = require('pull-stream')
var pullWeird    = require('./pull-weird')
var goodbye      = require('pull-goodbye')
var u            = require('./util')
var explain      = require('explain-error')

function isFunction (f) {
  return 'function' === typeof f
}

function isString (s) {
  return 'string' === typeof s
}

function isObject (o) {
  return o && 'object' === typeof o
}

function isSource    (t) { return 'source' === t }
function isSink      (t) { return 'sink'   === t }
function isDuplex    (t) { return 'duplex' === t }
function isSync      (t) { return 'sync'  === t }
function isAsync     (t) { return 'async'  === t }
function isRequest   (t) { return isSync(t) || isAsync(t) }
function isStream    (t) { return isSource(t) || isSink(t) || isDuplex(t) }

module.exports = function initStream (localCall, codec, onClose) {

  var ps = PacketStream({
    message: function (msg) {
//      if(isString(msg)) return
//      if(msg.length > 0 && isString(msg[0]))
//        localCall('msg', 'emit', msg)
    },
    request: function (opts, cb) {
      var name = opts.name, args = opts.args
      var inCB = false, called = false, async = false, value

      args.push(function (err, value) {
        called = true
        inCB = true; cb(err, value)
      })
      try {
        value = localCall('async', name, args)
      } catch (err) {
        if(inCB || called) throw explain(err, 'no callback provided to muxrpc async funtion')
        return cb(err)
      }

    },
    stream: function (stream) {
      stream.read = function (data, end) {
        var name = data.name
        var type = data.type
        var err, value

        stream.read = null

        if(!isStream(type))
          return stream.write(null, new Error('unsupported stream type:'+type))

        //how would this actually happen?
        if(end) return stream.write(null, end)

        try { value = localCall(type, name, data.args) }
        catch (_err) { err = _err }

        var _stream = pullWeird[
          {source: 'sink', sink: 'source'}[type] || 'duplex'
        ](stream)

        return u.pipeToStream(
          type, _stream,
          err ? u.errorAsStream(type, err) : value
        )

//        if(isSource(type))
//          _stream(err ? pull.error(err) : value)
//        else if (isSink(type))
//          (err ? abortSink(err) : value)(_stream)
//        else if (isDuplex(type))
//          pull(_stream, err ? abortDuplex(err) : value, _stream)
      }
    },

    close: function (err) {
        ps = null // deallocate
        ws.ended = true
        if(ws.closed) return
        ws.closed = true
        if(onClose) {
          var close = onClose; onClose = null; close(err)
        }
      }
  })

  var ws = goodbye(pullWeird(ps, function (_) {
    //this error will be handled in PacketStream.close
  }))

  ws = codec ? codec(ws) : ws

  ws.remoteCall = function (type, name, args, cb) {
    if(name === 'emit') return ps.message(args)

    if(!(isRequest(type) || isStream(type)))
      throw new Error('unsupported type:' + JSON.stringify(type))

    if(isRequest(type))
      return ps.request({name: name, args: args}, cb)

    var ws = ps.stream(), s = pullWeird[type](ws, cb)
    ws.write({name: name, args: args, type: type})
    return s
  }


  //hack to work around ordering in setting ps.ended.
  //Question: if an object has subobjects, which
  //all have close events, should the subobjects fire close
  //before the parent? or should parents close after?
  //should there be a preclose event on the parent
  //that fires when it's about to close all the children?
  ws.isOpen = function () {
    return !ps.ended
  }

  ws.close = function (err, cb) {
    if(isFunction(err))
      cb = err, err = false
    if(!ps) return (cb && cb())
    if(err) return ps.destroy(err), (cb && cb())

    ps.close(function (err) {
      if(cb) cb(err)
      else if(err) throw explain(err, 'no callback provided for muxrpc close')
    })

    return this
  }
  ws.closed = false

  return ws
}




},
"AFvCeNe811ygBqy8kVeCFHjQEwL3wFS9UExrdvFsdls=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module remark:html:h
 * @fileoverview
 *   Create HTML nodes. Loosely inspired by
 *   https://github.com/Matt-Esch/virtual-dom/blob/master/
 *   virtual-hyperscript/index.js
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var assign = require('object-assign');

/*
 * Constants.
 */

var LINE = '\n';
var EMPTY = '';
var SPACE = ' ';
var GT = '>';
var LT = '<';
var SLASH = '/';
var QUOTE = '"';
var EQUALS = '=';

/*
 * List of self-closing tags.
 */

var CLOSING = ['hr', 'img', 'br'];

/**
 * Compile attributes.
 *
 * @param {Object?} attributes - Map of attributes.
 * @param {function(string): string} encode - Strategy
 *   to use.
 * @param {Node} node - mdast node currently being
 *   compiled.
 * @return {string} - HTML attributes.
 */
function toAttributes(attributes, encode, node) {
    var parameters = [];
    var key;
    var value;

    for (key in attributes) {
        value = attributes[key];

        if (value !== null && value !== undefined) {
            value = encode(String(value || EMPTY), node);
            parameters.push(key + EQUALS + QUOTE + value + QUOTE);
        }
    }

    return parameters.length ? parameters.join(SPACE) : EMPTY;
}

/**
 * Compile a `node`, in `context`, into HTML.
 *
 * @example
 *   h(compiler, {
 *     'type': 'break'
 *     'attributes': {
 *       'id': 'foo'
 *     }
 *   }, 'br') // '<br id="foo">'
 *
 *   h(compiler, {
 *     'type': 'break'
 *   }, 'br', {
 *     'id': 'foo'
 *   }) // '<br id="foo">'
 *
 * @param {HTMLCompiler} context - Context compiler.
 * @param {Node} node - mdast node. Used for positions
 *   on errors.
 * @param {Object?} [defaults] - Default HTML configuration.
 * @param {Object?} [defaults.attributes] - Default Attributes.
 * @param {Object?} [defaults.content] - Default content.
 * @param {Object?} [defaults.name] - Default tag-name.
 * @param {Object?} [data] - Node configuration.
 * @param {Object?} [data.htmlAttributes] - HTML Attributes.
 * @param {Object?} [data.htmlContent] - Content of element.
 * @param {Object?} [data.htmlName] - Tag-name.
 * @param {boolean} [loose] - Whether to add an initial and
 *   a trailing newline character inside the opening and
 *   closing tags.
 * @return {string} - HTML representation of `node`, based
 *   on the given options.
 */
function h(context, node, defaults, data, loose) {
    var name;
    var value;
    var parameters;
    var content;

    if (!data) {
        data = {};
    }

    name = context.encode(data.htmlName || defaults.name);

    if (data.htmlContent && !context.options.sanitize) {
        content = data.htmlContent;
    } else {
        content = defaults.content || EMPTY;
    }

    parameters = toAttributes(
        assign({}, defaults.attributes, data.htmlAttributes
    ), context.encode, node);

    value = LT + name + (parameters ? SPACE + parameters : EMPTY);

    if (CLOSING.indexOf(name) !== -1) {
        return value + (context.options.xhtml ? SPACE + SLASH : EMPTY) + GT;
    }

    return value + GT +
        (loose ? LINE : EMPTY) +
        content +
        (loose && content ? LINE : EMPTY) +
        LT + SLASH + name + GT;
}

/*
 * Expose.
 */

module.exports = h;

},
"AGhN3UloVJCnXog8WMFp0UBsK79/zGQ13nCSa2m8DtE=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015-2016 Titus Wormer
 * @license MIT
 * @module remark:stringify
 * @version 3.2.2
 * @fileoverview Compile an abstract syntax tree into
 *   a markdown document.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var decode = require('parse-entities');
var encode = require('stringify-entities');
var table = require('markdown-table');
var repeat = require('repeat-string');
var extend = require('extend.js');
var ccount = require('ccount');
var longestStreak = require('longest-streak');
var utilities = require('./utilities.js');
var defaultOptions = require('./defaults.js').stringify;

/*
 * Methods.
 */

var raise = utilities.raise;
var validate = utilities.validate;
var stateToggler = utilities.stateToggler;
var mergeable = utilities.mergeable;
var MERGEABLE_NODES = utilities.MERGEABLE_NODES;

/*
 * Constants.
 */

var INDENT = 4;
var MINIMUM_CODE_FENCE_LENGTH = 3;
var YAML_FENCE_LENGTH = 3;
var MINIMUM_RULE_LENGTH = 3;
var MAILTO = 'mailto:';
var ERROR_LIST_ITEM_INDENT = 'Cannot indent code properly. See ' +
    'http://git.io/mdast-lii';

/*
 * Expressions.
 */

var EXPRESSIONS_WHITE_SPACE = /\s/;

/*
 * Naive fence expression.
 */

var FENCE = /([`~])\1{2}/;

/*
 * Expression for a protocol.
 *
 * @see http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax
 */

var PROTOCOL = /^[a-z][a-z+.-]+:\/?/i;

/*
 * Punctuation characters.
 */

var PUNCTUATION = /[-!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~_]/;

/*
 * Characters.
 */

var ANGLE_BRACKET_CLOSE = '>';
var ANGLE_BRACKET_OPEN = '<';
var ASTERISK = '*';
var BACKSLASH = '\\';
var CARET = '^';
var COLON = ':';
var SEMICOLON = ';';
var DASH = '-';
var DOT = '.';
var EMPTY = '';
var EQUALS = '=';
var EXCLAMATION_MARK = '!';
var HASH = '#';
var AMPERSAND = '&';
var LINE = '\n';
var CARRIAGE = '\r';
var FORM_FEED = '\f';
var PARENTHESIS_OPEN = '(';
var PARENTHESIS_CLOSE = ')';
var PIPE = '|';
var PLUS = '+';
var QUOTE_DOUBLE = '"';
var QUOTE_SINGLE = '\'';
var SPACE = ' ';
var TAB = '\t';
var VERTICAL_TAB = '\u000B';
var SQUARE_BRACKET_OPEN = '[';
var SQUARE_BRACKET_CLOSE = ']';
var TICK = '`';
var TILDE = '~';
var UNDERSCORE = '_';

/*
 * Entities.
 */

var ENTITY_AMPERSAND = AMPERSAND + 'amp' + SEMICOLON;
var ENTITY_ANGLE_BRACKET_OPEN = AMPERSAND + 'lt' + SEMICOLON;
var ENTITY_COLON = AMPERSAND + '#x3A' + SEMICOLON;

/*
 * Character combinations.
 */

var BREAK = LINE + LINE;
var GAP = BREAK + LINE;
var DOUBLE_TILDE = TILDE + TILDE;

/*
 * Allowed entity options.
 */

var ENTITY_OPTIONS = {};

ENTITY_OPTIONS.true = true;
ENTITY_OPTIONS.false = true;
ENTITY_OPTIONS.numbers = true;
ENTITY_OPTIONS.escape = true;

/*
 * Allowed list-bullet characters.
 */

var LIST_BULLETS = {};

LIST_BULLETS[ASTERISK] = true;
LIST_BULLETS[DASH] = true;
LIST_BULLETS[PLUS] = true;

/*
 * Allowed horizontal-rule bullet characters.
 */

var HORIZONTAL_RULE_BULLETS = {};

HORIZONTAL_RULE_BULLETS[ASTERISK] = true;
HORIZONTAL_RULE_BULLETS[DASH] = true;
HORIZONTAL_RULE_BULLETS[UNDERSCORE] = true;

/*
 * Allowed emphasis characters.
 */

var EMPHASIS_MARKERS = {};

EMPHASIS_MARKERS[UNDERSCORE] = true;
EMPHASIS_MARKERS[ASTERISK] = true;

/*
 * Allowed fence markers.
 */

var FENCE_MARKERS = {};

FENCE_MARKERS[TICK] = true;
FENCE_MARKERS[TILDE] = true;

/*
 * Which method to use based on `list.ordered`.
 */

var ORDERED_MAP = {};

ORDERED_MAP.true = 'visitOrderedItems';
ORDERED_MAP.false = 'visitUnorderedItems';

/*
 * Allowed list-item-indent's.
 */

var LIST_ITEM_INDENTS = {};

var LIST_ITEM_TAB = 'tab';
var LIST_ITEM_ONE = '1';
var LIST_ITEM_MIXED = 'mixed';

LIST_ITEM_INDENTS[LIST_ITEM_ONE] = true;
LIST_ITEM_INDENTS[LIST_ITEM_TAB] = true;
LIST_ITEM_INDENTS[LIST_ITEM_MIXED] = true;

/*
 * Which checkbox to use.
 */

var CHECKBOX_MAP = {};

CHECKBOX_MAP.null = EMPTY;
CHECKBOX_MAP.undefined = EMPTY;
CHECKBOX_MAP.true = SQUARE_BRACKET_OPEN + 'x' + SQUARE_BRACKET_CLOSE + SPACE;
CHECKBOX_MAP.false = SQUARE_BRACKET_OPEN + SPACE + SQUARE_BRACKET_CLOSE +
    SPACE;

/**
 * Encode noop.
 * Simply returns the given value.
 *
 * @example
 *   var encode = encodeNoop();
 *   encode('AT&T') // 'AT&T'
 *
 * @param {string} value - Content.
 * @return {string} - Content, without any modifications.
 */
function encodeNoop(value) {
    return value;
}

/**
 * Factory to encode HTML entities.
 * Creates a no-operation function when `type` is
 * `'false'`, a function which encodes using named
 * references when `type` is `'true'`, and a function
 * which encodes using numbered references when `type` is
 * `'numbers'`.
 *
 * @example
 *   encodeFactory('false')('AT&T') // 'AT&T'
 *   encodeFactory('true')('AT&T') // 'AT&amp;T'
 *   encodeFactory('numbers')('AT&T') // 'ATT&#x26;T'
 *
 * @param {string} type - Either `'true'`, `'false'`, or
 *   `'numbers'`.
 * @return {function(string): string} - Function which
 *   takes a value and returns its encoded version.
 */
function encodeFactory(type) {
    var options = {};

    if (type === 'false') {
        return encodeNoop;
    }

    if (type === 'true') {
        options.useNamedReferences = true;
    }

    if (type === 'escape') {
        options.escapeOnly = options.useNamedReferences = true;
    }

    /**
     * Encode HTML entities using `he` using bound options.
     *
     * @see https://github.com/mathiasbynens/he#strict
     *
     * @example
     *   // When `type` is `'true'`.
     *   encode('AT&T'); // 'AT&amp;T'
     *
     *   // When `type` is `'numbers'`.
     *   encode('AT&T'); // 'ATT&#x26;T'
     *
     * @param {string} value - Content.
     * @param {Object} [node] - Node which is compiled.
     * @return {string} - Encoded content.
     * @throws {Error} - When `file.quiet` is not `true`.
     *   However, by default `he` does not throw on
     *   parse errors, but when
     *   `he.encode.options.strict: true`, they occur on
     *   invalid HTML.
     */
    function encoder(value) {
        return encode(value, options);
    }

    return encoder;
}

/**
 * Returns the length of HTML entity that is a prefix of
 * the given string (excluding the ampersand), 0 if it
 * does not start with an entity.
 *
 * @example
 *   entityPrefixLength('&copycat') // 4
 *   entityPrefixLength('&foo &amp &bar') // 0
 *
 * @param {string} value - Input string.
 * @return {number} - Length of an entity.
 */
function entityPrefixLength(value) {
    var prefix;

    /* istanbul ignore if - Currently also tested for at
     * implemention, but we keep it here because thats
     * proper. */
    if (value.charAt(0) !== AMPERSAND) {
        return 0;
    }

    prefix = value.split(AMPERSAND, 2).join(AMPERSAND);

    return prefix.length - decode(prefix).length;
}

/**
 * Checks if a string starts with HTML entity.
 *
 * @example
 *   startsWithEntity('&copycat') // true
 *   startsWithEntity('&foo &amp &bar') // false
 *
 * @param {string} value - Value to check.
 * @return {number} - Whether `value` starts an entity.
 */
function startsWithEntity(value) {
    return entityPrefixLength(value) > 0;
}

/**
 * Check if `character` is a valid alignment row character.
 *
 * @example
 *   isAlignmentRowCharacter(':') // true
 *   isAlignmentRowCharacter('=') // false
 *
 * @param {string} character - Character to check.
 * @return {boolean} - Whether `character` is a valid
 *   alignment row character.
 */
function isAlignmentRowCharacter(character) {
    return character === COLON ||
        character === DASH ||
        character === SPACE ||
        character === PIPE;
}

/**
 * Check if `index` in `value` is inside an alignment row.
 *
 * @example
 *   isInAlignmentRow(':--:', 2) // true
 *   isInAlignmentRow(':--:\n:-*-:', 9) // false
 *
 * @param {string} value - Value to check.
 * @param {number} index - Position in `value` to check.
 * @return {boolean} - Whether `index` in `value` is in
 *   an alignment row.
 */
function isInAlignmentRow(value, index) {
    var length = value.length;
    var start = index;
    var character;

    while (++index < length) {
        character = value.charAt(index);

        if (character === LINE) {
            break;
        }

        if (!isAlignmentRowCharacter(character)) {
            return false;
        }
    }

    index = start;

    while (--index > -1) {
        character = value.charAt(index);

        if (character === LINE) {
            break;
        }

        if (!isAlignmentRowCharacter(character)) {
            return false;
        }
    }

    return true;
}

/**
 * Factory to escape characters.
 *
 * @example
 *   var escape = escapeFactory({ commonmark: true });
 *   escape('x*x', { type: 'text', value: 'x*x' }) // 'x\\*x'
 *
 * @param {Object} options - Compiler options.
 * @return {function(value, node, parent): string} - Function which
 *   takes a value and a node and (optionally) its parent and returns
 *   its escaped value.
 */
function escapeFactory(options) {
    /**
     * Escape punctuation characters in a node's value.
     *
     * @param {string} value - Value to escape.
     * @param {Object} node - Node in which `value` exists.
     * @param {Object} [parent] - Parent of `node`.
     * @return {string} - Escaped `value`.
     */
    return function escape(value, node, parent) {
        var self = this;
        var gfm = options.gfm;
        var commonmark = options.commonmark;
        var siblings = parent && parent.children;
        var index = siblings && siblings.indexOf(node);
        var prev = siblings && siblings[index - 1];
        var next = siblings && siblings[index + 1];
        var length = value.length;
        var position = -1;
        var queue = [];
        var escaped = queue;
        var afterNewLine;
        var character;

        if (prev) {
            afterNewLine = prev.type === 'text' && /\n\s*$/.test(prev.value);
        } else if (parent) {
            afterNewLine = parent.type === 'paragraph';
        }

        while (++position < length) {
            character = value.charAt(position);

            if (
                character === BACKSLASH ||
                character === TICK ||
                character === ASTERISK ||
                character === SQUARE_BRACKET_OPEN ||
                character === UNDERSCORE ||
                (self.inLink && character === SQUARE_BRACKET_CLOSE) ||
                (
                    gfm &&
                    character === PIPE &&
                    (
                        self.inTable ||
                        isInAlignmentRow(value, position)
                    )
                )
            ) {
                afterNewLine = false;
                queue.push(BACKSLASH);
            } else if (character === ANGLE_BRACKET_OPEN) {
                afterNewLine = false;

                if (commonmark) {
                    queue.push(BACKSLASH);
                } else {
                    queue.push(ENTITY_ANGLE_BRACKET_OPEN);
                    continue;
                }
            } else if (
                gfm &&
                !self.inLink &&
                character === COLON &&
                (
                    queue.slice(-6).join(EMPTY) === 'mailto' ||
                    queue.slice(-5).join(EMPTY) === 'https' ||
                    queue.slice(-4).join(EMPTY) === 'http'
                )
            ) {
                afterNewLine = false;

                if (commonmark) {
                    queue.push(BACKSLASH);
                } else {
                    queue.push(ENTITY_COLON);
                    continue;
                }
            /* istanbul ignore if - Impossible to test with
             * the current set-up.  We need tests which try
             * to force markdown content into the tree. */
            } else if (
                character === AMPERSAND &&
                startsWithEntity(value.slice(position))
            ) {
                afterNewLine = false;

                if (commonmark) {
                    queue.push(BACKSLASH);
                } else {
                    queue.push(ENTITY_AMPERSAND);
                    continue;
                }
            } else if (
                gfm &&
                character === TILDE &&
                value.charAt(position + 1) === TILDE
            ) {
                queue.push(BACKSLASH, TILDE);
                afterNewLine = false;
                position += 1;
            } else if (character === LINE) {
                afterNewLine = true;
            } else if (afterNewLine) {
                if (
                    character === ANGLE_BRACKET_CLOSE ||
                    character === HASH ||
                    LIST_BULLETS[character]
                ) {
                    queue.push(BACKSLASH);
                    afterNewLine = false;
                } else if (
                    character !== SPACE &&
                    character !== TAB &&
                    character !== CARRIAGE &&
                    character !== VERTICAL_TAB &&
                    character !== FORM_FEED
                ) {
                    afterNewLine = false;
                }
            }

            queue.push(character);
        }

        /*
         * Multi-node versions.
         */

        if (siblings && node.type === 'text') {
            /*
             * Check for an opening parentheses after a
             * link-reference (which can be joined by
             * white-space).
             */

            if (
                prev &&
                prev.referenceType === 'shortcut'
            ) {
                position = -1;
                length = escaped.length;

                while (++position < length) {
                    character = escaped[position];

                    if (character === SPACE || character === TAB) {
                        continue;
                    }

                    if (character === PARENTHESIS_OPEN) {
                        escaped[position] = BACKSLASH + character;
                    }

                    if (character === COLON) {
                        if (commonmark) {
                            escaped[position] = BACKSLASH + character;
                        } else {
                            escaped[position] = ENTITY_COLON;
                        }
                    }

                    break;
                }
            }

            /*
             * Ensure non-auto-links are not seen as links.
             * This pattern needs to check the preceding
             * nodes too.
             */

            if (
                gfm &&
                !self.inLink &&
                prev &&
                prev.type === 'text' &&
                value.charAt(0) === COLON
            ) {
                queue = prev.value.slice(-6);

                if (
                    queue === 'mailto' ||
                    queue.slice(-5) === 'https' ||
                    queue.slice(-4) === 'http'
                ) {
                    if (commonmark) {
                        escaped.unshift(BACKSLASH);
                    } else {
                        escaped.splice(0, 1, ENTITY_COLON);
                    }
                }
            }

            /*
             * Escape ampersand if it would otherwise
             * start an entity.
             */

            if (
                next &&
                next.type === 'text' &&
                value.slice(-1) === AMPERSAND &&
                startsWithEntity(AMPERSAND + next.value)
            ) {
                if (commonmark) {
                    escaped.splice(escaped.length - 1, 0, BACKSLASH);
                } else {
                    escaped.push('amp', SEMICOLON);
                }
            }

            /*
             * Escape double tildes in GFM.
             */

            if (
                gfm &&
                next &&
                next.type === 'text' &&
                value.slice(-1) === TILDE &&
                next.value.charAt(0) === TILDE
            ) {
                escaped.splice(escaped.length - 1, 0, BACKSLASH);
            }
        }

        return escaped.join(EMPTY);
    };
}

/**
 * Wrap `url` in angle brackets when needed, or when
 * forced.
 *
 * In links, images, and definitions, the URL part needs
 * to be enclosed when it:
 *
 * - has a length of `0`;
 * - contains white-space;
 * - has more or less opening than closing parentheses.
 *
 * @example
 *   encloseURI('foo bar') // '<foo bar>'
 *   encloseURI('foo(bar(baz)') // '<foo(bar(baz)>'
 *   encloseURI('') // '<>'
 *   encloseURI('example.com') // 'example.com'
 *   encloseURI('example.com', true) // '<example.com>'
 *
 * @param {string} uri - URI to enclose.
 * @param {boolean?} [always] - Force enclosing.
 * @return {boolean} - Properly enclosed `uri`.
 */
function encloseURI(uri, always) {
    if (
        always ||
        !uri.length ||
        EXPRESSIONS_WHITE_SPACE.test(uri) ||
        ccount(uri, PARENTHESIS_OPEN) !== ccount(uri, PARENTHESIS_CLOSE)
    ) {
        return ANGLE_BRACKET_OPEN + uri + ANGLE_BRACKET_CLOSE;
    }

    return uri;
}

/**
 * There is currently no way to support nested delimiters
 * across Markdown.pl, CommonMark, and GitHub (RedCarpet).
 * The following code supports Markdown.pl and GitHub.
 * CommonMark is not supported when mixing double- and
 * single quotes inside a title.
 *
 * @see https://github.com/vmg/redcarpet/issues/473
 * @see https://github.com/jgm/CommonMark/issues/308
 *
 * @example
 *   encloseTitle('foo') // '"foo"'
 *   encloseTitle('foo \'bar\' baz') // '"foo \'bar\' baz"'
 *   encloseTitle('foo "bar" baz') // '\'foo "bar" baz\''
 *   encloseTitle('foo "bar" \'baz\'') // '"foo "bar" \'baz\'"'
 *
 * @param {string} title - Content.
 * @return {string} - Properly enclosed title.
 */
function encloseTitle(title) {
    var delimiter = QUOTE_DOUBLE;

    if (title.indexOf(delimiter) !== -1) {
        delimiter = QUOTE_SINGLE;
    }

    return delimiter + title + delimiter;
}

/**
 * Pad `value` with `level * INDENT` spaces.  Respects
 * lines. Ignores empty lines.
 *
 * @example
 *   pad('foo', 1) // '    foo'
 *
 * @param {string} value - Content.
 * @param {number} level - Indentation level.
 * @return {string} - Padded `value`.
 */
function pad(value, level) {
    var index;
    var padding;

    value = value.split(LINE);

    index = value.length;
    padding = repeat(SPACE, level * INDENT);

    while (index--) {
        if (value[index].length !== 0) {
            value[index] = padding + value[index];
        }
    }

    return value.join(LINE);
}

/**
 * Construct a new compiler.
 *
 * @example
 *   var compiler = new Compiler(new File('> foo.'));
 *
 * @constructor
 * @class {Compiler}
 * @param {File} file - Virtual file.
 * @param {Object?} [options] - Passed to
 *   `Compiler#setOptions()`.
 */
function Compiler(file, options) {
    var self = this;

    self.file = file;

    self.options = extend({}, self.options);

    self.setOptions(options);
}

/*
 * Cache prototype.
 */

var compilerPrototype = Compiler.prototype;

/*
 * Expose defaults.
 */

compilerPrototype.options = defaultOptions;

/*
 * Map of applicable enum's.
 */

var maps = {
    'entities': ENTITY_OPTIONS,
    'bullet': LIST_BULLETS,
    'rule': HORIZONTAL_RULE_BULLETS,
    'listItemIndent': LIST_ITEM_INDENTS,
    'emphasis': EMPHASIS_MARKERS,
    'strong': EMPHASIS_MARKERS,
    'fence': FENCE_MARKERS
};

/**
 * Set options.  Does not overwrite previously set
 * options.
 *
 * @example
 *   var compiler = new Compiler();
 *   compiler.setOptions({bullet: '*'});
 *
 * @this {Compiler}
 * @throws {Error} - When an option is invalid.
 * @param {Object?} [options] - Stringify settings.
 * @return {Compiler} - `self`.
 */
compilerPrototype.setOptions = function (options) {
    var self = this;
    var current = self.options;
    var ruleRepetition;
    var key;

    if (options === null || options === undefined) {
        options = {};
    } else if (typeof options === 'object') {
        options = extend({}, options);
    } else {
        raise(options, 'options');
    }

    for (key in defaultOptions) {
        validate[typeof current[key]](
            options, key, current[key], maps[key]
        );
    }

    ruleRepetition = options.ruleRepetition;

    if (ruleRepetition && ruleRepetition < MINIMUM_RULE_LENGTH) {
        raise(ruleRepetition, 'options.ruleRepetition');
    }

    self.encode = encodeFactory(String(options.entities));
    self.escape = escapeFactory(options);

    self.options = options;

    return self;
};

/*
 * Enter and exit helpers.
 */

compilerPrototype.enterLink = stateToggler('inLink', false);
compilerPrototype.enterTable = stateToggler('inTable', false);

/**
 * Shortcut and collapsed link references need no escaping
 * and encoding during the processing of child nodes (it
 * must be implied from identifier).
 *
 * This toggler turns encoding and escaping off for shortcut
 * and collapsed references.
 *
 * Implies `enterLink`.
 *
 * @param {Compiler} compiler - Compiler instance.
 * @param {LinkReference} node - LinkReference node.
 * @return {Function} - Exit state.
 */
compilerPrototype.enterLinkReference = function (compiler, node) {
    var encode = compiler.encode;
    var escape = compiler.escape;
    var exitLink = compiler.enterLink();

    if (
        node.referenceType === 'shortcut' ||
        node.referenceType === 'collapsed'
    ) {
        compiler.encode = compiler.escape = encodeNoop;
        return function () {
            compiler.encode = encode;
            compiler.escape = escape;
            exitLink();
        };
    } else {
        return exitLink;
    }
};

/**
 * Visit a node.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.visit({
 *     type: 'strong',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '**Foo**'
 *
 * @param {Object} node - Node.
 * @param {Object?} [parent] - `node`s parent.
 * @return {string} - Compiled `node`.
 */
compilerPrototype.visit = function (node, parent) {
    var self = this;

    /*
     * Fail on unknown nodes.
     */

    if (typeof self[node.type] !== 'function') {
        self.file.fail(
            'Missing compiler for node of type `' +
            node.type + '`: `' + node + '`',
            node
        );
    }

    return self[node.type](node, parent);
};

/**
 * Visit all children of `parent`.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.all({
 *     type: 'strong',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     },
 *     {
 *       type: 'text',
 *       value: 'Bar'
 *     }]
 *   });
 *   // ['Foo', 'Bar']
 *
 * @param {Object} parent - Parent node of children.
 * @return {Array.<string>} - List of compiled children.
 */
compilerPrototype.all = function (parent) {
    var self = this;
    var children = parent.children;
    var values = [];
    var index = 0;
    var length = children.length;
    var node = children[0];
    var next;

    if (length === 0) {
        return values;
    }

    while (++index < length) {
        next = children[index];

        if (
            node.type === next.type &&
            node.type in MERGEABLE_NODES &&
            mergeable(node) &&
            mergeable(next)
        ) {
            node = MERGEABLE_NODES[node.type].call(self, node, next);
        } else {
            values.push(self.visit(node, parent));
            node = next;
        }
    }

    values.push(self.visit(node, parent));

    return values;
};

/**
 * Visit ordered list items.
 *
 * Starts the list with
 * `node.start` and increments each following list item
 * bullet by one:
 *
 *     2. foo
 *     3. bar
 *
 * In `incrementListMarker: false` mode, does not increment
 * each marker and stays on `node.start`:
 *
 *     1. foo
 *     1. bar
 *
 * Adds an extra line after an item if it has
 * `loose: true`.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.visitOrderedItems({
 *     type: 'list',
 *     ordered: true,
 *     children: [{
 *       type: 'listItem',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // '1.  bar'
 *
 * @param {Object} node - `list` node with
 *   `ordered: true`.
 * @return {string} - Markdown list.
 */
compilerPrototype.visitOrderedItems = function (node) {
    var self = this;
    var increment = self.options.incrementListMarker;
    var values = [];
    var start = node.start;
    var children = node.children;
    var length = children.length;
    var index = -1;
    var bullet;

    while (++index < length) {
        bullet = (increment ? start + index : start) + DOT;
        values[index] = self.listItem(children[index], node, index, bullet);
    }

    return values.join(LINE);
};

/**
 * Visit unordered list items.
 *
 * Uses `options.bullet` as each item's bullet.
 *
 * Adds an extra line after an item if it has
 * `loose: true`.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.visitUnorderedItems({
 *     type: 'list',
 *     ordered: false,
 *     children: [{
 *       type: 'listItem',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // '-   bar'
 *
 * @param {Object} node - `list` node with
 *   `ordered: false`.
 * @return {string} - Markdown list.
 */
compilerPrototype.visitUnorderedItems = function (node) {
    var self = this;
    var values = [];
    var children = node.children;
    var length = children.length;
    var index = -1;
    var bullet = self.options.bullet;

    while (++index < length) {
        values[index] = self.listItem(children[index], node, index, bullet);
    }

    return values.join(LINE);
};

/**
 * Stringify a block node with block children (e.g., `root`
 * or `blockquote`).
 *
 * Knows about code following a list, or adjacent lists
 * with similar bullets, and places an extra newline
 * between them.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.block({
 *     type: 'root',
 *     children: [{
 *       type: 'paragraph',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // 'bar'
 *
 * @param {Object} node - `root` node.
 * @return {string} - Markdown block content.
 */
compilerPrototype.block = function (node) {
    var self = this;
    var values = [];
    var children = node.children;
    var length = children.length;
    var index = -1;
    var child;
    var prev;

    while (++index < length) {
        child = children[index];

        if (prev) {
            /*
             * Duplicate nodes, such as a list
             * directly following another list,
             * often need multiple new lines.
             *
             * Additionally, code blocks following a list
             * might easily be mistaken for a paragraph
             * in the list itself.
             */

            if (child.type === prev.type && prev.type === 'list') {
                values.push(prev.ordered === child.ordered ? GAP : BREAK);
            } else if (
                prev.type === 'list' &&
                child.type === 'code' &&
                !child.lang
            ) {
                values.push(GAP);
            } else {
                values.push(BREAK);
            }
        }

        values.push(self.visit(child, node));

        prev = child;
    }

    return values.join(EMPTY);
};

/**
 * Stringify a root.
 *
 * Adds a final newline to ensure valid POSIX files.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.root({
 *     type: 'root',
 *     children: [{
 *       type: 'paragraph',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // 'bar'
 *
 * @param {Object} node - `root` node.
 * @return {string} - Markdown document.
 */
compilerPrototype.root = function (node) {
    return this.block(node) + LINE;
};

/**
 * Stringify a heading.
 *
 * In `setext: true` mode and when `depth` is smaller than
 * three, creates a setext header:
 *
 *     Foo
 *     ===
 *
 * Otherwise, an ATX header is generated:
 *
 *     ### Foo
 *
 * In `closeAtx: true` mode, the header is closed with
 * hashes:
 *
 *     ### Foo ###
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.heading({
 *     type: 'heading',
 *     depth: 2,
 *     children: [{
 *       type: 'strong',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // '## **bar**'
 *
 * @param {Object} node - `heading` node.
 * @return {string} - Markdown heading.
 */
compilerPrototype.heading = function (node) {
    var self = this;
    var setext = self.options.setext;
    var closeAtx = self.options.closeAtx;
    var depth = node.depth;
    var content = self.all(node).join(EMPTY);
    var prefix;

    if (setext && depth < 3) {
        return content + LINE +
            repeat(depth === 1 ? EQUALS : DASH, content.length);
    }

    prefix = repeat(HASH, node.depth);
    content = prefix + SPACE + content;

    if (closeAtx) {
        content += SPACE + prefix;
    }

    return content;
};

/**
 * Stringify text.
 *
 * Supports named entities in `settings.encode: true` mode:
 *
 *     AT&amp;T
 *
 * Supports numbered entities in `settings.encode: numbers`
 * mode:
 *
 *     AT&#x26;T
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.text({
 *     type: 'text',
 *     value: 'foo'
 *   });
 *   // 'foo'
 *
 * @param {Object} node - `text` node.
 * @param {Object} parent - Parent of `node`.
 * @return {string} - Raw markdown text.
 */
compilerPrototype.text = function (node, parent) {
    return this.encode(this.escape(node.value, node, parent), node);
};

/**
 * Stringify a paragraph.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.paragraph({
 *     type: 'paragraph',
 *     children: [{
 *       type: 'strong',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // '**bar**'
 *
 * @param {Object} node - `paragraph` node.
 * @return {string} - Markdown paragraph.
 */
compilerPrototype.paragraph = function (node) {
    return this.all(node).join(EMPTY);
};

/**
 * Stringify a block quote.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.paragraph({
 *     type: 'blockquote',
 *     children: [{
 *       type: 'paragraph',
 *       children: [{
 *         type: 'strong',
 *         children: [{
 *           type: 'text',
 *           value: 'bar'
 *         }]
 *       }]
 *     }]
 *   });
 *   // '> **bar**'
 *
 * @param {Object} node - `blockquote` node.
 * @return {string} - Markdown block quote.
 */
compilerPrototype.blockquote = function (node) {
    var values = this.block(node).split(LINE);
    var result = [];
    var length = values.length;
    var index = -1;
    var value;

    while (++index < length) {
        value = values[index];
        result[index] = (value ? SPACE : EMPTY) + value;
    }

    return ANGLE_BRACKET_CLOSE + result.join(LINE + ANGLE_BRACKET_CLOSE);
};

/**
 * Stringify a list. See `Compiler#visitOrderedList()` and
 * `Compiler#visitUnorderedList()` for internal working.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.visitUnorderedItems({
 *     type: 'list',
 *     ordered: false,
 *     children: [{
 *       type: 'listItem',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // '-   bar'
 *
 * @param {Object} node - `list` node.
 * @return {string} - Markdown list.
 */
compilerPrototype.list = function (node) {
    return this[ORDERED_MAP[node.ordered]](node);
};

/**
 * Stringify a list item.
 *
 * Prefixes the content with a checked checkbox when
 * `checked: true`:
 *
 *     [x] foo
 *
 * Prefixes the content with an unchecked checkbox when
 * `checked: false`:
 *
 *     [ ] foo
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.listItem({
 *     type: 'listItem',
 *     checked: true,
 *     children: [{
 *       type: 'text',
 *       value: 'bar'
 *     }]
 *   }, {
 *     type: 'list',
 *     ordered: false,
 *     children: [{
 *       type: 'listItem',
 *       checked: true,
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   }, 0, '*');
 *   '-   [x] bar'
 *
 * @param {Object} node - `listItem` node.
 * @param {Object} parent - `list` node.
 * @param {number} position - Index of `node` in `parent`.
 * @param {string} bullet - Bullet to use.  This, and the
 *   `listItemIndent` setting define the used indent.
 * @return {string} - Markdown list item.
 */
compilerPrototype.listItem = function (node, parent, position, bullet) {
    var self = this;
    var style = self.options.listItemIndent;
    var children = node.children;
    var values = [];
    var index = -1;
    var length = children.length;
    var loose = node.loose;
    var value;
    var indent;
    var spacing;

    while (++index < length) {
        values[index] = self.visit(children[index], node);
    }

    value = CHECKBOX_MAP[node.checked] + values.join(loose ? BREAK : LINE);

    if (
        style === LIST_ITEM_ONE ||
        (style === LIST_ITEM_MIXED && value.indexOf(LINE) === -1)
    ) {
        indent = bullet.length + 1;
        spacing = SPACE;
    } else {
        indent = Math.ceil((bullet.length + 1) / INDENT) * INDENT;
        spacing = repeat(SPACE, indent - bullet.length);
    }

    value = bullet + spacing + pad(value, indent / INDENT).slice(indent);

    if (loose && parent.children.length - 1 !== position) {
        value += LINE;
    }

    return value;
};

/**
 * Stringify inline code.
 *
 * Knows about internal ticks (`\``), and ensures one more
 * tick is used to enclose the inline code:
 *
 *     ```foo ``bar`` baz```
 *
 * Even knows about inital and final ticks:
 *
 *     `` `foo ``
 *     `` foo` ``
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.inlineCode({
 *     type: 'inlineCode',
 *     value: 'foo(); `bar`; baz()'
 *   });
 *   // '``foo(); `bar`; baz()``'
 *
 * @param {Object} node - `inlineCode` node.
 * @return {string} - Markdown inline code.
 */
compilerPrototype.inlineCode = function (node) {
    var value = node.value;
    var ticks = repeat(TICK, longestStreak(value, TICK) + 1);
    var start = ticks;
    var end = ticks;

    if (value.charAt(0) === TICK) {
        start += SPACE;
    }

    if (value.charAt(value.length - 1) === TICK) {
        end = SPACE + end;
    }

    return start + node.value + end;
};

/**
 * Stringify YAML front matter.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.yaml({
 *     type: 'yaml',
 *     value: 'foo: bar'
 *   });
 *   // '---\nfoo: bar\n---'
 *
 * @param {Object} node - `yaml` node.
 * @return {string} - Markdown YAML document.
 */
compilerPrototype.yaml = function (node) {
    var delimiter = repeat(DASH, YAML_FENCE_LENGTH);
    var value = node.value ? LINE + node.value : EMPTY;

    return delimiter + value + LINE + delimiter;
};

/**
 * Stringify a code block.
 *
 * Creates indented code when:
 *
 * - No language tag exists;
 * - Not in `fences: true` mode;
 * - A non-empty value exists.
 *
 * Otherwise, GFM fenced code is created:
 *
 *     ```js
 *     foo();
 *     ```
 *
 * When in ``fence: `~` `` mode, uses tildes as fences:
 *
 *     ~~~js
 *     foo();
 *     ~~~
 *
 * Knows about internal fences (Note: GitHub/Kramdown does
 * not support this):
 *
 *     ````javascript
 *     ```markdown
 *     foo
 *     ```
 *     ````
 *
 * Supports named entities in the language flag with
 * `settings.encode` mode.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.code({
 *     type: 'code',
 *     lang: 'js',
 *     value: 'fooo();'
 *   });
 *   // '```js\nfooo();\n```'
 *
 * @param {Object} node - `code` node.
 * @param {Object} parent - Parent of `node`.
 * @return {string} - Markdown code block.
 */
compilerPrototype.code = function (node, parent) {
    var self = this;
    var value = node.value;
    var options = self.options;
    var marker = options.fence;
    var language = self.encode(node.lang || EMPTY, node);
    var fence;

    /*
     * Without (needed) fences.
     */

    if (!language && !options.fences && value) {
        /*
         * Throw when pedantic, in a list item which
         * isnt compiled using a tab.
         */

        if (
            parent &&
            parent.type === 'listItem' &&
            options.listItemIndent !== LIST_ITEM_TAB &&
            options.pedantic
        ) {
            self.file.fail(ERROR_LIST_ITEM_INDENT, node.position);
        }

        return pad(value, 1);
    }

    fence = longestStreak(value, marker) + 1;

    /*
     * Fix GFM / RedCarpet bug, where fence-like characters
     * inside fenced code can exit a code-block.
     * Yes, even when the outer fence uses different
     * characters, or is longer.
     * Thus, we can only pad the code to make it work.
     */

    if (FENCE.test(value)) {
        value = pad(value, 1);
    }

    fence = repeat(marker, Math.max(fence, MINIMUM_CODE_FENCE_LENGTH));

    return fence + language + LINE + value + LINE + fence;
};

/**
 * Stringify HTML.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.html({
 *     type: 'html',
 *     value: '<div>bar</div>'
 *   });
 *   // '<div>bar</div>'
 *
 * @param {Object} node - `html` node.
 * @return {string} - Markdown HTML.
 */
compilerPrototype.html = function (node) {
    return node.value;
};

/**
 * Stringify a horizontal rule.
 *
 * The character used is configurable by `rule`: (`'_'`)
 *
 *     ___
 *
 * The number of repititions is defined through
 * `ruleRepetition`: (`6`)
 *
 *     ******
 *
 * Whether spaces delimit each character, is configured
 * through `ruleSpaces`: (`true`)
 *
 *     * * *
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.horizontalRule({
 *     type: 'horizontalRule'
 *   });
 *   // '***'
 *
 * @return {string} - Markdown rule.
 */
compilerPrototype.horizontalRule = function () {
    var options = this.options;
    var rule = repeat(options.rule, options.ruleRepetition);

    if (options.ruleSpaces) {
        rule = rule.split(EMPTY).join(SPACE);
    }

    return rule;
};

/**
 * Stringify a strong.
 *
 * The marker used is configurable by `strong`, which
 * defaults to an asterisk (`'*'`) but also accepts an
 * underscore (`'_'`):
 *
 *     _foo_
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.strong({
 *     type: 'strong',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '**Foo**'
 *
 * @param {Object} node - `strong` node.
 * @return {string} - Markdown strong-emphasised text.
 */
compilerPrototype.strong = function (node) {
    var marker = this.options.strong;

    marker = marker + marker;

    return marker + this.all(node).join(EMPTY) + marker;
};

/**
 * Stringify an emphasis.
 *
 * The marker used is configurable by `emphasis`, which
 * defaults to an underscore (`'_'`) but also accepts an
 * asterisk (`'*'`):
 *
 *     *foo*
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.emphasis({
 *     type: 'emphasis',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '_Foo_'
 *
 * @param {Object} node - `emphasis` node.
 * @return {string} - Markdown emphasised text.
 */
compilerPrototype.emphasis = function (node) {
    var marker = this.options.emphasis;

    return marker + this.all(node).join(EMPTY) + marker;
};

/**
 * Stringify a hard break.
 *
 * In Commonmark mode, trailing backslash form is used in order
 * to preserve trailing whitespace that the line may end with,
 * and also for better visibility.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.break({
 *     type: 'break'
 *   });
 *   // '  \n'
 *
 * @return {string} - Hard markdown break.
 */
compilerPrototype.break = function () {
    return this.options.commonmark ? BACKSLASH + LINE : SPACE + SPACE + LINE;
};

/**
 * Stringify a delete.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.delete({
 *     type: 'delete',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '~~Foo~~'
 *
 * @param {Object} node - `delete` node.
 * @return {string} - Markdown strike-through.
 */
compilerPrototype.delete = function (node) {
    return DOUBLE_TILDE + this.all(node).join(EMPTY) + DOUBLE_TILDE;
};

/**
 * Stringify a link.
 *
 * When no title exists, the compiled `children` equal
 * `href`, and `href` starts with a protocol, an auto
 * link is created:
 *
 *     <http://example.com>
 *
 * Otherwise, is smart about enclosing `href` (see
 * `encloseURI()`) and `title` (see `encloseTitle()`).
 *
 *    [foo](<foo at bar dot com> 'An "example" e-mail')
 *
 * Supports named entities in the `href` and `title` when
 * in `settings.encode` mode.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.link({
 *     type: 'link',
 *     href: 'http://example.com',
 *     title: 'Example Domain',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '[Foo](http://example.com "Example Domain")'
 *
 * @param {Object} node - `link` node.
 * @return {string} - Markdown link.
 */
compilerPrototype.link = function (node) {
    var self = this;
    var url = self.encode(node.href, node);
    var exit = self.enterLink();
    var escapedURL = self.encode(self.escape(node.href, node));
    var value = self.all(node).join(EMPTY);

    exit();

    if (
        node.title === null &&
        PROTOCOL.test(url) &&
        (escapedURL === value || escapedURL === MAILTO + value)
    ) {
        /*
         * Backslash escapes do not work in autolinks,
         * so we do not escape.
         */

        return encloseURI(self.encode(node.href), true);
    }

    url = encloseURI(url);

    if (node.title) {
        url += SPACE + encloseTitle(self.encode(self.escape(
            node.title, node
        ), node));
    }

    value = SQUARE_BRACKET_OPEN + value + SQUARE_BRACKET_CLOSE;

    value += PARENTHESIS_OPEN + url + PARENTHESIS_CLOSE;

    return value;
};

/**
 * Stringify a link label.
 *
 * Because link references are easily, mistakingly,
 * created (for example, `[foo]`), reference nodes have
 * an extra property depicting how it looked in the
 * original document, so stringification can cause minimal
 * changes.
 *
 * @example
 *   label({
 *     type: 'referenceImage',
 *     referenceType: 'full',
 *     identifier: 'foo'
 *   });
 *   // '[foo]'
 *
 *   label({
 *     type: 'referenceImage',
 *     referenceType: 'collapsed',
 *     identifier: 'foo'
 *   });
 *   // '[]'
 *
 *   label({
 *     type: 'referenceImage',
 *     referenceType: 'shortcut',
 *     identifier: 'foo'
 *   });
 *   // ''
 *
 * @param {Object} node - `linkReference` or
 *   `imageReference` node.
 * @return {string} - Markdown label reference.
 */
function label(node) {
    var value = EMPTY;
    var type = node.referenceType;

    if (type === 'full') {
        value = node.identifier;
    }

    if (type !== 'shortcut') {
        value = SQUARE_BRACKET_OPEN + value + SQUARE_BRACKET_CLOSE;
    }

    return value;
}

/**
 * For shortcut and collapsed reference links, the contents
 * is also an identifier, so we need to restore the original
 * encoding and escaping that were present in the source
 * string.
 *
 * This function takes the unescaped & unencoded value from
 * shortcut's child nodes and the identifier and encodes
 * the former according to the latter.
 *
 * @example
 *   copyIdentifierEncoding('a*b', 'a\\*b*c')
 *   // 'a\\*b*c'
 *
 * @param {string} value - Unescaped and unencoded stringified
 *   link value.
 * @param {string} identifier - Link identifier.
 * @return {string} - Encoded link value.
 */
function copyIdentifierEncoding(value, identifier) {
    var index = 0;
    var position = 0;
    var length = value.length;
    var count = identifier.length;
    var result = [];
    var start;

    while (index < length) {
        /*
         * Take next non-punctuation characters from `value`.
         */

        start = index;

        while (
            index < length &&
            !PUNCTUATION.test(value.charAt(index))
        ) {
            index += 1;
        }

        result.push(value.slice(start, index));

        /*
         * Advance `position` to the next punctuation character.
         */
        while (
            position < count &&
            !PUNCTUATION.test(identifier.charAt(position))
        ) {
            position += 1;
        }

        /*
         * Take next punctuation characters from `identifier`.
         */
        start = position;

        while (
            position < count &&
            PUNCTUATION.test(identifier.charAt(position))
        ) {
            if (identifier.charAt(position) === AMPERSAND) {
                position += entityPrefixLength(identifier.slice(position));
            }
            position += 1;
        }

        result.push(identifier.slice(start, position));

        /*
         * Advance `index` to the next non-punctuation character.
         */
        while (index < length && PUNCTUATION.test(value.charAt(index))) {
            index += 1;
        }
    }

    return result.join(EMPTY);
}

/**
 * Stringify a link reference.
 *
 * See `label()` on how reference labels are created.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.linkReference({
 *     type: 'linkReference',
 *     referenceType: 'collapsed',
 *     identifier: 'foo',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '[Foo][]'
 *
 * @param {Object} node - `linkReference` node.
 * @return {string} - Markdown link reference.
 */
compilerPrototype.linkReference = function (node) {
    var self = this;
    var exitLinkReference = self.enterLinkReference(self, node);
    var value = self.all(node).join(EMPTY);

    exitLinkReference();

    if (
        node.referenceType === 'shortcut' ||
        node.referenceType === 'collapsed'
    ) {
        value = copyIdentifierEncoding(value, node.identifier);
    }

    return SQUARE_BRACKET_OPEN + value + SQUARE_BRACKET_CLOSE + label(node);
};

/**
 * Stringify an image reference.
 *
 * See `label()` on how reference labels are created.
 *
 * Supports named entities in the `alt` when
 * in `settings.encode` mode.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.imageReference({
 *     type: 'imageReference',
 *     referenceType: 'full',
 *     identifier: 'foo',
 *     alt: 'Foo'
 *   });
 *   // '![Foo][foo]'
 *
 * @param {Object} node - `imageReference` node.
 * @return {string} - Markdown image reference.
 */
compilerPrototype.imageReference = function (node) {
    var alt = this.encode(node.alt, node) || EMPTY;

    return EXCLAMATION_MARK +
        SQUARE_BRACKET_OPEN + alt + SQUARE_BRACKET_CLOSE +
        label(node);
};

/**
 * Stringify a footnote reference.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.footnoteReference({
 *     type: 'footnoteReference',
 *     identifier: 'foo'
 *   });
 *   // '[^foo]'
 *
 * @param {Object} node - `footnoteReference` node.
 * @return {string} - Markdown footnote reference.
 */
compilerPrototype.footnoteReference = function (node) {
    return SQUARE_BRACKET_OPEN + CARET + node.identifier +
        SQUARE_BRACKET_CLOSE;
};

/**
 * Stringify an link- or image definition.
 *
 * Is smart about enclosing `href` (see `encloseURI()`) and
 * `title` (see `encloseTitle()`).
 *
 *    [foo]: <foo at bar dot com> 'An "example" e-mail'
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.definition({
 *     type: 'definition',
 *     link: 'http://example.com',
 *     title: 'Example Domain',
 *     identifier: 'foo'
 *   });
 *   // '[foo]: http://example.com "Example Domain"'
 *
 * @param {Object} node - `definition` node.
 * @return {string} - Markdown link- or image definition.
 */
compilerPrototype.definition = function (node) {
    var value = SQUARE_BRACKET_OPEN + node.identifier + SQUARE_BRACKET_CLOSE;
    var url = encloseURI(node.link);

    if (node.title) {
        url += SPACE + encloseTitle(node.title);
    }

    return value + COLON + SPACE + url;
};

/**
 * Stringify an image.
 *
 * Is smart about enclosing `href` (see `encloseURI()`) and
 * `title` (see `encloseTitle()`).
 *
 *    ![foo](</fav icon.png> 'My "favourite" icon')
 *
 * Supports named entities in `src`, `alt`, and `title`
 * when in `settings.encode` mode.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.image({
 *     type: 'image',
 *     href: 'http://example.png/favicon.png',
 *     title: 'Example Icon',
 *     alt: 'Foo'
 *   });
 *   // '![Foo](http://example.png/favicon.png "Example Icon")'
 *
 * @param {Object} node - `image` node.
 * @return {string} - Markdown image.
 */
compilerPrototype.image = function (node) {
    var url = encloseURI(this.encode(node.src, node));
    var value;

    if (node.title) {
        url += SPACE + encloseTitle(this.encode(node.title, node));
    }

    value = EXCLAMATION_MARK +
        SQUARE_BRACKET_OPEN + this.encode(node.alt || EMPTY, node) +
        SQUARE_BRACKET_CLOSE;

    value += PARENTHESIS_OPEN + url + PARENTHESIS_CLOSE;

    return value;
};

/**
 * Stringify a footnote.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.footnote({
 *     type: 'footnote',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '[^Foo]'
 *
 * @param {Object} node - `footnote` node.
 * @return {string} - Markdown footnote.
 */
compilerPrototype.footnote = function (node) {
    return SQUARE_BRACKET_OPEN + CARET + this.all(node).join(EMPTY) +
        SQUARE_BRACKET_CLOSE;
};

/**
 * Stringify a footnote definition.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.footnoteDefinition({
 *     type: 'footnoteDefinition',
 *     identifier: 'foo',
 *     children: [{
 *       type: 'paragraph',
 *       children: [{
 *         type: 'text',
 *         value: 'bar'
 *       }]
 *     }]
 *   });
 *   // '[^foo]: bar'
 *
 * @param {Object} node - `footnoteDefinition` node.
 * @return {string} - Markdown footnote definition.
 */
compilerPrototype.footnoteDefinition = function (node) {
    var id = node.identifier.toLowerCase();

    return SQUARE_BRACKET_OPEN + CARET + id +
        SQUARE_BRACKET_CLOSE + COLON + SPACE +
        this.all(node).join(BREAK + repeat(SPACE, INDENT));
};

/**
 * Stringify table.
 *
 * Creates a fenced table by default, but not in
 * `looseTable: true` mode:
 *
 *     Foo | Bar
 *     :-: | ---
 *     Baz | Qux
 *
 * NOTE: Be careful with `looseTable: true` mode, as a
 * loose table inside an indented code block on GitHub
 * renders as an actual table!
 *
 * Creates a spaces table by default, but not in
 * `spacedTable: false`:
 *
 *     |Foo|Bar|
 *     |:-:|---|
 *     |Baz|Qux|
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.table({
 *     type: 'table',
 *     align: ['center', null],
 *     children: [
 *       {
 *         type: 'tableHeader',
 *         children: [
 *           {
 *             type: 'tableCell'
 *             children: [{
 *               type: 'text'
 *               value: 'Foo'
 *             }]
 *           },
 *           {
 *             type: 'tableCell'
 *             children: [{
 *               type: 'text'
 *               value: 'Bar'
 *             }]
 *           }
 *         ]
 *       },
 *       {
 *         type: 'tableRow',
 *         children: [
 *           {
 *             type: 'tableCell'
 *             children: [{
 *               type: 'text'
 *               value: 'Baz'
 *             }]
 *           },
 *           {
 *             type: 'tableCell'
 *             children: [{
 *               type: 'text'
 *               value: 'Qux'
 *             }]
 *           }
 *         ]
 *       }
 *     ]
 *   });
 *   // '| Foo | Bar |\n| :-: | --- |\n| Baz | Qux |'
 *
 * @param {Object} node - `table` node.
 * @return {string} - Markdown table.
 */
compilerPrototype.table = function (node) {
    var self = this;
    var loose = self.options.looseTable;
    var spaced = self.options.spacedTable;
    var rows = node.children;
    var index = rows.length;
    var exit = self.enterTable();
    var result = [];
    var start;

    while (index--) {
        result[index] = self.all(rows[index]);
    }

    exit();

    start = loose ? EMPTY : spaced ? PIPE + SPACE : PIPE;

    return table(result, {
        'align': node.align,
        'start': start,
        'end': start.split(EMPTY).reverse().join(EMPTY),
        'delimiter': spaced ? SPACE + PIPE + SPACE : PIPE
    });
};

/**
 * Stringify a table cell.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.tableCell({
 *     type: 'tableCell',
 *     children: [{
 *       type: 'text'
 *       value: 'Qux'
 *     }]
 *   });
 *   // 'Qux'
 *
 * @param {Object} node - `tableCell` node.
 * @return {string} - Markdown table cell.
 */
compilerPrototype.tableCell = function (node) {
    return this.all(node).join(EMPTY);
};

/**
 * Stringify the bound file.
 *
 * @example
 *   var file = new VFile('__Foo__');
 *
 *   file.namespace('mdast').tree = {
 *     type: 'strong',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *
 *   new Compiler(file).compile();
 *   // '**Foo**'
 *
 * @this {Compiler}
 * @return {string} - Markdown document.
 */
compilerPrototype.compile = function () {
    return this.visit(this.file.namespace('mdast').tree);
};

/*
 * Expose `stringify` on `module.exports`.
 */

module.exports = Compiler;

},
"ASDCxahJ+Or7CgLG3GNNAJoIL7PCdeAgI6EXsMNVwck=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')
var valid = require('../lib/validators')

exports.name = 'block'
exports.version = '1.0.0'
exports.manifest = {
  isBlocked  : 'sync',
}

exports.init = function (sbot) {

  //TODO: move other blocking code in here,
  //      i think we'll need a hook system for this.

  //if a currently connected peer is blocked, disconnect them immediately.
  pull(
    sbot.friends.createFriendStream({graph: 'flag', live: true}),
    pull.drain(function (blocked) {
      if(sbot.peers[blocked]) {
        sbot.peers[blocked].forEach(function (b) {
          b.close(true, function () {})
        })
      }
    })
  )

  function isBlocked (_opts) {
    var opts

    if('string' === typeof _opts)
      opts = {
        source: sbot.id, dest: _opts, graph:'flag'
      }
    else opts = {
      source: _opts.source, dest: _opts.dest, graph: 'flag'
    }
    return sbot.friends.get(opts)
  }

  sbot.createHistoryStream.hook(function (fn, args) {
    var opts = args[0], id = this.id
    if(opts.id !== this.id && isBlocked({source: opts.id, dest: this.id}))
      return fn({id: null, sequence: 0})
    else
      return pull(
        fn.apply(this, args),
        //break off this feed if they suddenly block
        //the recipient.
        pull.take(function (msg) {
          //handle when createHistoryStream is called with keys: true
          if(!msg.content && msg.value.content)
            msg = msg.value
          if(msg.content.type !== 'contact') return true
          return !(
            msg.content.flagged &&
            msg.content.contact === id
          )
        })
      )
  })

  sbot.auth.hook(function (fn, args) {
    if(isBlocked(args[0])) args[1](new Error('client is blocked'))
    else return fn.apply(this, args)
  })

  return {isBlocked: valid.sync(isBlocked, 'feedId|isBlockedOpts') }

}

},
"AUxu/Cmmc0FX3M7yXM88JLsjfwjSfPBegwTEWDwbJq8=":
function (require, module, exports, __dirname, __filename) {
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},
"AbPXrX3k5ewZpKfUv2eCaF2LR8rtRdZZE+blrCXeo9o=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')
var Queue = require('./queue')

function each (obj, iter) {
  for(var k in obj)
    iter(obj[k], k, obj)
}

function first (obj, test) {
  var v
  for (var k in obj)
    if(v = test(obj[k], k, obj))
      return v
}

function union (a, b) {
  b = toArray(b)
  a = toArray(a)
  if(!a.length) return b
  if(a.length < b.length) {
    var t = b; b = a; a = t
  }
  b.forEach(function (e) {
    if(!~a.indexOf(e)) a.push(e)
  })
  return a
}

function toArray (s) {
  return s != null ? (Array.isArray(s) ? s : [s]) : []
}

function isFunction (f) {
  return 'function' === typeof f
}

var MB = 1024*1024
//default replication limits.
var defaults = {limit: [-1, 100*MB, 20*MB], minLimit: 5*MB}
module.exports = function (sbot, opts, notify, userQuotas) {
  var jobs = {}, hasQueue, getQueue
  var conf = opts.blobs || defaults, wl

  //keep track of who is over quota so that it doesn't get logged again and again.
  var over = {}

  // calculate quotas for each feed.
  // start with size of each blob
  // divided between the feeds that mention it.
  // getting a use for each feed.

  function createJob(id, owner, cb) {
    toArray(owner).forEach(function (e) {
      if(e[0] !== '@') throw new Error('not a owner:'+e)
    })
    if(jobs[id]) {
      jobs[id].owner = union(jobs[id].owner, owner || [])
      jobs[id].cbs.push(cb)
      return
    }
    hasQueue.push(jobs[id] = {
      id: id, has: {}, owner: toArray(owner),
      cbs: cb ? [cb] : [], done: false
    })
  }

  function finishJob(job) {
    if(!job) return
    delete jobs[job.id]
    while(job.cbs && job.cbs.length) {
      var cb = job.cbs.shift()
      if(isFunction(cb)) cb(null, true)
    }
  }

  //if want is called and then it's locally added,
  //handle that by calling back want.
  pull(notify.listen(), pull.drain(function (hash) {
    finishJob(hasQueue.pull(hash) || getQueue.pull(hash))
  }))

  function hasPeers () {
    return Object.keys(sbot.peers).length !== 0
  }

  function hops (id) {
    var p = sbot.friends.path({
      source: sbot.id, dest: id, hops: conf.limit.length
    })
    return p ? p.length - 1 : -1
  }

  function limitFor(id) {
    if(opts.party) return -1
    var h = hops(id)
    if(hops === -1) return conf.minLimit
    return conf.limit[h] || conf.minLimit
  }

  function filter (job) {
    //set config.blobs.party = true
    //to disable all quotas.
    if(conf.party) return true
    return job.owner.every(function (id) {
      var l = limitFor(id)
      if(l < 0) return true
      else if ((userQuotas[id] || 0) < l)
        return true
      else if(!over[id]) {
        over[id] = userQuotas[id]
        console.log('Over Quota:', id, wl.quota(id))
      }
    })
  }

  hasQueue = Queue(function (_, done) {
    //check if there is a something in the has queue.
    //filter out cases where work is impossible...
    //(empty queue, or no peers)
    if(!hasPeers()) return done()

    var job = hasQueue.pull(filter)

    if(!job || job.done) return done()

    var n = 0, found = false
    each(sbot.peers, function (peers, id) {
      if(('undefined' !== typeof job.has[id]) || !peers[0]) return
      n++
      peers[0].blobs.has(job.id, function (err, has) {
        found = found || (job.has[id] = has)
        if(--n) return
        next()
      })
    })
    if(!n) return hasQueue.push(job), done()

    function next () {
      (found ? getQueue : hasQueue).push(job)
      done()
    }
  })

  getQueue = Queue(function (_, done) {
    if(!hasPeers()) return done()

    //check if this file is over quota.
    var job = getQueue.pull(filter)
    if(!job) return done()
    //this covers weird edgecase where a blob is added
    //while something is looking for it. covered in
    //test/blobs2.js
    if(job.done) {
      delete jobs[job.id]
      return done()
    }

    var remote = first(job.has, function (has, id) {
      if (has)
        return getPeer(id)
    })

    if(!remote) {
      hasQueue.push(job); return done()
    }

    pull(
      remote.blobs.get(job.id),
      //only accept blobs that have the correct size.
      sbot.blobs.add(job.id, function (err) {
        if(!err) {
          finishJob(job)
          return done() //success
        }
        // remove the remote, it may be misbehaving
        delete job.has[remote.id]
        // put it back on the get or has queue
        if(Object.keys(job.has).length) getQueue.push(job)
        else hasQueue.push(job)
        done()
      })
    )
  })

  function getPeer(id) {
    return sbot.peers[id] && sbot.peers[id][0]
  }

  // monitor the feed for new links to blobs
  pull(
    sbot.links({dest: '&', live: true}),
    pull.drain(function (data) {
      // do we have the referenced blob yet?
      sbot.blobs.has(data.dest, function (_, has) {
        if(!has) createJob(data.dest, data.source)
      })
    })
  )

  //handle weird edge case where something is added locally
  //but we are already looking for it because we saw a link.
  sbot.on('blobs:got', function (hash) {
    if(jobs[hash]) jobs[hash].done = true
  })

  sbot.on('rpc:connect', function (rpc) {
    for(id in jobs)
      if(false === jobs[id].has[rpc.id])
        delete jobs[id].has[rpc.id]
  })

  return wl = {
    has: hasQueue,
    get: getQueue,
    want: function (id, owner, cb) {
      createJob(id, owner || sbot.id, cb)
    },
    quota: function (id) {
      var l = limitFor(id), q = userQuotas[id] || 0
      return {
        limit: l,
        usage: q,
        hops: hops(id),
        percent: ((q/l)*100).toPrecision(4)+'%'
      }
    }
  }
}




},
"AhGM13F38Ugmo+1/psfxxr/69gITlpyAFudfqUhCubg=":
function (require, module, exports, __dirname, __filename) {
module.exports = of

// of := (Value) => Continuable<Value>
function of(value) {
    return function continuable(callback) {
        callback(null, value)
    }
}

},
"Ahj5MOWAc3zLSPmCu+tk09wAk00L3ACy/9cMQiayvUg=":
function (require, module, exports, __dirname, __filename) {
'use strict'

var Blobs  = require('multiblob')
var path   = require('path')
var pull   = require('pull-stream')
var isBlob = require('ssb-ref').isBlobId
var Quota  = require('./quota')
var Notify = require('pull-notify')
var mdm    = require('mdmanifest')
var valid  = require('../../lib/validators')
var apidoc = require('../../lib/apidocs').blobs
var Replicate = require('./replication')

// blobs plugin
// methods to read/write the blobstore
// and automated blob-fetching from the network

function isFunction (f) {
  return 'function' === typeof f
}

function desigil (hash) {
  return isBlob(hash) ? hash.substring(1) : hash
}

function resigil (hash) {
  return isBlob(hash) ? hash : '&'+hash
}

function isString (s) {
  return 'string' === typeof s
}

module.exports = {
  name: 'blobs',
  version: '0.0.0',
  manifest: mdm.manifest(apidoc),
  permissions: {
    anonymous: {allow: ['has', 'get', 'changes']},
  },
  init: function (sbot, opts) {

    var notify = Notify()
    var config = opts

    var blobs = sbot._blobs = Blobs({
      dir: path.join(config.path, 'blobs'),
      hash: 'sha256'
    })

    var userQuotas = {} // map of { feedId => quotaUsage }, for rate-limiting
    var drain = Quota(sbot, blobs, userQuotas)
    var wantList = Replicate(sbot, config, notify, userQuotas)

    return {
      get: valid.source(function (hash) {
        return blobs.get(desigil(hash))
      }, 'blobId'),

      has: valid.async(function (hash, cb) {
        //emit blobs:has event when this api is called remotely.
        //needed to make tests pass. should probably remove this.
        if(this.id) sbot.emit('blobs:has', hash)
        blobs.has(desigil(hash), cb)
      }, 'blobId|array'),

      size: valid.async(function (hash, cb) {
        //sbot.emit('blobs:size', hash)
        blobs.size(desigil(hash), cb)
      }, 'blobId|array'),

      add: valid.sink(function (hash, cb) {
        // cb once blob is successfully added.
        // sink cbs are not exposed over rpc
        // so this is only available when using this api 
        if(isFunction(hash)) cb = hash, hash = null

        return blobs.add(desigil(hash), function (err, hash) {
          if(!err) {
            hash = resigil(hash)
            sbot.emit('blobs:got', hash)
            notify(hash)
            //wait until quotas have been calculated
            //befor returning (tests will fail without this)
            if(cb) drain(function () {
              cb(null, hash)
            })
          }
          else {
            if(cb) cb(err, hash)
            else   console.error(err.stack)
          }
        })
      }, 'string?'),

      rm: valid.async(function (hash, cb) {
        return blobs.rm(desigil(hash), cb)
      }, 'string'),

      ls: function (opts) {
        return pull(blobs.ls(opts), pull.map(function (e) {
          if(e.sync) return e
          if(isString(e)) return resigil(e)
          e.id = resigil(e.id)
          return e
        }))
      },
      // request to retrieve a blob,
      // calls back when that file is available.
      // - `opts.nowait`: call cb immediately if not found (dont register for callback)
      want: valid.async(function (hash, opts, cb) {
        if (isFunction(opts)) {
          cb = opts
          opts = null
        }
        var id = this.id
        if(!isBlob(hash)) return cb(new Error('not a hash:' + hash))

        sbot.emit('blobs:wants', hash)
        blobs.has(desigil(hash), function (_, has) {
          if (has) return cb(null, true)
          // update queue
          wantList.want(hash, id, cb)
        })
      }, 'blobId', 'object?'),

      changes: function () {
        return notify.listen()
      },

      quota: valid.sync(function (id) {
        return wantList.quota(id)
      }, 'feedId'),

      // get current want list
      wants: function () {
        return wantList.jobs
      }
    }
  }
}

},
"Aiof4cwLPSta1X4eOgc9moqQX2P/I4sJUCAvGWgJico=":
function (require, module, exports, __dirname, __filename) {
var os = require('os')
var ip = require('ip')
//pick the first reasonable looking host.
//this should *just work* when running on a vps.

var isPrivate = ip.isPrivate

function isNonPrivate (e) {
  return !isPrivate(e)
}


var address = module.exports = function (inter, filter) {
  inter = inter || os.networkInterfaces()
  filter = filter || isNonPrivate
  for(var k in inter) {
    for(var i in inter[k]) {
      var e = inter[k][i]
      // find a reasonable looking address
      if(!e.internal && filter(e.address, e))
          return e.address
    }
  }
}

function isV4 (e) {
  return e.family === 'IPv4'
}

function isV6 (e) {
  return e.family === 'IPv6'
}

var private = module.exports.private = function (inter) {
  return address(inter, isPrivate)
}

module.exports.v4 = address(null, function (addr, e) {
  return isV4(e) && isNonPrivate(addr)
})

module.exports.v6 = address(null, function (addr, e) {
  return isV6(e) && isNonPrivate(addr)
})

private.v4 = address(null, function (addr, e) {
  return isV4(e) && isPrivate(addr)
})

private.v6 = address(null, function (addr, e) {
  return isV6(e) && isPrivate(addr)
})

module.exports.all = {
  public: {
    v4: module.exports.v4, v6: module.exports.v6
  },
  private: {
    v4: private.v4, v6: private.v6
  }
}


if(!module.parent) {
  console.log(module.exports.all)
}

},
"AqVGCNrxVxtp4LhJsi+BzEUKQnv2xXCUhkK7hqxssS0=":
function (require, module, exports, __dirname, __filename) {
var u      = require('pull-core')
var sources = require('./sources')
var sinks = require('./sinks')

var prop   = u.prop
var id     = u.id
var tester = u.tester

var map = exports.map = 
function (read, map) {
  map = prop(map) || id
  return function (abort, cb) {
    read(abort, function (end, data) {
      try {
      data = !end ? map(data) : null
      } catch (err) {
        return read(err, function () {
          return cb(err)
        })
      }
      cb(end, data)
    })
  }
}

var asyncMap = exports.asyncMap =
function (read, map) {
  if(!map) return read
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    read(null, function (end, data) {
      if(end) return cb(end, data)
      map(data, cb)
    })
  }
}

var paraMap = exports.paraMap =
function (read, map, width) {
  if(!map) return read
  var ended = false, queue = [], _cb

  function drain () {
    if(!_cb) return
    var cb = _cb
    _cb = null
    if(queue.length)
      return cb(null, queue.shift())
    else if(ended && !n)
      return cb(ended)
    _cb = cb
  }

  function pull () {
    read(null, function (end, data) {
      if(end) {
        ended = end
        return drain()
      }
      n++
      map(data, function (err, data) {
        n--

        queue.push(data)
        drain()
      })

      if(n < width && !ended)
        pull()
    })
  }

  var n = 0
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    //continue to read while there are less than 3 maps in flight
    _cb = cb
    if(queue.length || ended)
      pull(), drain()
    else pull()
  }
  return highWaterMark(asyncMap(read, map), width)
}

var filter = exports.filter =
function (read, test) {
  //regexp
  test = tester(test)
  return function next (end, cb) {
    var sync, loop = true
    while(loop) {
      loop = false
      sync = true
      read(end, function (end, data) {
        if(!end && !test(data))
          return sync ? loop = true : next(end, cb)
        cb(end, data)
      })
      sync = false
    }
  }
}

var filterNot = exports.filterNot =
function (read, test) {
  test = tester(test)
  return filter(read, function (e) {
    return !test(e)
  })
}

var through = exports.through = 
function (read, op, onEnd) {
  var a = false
  function once (abort) {
    if(a || !onEnd) return
    a = true
    onEnd(abort === true ? null : abort)
  }

  return function (end, cb) {
    if(end) once(end)
    return read(end, function (end, data) {
      if(!end) op && op(data)
      else once(end)
      cb(end, data)
    })
  }
}

var take = exports.take =
function (read, test) {
  var ended = false
  if('number' === typeof test) {
    var n = test; test = function () {
      return n --
    }
  }

  return function (end, cb) {
    if(ended) return cb(ended)
    if(ended = end) return read(ended, cb)

    read(null, function (end, data) {
      if(ended = ended || end) return cb(ended)
      if(!test(data)) {
        ended = true
        read(true, function (end, data) {
          cb(ended, data)
        })
      }
      else
        cb(null, data)
    })
  }
}

var unique = exports.unique = function (read, field, invert) {
  field = prop(field) || id
  var seen = {}
  return filter(read, function (data) {
    var key = field(data)
    if(seen[key]) return !!invert //false, by default
    else seen[key] = true
    return !invert //true by default
  })
}

var nonUnique = exports.nonUnique = function (read, field) {
  return unique(read, field, true)
}

var group = exports.group =
function (read, size) {
  var ended; size = size || 5
  var queue = []

  return function (end, cb) {
    //this means that the upstream is sending an error.
    if(end) return read(ended = end, cb)
    //this means that we read an end before.
    if(ended) return cb(ended)

    read(null, function next(end, data) {
      if(ended = ended || end) {
        if(!queue.length)
          return cb(ended)

        var _queue = queue; queue = []
        return cb(null, _queue)
      }
      queue.push(data)
      if(queue.length < size)
        return read(null, next)

      var _queue = queue; queue = []
      cb(null, _queue)
    })
  }
}

var flatten = exports.flatten = function (read) {
  var _read
  return function (abort, cb) {
    if(_read) nextChunk()
    else      nextStream()

    function nextChunk () {
      _read(null, function (end, data) {
        if(end) nextStream()
        else    cb(null, data)
      })
    }
    function nextStream () {
      read(null, function (end, stream) {
        if(end)
          return cb(end)
        if(Array.isArray(stream))
          stream = sources.values(stream)
        else if('function' != typeof stream)
          throw new Error('expected stream of streams')
        
        _read = stream
        nextChunk()
      })
    }
  }
}

var prepend =
exports.prepend =
function (read, head) {

  return function (abort, cb) {
    if(head !== null) {
      if(abort)
        return read(abort, cb)
      var _head = head
      head = null
      cb(null, _head)
    } else {
      read(abort, cb)
    }
  }

}

//var drainIf = exports.drainIf = function (op, done) {
//  sinks.drain(
//}

var _reduce = exports._reduce = function (read, reduce, initial) {
  return function (close, cb) {
    if(close) return read(close, cb)
    if(ended) return cb(ended)

    sinks.drain(function (item) {
      initial = reduce(initial, item)
    }, function (err, data) {
      ended = err || true
      if(!err) cb(null, initial)
      else     cb(ended)
    })
    (read)
  }
}

var nextTick = process.nextTick

var highWaterMark = exports.highWaterMark =
function (read, highWaterMark) {
  var buffer = [], waiting = [], ended, ending, reading = false
  highWaterMark = highWaterMark || 10

  function readAhead () {
    while(waiting.length && (buffer.length || ended))
      waiting.shift()(ended, ended ? null : buffer.shift())

    if (!buffer.length && ending) ended = ending;
  }

  function next () {
    if(ended || ending || reading || buffer.length >= highWaterMark)
      return
    reading = true
    return read(ended || ending, function (end, data) {
      reading = false
      ending = ending || end
      if(data != null) buffer.push(data)

      next(); readAhead()
    })
  }

  process.nextTick(next)

  return function (end, cb) {
    ended = ended || end
    waiting.push(cb)

    next(); readAhead()
  }
}

var flatMap = exports.flatMap =
function (read, mapper) {
  mapper = mapper || id
  var queue = [], ended

  return function (abort, cb) {
    if(queue.length) return cb(null, queue.shift())
    else if(ended)   return cb(ended)

    read(abort, function next (end, data) {
      if(end) ended = end
      else {
        var add = mapper(data)
        while(add && add.length)
          queue.push(add.shift())
      }

      if(queue.length) cb(null, queue.shift())
      else if(ended)   cb(ended)
      else             read(null, next)
    })
  }
}


},
"BAb8PtZjQg38fOfdP6kJel/Askmzk4LekGrQIq39Zbo=":
function (require, module, exports, __dirname, __filename) {
module.exports = mapAsync

// mapAsync := (Continuable<A>, lambda: (A, Callback<B>)) => Continuable<B>
function mapAsync(source, lambda) {
    return function continuable(callback) {
        source(function continuation(err, value) {
            if (err) {
                return callback(err)
            }

            lambda(value, callback)
        })
    }
}

},
"BJhvFouPFvTyUjfQYIzfV7bKFPEA/tYsApW9olWasks=":
function (require, module, exports, __dirname, __filename) {
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},
"BPW+ohGOj+1TlKqaWFsfFn7zUbaW6USLAAF5Ln1+CLI=":
function (require, module, exports, __dirname, __filename) {
var maybeCallback = require("./maybe-callback.js")
maybeCallback.both = require("./both.js")
maybeCallback.chain = require("./chain.js")
maybeCallback.either = require("./either.js")
maybeCallback.error = require("./error.js")
maybeCallback.join = require("./join.js")
maybeCallback.mapAsync = require("./map-async.js")
maybeCallback.map = require("./map.js")
maybeCallback.of = require("./of.js")
maybeCallback.to = require("./to.js")

module.exports = maybeCallback


},
"BRyl1wpAIHYEkjXhofg3UElrJ9Zh3dzY2VLzYxEZqqI=":
function (require, module, exports, __dirname, __filename) {
var assert = require('assert')
var remark = require('remark')
var html = require('remark-html')

// - obj: object
// - path: array, a list of keys
// - value: any
// will create any subobject needed
// eg var x = {}; set(x, ['foo', 'bar'], 5); x.foo.bar == 5
function set (obj, path, value) {
  while (path.length > 1) {
    var k = path.shift()
    if (!obj[k])
      obj[k] = {}
    obj = obj[k]
  }
  obj[path[0]] = value
}

function fill (str, n) {
  if (n > str.length)
    return str + ' '.repeat(n - str.length)
  return str
}

function methodTable (methods, nameWidth) {
  // figure out how long the names column needs to be
  if (!nameWidth) {
    nameWidth = 1
    methods.forEach(function (m) {
      if (m.name.length > nameWidth)
        nameWidth = m.name.length
    })
  }

  return methods.map(function (m) {
    return '  ' + fill(m.name, nameWidth) + ' ' + m.desc
  }).join('').trim()
}

function parseMethodHeading (token, prefix) {
  var textToken = token.children[0]
  assert.equal(textToken.type, 'text', 'Headings should not have any markup')

  var parts = textToken.value.split(': ')
  assert.equal(parts.length, 2, 'Heading "'+textToken.value+'" should be of form `method: type`')
  
  var name = parts[0], type = parts[1]
  assert(nameRegex.test(name), 'Function name "'+name+'" does nots match '+nameRegex)
  assert(nameRegex.test(type), 'Function type "'+type+'" does not match '+typeRegex)

  if (prefix)
    parts[0] = prefix + '.' + parts[0]

  return parts
}

var nameRegex = /^[a-z][a-z0-9\.\-_]*$/i
var typeRegex = /^[a-z]+$/i
module.exports.manifest = function (text) {
  assert.equal(typeof text, 'string', 'Input should be a markdown string')

  var manifest = {}
  remark().parse(text).children.forEach(function (token, i) {
    if (token.type === 'heading' && token.depth === 2) {
      var parts = parseMethodHeading(token)
      set(manifest, parts[0].split('.'), parts[1])
    }
  })

  return manifest
}

module.exports.usage = function (text, cmd, opts) {
  assert.equal(typeof text, 'string', 'Input should be a markdown string')
  opts = opts || {}

  var lexer = remark()
  var tokens = lexer.parse(text).children
  if (!cmd) {
    // toplevel usage
    var inSummary = true // in the api summary?
    var toplevelParas = []
    var methods = []
    var currentMethod
    tokens.forEach(function (token) {
      if (token.type == 'paragraph' && inSummary) {
        // a para in the api's toplevel summary
        toplevelParas.push(lexer.stringify({ type: 'root', children: token.children }))
      } else if (token.type == 'heading' && token.depth == 2) {
        // a method heading
        inSummary = false // no longer in the api summary
        var parts = parseMethodHeading(token, opts.prefix)
        currentMethod = parts[0]
      }
      else if (token.type == 'paragraph' && currentMethod) {
        // the first para in a method
        methods.push({ name: currentMethod, desc: lexer.stringify({ type: 'root', children: token.children })})
        currentMethod = null
      }
    })
    if (currentMethod)
      methods.push({ name: currentMethod })
    return toplevelParas.join('\n') + '\nCommands:\n  ' + methodTable(methods, opts.nameWidth)
  }

  // method usage
  var inMethod = false // in the method?
  var elems = []
  for (var i=0; i < tokens.length; i++) {
    var token = tokens[i]
    if (token.type == 'heading') {
      // a heading
      if (inMethod)
        break // done pulling from the method's summary
      if (token.depth == 2 && parseMethodHeading(token)[0] == cmd)
        inMethod = true // we're in the target method's summary
    }
    else if (inMethod) {
      if (token.type == 'code') {
        // only include code examples for the CLI
        if (token.lang == 'bash' || token.lang == 'sh' || token.lang == 'shell' || !token.lang) {
          token.type = 'text'
          elems.push(token)
        }
      } else
        elems.push(token)
    }
  }
  return lexer
    .stringify({ type: 'root', children: elems })
    .trim()
    .replace(/\\\[/g, '[') // dont escape '['
}

module.exports.html = function (text) {
  assert.equal(typeof text, 'string', 'Input should be a markdown string')
  return remark().use(html).process(text)
}
},
"BaBU3XNYuC/dAjAHsmsNjoovvlJVJ9F8ErHT/fAfGqw=":
function (require, module, exports, __dirname, __filename) {
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},
"CCG7VfnVJmjiqojU3hIcpvXR16wywNOzElEGQTO0gNI=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module remark:html
 * @fileoverview Compile Markdown to HTML with remark.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var compilers = require('./lib/compilers');
var transformer = require('./lib/transformer');

/**
 * Attach an HTML compiler.
 *
 * @param {Remark} remark - Instance.
 * @param {Object?} [options] - Configuration.
 */
function plugin(remark, options) {
    var MarkdownCompiler = remark.Compiler;
    var ancestor = MarkdownCompiler.prototype;
    var proto;
    var key;

    /**
     * Extensible prototype.
     */
    function HTMLCompilerPrototype() {}

    HTMLCompilerPrototype.prototype = ancestor;

    proto = new HTMLCompilerPrototype();

    proto.options.xhtml = false;
    proto.options.sanitize = false;
    proto.options.entities = 'true';

    /**
     * Extensible constructor.
     *
     * @param {VFile} file - Virtual file.
     */
    function HTMLCompiler(file) {
        if (file.extension) {
            file.move({
                'extension': 'html'
            });
        }

        MarkdownCompiler.apply(this, [file, options]);
    }

    HTMLCompiler.prototype = proto;

    /*
     * Expose compilers.
     */

    for (key in compilers) {
        proto[key] = compilers[key];
    }

    remark.Compiler = HTMLCompiler;

    return transformer;
}

/*
 * Expose `plugin`.
 */

module.exports = plugin;

},
"CIDVcGPCFa+nEGez6vokCvNxNJKIA/mtRyEHrSLzgMo=":
function (require, module, exports, __dirname, __filename) {

var typewiselite = require('typewiselite')
var search = require('binary-search')
var ltgt = require('ltgt')

module.exports = function (compare) {

  var set = []

  compare = compare || typewiselite

  function index (item) {
    if(set.length === 0) return -1
    return search(set, item, compare, 0, set.length - 1)
  }

  return {
    add: function (item) {
      var i = index(item)
      //insert a if not already in the array.
      if(i < 0) i = ~i, set.splice(i, 0, item)
      return i
    },

    rm: function (item) {
      var i = index(item)
      //insert a if not already in the array.
      if(i >= 0) set.splice(i, 1)
      return i
    },

    has: function (item) {
      return index(item) >= 0
    },

    range: function (opts) {
      if(!opts) return set.slice()

      var lb = ltgt.lowerBound(opts) || null
      var lx = ltgt.lowerBoundExclusive(opts)
      var ub = ltgt.upperBound(opts) || undefined
      var ux = ltgt.upperBoundExclusive(opts)

      var i = index(lb)
      i = i < 0 ? ~i : i
      var j = index(ub)
      j = j < 0 ? ~j : j

      if(lx && compare(set[i], lb) === 0)
        i++
      if(!ux && compare(set[j], ub) === 0)
        j++

      var _set = set.slice(i, j)

      if(opts.reverse) _set.reverse()

      if(opts.limit) _set = _set.slice(0, opts.limit)

      return _set
    },

    array: set
  }

}

},
"COrqk1kH+qgsFK+ITWPhd0ROLv1O41t0Pxasmi3ZqkU=":
function (require, module, exports, __dirname, __filename) {
var Buffer = require('buffer').Buffer

module.exports = function(source, encoding) {
  return new Buffer(source, encoding)
}

},
"CRtl13gzdZnQFAs11TwDhgPRcy0nwzv+OeA4calpJrI=":
function (require, module, exports, __dirname, __filename) {
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},
"CYFjk0MA9cqunsqirN4JfopZp1rC3FTB21giVtLNJLQ=":
function (require, module, exports, __dirname, __filename) {
var slice = Array.prototype.slice

module.exports = to

function to(asyncFn) {
    return function () {
        var args = slice.call(arguments)
        var callback = args[args.length - 1]
        var self = this

        if (typeof callback === "function") {
            return asyncFn.apply(this, args)
        }

        return function continuable(callback) {
            var _args = args.slice()
            _args.push(callback)
            return asyncFn.apply(self, _args)
        }
    }
}

},
"CjHN3zu/36TgA0eBoBkFFjR+bkoa1pUbdCVsIh5Ppqc=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2013 Rod Vagg, MIT License */

var xtend                = require('xtend')
  , AbstractIterator     = require('./abstract-iterator')
  , AbstractChainedBatch = require('./abstract-chained-batch')

function AbstractLevelDOWN (location) {
  if (!arguments.length || location === undefined)
    throw new Error('constructor requires at least a location argument')

  if (typeof location != 'string')
    throw new Error('constructor requires a location string argument')

  this.location = location
  this.status = 'new'
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  var self      = this
    , oldStatus = this.status

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('open() requires a callback argument')

  if (typeof options != 'object')
    options = {}

  options.createIfMissing = options.createIfMissing != false
  options.errorIfExists = !!options.errorIfExists

  if (typeof this._open == 'function') {
    this.status = 'opening'
    this._open(options, function (err) {
      if (err) {
        self.status = oldStatus
        return callback(err)
      }
      self.status = 'open'
      callback()
    })
  } else {
    this.status = 'open'
    process.nextTick(callback)
  }
}

AbstractLevelDOWN.prototype.close = function (callback) {
  var self      = this
    , oldStatus = this.status

  if (typeof callback != 'function')
    throw new Error('close() requires a callback argument')

  if (typeof this._close == 'function') {
    this.status = 'closing'
    this._close(function (err) {
      if (err) {
        self.status = oldStatus
        return callback(err)
      }
      self.status = 'closed'
      callback()
    })
  } else {
    this.status = 'closed'
    process.nextTick(callback)
  }
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('get() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  options.asBuffer = options.asBuffer != false

  if (typeof this._get == 'function')
    return this._get(key, options, callback)

  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('put() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  // coerce value to string in node, don't touch it in browser
  // (indexeddb can store any JS type)
  if (value != null && !this._isBuffer(value) && !process.browser)
    value = String(value)

  if (typeof options != 'object')
    options = {}

  if (typeof this._put == 'function')
    return this._put(key, value, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  var err

  if (typeof options == 'function')
    callback = options

  if (typeof callback != 'function')
    throw new Error('del() requires a callback argument')

  if (err = this._checkKey(key, 'key', this._isBuffer))
    return callback(err)

  if (!this._isBuffer(key))
    key = String(key)

  if (typeof options != 'object')
    options = {}

  if (typeof this._del == 'function')
    return this._del(key, options, callback)

  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length)
    return this._chainedBatch()

  if (typeof options == 'function')
    callback = options

  if (typeof array == 'function')
    callback = array

  if (typeof callback != 'function')
    throw new Error('batch(array) requires a callback argument')

  if (!Array.isArray(array))
    return callback(new Error('batch(array) requires an array argument'))

  if (!options || typeof options != 'object')
    options = {}

  var i = 0
    , l = array.length
    , e
    , err

  for (; i < l; i++) {
    e = array[i]
    if (typeof e != 'object')
      continue

    if (err = this._checkKey(e.type, 'type', this._isBuffer))
      return callback(err)

    if (err = this._checkKey(e.key, 'key', this._isBuffer))
      return callback(err)
  }

  if (typeof this._batch == 'function')
    return this._batch(array, options, callback)

  process.nextTick(callback)
}

//TODO: remove from here, not a necessary primitive
AbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {
  if (   start == null
      || end == null
      || typeof start == 'function'
      || typeof end == 'function') {
    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments')
  }

  if (typeof callback != 'function')
    throw new Error('approximateSize() requires a callback argument')

  if (!this._isBuffer(start))
    start = String(start)

  if (!this._isBuffer(end))
    end = String(end)

  if (typeof this._approximateSize == 'function')
    return this._approximateSize(start, end, callback)

  process.nextTick(function () {
    callback(null, 0)
  })
}

AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
  var self = this

  options = xtend(options)

  ;[ 'start', 'end', 'gt', 'gte', 'lt', 'lte' ].forEach(function (o) {
    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0)
      delete options[o]
  })

  options.reverse = !!options.reverse
  options.keys = options.keys != false
  options.values = options.values != false
  options.limit = 'limit' in options ? options.limit : -1
  options.keyAsBuffer = options.keyAsBuffer != false
  options.valueAsBuffer = options.valueAsBuffer != false

  return options
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options != 'object')
    options = {}

  options = this._setupIteratorOptions(options)

  if (typeof this._iterator == 'function')
    return this._iterator(options)

  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._isBuffer = function (obj) {
  return Buffer.isBuffer(obj)
}

AbstractLevelDOWN.prototype._checkKey = function (obj, type) {

  if (obj === null || obj === undefined)
    return new Error(type + ' cannot be `null` or `undefined`')

  if (this._isBuffer(obj)) {
    if (obj.length === 0)
      return new Error(type + ' cannot be an empty Buffer')
  } else if (String(obj) === '')
    return new Error(type + ' cannot be an empty String')
}

module.exports = AbstractLevelDOWN

},
"Crin1SD/SJUBSV8jaTX5xHAFry2C+21LbfHLQxpfrEc=":
function (require, module, exports, __dirname, __filename) {
var path = require('path')
var pull = require('pull-stream')
var split = require('pull-split')
var core  = require('./core')
var fs    = require('fs')

var ancestors = 
exports.ancestors = 
function (dir) {
  dir = dir || process.cwd()
  var paths = []

  while(dir) {
    paths.push(dir)
    dir = path.dirname(dir)
    if(dir === '/') {
      paths.push(dir) 
      break
    }
  }

  return pull.values(paths)
}


var wc = 
exports.wc = 
function () {
  return pull.asyncMap(function (file, cb) {
    var data = {lines: 0, chars:0, words: 0, file: file}

    core.read(file)
    .pipe(split())
    .pipe(pull.reduce(function (total, line) {
      total.lines ++
      total.chars += line.length + 1 //+1 for new line
      //note, splitting, since it creates an array,
      //will not be the most optimal method.
      total.words +=
        line.split(/\s+/)
        .reduce(function (s, i) {
          return s + (i ? 1 : 0)
        }, 0)

      return total
    }, data, cb))
  })
}

var star =
exports.star = 
function (match) {
  return pull.map(function (dir) {
    return core.readdir(dir, match)
  })
  .pipe(pull.flatten())
  .pipe(pull.filter())
}

var starStar =
exports.starStar =
function (match) {
  var seen = {}
  return pull.map(function (dir) {
    var first = true
    return pull.depthFirst(path.resolve(dir), function (_dir) {
      return core.readdir(_dir, match)
      .pipe(pull.filter(function (e) {
        if(seen[e]) return false
        return seen[e] = true
      }))
    })

  })
  .pipe(pull.flatten())
  .pipe(pull.filter())
}

var resolve = 
exports.resolve = 
function (rel) {
 return pull.map(function (dir) { //map to $dir/node_modules
    if(rel)
      return path.resolve(dir, rel)
    return path.resolve(dir)
  })
}

var relative = 
exports.relative =
function (rel) {
  rel = rel || process.cwd()
  return pull.map(function (file) {
    return path.relative(rel, file)
  })
}

var absolute =
exports.absolute =
function () {
  return resolve()
}

var readFile =
exports.readFile = function (parse) {
  return pull.asyncMap(function (file, cb) {
    fs.readFile(file, 'utf-8', function (err, data) {
      if(err) return cb(err) 
      try {
         data = parse ? parse(data) : data
      } catch (err) {
        return cb(err)
      }
      return cb(null, data)
    })
  })
}

if(!module.parent) {
  pull.values(['.'])
  .pipe(starStar())
  .pipe(pull.drain(console.log))
}

},
"D0nA59GBhKIX7Sc5Kwjc5GZ5UCdU/INt/J2cmRjCIAQ=":
function (require, module, exports, __dirname, __filename) {
module.exports = join

// join := (Continuable<Continuable<T>>) => Continuable<T>
function join(source) {
    return function continuable(callback) {
        source(function continuation(err, next) {
            if (err) {
                return callback(err)
            }

            next(callback)
        })
    }
}

},
"DCz7NWqxOekMbHRmpp8ctQet00Bwrg9RRODkTgsGm6E=":
function (require, module, exports, __dirname, __filename) {
var util = require('util')
  , AbstractIterator = require('abstract-leveldown').AbstractIterator


function DeferredIterator (options) {
  AbstractIterator.call(this, options)

  this._options = options
  this._iterator = null
  this._operations = []
}

util.inherits(DeferredIterator, AbstractIterator)

DeferredIterator.prototype.setDb = function (db) {
  var it = this._iterator = db.iterator(this._options)
  this._operations.forEach(function (op) {
    it[op.method].apply(it, op.args)
  })
}

DeferredIterator.prototype._operation = function (method, args) {
  if (this._iterator)
    return this._iterator[method].apply(this._iterator, args)
  this._operations.push({ method: method, args: args })
}

'next end'.split(' ').forEach(function (m) {
  DeferredIterator.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

module.exports = DeferredIterator;

},
"DexsfBUFsq5FHMjez4Z9JtGCPLm5JDOvFd6UNZIu7Cs=":
function (require, module, exports, __dirname, __filename) {

var pull = require('pull-stream')
var Abortable = require('pull-abortable')
var Rate = require('./rate')

module.exports = function (duplex, min, onEnd) {
  if('function' === typeof min)
    onEnd = min, min = null

  var n = 2, error, interval

  function done (err) {
    error = error || err
    if(--n) return
    clearInterval(interval)
    onEnd && onEnd(error)
  }

  min = min || 1000 //close after 1 second inactivity.

  var sourceAbort = Abortable(done)
  var sinkAbort   = Abortable(done)
  var sourceRate  = Rate()
  var sinkRate    = Rate()

  function rate () {
    return sourceRate.rate() + sinkRate.rate()
  }

  function abort () {
    clearInterval(interval)
    sourceAbort.abort()
    sinkAbort.abort()
  }

  interval = setInterval(function () {
    if(!min) return
    if(Math.max(sourceRate.ts, sinkRate.ts) + min < Date.now())
      abort()
  }, 200)

  return {
    source: pull(duplex.source, sourceRate, sourceAbort),
    sink  : pull(sinkRate, sinkAbort, duplex.sink),
    rate  : rate,
    setTTL: function (_min) {
      if(!_min) clearInterval(interval)
      min = _min
      return this
    },
    abort : abort
  }

}

module.exports.through = function (min, onEnd) {
  min = min || 0.002 //2k per second
  var abortable = Abortable(onEnd)
  var flow = Rate()
  var interval = setInterval(function () {
    if(flow.rate() < min) {
      clearInterval(interval)
      abortable.abort()
    }
  }, 500)

  var stream = pull(
    flow,
    abortable,
    pull.through(null, function () {
      clearInterval(interval)
    })
  )

  stream.rate = flow.rate

  return stream
}

},
"E+L4oEbFSnp++gSNtiqqzjpJ0zA9kB55PRQJNyO4610=":
function (require, module, exports, __dirname, __filename) {
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
    } else if (typeof exports === 'object' &&
               typeof exports.nodeName !== 'string') {
        factory(exports);
    } else {
        factory(root.libsodium = {});
    }
})(this, function (exports) {
    "use strict";
    var Module = exports;
    Object.defineProperty(exports, '__esModule', { value: true });
var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};for(var key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var ENVIRONMENT_IS_WEB=typeof window==="object";var ENVIRONMENT_IS_WORKER=typeof importScripts==="function";var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=function print(x){process["stdout"].write(x+"\n")};if(!Module["printErr"])Module["printErr"]=function printErr(x){process["stderr"].write(x+"\n")};var nodeFS=require("fs");var nodePath=require("path");Module["read"]=function read(filename,binary){filename=nodePath["normalize"](filename);var ret=nodeFS["readFileSync"](filename);if(!ret&&filename!=nodePath["resolve"](filename)){filename=path.join(__dirname,"..","src",filename);ret=nodeFS["readFileSync"](filename)}if(ret&&!binary)ret=ret.toString();return ret};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};Module["load"]=function load(f){globalEval(read(f))};if(!Module["thisProgram"]){if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}else{Module["thisProgram"]="unknown-program"}}Module["arguments"]=process["argv"].slice(2);if(typeof module!=="undefined"){module["exports"]=Module}process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined"){Module["read"]=read}else{Module["read"]=function read(){throw"no read() available (jsc?)"}}Module["readBinary"]=function readBinary(f){if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}var data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=function print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function printErr(x){console.log(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?(function(x){dump(x)}):(function(x){})}if(ENVIRONMENT_IS_WORKER){Module["load"]=importScripts}if(typeof Module["setWindowTitle"]==="undefined"){Module["setWindowTitle"]=(function(title){document.title=title})}}else{throw"Unknown runtime environment. Where are we?"}function globalEval(x){throw"NO_DYNAMIC_EXECUTION was set, cannot eval"}if(!Module["load"]&&Module["read"]){Module["load"]=function load(f){globalEval(Module["read"](f))}}if(!Module["print"]){Module["print"]=(function(){})}if(!Module["printErr"]){Module["printErr"]=Module["print"]}if(!Module["arguments"]){Module["arguments"]=[]}if(!Module["thisProgram"]){Module["thisProgram"]="./this.program"}Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(var key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}var Runtime={setTempRet0:(function(value){tempRet0=value}),getTempRet0:(function(){return tempRet0}),stackSave:(function(){return STACKTOP}),stackRestore:(function(stackTop){STACKTOP=stackTop}),getNativeTypeSize:(function(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return Runtime.QUANTUM_SIZE}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else{return 0}}}}),getNativeFieldSize:(function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)}),STACK_ALIGN:16,prepVararg:(function(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){assert((ptr&7)===4);ptr+=4}}else{assert((ptr&3)===0)}return ptr}),getAlignSize:(function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)}),dynCall:(function(sig,ptr,args){if(args&&args.length){if(!args.splice)args=Array.prototype.slice.call(args);args.splice(0,0,ptr);return Module["dynCall_"+sig].apply(null,args)}else{return Module["dynCall_"+sig].call(null,ptr)}}),functionPointers:[null,null,null,null,null,null,null,null],addFunction:(function(func){for(var i=0;i<Runtime.functionPointers.length;i++){if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=func;return 2*(1+i)}}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS."}),removeFunction:(function(index){Runtime.functionPointers[(index-2)/2]=null}),warnOnce:(function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown={};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}}),funcWrappers:{},getFuncWrapper:(function(func,sig){assert(sig);if(!Runtime.funcWrappers[sig]){Runtime.funcWrappers[sig]={}}var sigCache=Runtime.funcWrappers[sig];if(!sigCache[func]){sigCache[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,arguments)}}return sigCache[func]}),getCompilerSetting:(function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work"}),stackAlloc:(function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+15&-16;return ret}),staticAlloc:(function(size){var ret=STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+15&-16;return ret}),dynamicAlloc:(function(size){var ret=DYNAMICTOP;DYNAMICTOP=DYNAMICTOP+size|0;DYNAMICTOP=DYNAMICTOP+15&-16;if(DYNAMICTOP>=TOTAL_MEMORY){var success=enlargeMemory();if(!success){DYNAMICTOP=ret;return 0}}return ret}),alignMemory:(function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:16))*(quantum?quantum:16);return ret}),makeBigInt:(function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret}),GLOBAL_BASE:8,QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var __THREW__=0;var ABORT=false;var EXITSTATUS=0;var undef=0;var tempValue,tempInt,tempBigInt,tempInt2,tempBigInt2,tempPair,tempBigIntI,tempBigIntR,tempBigIntS,tempBigIntP,tempBigIntD,tempDouble,tempFloat;var tempI64,tempI64b;var tempRet0,tempRet1,tempRet2,tempRet3,tempRet4,tempRet5,tempRet6,tempRet7,tempRet8,tempRet9;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var globalScope=this;function getCFunc(ident){var func=Module["_"+ident];if(!func){abort("NO_DYNAMIC_EXECUTION was set, cannot eval - ccall/cwrap are not functional")}assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)");return func}var cwrap,ccall;((function(){var JSfuncs={"stackSave":(function(){Runtime.stackSave()}),"stackRestore":(function(){Runtime.stackRestore()}),"arrayToC":(function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=Runtime.stackAlloc((str.length<<2)+1);writeStringToMemory(str,ret)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};ccall=function ccallFunc(ident,returnType,argTypes,args,opts){var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0){if(opts&&opts.async){EmterpreterAsync.asyncFinalizers.push((function(){Runtime.stackRestore(stack)}));return}Runtime.stackRestore(stack)}return ret};cwrap=function cwrap(ident,returnType,argTypes){return(function(){return ccall(ident,returnType,argTypes,arguments)})}}))();Module["ccall"]=ccall;Module["cwrap"]=cwrap;function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for setValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[_malloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function"){curr=Runtime.getFunctionIndex(curr)}type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}Module["allocate"]=allocate;function getMemory(size){if(!staticSealed)return Runtime.staticAlloc(size);if(typeof _sbrk!=="undefined"&&!_sbrk.called||!runtimeInitialized)return Runtime.dynamicAlloc(size);return _malloc(size)}Module["getMemory"]=getMemory;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return Module["UTF8ToString"](ptr)}Module["Pointer_stringify"]=Pointer_stringify;function AsciiToString(ptr){var str="";while(1){var ch=HEAP8[ptr++>>0];if(!ch)return str;str+=String.fromCharCode(ch)}}Module["AsciiToString"]=AsciiToString;function stringToAscii(str,outPtr){return writeAsciiToMemory(str,outPtr,false)}Module["stringToAscii"]=stringToAscii;function UTF8ArrayToString(u8Array,idx){var u0,u1,u2,u3,u4,u5;var str="";while(1){u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u3=u8Array[idx++]&63;if((u0&248)==240){u0=(u0&7)<<18|u1<<12|u2<<6|u3}else{u4=u8Array[idx++]&63;if((u0&252)==248){u0=(u0&3)<<24|u1<<18|u2<<12|u3<<6|u4}else{u5=u8Array[idx++]&63;u0=(u0&1)<<30|u1<<24|u2<<18|u3<<12|u4<<6|u5}}}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}Module["UTF8ArrayToString"]=UTF8ArrayToString;function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}Module["UTF8ToString"]=UTF8ToString;function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=2097151){if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else if(u<=67108863){if(outIdx+4>=endIdx)break;outU8Array[outIdx++]=248|u>>24;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+5>=endIdx)break;outU8Array[outIdx++]=252|u>>30;outU8Array[outIdx++]=128|u>>24&63;outU8Array[outIdx++]=128|u>>18&63;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}Module["stringToUTF8Array"]=stringToUTF8Array;function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}Module["stringToUTF8"]=stringToUTF8;function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}Module["lengthBytesUTF8"]=lengthBytesUTF8;function UTF16ToString(ptr){var i=0;var str="";while(1){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)return str;++i;str+=String.fromCharCode(codeUnit)}}Module["UTF16ToString"]=UTF16ToString;function stringToUTF16(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr}Module["stringToUTF16"]=stringToUTF16;function lengthBytesUTF16(str){return str.length*2}Module["lengthBytesUTF16"]=lengthBytesUTF16;function UTF32ToString(ptr){var i=0;var str="";while(1){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)return str;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else{str+=String.fromCharCode(utf32)}}}Module["UTF32ToString"]=UTF32ToString;function stringToUTF32(str,outPtr,maxBytesToWrite){if(maxBytesToWrite===undefined){maxBytesToWrite=2147483647}if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++i);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr>>2]=codeUnit;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr}Module["stringToUTF32"]=stringToUTF32;function lengthBytesUTF32(str){var len=0;for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);if(codeUnit>=55296&&codeUnit<=57343)++i;len+=4}return len}Module["lengthBytesUTF32"]=lengthBytesUTF32;function demangle(func){var hasLibcxxabi=!!Module["___cxa_demangle"];if(hasLibcxxabi){try{var buf=_malloc(func.length);writeStringToMemory(func.substr(1),buf);var status=_malloc(4);var ret=Module["___cxa_demangle"](buf,0,0,status);if(getValue(status,"i32")===0&&ret){return Pointer_stringify(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret)}}var i=3;var basicTypes={"v":"void","b":"bool","c":"char","s":"short","i":"int","l":"long","f":"float","d":"double","w":"wchar_t","a":"signed char","h":"unsigned char","t":"unsigned short","j":"unsigned int","m":"unsigned long","x":"long long","y":"unsigned long long","z":"..."};var subs=[];var first=true;function dump(x){if(x)Module.print(x);Module.print(func);var pre="";for(var a=0;a<i;a++)pre+=" ";Module.print(pre+"^")}function parseNested(){i++;if(func[i]==="K")i++;var parts=[];while(func[i]!=="E"){if(func[i]==="S"){i++;var next=func.indexOf("_",i);var num=func.substring(i,next)||0;parts.push(subs[num]||"?");i=next+1;continue}if(func[i]==="C"){parts.push(parts[parts.length-1]);i+=2;continue}var size=parseInt(func.substr(i));var pre=size.toString().length;if(!size||!pre){i--;break}var curr=func.substr(i+pre,size);parts.push(curr);subs.push(curr);i+=pre+size}i++;return parts}function parse(rawList,limit,allowVoid){limit=limit||Infinity;var ret="",list=[];function flushList(){return"("+list.join(", ")+")"}var name;if(func[i]==="N"){name=parseNested().join("::");limit--;if(limit===0)return rawList?[name]:name}else{if(func[i]==="K"||first&&func[i]==="L")i++;var size=parseInt(func.substr(i));if(size){var pre=size.toString().length;name=func.substr(i+pre,size);i+=pre+size}}first=false;if(func[i]==="I"){i++;var iList=parse(true);var iRet=parse(true,1,true);ret+=iRet[0]+" "+name+"<"+iList.join(", ")+">"}else{ret=name}paramLoop:while(i<func.length&&limit-->0){var c=func[i++];if(c in basicTypes){list.push(basicTypes[c])}else{switch(c){case"P":list.push(parse(true,1,true)[0]+"*");break;case"R":list.push(parse(true,1,true)[0]+"&");break;case"L":{i++;var end=func.indexOf("E",i);var size=end-i;list.push(func.substr(i,size));i+=size+2;break};case"A":{var size=parseInt(func.substr(i));i+=size.toString().length;if(func[i]!=="_")throw"?";i++;list.push(parse(true,1,true)[0]+" ["+size+"]");break};case"E":break paramLoop;default:ret+="?"+c;break paramLoop}}}if(!allowVoid&&list.length===1&&list[0]==="void")list=[];if(rawList){if(ret){list.push(ret+"?")}return list}else{return ret+flushList()}}var parsed=func;try{if(func=="Object._main"||func=="_main"){return"main()"}if(typeof func==="number")func=Pointer_stringify(func);if(func[0]!=="_")return func;if(func[1]!=="_")return func;if(func[2]!=="Z")return func;switch(func[3]){case"n":return"operator new()";case"d":return"operator delete()"}parsed=parse()}catch(e){parsed+="?"}if(parsed.indexOf("?")>=0&&!hasLibcxxabi){Runtime.warnOnce("warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling")}return parsed}function demangleAll(text){return text.replace(/__Z[\w\d_]+/g,(function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){return demangleAll(jsStackTrace())}Module["stackTrace"]=stackTrace;var PAGE_SIZE=4096;function alignMemoryPage(x){if(x%4096>0){x+=4096-x%4096}return x}var HEAP;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var STATIC_BASE=0,STATICTOP=0,staticSealed=false;var STACK_BASE=0,STACKTOP=0,STACK_MAX=0;var DYNAMIC_BASE=0,DYNAMICTOP=0;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function enlargeMemory(){abortOnCannotGrowMemory()}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||33554432;var totalMemory=64*1024;while(totalMemory<TOTAL_MEMORY||totalMemory<2*TOTAL_STACK){if(totalMemory<16*1024*1024){totalMemory*=2}else{totalMemory+=16*1024*1024}}if(totalMemory!==TOTAL_MEMORY){TOTAL_MEMORY=totalMemory}assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&!!(new Int32Array(1))["subarray"]&&!!(new Int32Array(1))["set"],"JS engine does not provide full typed array support");var buffer;buffer=new ArrayBuffer(TOTAL_MEMORY);HEAP8=new Int8Array(buffer);HEAP16=new Int16Array(buffer);HEAP32=new Int32Array(buffer);HEAPU8=new Uint8Array(buffer);HEAPU16=new Uint16Array(buffer);HEAPU32=new Uint32Array(buffer);HEAPF32=new Float32Array(buffer);HEAPF64=new Float64Array(buffer);HEAP32[0]=255;assert(HEAPU8[0]===255&&HEAPU8[3]===0,"Typed arrays 2 must be run on a little-endian system");Module["HEAP"]=HEAP;Module["buffer"]=buffer;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Runtime.dynCall("v",func)}else{Runtime.dynCall("vi",func,[callback.arg])}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=addOnInit;function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=addOnPostRun;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}Module["intArrayFromString"]=intArrayFromString;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayToString"]=intArrayToString;function writeStringToMemory(string,buffer,dontAddNull){var array=intArrayFromString(string,dontAddNull);var i=0;while(i<array.length){var chr=array[i];HEAP8[buffer+i>>0]=chr;i=i+1}}Module["writeStringToMemory"]=writeStringToMemory;function writeArrayToMemory(array,buffer){for(var i=0;i<array.length;i++){HEAP8[buffer++>>0]=array[i]}}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;function unSign(value,bits,ignore){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}function reSign(value,bits,ignore){if(value<=0){return value}var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half)){value=-2*half+value}return value}if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];if(!Math["clz32"])Math["clz32"]=(function(x){x=x>>>0;for(var i=0;i<32;i++){if(x&1<<31-i)return i}return 32});Math.clz32=Math["clz32"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_min=Math.min;var Math_clz32=Math.clz32;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}Module["addRunDependency"]=addRunDependency;function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var ASM_CONSTS=[(function(){{return Module.getRandomValue()}}),(function(){{if(Module.getRandomValue===undefined){try{var window_="object"===typeof window?window:self,crypto_=typeof window_.crypto!=="undefined"?window_.crypto:window_.msCrypto,randomValuesStandard=(function(){var buf=new Uint32Array(1);crypto_.getRandomValues(buf);return buf[0]>>>0});randomValuesStandard();Module.getRandomValue=randomValuesStandard}catch(e){try{var crypto=require("crypto"),randomValueNodeJS=(function(){var buf=crypto.randomBytes(4);return(buf[0]<<24|buf[1]<<16|buf[2]<<8|buf[3])>>>0});randomValueNodeJS();Module.getRandomValue=randomValueNodeJS}catch(e){throw"No secure random number generator found"}}}}})];function _emscripten_asm_const_0(code){return ASM_CONSTS[code]()}STATIC_BASE=8;STATICTOP=STATIC_BASE+34944;__ATINIT__.push();allocate([8,201,188,243,103,230,9,106,59,167,202,132,133,174,103,187,43,248,148,254,114,243,110,60,241,54,29,95,58,245,79,165,209,130,230,173,127,82,14,81,31,108,62,43,140,104,5,155,107,189,65,251,171,217,131,31,121,33,126,19,25,205,224,91,103,230,9,106,133,174,103,187,114,243,110,60,58,245,79,165,127,82,14,81,140,104,5,155,171,217,131,31,25,205,224,91,133,59,140,1,189,241,36,255,248,37,195,1,96,220,55,0,183,76,62,255,195,66,61,0,50,76,164,1,225,164,76,255,76,61,163,255,117,62,31,0,81,145,64,255,118,65,14,0,162,115,214,255,6,138,46,0,124,230,244,255,10,138,143,0,52,26,194,0,184,244,76,0,129,143,41,1,190,244,19,255,123,170,122,255,98,129,68,0,121,213,147,0,86,101,30,255,161,103,155,0,140,89,67,255,239,229,190,1,67,11,181,0,198,240,137,254,238,69,188,255,67,151,238,0,19,42,108,255,229,85,113,1,50,68,135,255,17,106,9,0,50,103,1,255,80,1,168,1,35,152,30,255,16,168,185,1,56,89,232,255,101,210,252,0,41,250,71,0,204,170,79,255,14,46,239,255,80,77,239,0,189,214,75,255,17,141,249,0,38,80,76,255,190,85,117,0,86,228,170,0,156,216,208,1,195,207,164,255,150,66,76,255,175,225,16,255,141,80,98,1,76,219,242,0,198,162,114,0,46,218,152,0,155,43,241,254,155,160,104,255,51,187,165,0,2,17,175,0,66,84,160,1,247,58,30,0,35,65,53,254,69,236,191,0,45,134,245,1,163,123,221,0,32,110,20,255,52,23,165,0,186,214,71,0,233,176,96,0,242,239,54,1,57,89,138,0,83,0,84,255,136,160,100,0,92,142,120,254,104,124,190,0,181,177,62,255,250,41,85,0,152,130,42,1,96,252,246,0,151,151,63,254,239,133,62,0,32,56,156,0,45,167,189,255,142,133,179,1,131,86,211,0,187,179,150,254,250,170,14,255,210,163,78,0,37,52,151,0,99,77,26,0,238,156,213,255,213,192,209,1,73,46,84,0,20,65,41,1,54,206,79,0,201,131,146,254,170,111,24,255,177,33,50,254,171,38,203,255,78,247,116,0,209,221,153,0,133,128,178,1,58,44,25,0,201,39,59,1,189,19,252,0,49,229,210,1,117,187,117,0,181,179,184,1,0,114,219,0,48,94,147,0,245,41,56,0,125,13,204,254,244,173,119,0,44,221,32,254,84,234,20,0,249,160,198,1,236,126,234,255,47,99,168,254,170,226,153,255,102,179,216,0,226,141,122,255,122,66,153,254,182,245,134,0,227,228,25,1,214,57,235,255,216,173,56,255,181,231,210,0,119,128,157,255,129,95,136,255,110,126,51,0,2,169,183,255,7,130,98,254,69,176,94,255,116,4,227,1,217,242,145,255,202,173,31,1,105,1,39,255,46,175,69,0,228,47,58,255,215,224,69,254,207,56,69,255,16,254,139,255,23,207,212,255,202,20,126,255,95,213,96,255,9,176,33,0,200,5,207,255,241,42,128,254,35,33,192,255,248,229,196,1,129,17,120,0,251,103,151,255,7,52,112,255,140,56,66,255,40,226,245,255,217,70,37,254,172,214,9,255,72,67,134,1,146,192,214,255,44,38,112,0,68,184,75,255,206,90,251,0,149,235,141,0,181,170,58,0,116,244,239,0,92,157,2,0,102,173,98,0,233,137,96,1,127,49,203,0,5,155,148,0,23,148,9,255,211,122,12,0,34,134,26,255,219,204,136,0,134,8,41,255,224,83,43,254,85,25,247,0,109,127,0,254,169,136,48,0,238,119,219,255,231,173,213,0,206,18,254,254,8,186,7,255,126,9,7,1,111,42,72,0,111,52,236,254,96,63,141,0,147,191,127,254,205,78,192,255,14,106,237,1,187,219,76,0,175,243,187,254,105,89,173,0,85,25,89,1,162,243,148,0,2,118,209,254,33,158,9,0,139,163,46,255,93,70,40,0,108,42,142,254,111,252,142,255,155,223,144,0,51,229,167,255,73,252,155,255,94,116,12,255,152,160,218,255,156,238,37,255,179,234,207,255,197,0,179,255,154,164,141,0,225,196,104,0,10,35,25,254,209,212,242,255,97,253,222,254,184,101,229,0,222,18,127,1,164,136,135,255,30,207,140,254,146,97,243,0,129,192,26,254,201,84,33,255,111,10,78,255,147,81,178,255,4,4,24,0,161,238,215,255,6,141,33,0,53,215,14,255,41,181,208,255,231,139,157,0,179,203,221,255,255,185,113,0,189,226,172,255,113,66,214,255,202,62,45,255,102,64,8,255,78,174,16,254,133,117,68,255,182,120,89,255,133,114,211,0,189,110,21,255,15,10,106,0,41,192,1,0,152,232,121,255,188,60,160,255,153,113,206,255,0,183,226,254,180,13,72,255,176,160,14,254,211,201,134,255,158,24,143,0,127,105,53,0,96,12,189,0,167,215,251,255,159,76,128,254,106,101,225,255,30,252,4,0,146,12,174,0,89,241,178,254,10,229,166,255,123,221,42,254,30,20,212,0,82,128,3,0,48,209,243,0,119,121,64,255,50,227,156,255,0,110,197,1,103,27,144,0,133,59,140,1,189,241,36,255,248,37,195,1,96,220,55,0,183,76,62,255,195,66,61,0,50,76,164,1,225,164,76,255,76,61,163,255,117,62,31,0,81,145,64,255,118,65,14,0,162,115,214,255,6,138,46,0,124,230,244,255,10,138,143,0,52,26,194,0,184,244,76,0,129,143,41,1,190,244,19,255,123,170,122,255,98,129,68,0,121,213,147,0,86,101,30,255,161,103,155,0,140,89,67,255,239,229,190,1,67,11,181,0,198,240,137,254,238,69,188,255,234,113,60,255,37,255,57,255,69,178,182,254,128,208,179,0,118,26,125,254,3,7,214,255,241,50,77,255,85,203,197,255,211,135,250,255,25,48,100,255,187,213,180,254,17,88,105,0,83,209,158,1,5,115,98,0,4,174,60,254,171,55,110,255,217,181,17,255,20,188,170,0,146,156,102,254,87,214,174,255,114,122,155,1,233,44,170,0,127,8,239,1,214,236,234,0,175,5,219,0,49,106,61,255,6,66,208,255,2,106,110,255,81,234,19,255,215,107,192,255,67,151,238,0,19,42,108,255,229,85,113,1,50,68,135,255,17,106,9,0,50,103,1,255,80,1,168,1,35,152,30,255,16,168,185,1,56,89,232,255,101,210,252,0,41,250,71,0,204,170,79,255,14,46,239,255,80,77,239,0,189,214,75,255,17,141,249,0,38,80,76,255,190,85,117,0,86,228,170,0,156,216,208,1,195,207,164,255,150,66,76,255,175,225,16,255,141,80,98,1,76,219,242,0,198,162,114,0,46,218,152,0,155,43,241,254,155,160,104,255,178,9,252,254,100,110,212,0,14,5,167,0,233,239,163,255,28,151,157,1,101,146,10,255,254,158,70,254,71,249,228,0,88,30,50,0,68,58,160,255,191,24,104,1,129,66,129,255,192,50,85,255,8,179,138,255,38,250,201,0,115,80,160,0,131,230,113,0,125,88,147,0,90,68,199,0,253,76,158,0,28,255,118,0,113,250,254,0,66,75,46,0,230,218,43,0,229,120,186,1,148,68,43,0,136,124,238,1,187,107,197,255,84,53,246,255,51,116,254,255,51,187,165,0,2,17,175,0,66,84,160,1,247,58,30,0,35,65,53,254,69,236,191,0,45,134,245,1,163,123,221,0,32,110,20,255,52,23,165,0,186,214,71,0,233,176,96,0,242,239,54,1,57,89,138,0,83,0,84,255,136,160,100,0,92,142,120,254,104,124,190,0,181,177,62,255,250,41,85,0,152,130,42,1,96,252,246,0,151,151,63,254,239,133,62,0,32,56,156,0,45,167,189,255,142,133,179,1,131,86,211,0,187,179,150,254,250,170,14,255,68,113,21,255,222,186,59,255,66,7,241,1,69,6,72,0,86,156,108,254,55,167,89,0,109,52,219,254,13,176,23,255,196,44,106,255,239,149,71,255,164,140,125,255,159,173,1,0,51,41,231,0,145,62,33,0,138,111,93,1,185,83,69,0,144,115,46,0,97,151,16,255,24,228,26,0,49,217,226,0,113,75,234,254,193,153,12,255,182,48,96,255,14,13,26,0,128,195,249,254,69,193,59,0,132,37,81,254,125,106,60,0,214,240,169,1,164,227,66,0,210,163,78,0,37,52,151,0,99,77,26,0,238,156,213,255,213,192,209,1,73,46,84,0,20,65,41,1,54,206,79,0,201,131,146,254,170,111,24,255,177,33,50,254,171,38,203,255,78,247,116,0,209,221,153,0,133,128,178,1,58,44,25,0,201,39,59,1,189,19,252,0,49,229,210,1,117,187,117,0,181,179,184,1,0,114,219,0,48,94,147,0,245,41,56,0,125,13,204,254,244,173,119,0,44,221,32,254,84,234,20,0,249,160,198,1,236,126,234,255,143,62,221,0,129,89,214,255,55,139,5,254,68,20,191,255,14,204,178,1,35,195,217,0,47,51,206,1,38,246,165,0,206,27,6,254,158,87,36,0,217,52,146,255,125,123,215,255,85,60,31,255,171,13,7,0,218,245,88,254,252,35,60,0,55,214,160,255,133,101,56,0,224,32,19,254,147,64,234,0,26,145,162,1,114,118,125,0,248,252,250,0,101,94,196,255,198,141,226,254,51,42,182,0,135,12,9,254,109,172,210,255,197,236,194,1,241,65,154,0,48,156,47,255,153,67,55,255,218,165,34,254,74,180,179,0,218,66,71,1,88,122,99,0,212,181,219,255,92,42,231,255,239,0,154,0,245,77,183,255,94,81,170,1,18,213,216,0,171,93,71,0,52,94,248,0,18,151,161,254,197,209,66,255,174,244,15,254,162,48,183,0,49,61,240,254,182,93,195,0,199,228,6,1,200,5,17,255,137,45,237,255,108,148,4,0,90,79,237,255,39,63,77,255,53,82,207,1,142,22,118,255,101,232,18,1,92,26,67,0,5,200,88,255,33,168,138,255,149,225,72,0,2,209,27,255,44,245,168,1,220,237,17,255,30,211,105,254,141,238,221,0,128,80,245,254,111,254,14,0,222,95,190,1,223,9,241,0,146,76,212,255,108,205,104,255,63,117,153,0,144,69,48,0,35,228,111,0,192,33,193,255,112,214,190,254,115,152,151,0,23,102,88,0,51,74,248,0,226,199,143,254,204,162,101,255,208,97,189,1,245,104,18,0,230,246,30,255,23,148,69,0,110,88,52,254,226,181,89,255,208,47,90,254,114,161,80,255,33,116,248,0,179,152,87,255,69,144,177,1,88,238,26,255,58,32,113,1,1,77,69,0,59,121,52,255,152,238,83,0,52,8,193,0,231,39,233,255,199,34,138,0,222,68,173,0,91,57,242,254,220,210,127,255,192,7,246,254,151,35,187,0,195,236,165,0,111,93,206,0,212,247,133,1,154,133,209,255,155,231,10,0,64,78,38,0,122,249,100,1,30,19,97,255,62,91,249,1,248,133,77,0,197,63,168,254,116,10,82,0,184,236,113,254,212,203,194,255,61,100,252,254,36,5,202,255,119,91,153,255,129,79,29,0,103,103,171,254,237,215,111,255,216,53,69,0,239,240,23,0,194,149,221,255,38,225,222,0,232,255,180,254,118,82,133,255,57,209,177,1,139,232,133,0,158,176,46,254,194,115,46,0,88,247,229,1,28,103,191,0,221,222,175,254,149,235,44,0,151,228,25,254,218,105,103,0,142,85,210,0,149,129,190,255,213,65,94,254,117,134,224,255,82,198,117,0,157,221,220,0,163,101,36,0,197,114,37,0,104,172,166,254,11,182,0,0,81,72,188,255,97,188,16,255,69,6,10,0,199,147,145,255,8,9,115,1,65,214,175,255,217,173,209,0,80,127,166,0,247,229,4,254,167,183,124,255,90,28,204,254,175,59,240,255,11,41,248,1,108,40,51,255,144,177,195,254,150,250,126,0,138,91,65,1,120,60,222,255,245,193,239,0,29,214,189,255,128,2,25,0,80,154,162,0,77,220,107,1,234,205,74,255,54,166,103,255,116,72,9,0,228,94,47,255,30,200,25,255,35,214,89,255,61,176,140,255,83,226,163,255,75,130,172,0,128,38,17,0,95,137,152,255,215,124,159,1,79,93,0,0,148,82,157,254,195,130,251,255,40,202,76,255,251,126,224,0,157,99,62,254,207,7,225,255,96,68,195,0,140,186,157,255,131,19,231,255,42,128,254,0,52,219,61,254,102,203,72,0,141,7,11,255,186,164,213,0,31,122,119,0,133,242,145,0,208,252,232,255,91,213,182,255,143,4,250,254,249,215,74,0,165,30,111,1,171,9,223,0,229,123,34,1,92,130,26,255,77,155,45,1,195,139,28,255,59,224,78,0,136,17,247,0,108,121,32,0,79,250,189,255,96,227,252,254,38,241,62,0,62,174,125,255,155,111,93,255,10,230,206,1,97,197,40,255,0,49,57,254,65,250,13,0,18,251,150,255,220,109,210,255,5,174,166,254,44,129,189,0,235,35,147,255,37,247,141,255,72,141,4,255,103,107,255,0,247,90,4,0,53,44,42,0,2,30,240,0,4,59,63,0,88,78,36,0,113,167,180,0,190,71,193,255,199,158,164,255,58,8,172,0,77,33,12,0,65,63,3,0,153,77,33,255,172,254,102,1,228,221,4,255,87,30,254,1,146,41,86,255,138,204,239,254,108,141,17,255,187,242,135,0,210,208,127,0,68,45,14,254,73,96,62,0,81,60,24,255,170,6,36,255,3,249,26,0,35,213,109,0,22,129,54,255,21,35,225,255,234,61,56,255,58,217,6,0,143,124,88,0,236,126,66,0,209,38,183,255,34,238,6,255,174,145,102,0,95,22,211,0,196,15,153,254,46,84,232,255,117,34,146,1,231,250,74,255,27,134,100,1,92,187,195,255,170,198,112,0,120,28,42,0,209,70,67,0,29,81,31,0,29,168,100,1,169,173,160,0,107,35,117,0,62,96,59,255,81,12,69,1,135,239,190,255,220,252,18,0,163,220,58,255,137,137,188,255,83,102,109,0,96,6,76,0,234,222,210,255,185,174,205,1,60,158,213,255,13,241,214,0,172,129,140,0,93,104,242,0,192,156,251,0,43,117,30,0,225,81,158,0,127,232,218,0,226,28,203,0,233,27,151,255,117,43,5,255,242,14,47,255,33,20,6,0,137,251,44,254,27,31,245,255,183,214,125,254,40,121,149,0,186,158,213,255,89,8,227,0,69,88,0,254,203,135,225,0,201,174,203,0,147,71,184,0,18,121,41,254,94,5,78,0,224,214,240,254,36,5,180,0,251,135,231,1,163,138,212,0,210,249,116,254,88,129,187,0,19,8,49,254,62,14,144,255,159,76,211,0,214,51,82,0,109,117,228,254,103,223,203,255,75,252,15,1,154,71,220,255,23,13,91,1,141,168,96,255,181,182,133,0,250,51,55,0,234,234,212,254,175,63,158,0,39,240,52,1,158,189,36,255,213,40,85,1,32,180,247,255,19,102,26,1,84,24,97,255,69,21,222,0,148,139,122,255,220,213,235,1,232,203,255,0,121,57,147,0,227,7,154,0,53,22,147,1,72,1,225,0,82,134,48,254,83,60,157,255,145,72,169,0,34,103,239,0,198,233,47,0,116,19,4,255,184,106,9,255,183,129,83,0,36,176,230,1,34,103,72,0,219,162,134,0,245,42,158,0,32,149,96,254,165,44,144,0,202,239,72,254,215,150,5,0,42,66,36,1,132,215,175,0,86,174,86,255,26,197,156,255,49,232,135,254,103,182,82,0,253,128,176,1,153,178,122,0,245,250,10,0,236,24,178,0,137,106,132,0,40,29,41,0,50,30,152,255,124,105,38,0,230,191,75,0,143,43,170,0,44,131,20,255,44,13,23,255,237,255,155,1,159,109,100,255,112,181,24,255,104,220,108,0,55,211,131,0,99,12,213,255,152,151,145,255,238,5,159,0,97,155,8,0,33,108,81,0,1,3,103,0,62,109,34,255,250,155,180,0,32,71,195,255,38,70,145,1,159,95,245,0,69,229,101,1,136,28,240,0,79,224,25,0,78,110,121,255,248,168,124,0,187,128,247,0,2,147,235,254,79,11,132,0,70,58,12,1,181,8,163,255,79,137,133,255,37,170,11,255,141,243,85,255,176,231,215,255,204,150,164,255,239,215,39,255,46,87,156,254,8,163,88,255,172,34,232,0,66,44,102,255,27,54,41,254,236,99,87,255,41,123,169,1,52,114,43,0,117,134,40,0,155,134,26,0,231,207,91,254,35,132,38,255,19,102,125,254,36,227,133,255,118,3,113,255,29,13,124,0,152,96,74,1,88,146,206,255,167,191,220,254,162,18,88,255,182,100,23,0,31,117,52,0,81,46,106,1,12,2,7,0,69,80,201,1,209,246,172,0,12,48,141,1,224,211,88,0,116,226,159,0,122,98,130,0,65,236,234,1,225,226,9,255,207,226,123,1,89,214,59,0,112,135,88,1,90,244,203,255,49,11,38,1,129,108,186,0,89,112,15,1,101,46,204,255,127,204,45,254,79,255,221,255,51,73,18,255,127,42,101,255,241,21,202,0,160,227,7,0,105,50,236,0,79,52,197,255,104,202,208,1,180,15,16,0,101,197,78,255,98,77,203,0,41,185,241,1,35,193,124,0,35,155,23,255,207,53,192,0,11,125,163,1,249,158,185,255,4,131,48,0,21,93,111,255,61,121,231,1,69,200,36,255,185,48,185,255,111,238,21,255,39,50,25,255,99,215,163,255,87,212,30,255,164,147,5,255,128,6,35,1,108,223,110,255,194,76,178,0,74,101,180,0,243,47,48,0,174,25,43,255,82,173,253,1,54,114,192,255,40,55,91,0,215,108,176,255,11,56,7,0,224,233,76,0,209,98,202,254,242,25,125,0,44,193,93,254,203,8,177,0,135,176,19,0,112,71,213,255,206,59,176,1,4,67,26,0,14,143,213,254,42,55,208,255,60,67,120,0,193,21,163,0,99,164,115,0,10,20,118,0,156,212,222,254,160,7,217,255,114,245,76,1,117,59,123,0,176,194,86,254,213,15,176,0,78,206,207,254,213,129,59,0,233,251,22,1,96,55,152,255,236,255,15,255,197,89,84,255,93,149,133,0,174,160,113,0,234,99,169,255,152,116,88,0,144,164,83,255,95,29,198,255,34,47,15,255,99,120,134,255,5,236,193,0,249,247,126,255,147,187,30,0,50,230,117,255,108,217,219,255,163,81,166,255,72,25,169,254,155,121,79,255,28,155,89,254,7,126,17,0,147,65,33,1,47,234,253,0,26,51,18,0,105,83,199,255,163,196,230,0,113,248,164,0,226,254,218,0,189,209,203,255,164,247,222,254,255,35,165,0,4,188,243,1,127,179,71,0,37,237,254,255,100,186,240,0,5,57,71,254,103,72,73,255,244,18,81,254,229,210,132,255,238,6,180,255,11,229,174,255,227,221,192,1,17,49,28,0,163,215,196,254,9,118,4,255,51,240,71,0,113,129,109,255,76,240,231,0,188,177,127,0,125,71,44,1,26,175,243,0,94,169,25,254,27,230,29,0,15,139,119,1,168,170,186,255,172,197,76,255,252,75,188,0,137,124,196,0,72,22,96,255,45,151,249,1,220,145,100,0,64,192,159,255,120,239,226,0,129,178,146,0,0,192,125,0,235,138,234,0,183,157,146,0,83,199,192,255,184,172,72,255,73,225,128,0,77,6,250,255,186,65,67,0,104,246,207,0,188,32,138,255,218,24,242,0,67,138,81,254,237,129,121,255,20,207,150,1,41,199,16,255,6,20,128,0,159,118,5,0,181,16,143,255,220,38,15,0,23,64,147,254,73,26,13,0,87,228,57,1,204,124,128,0,43,24,223,0,219,99,199,0,22,75,20,255,19,27,126,0,157,62,215,0,110,29,230,0,179,167,255,1,54,252,190,0,221,204,182,254,179,158,65,255,81,157,3,0,194,218,159,0,170,223,0,0,224,11,32,255,38,197,98,0,168,164,37,0,23,88,7,1,164,186,110,0,96,36,134,0,234,242,229,0,250,121,19,0,242,254,112,255,3,47,94,1,9,239,6,255,81,134,153,254,214,253,168,255,67,124,224,0,245,95,74,0,28,30,44,254,1,109,220,255,178,89,89,0,252,36,76,0,24,198,46,255,76,77,111,0,134,234,136,255,39,94,29,0,185,72,234,255,70,68,135,255,231,102,7,254,77,231,140,0,167,47,58,1,148,97,118,255,16,27,225,1,166,206,143,255,110,178,214,255,180,131,162,0,143,141,225,1,13,218,78,255,114,153,33,1,98,104,204,0,175,114,117,1,167,206,75,0,202,196,83,1,58,64,67,0,138,47,111,1,196,247,128,255,137,224,224,254,158,112,207,0,154,100,255,1,134,37,107,0,198,128,79,255,127,209,155,255,163,254,185,254,60,14,243,0,31,219,112,254,29,217,65,0,200,13,116,254,123,60,196,255,224,59,184,254,242,89,196,0,123,16,75,254,149,16,206,0,69,254,48,1,231,116,223,255,209,160,65,1,200,80,98,0,37,194,184,254,148,63,34,0,139,240,65,255,217,144,132,255,56,38,45,254,199,120,210,0,108,177,166,255,160,222,4,0,220,126,119,254,165,107,160,255,82,220,248,1,241,175,136,0,144,141,23,255,169,138,84,0,160,137,78,255,226,118,80,255,52,27,132,255,63,96,139,255,152,250,39,0,188,155,15,0,232,51,150,254,40,15,232,255,240,229,9,255,137,175,27,255,75,73,97,1,218,212,11,0,135,5,162,1,107,185,213,0,2,249,107,255,40,242,70,0,219,200,25,0,25,157,13,0,67,82,80,255,196,249,23,255,145,20,149,0,50,72,146,0,94,76,148,1,24,251,65,0,31,192,23,0,184,212,201,255,123,233,162,1,247,173,72,0,162,87,219,254,126,134,89,0,159,11,12,254,166,105,29,0,73,27,228,1,113,120,183,255,66,163,109,1,212,143,11,255,159,231,168,1,255,128,90,0,57,14,58,254,89,52,10,255,253,8,163,1,0,145,210,255,10,129,85,1,46,181,27,0,103,136,160,254,126,188,209,255,34,35,111,0,215,219,24,255,212,11,214,254,101,5,118,0,232,197,133,255,223,167,109,255,237,80,86,255,70,139,94,0,158,193,191,1,155,15,51,255,15,190,115,0,78,135,207,255,249,10,27,1,181,125,233,0,95,172,13,254,170,213,161,255,39,236,138,255,95,93,87,255,190,128,95,0,125,15,206,0,166,150,159,0,227,15,158,255,206,158,120,255,42,141,128,0,101,178,120,1,156,109,131,0,218,14,44,254,247,168,206,255,212,112,28,0,112,17,228,255,90,16,37,1,197,222,108,0,254,207,83,255,9,90,243,255,243,244,172,0,26,88,115,255,205,116,122,0,191,230,193,0,180,100,11,1,217,37,96,255,154,78,156,0,235,234,31,255,206,178,178,255,149,192,251,0,182,250,135,0,246,22,105,0,124,193,109,255,2,210,149,255,169,17,170,0,0,96,110,255,117,9,8,1,50,123,40,255,193,189,99,0,34,227,160,0,48,80,70,254,211,51,236,0,45,122,245,254,44,174,8,0,173,37,233,255,158,65,171,0,122,69,215,255,90,80,2,255,131,106,96,254,227,114,135,0,205,49,119,254,176,62,64,255,82,51,17,255,241,20,243,255,130,13,8,254,128,217,243,255,162,27,1,254,90,118,241,0,246,198,246,255,55,16,118,255,200,159,157,0,163,17,1,0,140,107,121,0,85,161,118,255,38,0,149,0,156,47,238,0,9,166,166,1,75,98,181,255,50,74,25,0,66,15,47,0,139,225,159,0,76,3,142,255,14,238,184,0,11,207,53,255,183,192,186,1,171,32,174,255,191,76,221,1,247,170,219,0,25,172,50,254,217,9,233,0,203,126,68,255,183,92,48,0,127,167,183,1,65,49,254,0,16,63,127,1,254,21,170,255,59,224,127,254,22,48,63,255,27,78,130,254,40,195,29,0,250,132,112,254,35,203,144,0,104,169,168,0,207,253,30,255,104,40,38,254,94,228,88,0,206,16,128,255,212,55,122,255,223,22,234,0,223,197,127,0,253,181,181,1,145,102,118,0,236,153,36,255,212,217,72,255,20,38,24,254,138,62,62,0,152,140,4,0,230,220,99,255,1,21,212,255,148,201,231,0,244,123,9,254,0,171,210,0,51,58,37,255,1,255,14,255,244,183,145,254,0,242,166,0,22,74,132,0,121,216,41,0,95,195,114,254,133,24,151,255,156,226,231,255,247,5,77,255,246,148,115,254,225,92,81,255,222,80,246,254,170,123,89,255,74,199,141,0,29,20,8,255,138,136,70,255,93,75,92,0,221,147,49,254,52,126,226,0,229,124,23,0,46,9,181,0,205,64,52,1,131,254,28,0,151,158,212,0,131,64,78,0,206,25,171,0,0,230,139,0,191,253,110,254,103,247,167,0,64,40,40,1,42,165,241,255,59,75,228,254,124,243,189,255,196,92,178,255,130,140,86,255,141,89,56,1,147,198,5,255,203,248,158,254,144,162,141,0,11,172,226,0,130,42,21,255,1,167,143,255,144,36,36,255,48,88,164,254,168,170,220,0,98,71,214,0,91,208,79,0,159,76,201,1,166,42,214,255,69,255,0,255,6,128,125,255,190,1,140,0,146,83,218,255,215,238,72,1,122,127,53,0,189,116,165,255,84,8,66,255,214,3,208,255,213,110,133,0,195,168,44,1,158,231,69,0,162,64,200,254,91,58,104,0,182,58,187,254,249,228,136,0,203,134,76,254,99,221,233,0,75,254,214,254,80,69,154,0,64,152,248,254,236,136,202,255,157,105,153,254,149,175,20,0,22,35,19,255,124,121,233,0,186,250,198,254,132,229,139,0,137,80,174,255,165,125,68,0,144,202,148,254,235,239,248,0,135,184,118,0,101,94,17,255,122,72,70,254,69,130,146,0,127,222,248,1,69,127,118,255,30,82,215,254,188,74,19,255,229,167,194,254,117,25,66,255,65,234,56,254,213,22,156,0,151,59,93,254,45,28,27,255,186,126,164,255,32,6,239,0,127,114,99,1,219,52,2,255,99,96,166,254,62,190,126,255,108,222,168,1,75,226,174,0,230,226,199,0,60,117,218,255,252,248,20,1,214,188,204,0,31,194,134,254,123,69,192,255,169,173,36,254,55,98,91,0,223,42,102,254,137,1,102,0,157,90,25,0,239,122,64,255,252,6,233,0,7,54,20,255,82,116,174,0,135,37,54,255,15,186,125,0,227,112,175,255,100,180,225,255,42,237,244,255,244,173,226,254,248,18,33,0,171,99,150,255,74,235,50,255,117,82,32,254,106,168,237,0,207,109,208,1,228,9,186,0,135,60,169,254,179,92,143,0,244,170,104,255,235,45,124,255,70,99,186,0,117,137,183,0,224,31,215,0,40,9,100,0,26,16,95,1,68,217,87,0,8,151,20,255,26,100,58,255,176,165,203,1,52,118,70,0,7,32,254,254,244,254,245,255,167,144,194,255,125,113,23,255,176,121,181,0,136,84,209,0,138,6,30,255,89,48,28,0,33,155,14,255,25,240,154,0,141,205,109,1,70,115,62,255,20,40,107,254,138,154,199,255,94,223,226,255,157,171,38,0,163,177,25,254,45,118,3,255,14,222,23,1,209,190,81,255,118,123,232,1,13,213,101,255,123,55,123,254,27,246,165,0,50,99,76,255,140,214,32,255,97,65,67,255,24,12,28,0,174,86,78,1,64,247,96,0,160,135,67,0,66,55,243,255,147,204,96,255,26,6,33,255,98,51,83,1,153,213,208,255,2,184,54,255,25,218,11,0,49,67,246,254,18,149,72,255,13,25,72,0,42,79,214,0,42,4,38,1,27,139,144,255,149,187,23,0,18,164,132,0,245,84,184,254,120,198,104,255,126,218,96,0,56,117,234,255,13,29,214,254,68,47,10,255,167,154,132,254,152,38,198,0,66,178,89,255,200,46,171,255,13,99,83,255,210,187,253,255,170,45,42,1,138,209,124,0,214,162,141,0,12,230,156,0,102,36,112,254,3,147,67,0,52,215,123,255,233,171,54,255,98,137,62,0,247,218,39,255,231,218,236,0,247,191,127,0,195,146,84,0,165,176,92,255,19,212,94,255,17,74,227,0,88,40,153,1,198,147,1,255,206,67,245,254,240,3,218,255,61,141,213,255,97,183,106,0,195,232,235,254,95,86,154,0,209,48,205,254,118,209,241,255,240,120,223,1,213,29,159,0,163,127,147,255,13,218,93,0,85,24,68,254,70,20,80,255,189,5,140,1,82,97,254,255,99,99,191,255,132,84,133,255,107,218,116,255,112,122,46,0,105,17,32,0,194,160,63,255,68,222,39,1,216,253,92,0,177,105,205,255,149,201,195,0,42,225,11,255,40,162,115,0,9,7,81,0,165,218,219,0,180,22,0,254,29,146,252,255,146,207,225,1,180,135,96,0,31,163,112,0,177,11,219,255,133,12,193,254,43,78,50,0,65,113,121,1,59,217,6,255,110,94,24,1,112,172,111,0,7,15,96,0,36,85,123,0,71,150,21,255,208,73,188,0,192,11,167,1,213,245,34,0,9,230,92,0,162,142,39,255,215,90,27,0,98,97,89,0,94,79,211,0,90,157,240,0,95,220,126,1,102,176,226,0,36,30,224,254,35,31,127,0,231,232,115,1,85,83,130,0,210,73,245,255,47,143,114,255,68,65,197,0,59,72,62,255,183,133,173,254,93,121,118,255,59,177,81,255,234,69,173,255,205,128,177,0,220,244,51,0,26,244,209,1,73,222,77,255,163,8,96,254,150,149,211,0,158,254,203,1,54,127,139,0,161,224,59,0,4,109,22,255,222,42,45,255,208,146,102,255,236,142,187,0,50,205,245,255,10,74,89,254,48,79,142,0,222,76,130,255,30,166,63,0,236,12,13,255,49,184,244,0,187,113,102,0,218,101,253,0,153,57,182,254,32,150,42,0,25,198,146,1,237,241,56,0,140,68,5,0,91,164,172,255,78,145,186,254,67,52,205,0,219,207,129,1,109,115,17,0,54,143,58,1,21,248,120,255,179,255,30,0,193,236,66,255,1,255,7,255,253,192,48,255,19,69,217,1,3,214,0,255,64,101,146,1,223,125,35,255,235,73,179,255,249,167,226,0,225,175,10,1,97,162,58,0,106,112,171,1,84,172,5,255,133,140,178,255,134,245,142,0,97,90,125,255,186,203,185,255,223,77,23,255,192,92,106,0,15,198,115,255,217,152,248,0,171,178,120,255,228,134,53,0,176,54,193,1,250,251,53,0,213,10,100,1,34,199,106,0,151,31,244,254,172,224,87,255,14,237,23,255,253,85,26,255,127,39,116,255,172,104,100,0,251,14,70,255,212,208,138,255,253,211,250,0,176,49,165,0,15,76,123,255,37,218,160,255,92,135,16,1,10,126,114,255,70,5,224,255,247,249,141,0,68,20,60,1,241,210,189,255,195,217,187,1,151,3,113,0,151,92,174,0,231,62,178,255,219,183,225,0,23,23,33,255,205,181,80,0,57,184,248,255,67,180,1,255,90,123,93,255,39,0,162,255,96,248,52,255,84,66,140,0,34,127,228,255,194,138,7,1,166,110,188,0,21,17,155,1,154,190,198,255,214,80,59,255,18,7,143,0,72,29,226,1,199,217,249,0,232,161,71,1,149,190,201,0,217,175,95,254,113,147,67,255,138,143,199,255,127,204,1,0,29,182,83,1,206,230,155,255,186,204,60,0,10,125,85,255,232,96,25,255,255,89,247,255,213,254,175,1,232,193,81,0,28,43,156,254,12,69,8,0,147,24,248,0,18,198,49,0,134,60,35,0,118,246,18,255,49,88,254,254,228,21,186,255,182,65,112,1,219,22,1,255,22,126,52,255,189,53,49,255,112,25,143,0,38,127,55,255,226,101,163,254,208,133,61,255,137,69,174,1,190,118,145,255,60,98,219,255,217,13,245,255,250,136,10,0,84,254,226,0,201,31,125,1,240,51,251,255,31,131,130,255,2,138,50,255,215,215,177,1,223,12,238,255,252,149,56,255,124,91,68,255,72,126,170,254,119,255,100,0,130,135,232,255,14,79,178,0,250,131,197,0,138,198,208,0,121,216,139,254,119,18,36,255,29,193,122,0,16,42,45,255,213,240,235,1,230,190,169,255,198,35,228,254,110,173,72,0,214,221,241,255,56,148,135,0,192,117,78,254,141,93,207,255,143,65,149,0,21,18,98,255,95,44,244,1,106,191,77,0,254,85,8,254,214,110,176,255,73,173,19,254,160,196,199,255,237,90,144,0,193,172,113,255,200,155,136,254,228,90,221,0,137,49,74,1,164,221,215,255,209,189,5,255,105,236,55,255,42,31,129,1,193,255,236,0,46,217,60,0,138,88,187,255,226,82,236,255,81,69,151,255,142,190,16,1,13,134,8,0,127,122,48,255,81,64,156,0,171,243,139,0,237,35,246,0,122,143,193,254,212,122,146,0,95,41,255,1,87,132,77,0,4,212,31,0,17,31,78,0,39,45,173,254,24,142,217,255,95,9,6,255,227,83,6,0,98,59,130,254,62,30,33,0,8,115,211,1,162,97,128,255,7,184,23,254,116,28,168,255,248,138,151,255,98,244,240,0,186,118,130,0,114,248,235,255,105,173,200,1,160,124,71,255,94,36,164,1,175,65,146,255,238,241,170,254,202,198,197,0,228,71,138,254,45,246,109,255,194,52,158,0,133,187,176,0,83,252,154,254,89,189,221,255,170,73,252,0,148,58,125,0,36,68,51,254,42,69,177,255,168,76,86,255,38,100,204,255,38,53,35,0,175,19,97,0,225,238,253,255,81,81,135,0,210,27,255,254,235,73,107,0,8,207,115,0,82,127,136,0,84,99,21,254,207,19,136,0,100,164,101,0,80,208,77,255,132,207,237,255,15,3,15,255,33,166,110,0,156,95,85,255,37,185,111,1,150,106,35,255,166,151,76,0,114,87,135,255,159,194,64,0,12,122,31,255,232,7,101,254,173,119,98,0,154,71,220,254,191,57,53,255,168,232,160,255,224,32,99,255,218,156,165,0,151,153,163,0,217,13,148,1,197,113,89,0,149,28,161,254,207,23,30,0,105,132,227,255,54,230,94,255,133,173,204,255,92,183,157,255,88,144,252,254,102,33,90,0,159,97,3,0,181,218,155,255,240,114,119,0,106,214,53,255,165,190,115,1,152,91,225,255,88,106,44,255,208,61,113,0,151,52,124,0,191,27,156,255,110,54,236,1,14,30,166,255,39,127,207,1,229,199,28,0,188,228,188,254,100,157,235,0,246,218,183,1,107,22,193,255,206,160,95,0,76,239,147,0,207,161,117,0,51,166,2,255,52,117,10,254,73,56,227,255,152,193,225,0,132,94,136,255,101,191,209,0,32,107,229,255,198,43,180,1,100,210,118,0,114,67,153,255,23,88,26,255,89,154,92,1,220,120,140,255,144,114,207,255,252,115,250,255,34,206,72,0,138,133,127,255,8,178,124,1,87,75,97,0,15,229,92,254,240,67,131,255,118,123,227,254,146,120,104,255,145,213,255,1,129,187,70,255,219,119,54,0,1,19,173,0,45,150,148,1,248,83,72,0,203,233,169,1,142,107,56,0,247,249,38,1,45,242,80,255,30,233,103,0,96,82,70,0,23,201,111,0,81,39,30,255,161,183,78,255,194,234,33,255,68,227,140,254,216,206,116,0,70,27,235,255,104,144,79,0,164,230,93,254,214,135,156,0,154,187,242,254,188,20,131,255,36,109,174,0,159,112,241,0,5,110,149,1,36,165,218,0,166,29,19,1,178,46,73,0,93,43,32,254,248,189,237,0,102,155,141,0,201,93,195,255,241,139,253,255,15,111,98,255,108,65,163,254,155,79,190,255,73,174,193,254,246,40,48,255,107,88,11,254,202,97,85,255,253,204,18,255,113,242,66,0,110,160,194,254,208,18,186,0,81,21,60,0,188,104,167,255,124,166,97,254,210,133,142,0,56,242,137,254,41,111,130,0,111,151,58,1,111,213,141,255,183,172,241,255,38,6,196,255,185,7,123,255,46,11,246,0,245,105,119,1,15,2,161,255,8,206,45,255,18,202,74,255,83,124,115,1,212,141,157,0,83,8,209,254,139,15,232,255,172,54,173,254,50,247,132,0,214,189,213,0,144,184,105,0,223,254,248,0,255,147,240,255,23,188,72,0,7,51,54,0,188,25,180,254,220,180,0,255,83,160,20,0,163,189,243,255,58,209,194,255,87,73,60,0,106,24,49,0,245,249,220,0,22,173,167,0,118,11,195,255,19,126,237,0,110,159,37,255,59,82,47,0,180,187,86,0,188,148,208,1,100,37,133,255,7,112,193,0,129,188,156,255,84,106,129,255,133,225,202,0,14,236,111,255,40,20,101,0,172,172,49,254,51,54,74,255,251,185,184,255,93,155,224,255,180,249,224,1,230,178,146,0,72,57,54,254,178,62,184,0,119,205,72,0,185,239,253,255,61,15,218,0,196,67,56,255,234,32,171,1,46,219,228,0,208,108,234,255,20,63,232,255,165,53,199,1,133,228,5,255,52,205,107,0,74,238,140,255,150,156,219,254,239,172,178,255,251,189,223,254,32,142,211,255,218,15,138,1,241,196,80,0,28,36,98,254,22,234,199,0,61,237,220,255,246,57,37,0,142,17,142,255,157,62,26,0,43,238,95,254,3,217,6,255,213,25,240,1,39,220,174,255,154,205,48,254,19,13,192,255,244,34,54,254,140,16,155,0,240,181,5,254,155,193,60,0,166,128,4,255,36,145,56,255,150,240,219,0,120,51,145,0,82,153,42,1,140,236,146,0,107,92,248,1,189,10,3,0,63,136,242,0,211,39,24,0,19,202,161,1,173,27,186,255,210,204,239,254,41,209,162,255,182,254,159,255,172,116,52,0,195,103,222,254,205,69,59,0,53,22,41,1,218,48,194,0,80,210,242,0,210,188,207,0,187,161,161,254,216,17,1,0,136,225,113,0,250,184,63,0,223,30,98,254,77,168,162,0,59,53,175,0,19,201,10,255,139,224,194,0,147,193,154,255,212,189,12,254,1,200,174,255,50,133,113,1,94,179,90,0,173,182,135,0,94,177,113,0,43,89,215,255,136,252,106,255,123,134,83,254,5,245,66,255,82,49,39,1,220,2,224,0,97,129,177,0,77,59,89,0,61,29,155,1,203,171,220,255,92,78,139,0,145,33,181,255,169,24,141,1,55,150,179,0,139,60,80,255,218,39,97,0,2,147,107,255,60,248,72,0,173,230,47,1,6,83,182,255,16,105,162,254,137,212,81,255,180,184,134,1,39,222,164,255,221,105,251,1,239,112,125,0,63,7,97,0,63,104,227,255,148,58,12,0,90,60,224,255,84,212,252,0,79,215,168,0,248,221,199,1,115,121,1,0,36,172,120,0,32,162,187,255,57,107,49,255,147,42,21,0,106,198,43,1,57,74,87,0,126,203,81,255,129,135,195,0,140,31,177,0,221,139,194,0,3,222,215,0,131,68,231,0,177,86,178,254,124,151,180,0,184,124,38,1,70,163,17,0,249,251,181,1,42,55,227,0,226,161,44,0,23,236,110,0,51,149,142,1,93,5,236,0,218,183,106,254,67,24,77,0,40,245,209,255,222,121,153,0,165,57,30,0,83,125,60,0,70,38,82,1,229,6,188,0,109,222,157,255,55,118,63,255,205,151,186,0,227,33,149,255,254,176,246,1,227,177,227,0,34,106,163,254,176,43,79,0,106,95,78,1,185,241,122,255,185,14,61,0,36,1,202,0,13,178,162,255,247,11,132,0,161,230,92,1,65,1,185,255,212,50,165,1,141,146,64,255,158,242,218,0,21,164,125,0,213,139,122,1,67,71,87,0,203,158,178,1,151,92,43,0,152,111,5,255,39,3,239,255,217,255,250,255,176,63,71,255,74,245,77,1,250,174,18,255,34,49,227,255,246,46,251,255,154,35,48,1,125,157,61,255,106,36,78,255,97,236,153,0,136,187,120,255,113,134,171,255,19,213,217,254,216,94,209,255,252,5,61,0,94,3,202,0,3,26,183,255,64,191,43,255,30,23,21,0,129,141,77,255,102,120,7,1,194,76,140,0,188,175,52,255,17,81,148,0,232,86,55,1,225,48,172,0,134,42,42,255,238,50,47,0,169,18,254,0,20,147,87,255,14,195,239,255,69,247,23,0,238,229,128,255,177,49,112,0,168,98,251,255,121,71,248,0,243,8,145,254,246,227,153,255,219,169,177,254,251,139,165,255,12,163,185,255,164,40,171,255,153,159,27,254,243,109,91,255,222,24,112,1,18,214,231,0,107,157,181,254,195,147,0,255,194,99,104,255,89,140,190,255,177,66,126,254,106,185,66,0,49,218,31,0,252,174,158,0,188,79,230,1,238,41,224,0,212,234,8,1,136,11,181,0,166,117,83,255,68,195,94,0,46,132,201,0,240,152,88,0,164,57,69,254,160,224,42,255,59,215,67,255,119,195,141,255,36,180,121,254,207,47,8,255,174,210,223,0,101,197,68,255,255,82,141,1,250,137,233,0,97,86,133,1,16,80,69,0,132,131,159,0,116,93,100,0,45,141,139,0,152,172,157,255,90,43,91,0,71,153,46,0,39,16,112,255,217,136,97,255,220,198,25,254,177,53,49,0,222,88,134,255,128,15,60,0,207,192,169,255,192,116,209,255,106,78,211,1,200,213,183,255,7,12,122,254,222,203,60,255,33,110,199,254,251,106,117,0,228,225,4,1,120,58,7,255,221,193,84,254,112,133,27,0,189,200,201,255,139,135,150,0,234,55,176,255,61,50,65,0,152,108,169,255,220,85,1,255,112,135,227,0,162,26,186,0,207,96,185,254,244,136,107,0,93,153,50,1,198,97,151,0,110,11,86,255,143,117,174,255,115,212,200,0,5,202,183,0,237,164,10,254,185,239,62,0,236,120,18,254,98,123,99,255,168,201,194,254,46,234,214,0,191,133,49,255,99,169,119,0,190,187,35,1,115,21,45,255,249,131,72,0,112,6,123,255,214,49,181,254,166,233,34,0,92,197,102,254,253,228,205,255,3,59,201,1,42,98,46,0,219,37,35,255,169,195,38,0,94,124,193,1,156,43,223,0,95,72,133,254,120,206,191,0,122,197,239,255,177,187,79,255,254,46,2,1,250,167,190,0,84,129,19,0,203,113,166,255,249,31,189,254,72,157,202,255,208,71,73,255,207,24,72,0,10,16,18,1,210,81,76,255,88,208,192,255,126,243,107,255,238,141,120,255,199,121,234,255,137,12,59,255,36,220,123,255,148,179,60,254,240,12,29,0,66,0,97,1,36,30,38,255,115,1,93,255,96,103,231,255,197,158,59,1,192,164,240,0,202,202,57,255,24,174,48,0,89,77,155,1,42,76,215,0,244,151,233,0,23,48,81,0,239,127,52,254,227,130,37,255,248,116,93,1,124,132,118,0,173,254,192,1,6,235,83,255,110,175,231,1,251,28,182,0,129,249,93,254,84,184,128,0,76,181,62,0,175,128,186,0,100,53,136,254,109,29,226,0,221,233,58,1,20,99,74,0,0,22,160,0,134,13,21,0,9,52,55,255,17,89,140,0,175,34,59,0,84,165,119,255,224,226,234,255,7,72,166,255,123,115,255,1,18,214,246,0,250,7,71,1,217,220,185,0,212,35,76,255,38,125,175,0,189,97,210,0,114,238,44,255,41,188,169,254,45,186,154,0,81,92,22,0,132,160,193,0,121,208,98,255,13,81,44,255,203,156,82,0,71,58,21,255,208,114,191,254,50,38,147,0,154,216,195,0,101,25,18,0,60,250,215,255,233,132,235,255,103,175,142,1,16,14,92,0,141,31,110,254,238,241,45,255,153,217,239,1,97,168,47,255,249,85,16,1,28,175,62,255,57,254,54,0,222,231,126,0,166,45,117,254,18,189,96,255,228,76,50,0,200,244,94,0,198,152,120,1,68,34,69,255,12,65,160,254,101,19,90,0,167,197,120,255,68,54,185,255,41,218,188,0,113,168,48,0,88,105,189,1,26,82,32,255,185,93,164,1,228,240,237,255,66,182,53,0,171,197,92,255,107,9,233,1,199,120,144,255,78,49,10,255,109,170,105,255,90,4,31,255,28,244,113,255,74,58,11,0,62,220,246,255,121,154,200,254,144,210,178,255,126,57,129,1,43,250,14,255,101,111,28,1,47,86,241,255,61,70,150,255,53,73,5,255,30,26,158,0,209,26,86,0,138,237,74,0,164,95,188,0,142,60,29,254,162,116,248,255,187,175,160,0,151,18,16,0,209,111,65,254,203,134,39,255,88,108,49,255,131,26,71,255,221,27,215,254,104,105,93,255,31,236,31,254,135,0,211,255,143,127,110,1,212,73,229,0,233,67,167,254,195,1,208,255,132,17,221,255,51,217,90,0,67,235,50,255,223,210,143,0,179,53,130,1,233,106,198,0,217,173,220,255,112,229,24,255,175,154,93,254,71,203,246,255,48,66,133,255,3,136,230,255,23,221,113,254,235,111,213,0,170,120,95,254,251,221,2,0,45,130,158,254,105,94,217,255,242,52,180,254,213,68,45,255,104,38,28,0,244,158,76,0,161,200,96,255,207,53,13,255,187,67,148,0,170,54,248,0,119,162,178,255,83,20,11,0,42,42,192,1,146,159,163,255,183,232,111,0,77,229,21,255,71,53,143,0,27,76,34],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE);allocate([246,136,47,255,219,39,182,255,92,224,201,1,19,142,14,255,69,182,241,255,163,118,245,0,9,109,106,1,170,181,247,255,78,47,238,255,84,210,176,255,213,107,139,0,39,38,11,0,72,21,150,0,72,130,69,0,205,77,155,254,142,133,21,0,71,111,172,254,226,42,59,255,179,0,215,1,33,128,241,0,234,252,13,1,184,79,8,0,110,30,73,255,246,141,189,0,170,207,218,1,74,154,69,255,138,246,49,255,155,32,100,0,125,74,105,255,90,85,61,255,35,229,177,255,62,125,193,255,153,86,188,1,73,120,212,0,209,123,246,254,135,209,38,255,151,58,44,1,92,69,214,255,14,12,88,255,252,153,166,255,253,207,112,255,60,78,83,255,227,124,110,0,180,96,252,255,53,117,33,254,164,220,82,255,41,1,27,255,38,164,166,255,164,99,169,254,61,144,70,255,192,166,18,0,107,250,66,0,197,65,50,0,1,179,18,255,255,104,1,255,43,153,35,255,80,111,168,0,110,175,168,0,41,105,45,255,219,14,205,255,164,233,140,254,43,1,118,0,233,67,195,0,178,82,159,255,138,87,122,255,212,238,90,255,144,35,124,254,25,140,164,0,251,215,44,254,133,70,107,255,101,227,80,254,92,169,55,0,215,42,49,0,114,180,85,255,33,232,27,1,172,213,25,0,62,176,123,254,32,133,24,255,225,191,62,0,93,70,153,0,181,42,104,1,22,191,224,255,200,200,140,255,249,234,37,0,149,57,141,0,195,56,208,255,254,130,70,255,32,173,240,255,29,220,199,0,110,100,115,255,132,229,249,0,228,233,223,255,37,216,209,254,178,177,209,255,183,45,165,254,224,97,114,0,137,97,168,255,225,222,172,0,165,13,49,1,210,235,204,255,252,4,28,254,70,160,151,0,232,190,52,254,83,248,93,255,62,215,77,1,175,175,179,255,160,50,66,0,121,48,208,0,63,169,209,255,0,210,200,0,224,187,44,1,73,162,82,0,9,176,143,255,19,76,193,255,29,59,167,1,24,43,154,0,28,190,190,0,141,188,129,0,232,235,203,255,234,0,109,255,54,65,159,0,60,88,232,255,121,253,150,254,252,233,131,255,198,110,41,1,83,77,71,255,200,22,59,254,106,253,242,255,21,12,207,255,237,66,189,0,90,198,202,1,225,172,127,0,53,22,202,0,56,230,132,0,1,86,183,0,109,190,42,0,243,68,174,1,109,228,154,0,200,177,122,1,35,160,183,255,177,48,85,255,90,218,169,255,248,152,78,0,202,254,110,0,6,52,43,0,142,98,65,255,63,145,22,0,70,106,93,0,232,138,107,1,110,179,61,255,211,129,218,1,242,209,92,0,35,90,217,1,182,143,106,255,116,101,217,255,114,250,221,255,173,204,6,0,60,150,163,0,73,172,44,255,239,110,80,255,237,76,153,254,161,140,249,0,149,232,229,0,133,31,40,255,174,164,119,0,113,51,214,0,129,228,2,254,64,34,243,0,107,227,244,255,174,106,200,255,84,153,70,1,50,35,16,0,250,74,216,254,236,189,66,255,153,249,13,0,230,178,4,255,221,41,238,0,118,227,121,255,94,87,140,254,254,119,92,0,73,239,246,254,117,87,128,0,19,211,145,255,177,46,252,0,229,91,246,1,69,128,247,255,202,77,54,1,8,11,9,255,153,96,166,0,217,214,173,255,134,192,2,1,0,207,0,0,189,174,107,1,140,134,100,0,158,193,243,1,182,102,171,0,235,154,51,0,142,5,123,255,60,168,89,1,217,14,92,255,19,214,5,1,211,167,254,0,44,6,202,254,120,18,236,255,15,113,184,255,184,223,139,0,40,177,119,254,182,123,90,255,176,165,176,0,247,77,194,0,27,234,120,0,231,0,214,255,59,39,30,0,125,99,145,255,150,68,68,1,141,222,248,0,153,123,210,255,110,127,152,255,229,33,214,1,135,221,197,0,137,97,2,0,12,143,204,255,81,41,188,0,115,79,130,255,94,3,132,0,152,175,187,255,124,141,10,255,126,192,179,255,11,103,198,0,149,6,45,0,219,85,187,1,230,18,178,255,72,182,152,0,3,198,184,255,128,112,224,1,97,161,230,0,254,99,38,255,58,159,197,0,151,66,219,0,59,69,143,255,185,112,249,0,119,136,47,255,123,130,132,0,168,71,95,255,113,176,40,1,232,185,173,0,207,93,117,1,68,157,108,255,102,5,147,254,49,97,33,0,89,65,111,254,247,30,163,255,124,217,221,1,102,250,216,0,198,174,75,254,57,55,18,0,227,5,236,1,229,213,173,0,201,109,218,1,49,233,239,0,30,55,158,1,25,178,106,0,155,111,188,1,94,126,140,0,215,31,238,1,77,240,16,0,213,242,25,1,38,71,168,0,205,186,93,254,49,211,140,255,219,0,180,255,134,118,165,0,160,147,134,255,110,186,35,255,198,243,42,0,243,146,119,0,134,235,163,1,4,241,135,255,193,46,193,254,103,180,79,255,225,4,184,254,242,118,130,0,146,135,176,1,234,111,30,0,69,66,213,254,41,96,123,0,121,94,42,255,178,191,195,255,46,130,42,0,117,84,8,255,233,49,214,254,238,122,109,0,6,71,89,1,236,211,123,0,244,13,48,254,119,148,14,0,114,28,86,255,75,237,25,255,145,229,16,254,129,100,53,255,134,150,120,254,168,157,50,0,23,72,104,255,224,49,14,0,255,123,22,255,151,185,151,255,170,80,184,1,134,182,20,0,41,100,101,1,153,33,16,0,76,154,111,1,86,206,234,255,192,160,164,254,165,123,93,255,1,216,164,254,67,17,175,255,169,11,59,255,158,41,61,255,73,188,14,255,195,6,137,255,22,147,29,255,20,103,3,255,246,130,227,255,122,40,128,0,226,47,24,254,35,36,32,0,152,186,183,255,69,202,20,0,195,133,195,0,222,51,247,0,169,171,94,1,183,0,160,255,64,205,18,1,156,83,15,255,197,58,249,254,251,89,110,255,50,10,88,254,51,43,216,0,98,242,198,1,245,151,113,0,171,236,194,1,197,31,199,255,229,81,38,1,41,59,20,0,253,104,230,0,152,93,14,255,246,242,146,254,214,169,240,255,240,102,108,254,160,167,236,0,154,218,188,0,150,233,202,255,27,19,250,1,2,71,133,255,175,12,63,1,145,183,198,0,104,120,115,255,130,251,247,0,17,212,167,255,62,123,132,255,247,100,189,0,155,223,152,0,143,197,33,0,155,59,44,255,150,93,240,1,127,3,87,255,95,71,207,1,167,85,1,255,188,152,116,255,10,23,23,0,137,195,93,1,54,98,97,0,240,0,168,255,148,188,127,0,134,107,151,0,76,253,171,0,90,132,192,0,146,22,54,0,224,66,54,254,230,186,229,255,39,182,196,0,148,251,130,255,65,131,108,254,128,1,160,0,169,49,167,254,199,254,148,255,251,6,131,0,187,254,129,255,85,82,62,0,178,23,58,255,254,132,5,0,164,213,39,0,134,252,146,254,37,53,81,255,155,134,82,0,205,167,238,255,94,45,180,255,132,40,161,0,254,111,112,1,54,75,217,0,179,230,221,1,235,94,191,255,23,243,48,1,202,145,203,255,39,118,42,255,117,141,253,0,254,0,222,0,43,251,50,0,54,169,234,1,80,68,208,0,148,203,243,254,145,7,135,0,6,254,0,0,252,185,127,0,98,8,129,255,38,35,72,255,211,36,220,1,40,26,89,0,168,64,197,254,3,222,239,255,2,83,215,254,180,159,105,0,58,115,194,0,186,116,106,255,229,247,219,255,129,118,193,0,202,174,183,1,166,161,72,0,201,107,147,254,237,136,74,0,233,230,106,1,105,111,168,0,64,224,30,1,1,229,3,0,102,151,175,255,194,238,228,255,254,250,212,0,187,237,121,0,67,251,96,1,197,30,11,0,183,95,204,0,205,89,138,0,64,221,37,1,255,223,30,255,178,48,211,255,241,200,90,255,167,209,96,255,57,130,221,0,46,114,200,255,61,184,66,0,55,182,24,254,110,182,33,0,171,190,232,255,114,94,31,0,18,221,8,0,47,231,254,0,255,112,83,0,118,15,215,255,173,25,40,254,192,193,31,255,238,21,146,255,171,193,118,255,101,234,53,254,131,212,112,0,89,192,107,1,8,208,27,0,181,217,15,255,231,149,232,0,140,236,126,0,144,9,199,255,12,79,181,254,147,182,202,255,19,109,182,255,49,212,225,0,74,163,203,0,175,233,148,0,26,112,51,0,193,193,9,255,15,135,249,0,150,227,130,0,204,0,219,1,24,242,205,0,238,208,117,255,22,244,112,0,26,229,34,0,37,80,188,255,38,45,206,254,240,90,225,255,29,3,47,255,42,224,76,0,186,243,167,0,32,132,15,255,5,51,125,0,139,135,24,0,6,241,219,0,172,229,133,255,246,214,50,0,231,11,207,255,191,126,83,1,180,163,170,255,245,56,24,1,178,164,211,255,3,16,202,1,98,57,118,255,141,131,89,254,33,51,24,0,243,149,91,255,253,52,14,0,35,169,67,254,49,30,88,255,179,27,36,255,165,140,183,0,58,189,151,0,88,31,0,0,75,169,66,0,66,101,199,255,24,216,199,1,121,196,26,255,14,79,203,254,240,226,81,255,94,28,10,255,83,193,240,255,204,193,131,255,94,15,86,0,218,40,157,0,51,193,209,0,0,242,177,0,102,185,247,0,158,109,116,0,38,135,91,0,223,175,149,0,220,66,1,255,86,60,232,0,25,96,37,255,225,122,162,1,215,187,168,255,158,157,46,0,56,171,162,0,232,240,101,1,122,22,9,0,51,9,21,255,53,25,238,255,217,30,232,254,125,169,148,0,13,232,102,0,148,9,37,0,165,97,141,1,228,131,41,0,222,15,243,255,254,18,17,0,6,60,237,1,106,3,113,0,59,132,189,0,92,112,30,0,105,208,213,0,48,84,179,255,187,121,231,254,27,216,109,255,162,221,107,254,73,239,195,255,250,31,57,255,149,135,89,255,185,23,115,1,3,163,157,255,18,112,250,0,25,57,187,255,161,96,164,0,47,16,243,0,12,141,251,254,67,234,184,255,41,18,161,0,175,6,96,255,160,172,52,254,24,176,183,255,198,193,85,1,124,121,137,255,151,50,114,255,220,203,60,255,207,239,5,1,0,38,107,255,55,238,94,254,70,152,94,0,213,220,77,1,120,17,69,255,85,164,190,255,203,234,81,0,38,49,37,254,61,144,124,0,137,78,49,254,168,247,48,0,95,164,252,0,105,169,135,0,253,228,134,0,64,166,75,0,81,73,20,255,207,210,10,0,234,106,150,255,94,34,90,255,254,159,57,254,220,133,99,0,139,147,180,254,24,23,185,0,41,57,30,255,189,97,76,0,65,187,223,255,224,172,37,255,34,62,95,1,231,144,240,0,77,106,126,254,64,152,91,0,29,98,155,0,226,251,53,255,234,211,5,255,144,203,222,255,164,176,221,254,5,231,24,0,179,122,205,0,36,1,134,255,125,70,151,254,97,228,252,0,172,129,23,254,48,90,209,255,150,224,82,1,84,134,30,0,241,196,46,0,103,113,234,255,46,101,121,254,40,124,250,255,135,45,242,254,9,249,168,255,140,108,131,255,143,163,171,0,50,173,199,255,88,222,142,255,200,95,158,0,142,192,163,255,7,117,135,0,111,124,22,0,236,12,65,254,68,38,65,255,227,174,254,0,244,245,38,0,240,50,208,255,161,63,250,0,60,209,239,0,122,35,19,0,14,33,230,254,2,159,113,0,106,20,127,255,228,205,96,0,137,210,174,254,180,212,144,255,89,98,154,1,34,88,139,0,167,162,112,1,65,110,197,0,241,37,169,0,66,56,131,255,10,201,83,254,133,253,187,255,177,112,45,254,196,251,0,0,196,250,151,255,238,232,214,255,150,209,205,0,28,240,118,0,71,76,83,1,236,99,91,0,42,250,131,1,96,18,64,255,118,222,35,0,113,214,203,255,122,119,184,255,66,19,36,0,204,64,249,0,146,89,139,0,134,62,135,1,104,233,101,0,188,84,26,0,49,249,129,0,208,214,75,255,207,130,77,255,115,175,235,0,171,2,137,255,175,145,186,1,55,245,135,255,154,86,181,1,100,58,246,255,109,199,60,255,82,204,134,255,215,49,230,1,140,229,192,255,222,193,251,255,81,136,15,255,179,149,162,255,23,39,29,255,7,95,75,254,191,81,222,0,241,81,90,255,107,49,201,255,244,211,157,0,222,140,149,255,65,219,56,254,189,246,90,255,178,59,157,1,48,219,52,0,98,34,215,0,28,17,187,255,175,169,24,0,92,79,161,255,236,200,194,1,147,143,234,0,229,225,7,1,197,168,14,0,235,51,53,1,253,120,174,0,197,6,168,255,202,117,171,0,163,21,206,0,114,85,90,255,15,41,10,255,194,19,99,0,65,55,216,254,162,146,116,0,50,206,212,255,64,146,29,255,158,158,131,1,100,165,130,255,172,23,129,255,125,53,9,255,15,193,18,1,26,49,11,255,181,174,201,1,135,201,14,255,100,19,149,0,219,98,79,0,42,99,143,254,96,0,48,255,197,249,83,254,104,149,79,255,235,110,136,254,82,128,44,255,65,41,36,254,88,211,10,0,187,121,187,0,98,134,199,0,171,188,179,254,210,11,238,255,66,123,130,254,52,234,61,0,48,113,23,254,6,86,120,255,119,178,245,0,87,129,201,0,242,141,209,0,202,114,85,0,148,22,161,0,103,195,48,0,25,49,171,255,138,67,130,0,182,73,122,254,148,24,130,0,211,229,154,0,32,155,158,0,84,105,61,0,177,194,9,255,166,89,86,1,54,83,187,0,249,40,117,255,109,3,215,255,53,146,44,1,63,47,179,0,194,216,3,254,14,84,136,0,136,177,13,255,72,243,186,255,117,17,125,255,211,58,211,255,93,79,223,0,90,88,245,255,139,209,111,255,70,222,47,0,10,246,79,255,198,217,178,0,227,225,11,1,78,126,179,255,62,43,126,0,103,148,35,0,129,8,165,254,245,240,148,0,61,51,142,0,81,208,134,0,15,137,115,255,211,119,236,255,159,245,248,255,2,134,136,255,230,139,58,1,160,164,254,0,114,85,141,255,49,166,182,255,144,70,84,1,85,182,7,0,46,53,93,0,9,166,161,255,55,162,178,255,45,184,188,0,146,28,44,254,169,90,49,0,120,178,241,1,14,123,127,255,7,241,199,1,189,66,50,255,198,143,101,254,189,243,135,255,141,24,24,254,75,97,87,0,118,251,154,1,237,54,156,0,171,146,207,255,131,196,246,255,136,64,113,1,151,232,57,0,240,218,115,0,49,61,27,255,64,129,73,1,252,169,27,255,40,132,10,1,90,201,193,255,252,121,240,1,186,206,41,0,43,198,97,0,145,100,183,0,204,216,80,254,172,150,65,0,249,229,196,254,104,123,73,255,77,104,96,254,130,180,8,0,104,123,57,0,220,202,229,255,102,249,211,0,86,14,232,255,182,78,209,0,239,225,164,0,106,13,32,255,120,73,17,255,134,67,233,0,83,254,181,0,183,236,112,1,48,64,131,255,241,216,243,255,65,193,226,0,206,241,100,254,100,134,166,255,237,202,197,0,55,13,81,0,32,124,102,255,40,228,177,0,118,181,31,1,231,160,134,255,119,187,202,0,0,142,60,255,128,38,189,255,166,201,150,0,207,120,26,1,54,184,172,0,12,242,204,254,133,66,230,0,34,38,31,1,184,112,80,0,32,51,165,254,191,243,55,0,58,73,146,254,155,167,205,255,100,104,152,255,197,254,207,255,173,19,247,0,238,10,202,0,239,151,242,0,94,59,39,255,240,29,102,255,10,92,154,255,229,84,219,255,161,129,80,0,208,90,204,1,240,219,174,255,158,102,145,1,53,178,76,255,52,108,168,1,83,222,107,0,211,36,109,0,118,58,56,0,8,29,22,0,237,160,199,0,170,209,157,0,137,71,47,0,143,86,32,0,198,242,2,0,212,48,136,1,92,172,186,0,230,151,105,1,96,191,229,0,138,80,191,254,240,216,130,255,98,43,6,254,168,196,49,0,253,18,91,1,144,73,121,0,61,146,39,1,63,104,24,255,184,165,112,254,126,235,98,0,80,213,98,255,123,60,87,255,82,140,245,1,223,120,173,255,15,198,134,1,206,60,239,0,231,234,92,255,33,238,19,255,165,113,142,1,176,119,38,0,160,43,166,254,239,91,105,0,107,61,194,1,25,4,68,0,15,139,51,0,164,132,106,255,34,116,46,254,168,95,197,0,137,212,23,0,72,156,58,0,137,112,69,254,150,105,154,255,236,201,157,0,23,212,154,255,136,82,227,254,226,59,221,255,95,149,192,0,81,118,52,255,33,43,215,1,14,147,75,255,89,156,121,254,14,18,79,0,147,208,139,1,151,218,62,255,156,88,8,1,210,184,98,255,20,175,123,255,102,83,229,0,220,65,116,1,150,250,4,255,92,142,220,255,34,247,66,255,204,225,179,254,151,81,151,0,71,40,236,255,138,63,62,0,6,79,240,255,183,185,181,0,118,50,27,0,63,227,192,0,123,99,58,1,50,224,155,255,17,225,223,254,220,224,77,255,14,44,123,1,141,128,175,0,248,212,200,0,150,59,183,255,147,97,29,0,150,204,181,0,253,37,71,0,145,85,119,0,154,200,186,0,2,128,249,255,83,24,124,0,14,87,143,0,168,51,245,1,124,151,231,255,208,240,197,1,124,190,185,0,48,58,246,0,20,233,232,0,125,18,98,255,13,254,31,255,245,177,130,255,108,142,35,0,171,125,242,254,140,12,34,255,165,161,162,0,206,205,101,0,247,25,34,1,100,145,57,0,39,70,57,0,118,204,203,255,242,0,162,0,165,244,30,0,198,116,226,0,128,111,153,255,140,54,182,1,60,122,15,255,155,58,57,1,54,50,198,0,171,211,29,255,107,138,167,255,173,107,199,255,109,161,193,0,89,72,242,255,206,115,89,255,250,254,142,254,177,202,94,255,81,89,50,0,7,105,66,255,25,254,255,254,203,64,23,255,79,222,108,255,39,249,75,0,241,124,50,0,239,152,133,0,221,241,105,0,147,151,98,0,213,161,121,254,242,49,137,0,233,37,249,254,42,183,27,0,184,119,230,255,217,32,163,255,208,251,228,1,137,62,131,255,79,64,9,254,94,48,113,0,17,138,50,254,193,255,22,0,247,18,197,1,67,55,104,0,16,205,95,255,48,37,66,0,55,156,63,1,64,82,74,255,200,53,71,254,239,67,125,0,26,224,222,0,223,137,93,255,30,224,202,255,9,220,132,0,198,38,235,1,102,141,86,0,60,43,81,1,136,28,26,0,233,36,8,254,207,242,148,0,164,162,63,0,51,46,224,255,114,48,79,255,9,175,226,0,222,3,193,255,47,160,232,255,255,93,105,254,14,42,230,0,26,138,82,1,208,43,244,0,27,39,38,255,98,208,127,255,64,149,182,255,5,250,209,0,187,60,28,254,49,25,218,255,169,116,205,255,119,18,120,0,156,116,147,255,132,53,109,255,13,10,202,0,110,83,167,0,157,219,137,255,6,3,130,255,50,167,30,255,60,159,47,255,129,128,157,254,94,3,189,0,3,166,68,0,83,223,215,0,150,90,194,1,15,168,65,0,227,83,51,255,205,171,66,255,54,187,60,1,152,102,45,255,119,154,225,0,240,247,136,0,100,197,178,255,139,71,223,255,204,82,16,1,41,206,42,255,156,192,221,255,216,123,244,255,218,218,185,255,187,186,239,255,252,172,160,255,195,52,22,0,144,174,181,254,187,100,115,255,211,78,176,255,27,7,193,0,147,213,104,255,90,201,10,255,80,123,66,1,22,33,186,0,1,7,99,254,30,206,10,0,229,234,5,0,53,30,210,0,138,8,220,254,71,55,167,0,72,225,86,1,118,190,188,0,254,193,101,1,171,249,172,255,94,158,183,254,93,2,108,255,176,93,76,255,73,99,79,255,74,64,129,254,246,46,65,0,99,241,127,254,246,151,102,255,44,53,208,254,59,102,234,0,154,175,164,255,88,242,32,0,111,38,1,0,255,182,190,255,115,176,15,254,169,60,129,0,122,237,241,0,90,76,63,0,62,74,120,255,122,195,110,0,119,4,178,0,222,242,210,0,130,33,46,254,156,40,41,0,167,146,112,1,49,163,111,255,121,176,235,0,76,207,14,255,3,25,198,1,41,235,213,0,85,36,214,1,49,92,109,255,200,24,30,254,168,236,195,0,145,39,124,1,236,195,149,0,90,36,184,255,67,85,170,255,38,35,26,254,131,124,68,255,239,155,35,255,54,201,164,0,196,22,117,255,49,15,205,0,24,224,29,1,126,113,144,0,117,21,182,0,203,159,141,0,223,135,77,0,176,230,176,255,190,229,215,255,99,37,181,255,51,21,138,255,25,189,89,255,49,48,165,254,152,45,247,0,170,108,222,0,80,202,5,0,27,69,103,254,204,22,129,255,180,252,62,254,210,1,91,255,146,110,254,255,219,162,28,0,223,252,213,1,59,8,33,0,206,16,244,0,129,211,48,0,107,160,208,0,112,59,209,0,109,77,216,254,34,21,185,255,246,99,56,255,179,139,19,255,185,29,50,255,84,89,19,0,74,250,98,255,225,42,200,255,192,217,205,255,210,16,167,0,99,132,95,1,43,230,57,0,254,11,203,255,99,188,63,255,119,193,251,254,80,105,54,0,232,181,189,1,183,69,112,255,208,171,165,255,47,109,180,255,123,83,165,0,146,162,52,255,154,11,4,255,151,227,90,255,146,137,97,254,61,233,41,255,94,42,55,255,108,164,236,0,152,68,254,0,10,140,131,255,10,106,79,254,243,158,137,0,67,178,66,254,177,123,198,255,15,62,34,0,197,88,42,255,149,95,177,255,152,0,198,255,149,254,113,255,225,90,163,255,125,217,247,0,18,17,224,0,128,66,120,254,192,25,9,255,50,221,205,0,49,212,70,0,233,255,164,0,2,209,9,0,221,52,219,254,172,224,244,255,94,56,206,1,242,179,2,255,31,91,164,1,230,46,138,255,189,230,220,0,57,47,61,255,111,11,157,0,177,91,152,0,28,230,98,0,97,87,126,0,198,89,145,255,167,79,107,0,249,77,160,1,29,233,230,255,150,21,86,254,60,11,193,0,151,37,36,254,185,150,243,255,228,212,83,1,172,151,180,0,201,169,155,0,244,60,234,0,142,235,4,1,67,218,60,0,192,113,75,1,116,243,207,255,65,172,155,0,81,30,156,255,80,72,33,254,18,231,109,255,142,107,21,254,125,26,132,255,176,16,59,255,150,201,58,0,206,169,201,0,208,121,226,0,40,172,14,255,150,61,94,255,56,57,156,255,141,60,145,255,45,108,149,255,238,145,155,255,209,85,31,254,192,12,210,0,99,98,93,254,152,16,151,0,225,185,220,0,141,235,44,255,160,172,21,254,71,26,31,255,13,64,93,254,28,56,198,0,177,62,248,1,182,8,241,0,166,101,148,255,78,81,133,255,129,222,215,1,188,169,129,255,232,7,97,0,49,112,60,255,217,229,251,0,119,108,138,0,39,19,123,254,131,49,235,0,132,84,145,0,130,230,148,255,25,74,187,0,5,245,54,255,185,219,241,1,18,194,228,255,241,202,102,0,105,113,202,0,155,235,79,0,21,9,178,255,156,1,239,0,200,148,61,0,115,247,210,255,49,221,135,0,58,189,8,1,35,46,9,0,81,65,5,255,52,158,185,255,125,116,46,255,74,140,13,255,210,92,172,254,147,23,71,0,217,224,253,254,115,108,180,255,145,58,48,254,219,177,24,255,156,255,60,1,154,147,242,0,253,134,87,0,53,75,229,0,48,195,222,255,31,175,50,255,156,210,120,255,208,35,222,255,18,248,179,1,2,10,101,255,157,194,248,255,158,204,101,255,104,254,197,255,79,62,4,0,178,172,101,1,96,146,251,255,65,10,156,0,2,137,165,255,116,4,231,0,242,215,1,0,19,35,29,255,43,161,79,0,59,149,246,1,251,66,176,0,200,33,3,255,80,110,142,255,195,161,17,1,228,56,66,255,123,47,145,254,132,4,164,0,67,174,172,0,25,253,114,0,87,97,87,1,250,220,84,0,96,91,200,255,37,125,59,0,19,65,118,0,161,52,241,255,237,172,6,255,176,191,255,255,1,65,130,254,223,190,230,0,101,253,231,255,146,35,109,0,250,29,77,1,49,0,19,0,123,90,155,1,22,86,32,255,218,213,65,0,111,93,127,0,60,93,169,255,8,127,182,0,17,186,14,254,253,137,246,255,213,25,48,254,76,238,0,255,248,92,70,255,99,224,139,0,184,9,255,1,7,164,208,0,205,131,198,1,87,214,199,0,130,214,95,0,221,149,222,0,23,38,171,254,197,110,213,0,43,115,140,254,215,177,118,0,96,52,66,1,117,158,237,0,14,64,182,255,46,63,174,255,158,95,190,255,225,205,177,255,43,5,142,255,172,99,212,255,244,187,147,0,29,51,153,255,228,116,24,254,30,101,207,0,19,246,150,255,134,231,5,0,125,134,226,1,77,65,98,0,236,130,33,255,5,110,62,0,69,108,127,255,7,113,22,0,145,20,83,254,194,161,231,255,131,181,60,0,217,209,177,255,229,148,212,254,3,131,184,0,117,177,187,1,28,14,31,255,176,102,80,0,50,84,151,255,125,31,54,255,21,157,133,255,19,179,139,1,224,232,26,0,34,117,170,255,167,252,171,255,73,141,206,254,129,250,35,0,72,79,236,1,220,229,20,255,41,202,173,255,99,76,238,255,198,22,224,255,108,198,195,255,36,141,96,1,236,158,59,255,106,100,87,0,110,226,2,0,227,234,222,0,154,93,119,255,74,112,164,255,67,91,2,255,21,145,33,255,102,214,137,255,175,230,103,254,163,246,166,0,93,247,116,254,167,224,28,255,220,2,57,1,171,206,84,0,123,228,17,255,27,120,119,0,119,11,147,1,180,47,225,255,104,200,185,254,165,2,114,0,77,78,212,0,45,154,177,255,24,196,121,254,82,157,182,0,90,16,190,1,12,147,197,0,95,239,152,255,11,235,71,0,86,146,119,255,172,134,214,0,60,131,196,0,161,225,129,0,31,130,120,254,95,200,51,0,105,231,210,255,58,9,148,255,43,168,221,255,124,237,142,0,198,211,50,254,46,245,103,0,164,248,84,0,152,70,208,255,180,117,177,0,70,79,185,0,243,74,32,0,149,156,207,0,197,196,161,1,245,53,239,0,15,93,246,254,139,240,49,255,196,88,36,255,162,38,123,0,128,200,157,1,174,76,103,255,173,169,34,254,216,1,171,255,114,51,17,0,136,228,194,0,110,150,56,254,106,246,159,0,19,184,79,255,150,77,240,255,155,80,162,0,0,53,169,255,29,151,86,0,68,94,16,0,92,7,110,254,98,117,149,255,249,77,230,255,253,10,140,0,214,124,92,254,35,118,235,0,89,48,57,1,22,53,166,0,184,144,61,255,179,255,194,0,214,248,61,254,59,110,246,0,121,21,81,254,166,3,228,0,106,64,26,255,69,232,134,255,242,220,53,254,46,220,85,0,113,149,247,255,97,179,103,255,190,127,11,0,135,209,182,0,95,52,129,1,170,144,206,255,122,200,204,255,168,100,146,0,60,144,149,254,70,60,40,0,122,52,177,255,246,211,101,255,174,237,8,0,7,51,120,0,19,31,173,0,126,239,156,255,143,189,203,0,196,128,88,255,233,133,226,255,30,125,173,255,201,108,50,0,123,100,59,255,254,163,3,1,221,148,181,255,214,136,57,254,222,180,137,255,207,88,54,255,28,33,251,255,67,214,52,1,210,208,100,0,81,170,94,0,145,40,53,0,224,111,231,254,35,28,244,255,226,199,195,254,238,17,230,0,217,217,164,254,169,157,221,0,218,46,162,1,199,207,163,255,108,115,162,1,14,96,187,255,118,60,76,0,184,159,152,0,209,231,71,254,42,164,186,255,186,153,51,254,221,171,182,255,162,142,173,0,235,47,193,0,7,139,16,1,95,164,64,255,16,221,166,0,219,197,16,0,132,29,44,255,100,69,117,255,60,235,88,254,40,81,173,0,71,190,61,255,187,88,157,0,231,11,23,0,237,117,164,0,225,168,223,255,154,114,116,255,163,152,242,1,24,32,170,0,125,98,113,254,168,19,76,0,17,157,220,254,155,52,5,0,19,111,161,255,71,90,252,255,173,110,240,0,10,198,121,255,253,255,240,255,66,123,210,0,221,194,215,254,121,163,17,255,225,7,99,0,190,49,182,0,115,9,133,1,232,26,138,255,213,68,132,0,44,119,122,255,179,98,51,0,149,90,106,0,71,50,230,255,10,153,118,255,177,70,25,0,165,87,205,0,55,138,234,0,238,30,97,0,113,155,207,0,98,153,127,0,34,107,219,254,117,114,172,255,76,180,255,254,242,57,179,255,221,34,172,254,56,162,49,255,83,3,255,255,113,221,189,255,188,25,228,254,16,88,89,255,71,28,198,254,22,17,149,255,243,121,254,255,107,202,99,255,9,206,14,1,220,47,153,0,107,137,39,1,97,49,194,255,149,51,197,254,186,58,11,255,107,43,232,1,200,6,14,255,181,133,65,254,221,228,171,255,123,62,231,1,227,234,179,255,34,189,212,254,244,187,249,0,190,13,80,1,130,89,1,0,223,133,173,0,9,222,198,255,66,127,74,0,167,216,93,255,155,168,198,1,66,145,0,0,68,102,46,1,172,90,154,0,216,128,75,255,160,40,51,0,158,17,27,1,124,240,49,0,236,202,176,255,151,124,192,255,38,193,190,0,95,182,61,0,163,147,124,255,255,165,51,255,28,40,17,254,215,96,78,0,86,145,218,254,31,36,202,255,86,9,5,0,111,41,200,255,237,108,97,0,57,62,44,0,117,184,15,1,45,241,116,0,152,1,220,255,157,165,188,0,250,15,131,1,60,44,125,255,65,220,251,255,75,50,184,0,53,90,128,255,231,80,194,255,136,129,127,1,21,18,187,255,45,58,161,255,71,147,34,0,174,249,11,254,35,141,29,0,239,68,177,255,115,110,58,0,238,190,177,1,87,245,166,255,190,49,247,255,146,83,184,255,173,14,39,255,146,215,104,0,142,223,120,0,149,200,155,255,212,207,145,1,16,181,217,0,173,32,87,255,255,35,181,0,119,223,161,1,200,223,94,255,70,6,186,255,192,67,85,255,50,169,152,0,144,26,123,255,56,243,179,254,20,68,136,0,39,140,188,254,253,208,5,255,200,115,135,1,43,172,229,255,156,104,187,0,151,251,167,0,52,135,23,0,151,153,72,0,147,197,107,254,148,158,5,255,238,143,206,0,126,153,137,255,88,152,197,254,7,68,167,0,252,159,165,255,239,78,54,255,24,63,55,255,38,222,94,0,237,183,12,255,206,204,210,0,19,39,246,254,30,74,231,0,135,108,29,1,179,115,0,0,117,118,116,1,132,6,252,255,145,129,161,1,105,67,141,0,82,37,226,255,238,226,228,255,204,214,129,254,162,123,100,255,185,121,234,0,45,108,231,0,66,8,56,255,132,136,128,0,172,224,66,254,175,157,188,0,230,223,226,254,242,219,69,0,184,14,119,1,82,162,56,0,114,123,20,0,162,103,85,255,49,239,99,254,156,135,215,0,111,255,167,254,39,196,214,0,144,38,79,1,249,168,125,0,155,97,156,255,23,52,219,255,150,22,144,0,44,149,165,255,40,127,183,0,196,77,233,255,118,129,210,255,170,135,230,255,214,119,198,0,233,240,35,0,253,52,7,255,117,102,48,255,21,204,154,255,179,136,177,255,23,2,3,1,149,130,89,255,252,17,159,1,70,60,26,0,144,107,17,0,180,190,60,255,56,182,59,255,110,71,54,255,198,18,129,255,149,224,87,255,223,21,152,255,138,22,182,255,250,156,205,0,236,45,208,255,79,148,242,1,101,70,209,0,103,78,174,0,101,144,172,255,152,136,237,1,191,194,136,0,113,80,125,1,152,4,141,0,155,150,53,255,196,116,245,0,239,114,73,254,19,82,17,255,124,125,234,255,40,52,191,0,42,210,158,255,155,132,165,0,178,5,42,1,64,92,40,255,36,85,77,255,178,228,118,0,137,66,96,254,115,226,66,0,110,240,69,254,151,111,80,0,167,174,236,255,227,108,107,255,188,242,65,255,183,81,255,0,57,206,181,255,47,34,181,255,213,240,158,1,71,75,95,0,156,40,24,255,102,210,81,0,171,199,228,255,154,34,41,0,227,175,75,0,21,239,195,0,138,229,95,1,76,192,49,0,117,123,87,1,227,225,130,0,125,62,63,255,2,198,171,0,254,36,13,254,145,186,206,0,148,255,244,255,35,0,166,0,30,150,219,1,92,228,212,0,92,198,60,254,62,133,200,255,201,41,59,0,125,238,109,255,180,163,238,1,140,122,82,0,9,22,88,255,197,157,47,255,153,94,57,0,88,30,182,0,84,161,85,0,178,146,124,0,166,166,7,255,21,208,223,0,156,182,242,0,155,121,185,0,83,156,174,254,154,16,118,255,186,83,232,1,223,58,121,255,29,23,88,0,35,125,127,255,170,5,149,254,164,12,130,255,155,196,29,0,161,96,136,0,7,35,29,1,162,37,251,0,3,46,242,255,0,217,188,0,57,174,226,1,206,233,2,0,57,187,136,254,123,189,9,255,201,117,127,255,186,36,204,0,231,25,216,0,80,78,105,0,19,134,129,255,148,203,68,0,141,81,125,254,248,165,200,255,214,144,135,0,151,55,166,255,38,235,91,0,21,46,154,0,223,254,150,255,35,153,180,255,125,176,29,1,43,98,30,255,216,122,230,255,233,160,12,0,57,185,12,254,240,113,7,255,5,9,16,254,26,91,108,0,109,198,203,0,8,147,40,0,129,134,228,255,124,186,40,255,114,98,132,254,166,132,23,0,99,69,44,0,9,242,238,255,184,53,59,0,132,129,102,255,52,32,243,254,147,223,200,255,123,83,179,254,135,144,201,255,141,37,56,1,151,60,227,255,90,73,156,1,203,172,187,0,80,151,47,255,94,137,231,255,36,191,59,255,225,209,181,255,74,215,213,254,6,118,179,255,153,54,193,1,50,0,231,0,104,157,72,1,140,227,154,255,182,226,16,254,96,225,92,255,115,20,170,254,6,250,78,0,248,75,173,255,53,89,6,255,0,180,118,0,72,173,1,0,64,8,206,1,174,133,223,0,185,62,133,255,214,11,98,0,197,31,208,0,171,167,244,255,22,231,181,1,150,218,185,0,247,169,97,1,165,139,247,255,47,120,149,1,103,248,51,0,60,69,28,254,25,179,196,0,124,7,218,254,58,107,81,0,184,233,156,255,252,74,36,0,118,188,67,0,141,95,53,255,222,94,165,254,46,61,53,0,206,59,115,255,47,236,250,255,74,5,32,1,129,154,238,255,106,32,226,0,121,187,61,255,3,166,241,254,67,170,172,255,29,216,178,255,23,201,252,0,253,110,243,0,200,125,57,0,109,192,96,255,52,115,238,0,38,121,243,255,201,56,33,0,194,118,130,0,75,96,25,255,170,30,230,254,39,63,253,0,36,45,250,255,251,1,239,0,160,212,92,1,45,209,237,0,243,33,87,254,237,84,201,255,212,18,157,254,212,99,127,255,217,98,16,254,139,172,239,0,168,201,130,255,143,193,169,255,238,151,193,1,215,104,41,0,239,61,165,254,2,3,242,0,22,203,177,254,177,204,22,0,149,129,213,254,31,11,41,255,0,159,121,254,160,25,114,255,162,80,200,0,157,151,11,0,154,134,78,1,216,54,252,0,48,103,133,0,105,220,197,0,253,168,77,254,53,179,23,0,24,121,240,1,255,46,96,255,107,60,135,254,98,205,249,255,63,249,119,255,120,59,211,255,114,180,55,254,91,85,237,0,149,212,77,1,56,73,49,0,86,198,150,0,93,209,160,0,69,205,182,255,244,90,43,0,20,36,176,0,122,116,221,0,51,167,39,1,231,1,63,255,13,197,134,0,3,209,34,255,135,59,202,0,167,100,78,0,47,223,76,0,185,60,62,0,178,166,123,1,132,12,161,255,61,174,43,0,195,69,144,0,127,47,191,1,34,44,78,0,57,234,52,1,255,22,40,255,246,94,146,0,83,228,128,0,60,78,224,255,0,96,210,255,153,175,236,0,159,21,73,0,180,115,196,254,131,225,106,0,255,167,134,0,159,8,112,255,120,68,194,255,176,196,198,255,118,48,168,255,93,169,1,0,112,200,102,1,74,24,254,0,19,141,4,254,142,62,63,0,131,179,187,255,77,156,155,255,119,86,164,0,170,208,146,255,208,133,154,255,148,155,58,255,162,120,232,254,252,213,155,0,241,13,42,0,94,50,131,0,179,170,112,0,140,83,151,255,55,119,84,1,140,35,239,255,153,45,67,1,236,175,39,0,54,151,103,255,158,42,65,255,196,239,135,254,86,53,203,0,149,97,47,254,216,35,17,255,70,3,70,1,103,36,90,255,40,26,173,0,184,48,13,0,163,219,217,255,81,6,1,255,221,170,108,254,233,208,93,0,100,201,249,254,86,36,35,255,209,154,30,1,227,201,251,255,2,189,167,254,100,57,3,0,13,128,41,0,197,100,75,0,150,204,235,255,145,174,59,0,120,248,149,255,85,55,225,0,114,210,53,254,199,204,119,0,14,247,74,1,63,251,129,0,67,104,151,1,135,130,80,0,79,89,55,255,117,230,157,255,25,96,143,0,213,145,5,0,69,241,120,1,149,243,95,255,114,42,20,0,131,72,2,0,154,53,20,255,73,62,109,0,196,102,152,0,41,12,204,255,122,38,11,1,250,10,145,0,207,125,148,0,246,244,222,255,41,32,85,1,112,213,126,0,162,249,86,1,71,198,127,255,81,9,21,1,98,39,4,255,204,71,45,1,75,111,137,0,234,59,231,0,32,48,95,255,204,31,114,1,29,196,181,255,51,241,167,254,93,109,142,0,104,144,45,0,235,12,181,255,52,112,164,0,76,254,202,255,174,14,162,0,61,235,147,255,43,64,185,254,233,125,217,0,243,88,167,254,74,49,8,0,156,204,66,0,124,214,123,0,38,221,118,1,146,112,236,0,114,98,177,0,151,89,199,0,87,197,112,0,185,149,161,0,44,96,165,0,248,179,20,255,188,219,216,254,40,62,13,0,243,142,141,0,229,227,206,255,172,202,35,255,117,176,225,255,82,110,38,1,42,245,14,255,20,83,97,0,49,171,10,0,242,119,120,0,25,232,61,0,212,240,147,255,4,115,56,255,145,17,239,254,202,17,251,255,249,18,245,255,99,117,239,0,184,4,179,255,246,237,51,255,37,239,137,255,166,112,166,255,81,188,33,255,185,250,142,255,54,187,173,0,208,112,201,0,246,43,228,1,104,184,88,255,212,52,196,255,51,117,108,255,254,117,155,0,46,91,15,255,87,14,144,255,87,227,204,0,83,26,83,1,159,76,227,0,159,27,213,1,24,151,108,0,117,144,179,254,137,209,82,0,38,159,10,0,115,133,201,0,223,182,156,1,110,196,93,255,57,60,233,0,5,167,105,255,154,197,164,0,96,34,186,255,147,133,37,1,220,99,190,0,1,167,84,255,20,145,171,0,194,197,251,254,95,78,133,255,252,248,243,255,225,93,131,255,187,134,196,255,216,153,170,0,20,118,158,254,140,1,118,0,86,158,15,1,45,211,41,255,147,1,100,254,113,116,76,255,211,127,108,1,103,15,48,0,193,16,102,1,69,51,95,255,107,128,157,0,137,171,233,0,90,124,144,1,106,161,182,0,175,76,236,1,200,141,172,255,163,58,104,0,233,180,52,255,240,253,14,255,162,113,254,255,38,239,138,254,52,46,166,0,241,101,33,254,131,186,156,0,111,208,62,255,124,94,160,255,31,172,254,0,112,174,56,255,188,99,27,255,67,138,251,0,125,58,128,1,156,152,174,255,178,12,247,255,252,84,158,0,82,197,14,254,172,200,83,255,37,39,46,1,106,207,167,0,24,189,34,0,131,178,144,0,206,213,4,0,161,226,210,0,72,51,105,255,97,45,187,255,78,184,223,255,176,29,251,0,79,160,86,255,116,37,178,0,82,77,213,1,82,84,141,255,226,101,212,1,175,88,199,255,245,94,247,1,172,118,109,255,166,185,190,0,131,181,120,0,87,254,93,255,134,240,73,255,32,245,143,255,139,162,103,255,179,98,18,254,217,204,112,0,147,223,120,255,53,10,243,0,166,140,150,0,125,80,200,255,14,109,219,255,91,218,1,255,252,252,47,254,109,156,116,255,115,49,127,1,204,87,211,255,148,202,217,255,26,85,249,255,14,245,134,1,76,89,169,255,242,45,230,0,59,98,172,255,114,73,132,254,78,155,49,255,158,126,84,0,49,175,43,255,16,182,84,255,157,103,35,0,104,193,109,255,67,221,154,0,201,172,1,254,8,162,88,0,165,1,29,255,125,155,229,255,30,154,220,1,103,239,92,0,220,1,109,255,202,198,1,0,94,2,142,1,36,54,44,0,235,226,158,255,170,251,214,255,185,77,9,0,97,74,242,0,219,163,149,255,240,35,118,255,223,114,88,254,192,199,3,0,106,37,24,255,201,161,118,255,97,89,99,1,224,58,103,255,101,199,147,254,222,60,99,0,234,25,59,1,52,135,27,0,102,3,91,254,168,216,235,0,229,232,136,0,104,60,129,0,46,168,238,0,39,191,67,0,75,163,47,0,143,97,98,255,56,216,168,1,168,233,252,255,35,111,22,255,92,84,43,0,26,200,87,1,91,253,152,0,202,56,70,0,142,8,77,0,80,10,175,1,252,199,76,0,22,110,82,255,129,1,194,0,11,128,61,1,87,14,145,255,253,222,190,1,15,72,174,0,85,163,86,254,58,99,44,255,45,24,188,254,26,205,15,0,19,229,210,254,248,67,195,0,99,71,184,0,154,199,37,255,151,243,121,255,38,51,75,255,201,85,130,254,44,65,250,0,57,147,243,254,146,43,59,255,89,28,53,0,33,84,24,255,179,51,18,254,189,70,83,0,11,156,179,1,98,134,119,0,158,111,111,0,119,154,73,255,200,63,140,254,45,13,13,255,154,192,2,254,81,72,42,0,46,160,185,254,44,112,6,0,146,215,149,1,26,176,104,0,68,28,87,1,236,50,153,255,179,128,250,254,206,193,191,255,166,92,137,254,53,40,239,0,210,1,204,254,168,173,35,0,141,243,45,1,36,50,109,255,15,242,194,255,227,159,122,255,176,175,202,254,70,57,72,0,40,223,56,0,208,162,58,255,183,98,93,0,15,111,12,0,30,8,76,255,132,127,246,255,45,242,103,0,69,181,15,255,10,209,30,0,3,179,121,0,241,232,218,1,123,199,88,255,2,210,202,1,188,130,81,255,94,101,208,1,103,36,45,0,76,193,24,1,95,26,241,255,165,162,187,0,36,114,140,0,202,66,5,255,37,56,147,0,152,11,243,1,127,85,232,255,250,135,212,1,185,177,113,0,90,220,75,255,69,248,146,0,50,111,50,0,92,22,80,0,244,36,115,254,163,100,82,255,25,193,6,1,127,61,36,0,253,67,30,254,65,236,170,255,161,17,215,254,63,175,140,0,55,127,4,0,79,112,233,0,109,160,40,0,143,83,7,255,65,26,238,255,217,169,140,255,78,94,189,255,0,147,190,255,147,71,186,254,106,77,127,255,233,157,233,1,135,87,237,255,208,13,236,1,155,109,36,255,180,100,218,0,180,163,18,0,190,110,9,1,17,63,123,255,179,136,180,255,165,123,123,255,144,188,81,254,71,240,108,255,25,112,11,255,227,218,51,255,167,50,234,255,114,79,108,255,31,19,115,255,183,240,99,0,227,87,143,255,72,217,248,255,102,169,95,1,129,149,149,0,238,133,12,1,227,204,35,0,208,115,26,1,102,8,234,0,112,88,143,1,144,249,14,0,240,158,172,254,100,112,119,0,194,141,153,254,40,56,83,255,121,176,46,0,42,53,76,255,158,191,154,0,91,209,92,0,173,13,16,1,5,72,226,255,204,254,149,0,80,184,207,0,100,9,122,254,118,101,171,255,252,203,0,254,160,207,54,0,56,72,249,1,56,140,13,255,10,64,107,254,91,101,52,255,225,181,248,1,139,255,132,0,230,145,17,0,233,56,23,0,119,1,241,255,213,169,151,255,99,99,9,254,185,15,191,255,173,103,109,1,174,13,251,255,178,88,7,254,27,59,68,255,10,33,2,255,248,97,59,0,26,30,146,1,176,147,10,0,95,121,207,1,188,88,24,0,185,94,254,254,115,55,201,0,24,50,70,0,120,53,6,0,142,66,146,0,228,226,249,255,104,192,222,1,173,68,219,0,162,184,36,255,143,102,137,255,157,11,23,0,125,45,98,0,235,93,225,254,56,112,160,255,70,116,243,1,153,249,55,255,129,39,17,1,241,80,244,0,87,69,21,1,94,228,73,255,78,66,65,255,194,227,231,0,61,146,87,255,173,155,23,255,112,116,219,254,216,38,11,255,131,186,133,0,94,212,187,0,100,47,91,0,204,254,175,255,222,18,215,254,173,68,108,255,227,228,79,255,38,221,213,0,163,227,150,254,31,190,18,0,160,179,11,1,10,90,94,255,220,174,88,0,163,211,229,255,199,136,52,0,130,95,221,255,140,188,231,254,139,113,128,255,117,171,236,254,49,220,20,255,59,20,171,255,228,109,188,0,20,225,32,254,195,16,174,0,227,254,136,1,135,39,105,0,150,77,206,255,210,238,226],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE+10240);allocate([55,212,132,254,239,57,124,0,170,194,93,255,249,16,247,255,24,151,62,255,10,151,10,0,79,139,178,255,120,242,202,0,26,219,213,0,62,125,35,255,144,2,108,255,230,33,83,255,81,45,216,1,224,62,17,0,214,217,125,0,98,153,153,255,179,176,106,254,131,93,138,255,109,62,36,255,178,121,32,255,120,252,70,0,220,248,37,0,204,88,103,1,128,220,251,255,236,227,7,1,106,49,198,255,60,56,107,0,99,114,238,0,220,204,94,1,73,187,1,0,89,154,34,0,78,217,165,255,14,195,249,255,9,230,253,255,205,135,245,0,26,252,7,255,84,205,27,1,134,2,112,0,37,158,32,0,231,91,237,255,191,170,204,255,152,7,222,0,109,192,49,0,193,166,146,255,232,19,181,255,105,142,52,255,103,16,27,1,253,200,165,0,195,217,4,255,52,189,144,255,123,155,160,254,87,130,54,255,78,120,61,255,14,56,41,0,25,41,125,255,87,168,245,0,214,165,70,0,212,169,6,255,219,211,194,254,72,93,164,255,197,33,103,255,43,142,141,0,131,225,172,0,244,105,28,0,68,68,225,0,136,84,13,255,130,57,40,254,139,77,56,0,84,150,53,0,54,95,157,0,144,13,177,254,95,115,186,0,117,23,118,255,244,166,241,255,11,186,135,0,178,106,203,255,97,218,93,0,43,253,45,0,164,152,4,0,139,118,239,0,96,1,24,254,235,153,211,255,168,110,20,255,50,239,176,0,114,41,232,0,193,250,53,0,254,160,111,254,136,122,41,255,97,108,67,0,215,152,23,255,140,209,212,0,42,189,163,0,202,42,50,255,106,106,189,255,190,68,217,255,233,58,117,0,229,220,243,1,197,3,4,0,37,120,54,254,4,156,134,255,36,61,171,254,165,136,100,255,212,232,14,0,90,174,10,0,216,198,65,255,12,3,64,0,116,113,115,255,248,103,8,0,231,125,18,255,160,28,197,0,30,184,35,1,223,73,249,255,123,20,46,254,135,56,37,255,173,13,229,1,119,161,34,255,245,61,73,0,205,125,112,0,137,104,134,0,217,246,30,255,237,142,143,0,65,159,102,255,108,164,190,0,219,117,173,255,34,37,120,254,200,69,80,0,31,124,218,254,74,27,160,255,186,154,199,255,71,199,252,0,104,81,159,1,17,200,39,0,211,61,192,1,26,238,91,0,148,217,12,0,59,91,213,255,11,81,183,255,129,230,122,255,114,203,145,1,119,180,66,255,72,138,180,0,224,149,106,0,119,82,104,255,208,140,43,0,98,9,182,255,205,101,134,255,18,101,38,0,95,197,166,255,203,241,147,0,62,208,145,255,133,246,251,0,2,169,14,0,13,247,184,0,142,7,254,0,36,200,23,255,88,205,223,0,91,129,52,255,21,186,30,0,143,228,210,1,247,234,248,255,230,69,31,254,176,186,135,255,238,205,52,1,139,79,43,0,17,176,217,254,32,243,67,0,242,111,233,0,44,35,9,255,227,114,81,1,4,71,12,255,38,105,191,0,7,117,50,255,81,79,16,0,63,68,65,255,157,36,110,255,77,241,3,255,226,45,251,1,142,25,206,0,120,123,209,1,28,254,238,255,5,128,126,255,91,222,215,255,162,15,191,0,86,240,73,0,135,185,81,254,44,241,163,0,212,219,210,255,112,162,155,0,207,101,118,0,168,72,56,255,196,5,52,0,72,172,242,255,126,22,157,255,146,96,59,255,162,121,152,254,140,16,95,0,195,254,200,254,82,150,162,0,119,43,145,254,204,172,78,255,166,224,159,0,104,19,237,255,245,126,208,255,226,59,213,0,117,217,197,0,152,72,237,0,220,31,23,254,14,90,231,255,188,212,64,1,60,101,246,255,85,24,86,0,1,177,109,0,146,83,32,1,75,182,192,0,119,241,224,0,185,237,27,255,184,101,82,1,235,37,77,255,253,134,19,0,232,246,122,0,60,106,179,0,195,11,12,0,109,66,235,1,125,113,59,0,61,40,164,0,175,104,240,0,2,47,187,255,50,12,141,0,194,139,181,255,135,250,104,0,97,92,222,255,217,149,201,255,203,241,118,255,79,151,67,0,122,142,218,255,149,245,239,0,138,42,200,254,80,37,97,255,124,112,167,255,36,138,87,255,130,29,147,255,241,87,78,255,204,97,19,1,177,209,22,255,247,227,127,254,99,119,83,255,212,25,198,1,16,179,179,0,145,77,172,254,89,153,14,255,218,189,167,0,107,233,59,255,35,33,243,254,44,112,112,255,161,127,79,1,204,175,10,0,40,21,138,254,104,116,228,0,199,95,137,255,133,190,168,255,146,165,234,1,183,99,39,0,183,220,54,254,255,222,133,0,162,219,121,254,63,239,6,0,225,102,54,255,251,18,246,0,4,34,129,1,135,36,131,0,206,50,59,1,15,97,183,0,171,216,135,255,101,152,43,255,150,251,91,0,38,145,95,0,34,204,38,254,178,140,83,255,25,129,243,255,76,144,37,0,106,36,26,254,118,144,172,255,68,186,229,255,107,161,213,255,46,163,68,255,149,170,253,0,187,17,15,0,218,160,165,255,171,35,246,1,96,13,19,0,165,203,117,0,214,107,192,255,244,123,177,1,100,3,104,0,178,242,97,255,251,76,130,255,211,77,42,1,250,79,70,255,63,244,80,1,105,101,246,0,61,136,58,1,238,91,213,0,14,59,98,255,167,84,77,0,17,132,46,254,57,175,197,255,185,62,184,0,76,64,207,0,172,175,208,254,175,74,37,0,138,27,211,254,148,125,194,0,10,89,81,0,168,203,101,255,43,213,209,1,235,245,54,0,30,35,226,255,9,126,70,0,226,125,94,254,156,117,20,255,57,248,112,1,230,48,64,255,164,92,166,1,224,214,230,255,36,120,143,0,55,8,43,255,251,1,245,1,106,98,165,0,74,107,106,254,53,4,54,255,90,178,150,1,3,120,123,255,244,5,89,1,114,250,61,255,254,153,82,1,77,15,17,0,57,238,90,1,95,223,230,0,236,52,47,254,103,148,164,255,121,207,36,1,18,16,185,255,75,20,74,0,187,11,101,0,46,48,129,255,22,239,210,255,77,236,129,255,111,77,204,255,61,72,97,255,199,217,251,255,42,215,204,0,133,145,201,255,57,230,146,1,235,100,198,0,146,73,35,254,108,198,20,255,182,79,210,255,82,103,136,0,246,108,176,0,34,17,60,255,19,74,114,254,168,170,78,255,157,239,20,255,149,41,168,0,58,121,28,0,79,179,134,255,231,121,135,255,174,209,98,255,243,122,190,0,171,166,205,0,212,116,48,0,29,108,66,255,162,222,182,1,14,119,21,0,213,39,249,255,254,223,228,255,183,165,198,0,133,190,48,0,124,208,109,255,119,175,85,255,9,209,121,1,48,171,189,255,195,71,134,1,136,219,51,255,182,91,141,254,49,159,72,0,35,118,245,255,112,186,227,255,59,137,31,0,137,44,163,0,114,103,60,254,8,213,150,0,162,10,113,255,194,104,72,0,220,131,116,255,178,79,92,0,203,250,213,254,93,193,189,255,130,255,34,254,212,188,151,0,136,17,20,255,20,101,83,255,212,206,166,0,229,238,73,255,151,74,3,255,168,87,215,0,155,188,133,255,166,129,73,0,240,79,133,255,178,211,81,255,203,72,163,254,193,168,165,0,14,164,199,254,30,255,204,0,65,72,91,1,166,74,102,255,200,42,0,255,194,113,227,255,66,23,208,0,229,216,100,255,24,239,26,0,10,233,62,255,123,10,178,1,26,36,174,255,119,219,199,1,45,163,190,0,16,168,42,0,166,57,198,255,28,26,26,0,126,165,231,0,251,108,100,255,61,229,121,255,58,118,138,0,76,207,17,0,13,34,112,254,89,16,168,0,37,208,105,255,35,201,215,255,40,106,101,254,6,239,114,0,40,103,226,254,246,127,110,255,63,167,58,0,132,240,142,0,5,158,88,255,129,73,158,255,94,89,146,0,230,54,146,0,8,45,173,0,79,169,1,0,115,186,247,0,84,64,131,0,67,224,253,255,207,189,64,0,154,28,81,1,45,184,54,255,87,212,224,255,0,96,73,255,129,33,235,1,52,66,80,255,251,174,155,255,4,179,37,0,234,164,93,254,93,175,253,0,198,69,87,255,224,106,46,0,99,29,210,0,62,188,114,255,44,234,8,0,169,175,247,255,23,109,137,255,229,182,39,0,192,165,94,254,245,101,217,0,191,88,96,0,196,94,99,255,106,238,11,254,53,126,243,0,94,1,101,255,46,147,2,0,201,124,124,255,141,12,218,0,13,166,157,1,48,251,237,255,155,250,124,255,106,148,146,255,182,13,202,0,28,61,167,0,217,152,8,254,220,130,45,255,200,230,255,1,55,65,87,255,93,191,97,254,114,251,14,0,32,105,92,1,26,207,141,0,24,207,13,254,21,50,48,255,186,148,116,255,211,43,225,0,37,34,162,254,164,210,42,255,68,23,96,255,182,214,8,255,245,117,137,255,66,195,50,0,75,12,83,254,80,140,164,0,9,165,36,1,228,110,227,0,241,17,90,1,25,52,212,0,6,223,12,255,139,243,57,0,12,113,75,1,246,183,191,255,213,191,69,255,230,15,142,0,1,195,196,255,138,171,47,255,64,63,106,1,16,169,214,255,207,174,56,1,88,73,133,255,182,133,140,0,177,14,25,255,147,184,53,255,10,227,161,255,120,216,244,255,73,77,233,0,157,238,139,1,59,65,233,0,70,251,216,1,41,184,153,255,32,203,112,0,146,147,253,0,87,101,109,1,44,82,133,255,244,150,53,255,94,152,232,255,59,93,39,255,88,147,220,255,78,81,13,1,32,47,252,255,160,19,114,255,93,107,39,255,118,16,211,1,185,119,209,255,227,219,127,254,88,105,236,255,162,110,23,255,36,166,110,255,91,236,221,255,66,234,116,0,111,19,244,254,10,233,26,0,32,183,6,254,2,191,242,0,218,156,53,254,41,60,70,255,168,236,111,0,121,185,126,255,238,142,207,255,55,126,52,0,220,129,208,254,80,204,164,255,67,23,144,254,218,40,108,255,127,202,164,0,203,33,3,255,2,158,0,0,37,96,188,255,192,49,74,0,109,4,0,0,111,167,10,254,91,218,135,255,203,66,173,255,150,194,226,0,201,253,6,255,174,102,121,0,205,191,110,0,53,194,4,0,81,40,45,254,35,102,143,255,12,108,198,255,16,27,232,255,252,71,186,1,176,110,114,0,142,3,117,1,113,77,142,0,19,156,197,1,92,47,252,0,53,232,22,1,54,18,235,0,46,35,189,255,236,212,129,0,2,96,208,254,200,238,199,255,59,175,164,255,146,43,231,0,194,217,52,255,3,223,12,0,138,54,178,254,85,235,207,0,232,207,34,0,49,52,50,255,166,113,89,255,10,45,216,255,62,173,28,0,111,165,246,0,118,115,91,255,128,84,60,0,167,144,203,0,87,13,243,0,22,30,228,1,177,113,146,255,129,170,230,254,252,153,129,255,145,225,43,0,70,231,5,255,122,105,126,254,86,246,148,255,110,37,154,254,209,3,91,0,68,145,62,0,228,16,165,255,55,221,249,254,178,210,91,0,83,146,226,254,69,146,186,0,93,210,104,254,16,25,173,0,231,186,38,0,189,122,140,255,251,13,112,255,105,110,93,0,251,72,170,0,192,23,223,255,24,3,202,1,225,93,228,0,153,147,199,254,109,170,22,0,248,101,246,255,178,124,12,255,178,254,102,254,55,4,65,0,125,214,180,0,183,96,147,0,45,117,23,254,132,191,249,0,143,176,203,254,136,183,54,255,146,234,177,0,146,101,86,255,44,123,143,1,33,209,152,0,192,90,41,254,83,15,125,255,213,172,82,0,215,169,144,0,16,13,34,0,32,209,100,255,84,18,249,1,197,17,236,255,217,186,230,0,49,160,176,255,111,118,97,255,237,104,235,0,79,59,92,254,69,249,11,255,35,172,74,1,19,118,68,0,222,124,165,255,180,66,35,255,86,174,246,0,43,74,111,255,126,144,86,255,228,234,91,0,242,213,24,254,69,44,235,255,220,180,35,0,8,248,7,255,102,47,92,255,240,205,102,255,113,230,171,1,31,185,201,255,194,246,70,255,122,17,187,0,134,70,199,255,149,3,150,255,117,63,103,0,65,104,123,255,212,54,19,1,6,141,88,0,83,134,243,255,136,53,103,0,169,27,180,0,177,49,24,0,111,54,167,0,195,61,215,255,31,1,108,1,60,42,70,0,185,3,162,255,194,149,40,255,246,127,38,254,190,119,38,255,61,119,8,1,96,161,219,255,42,203,221,1,177,242,164,255,245,159,10,0,116,196,0,0,5,93,205,254,128,127,179,0,125,237,246,255,149,162,217,255,87,37,20,254,140,238,192,0,9,9,193,0,97,1,226,0,29,38,10,0,0,136,63,255,229,72,210,254,38,134,92,255,78,218,208,1,104,36,84,255,12,5,193,255,242,175,61,255,191,169,46,1,179,147,147,255,113,190,139,254,125,172,31,0,3,75,252,254,215,36,15,0,193,27,24,1,255,69,149,255,110,129,118,0,203,93,249,0,138,137,64,254,38,70,6,0,153,116,222,0,161,74,123,0,193,99,79,255,118,59,94,255,61,12,43,1,146,177,157,0,46,147,191,0,16,255,38,0,11,51,31,1,60,58,98,255,111,194,77,1,154,91,244,0,140,40,144,1,173,10,251,0,203,209,50,254,108,130,78,0,228,180,90,0,174,7,250,0,31,174,60,0,41,171,30,0,116,99,82,255,118,193,139,255,187,173,198,254,218,111,56,0,185,123,216,0,249,158,52,0,52,180,93,255,201,9,91,255,56,45,166,254,132,155,203,255,58,232,110,0,52,211,89,255,253,0,162,1,9,87,183,0,145,136,44,1,94,122,245,0,85,188,171,1,147,92,198,0,0,8,104,0,30,95,174,0,221,230,52,1,247,247,235,255,137,174,53,255,35,21,204,255,71,227,214,1,232,82,194,0,11,48,227,255,170,73,184,255,198,251,252,254,44,112,34,0,131,101,131,255,72,168,187,0,132,135,125,255,138,104,97,255,238,184,168,255,243,104,84,255,135,216,226,255,139,144,237,0,188,137,150,1,80,56,140,255,86,169,167,255,194,78,25,255,220,17,180,255,17,13,193,0,117,137,212,255,141,224,151,0,49,244,175,0,193,99,175,255,19,99,154,1,255,65,62,255,156,210,55,255,242,244,3,255,250,14,149,0,158,88,217,255,157,207,134,254,251,232,28,0,46,156,251,255,171,56,184,255,239,51,234,0,142,138,131,255,25,254,243,1,10,201,194,0,63,97,75,0,210,239,162,0,192,200,31,1,117,214,243,0,24,71,222,254,54,40,232,255,76,183,111,254,144,14,87,255,214,79,136,255,216,196,212,0,132,27,140,254,131,5,253,0,124,108,19,255,28,215,75,0,76,222,55,254,233,182,63,0,68,171,191,254,52,111,222,255,10,105,77,255,80,170,235,0,143,24,88,255,45,231,121,0,148,129,224,1,61,246,84,0,253,46,219,255,239,76,33,0,49,148,18,254,230,37,69,0,67,134,22,254,142,155,94,0,31,157,211,254,213,42,30,255,4,228,247,254,252,176,13,255,39,0,31,254,241,244,255,255,170,45,10,254,253,222,249,0,222,114,132,0,255,47,6,255,180,163,179,1,84,94,151,255,89,209,82,254,229,52,169,255,213,236,0,1,214,56,228,255,135,119,151,255,112,201,193,0,83,160,53,254,6,151,66,0,18,162,17,0,233,97,91,0,131,5,78,1,181,120,53,255,117,95,63,255,237,117,185,0,191,126,136,255,144,119,233,0,183,57,97,1,47,201,187,255,167,165,119,1,45,100,126,0,21,98,6,254,145,150,95,255,120,54,152,0,209,98,104,0,143,111,30,254,184,148,249,0,235,216,46,0,248,202,148,255,57,95,22,0,242,225,163,0,233,247,232,255,71,171,19,255,103,244,49,255,84,103,93,255,68,121,244,1,82,224,13,0,41,79,43,255,249,206,167,255,215,52,21,254,192,32,22,255,247,111,60,0,101,74,38,255,22,91,84,254,29,28,13,255,198,231,215,254,244,154,200,0,223,137,237,0,211,132,14,0,95,64,206,255,17,62,247,255,233,131,121,1,93,23,77,0,205,204,52,254,81,189,136,0,180,219,138,1,143,18,94,0,204,43,140,254,188,175,219,0,111,98,143,255,151,63,162,255,211,50,71,254,19,146,53,0,146,45,83,254,178,82,238,255,16,133,84,255,226,198,93,255,201,97,20,255,120,118,35,255,114,50,231,255,162,229,156,255,211,26,12,0,114,39,115,255,206,212,134,0,197,217,160,255,116,129,94,254,199,215,219,255,75,223,249,1,253,116,181,255,232,215,104,255,228,130,246,255,185,117,86,0,14,5,8,0,239,29,61,1,237,87,133,255,125,146,137,254,204,168,223,0,46,168,245,0,154,105,22,0,220,212,161,255,107,69,24,255,137,218,181,255,241,84,198,255,130,122,211,255,141,8,153,255,190,177,118,0,96,89,178,0,255,16,48,254,122,96,105,255,117,54,232,255,34,126,105,255,204,67,166,0,232,52,138,255,211,147,12,0,25,54,7,0,44,15,215,254,51,236,45,0,190,68,129,1,106,147,225,0,28,93,45,254,236,141,15,255,17,61,161,0,220,115,192,0,236,145,24,254,111,168,169,0,224,58,63,255,127,164,188,0,82,234,75,1,224,158,134,0,209,68,110,1,217,166,217,0,70,225,166,1,187,193,143,255,16,7,88,255,10,205,140,0,117,192,156,1,17,56,38,0,27,124,108,1,171,215,55,255,95,253,212,0,155,135,168,255,246,178,153,254,154,68,74,0,232,61,96,254,105,132,59,0,33,76,199,1,189,176,130,255,9,104,25,254,75,198,102,255,233,1,112,0,108,220,20,255,114,230,70,0,140,194,133,255,57,158,164,254,146,6,80,255,169,196,97,1,85,183,130,0,70,158,222,1,59,237,234,255,96,25,26,255,232,175,97,255,11,121,248,254,88,35,194,0,219,180,252,254,74,8,227,0,195,227,73,1,184,110,161,255,49,233,164,1,128,53,47,0,82,14,121,255,193,190,58,0,48,174,117,255,132,23,32,0,40,10,134,1,22,51,25,255,240,11,176,255,110,57,146,0,117,143,239,1,157,101,118,255,54,84,76,0,205,184,18,255,47,4,72,255,78,112,85,255,193,50,66,1,93,16,52,255,8,105,134,0,12,109,72,255,58,156,251,0,144,35,204,0,44,160,117,254,50,107,194,0,1,68,165,255,111,110,162,0,158,83,40,254,76,214,234,0,58,216,205,255,171,96,147,255,40,227,114,1,176,227,241,0,70,249,183,1,136,84,139,255,60,122,247,254,143,9,117,255,177,174,137,254,73,247,143,0,236,185,126,255,62,25,247,255,45,64,56,255,161,244,6,0,34,57,56,1,105,202,83,0,128,147,208,0,6,103,10,255,74,138,65,255,97,80,100,255,214,174,33,255,50,134,74,255,110,151,130,254,111,84,172,0,84,199,75,254,248,59,112,255,8,216,178,1,9,183,95,0,238,27,8,254,170,205,220,0,195,229,135,0,98,76,237,255,226,91,26,1,82,219,39,255,225,190,199,1,217,200,121,255,81,179,8,255,140,65,206,0,178,207,87,254,250,252,46,255,104,89,110,1,253,189,158,255,144,214,158,255,160,245,54,255,53,183,92,1,21,200,194,255,146,33,113,1,209,1,255,0,235,106,43,255,167,52,232,0,157,229,221,0,51,30,25,0,250,221,27,1,65,147,87,255,79,123,196,0,65,196,223,255,76,44,17,1,85,241,68,0,202,183,249,255,65,212,212,255,9,33,154,1,71,59,80,0,175,194,59,255,141,72,9,0,100,160,244,0,230,208,56,0,59,25,75,254,80,194,194,0,18,3,200,254,160,159,115,0,132,143,247,1,111,93,57,255,58,237,11,1,134,222,135,255,122,163,108,1,123,43,190,255,251,189,206,254,80,182,72,255,208,246,224,1,17,60,9,0,161,207,38,0,141,109,91,0,216,15,211,255,136,78,110,0,98,163,104,255,21,80,121,255,173,178,183,1,127,143,4,0,104,60,82,254,214,16,13,255,96,238,33,1,158,148,230,255,127,129,62,255,51,255,210,255,62,141,236,254,157,55,224,255,114,39,244,0,192,188,250,255,228,76,53,0,98,84,81,255,173,203,61,254,147,50,55,255,204,235,191,0,52,197,244,0,88,43,211,254,27,191,119,0,188,231,154,0,66,81,161,0,92,193,160,1,250,227,120,0,123,55,226,0,184,17,72,0,133,168,10,254,22,135,156,255,41,25,103,255,48,202,58,0,186,149,81,255,188,134,239,0,235,181,189,254,217,139,188,255,74,48,82,0,46,218,229,0,189,253,251,0,50,229,12,255,211,141,191,1,128,244,25,255,169,231,122,254,86,47,189,255,132,183,23,255,37,178,150,255,51,137,253,0,200,78,31,0,22,105,50,0,130,60,0,0,132,163,91,254,23,231,187,0,192,79,239,0,157,102,164,255,192,82,20,1,24,181,103,255,240,9,234,0,1,123,164,255,133,233,0,255,202,242,242,0,60,186,245,0,241,16,199,255,224,116,158,254,191,125,91,255,224,86,207,0,121,37,231,255,227,9,198,255,15,153,239,255,121,232,217,254,75,112,82,0,95,12,57,254,51,214,105,255,148,220,97,1,199,98,36,0,156,209,12,254,10,212,52,0,217,180,55,254,212,170,232,255,216,20,84,255,157,250,135,0,157,99,127,254,1,206,41,0,149,36,70,1,54,196,201,255,87,116,0,254,235,171,150,0,27,163,234,0,202,135,180,0,208,95,0,254,123,156,93,0,183,62,75,0,137,235,182,0,204,225,255,255,214,139,210,255,2,115,8,255,29,12,111,0,52,156,1,0,253,21,251,255,37,165,31,254,12,130,211,0,106,18,53,254,42,99,154,0,14,217,61,254,216,11,92,255,200,197,112,254,147,38,199,0,36,252,120,254,107,169,77,0,1,123,159,255,207,75,102,0,163,175,196,0,44,1,240,0,120,186,176,254,13,98,76,255,237,124,241,255,232,146,188,255,200,96,224,0,204,31,41,0,208,200,13,0,21,225,96,255,175,156,196,0,247,208,126,0,62,184,244,254,2,171,81,0,85,115,158,0,54,64,45,255,19,138,114,0,135,71,205,0,227,47,147,1,218,231,66,0,253,209,28,0,244,15,173,255,6,15,118,254,16,150,208,255,185,22,50,255,86,112,207,255,75,113,215,1,63,146,43,255,4,225,19,254,227,23,62,255,14,255,214,254,45,8,205,255,87,197,151,254,210,82,215,255,245,248,247,255,128,248,70,0,225,247,87,0,90,120,70,0,213,245,92,0,13,133,226,0,47,181,5,1,92,163,105,255,6,30,133,254,232,178,61,255,230,149,24,255,18,49,158,0,228,100,61,254,116,243,251,255,77,75,92,1,81,219,147,255,76,163,254,254,141,213,246,0,232,37,152,254,97,44,100,0,201,37,50,1,212,244,57,0,174,171,183,255,249,74,112,0,166,156,30,0,222,221,97,255,243,93,73,254,251,101,100,255,216,217,93,255,254,138,187,255,142,190,52,255,59,203,177,255,200,94,52,0,115,114,158,255,165,152,104,1,126,99,226,255,118,157,244,1,107,200,16,0,193,90,229,0,121,6,88,0,156,32,93,254,125,241,211,255,14,237,157,255,165,154,21,255,184,224,22,255,250,24,152,255,113,77,31,0,247,171,23,255,237,177,204,255,52,137,145,255,194,182,114,0,224,234,149,0,10,111,103,1,201,129,4,0,238,142,78,0,52,6,40,255,110,213,165,254,60,207,253,0,62,215,69,0,96,97,0,255,49,45,202,0,120,121,22,255,235,139,48,1,198,45,34,255,182,50,27,1,131,210,91,255,46,54,128,0,175,123,105,255,198,141,78,254,67,244,239,255,245,54,103,254,78,38,242,255,2,92,249,254,251,174,87,255,139,63,144,0,24,108,27,255,34,102,18,1,34,22,152,0,66,229,118,254,50,143,99,0,144,169,149,1,118,30,152,0,178,8,121,1,8,159,18,0,90,101,230,255,129,29,119,0,68,36,11,1,232,183,55,0,23,255,96,255,161,41,193,255,63,139,222,0,15,179,243,0,255,100,15,255,82,53,135,0,137,57,149,1,99,240,170,255,22,230,228,254,49,180,82,255,61,82,43,0,110,245,217,0,199,125,61,0,46,253,52,0,141,197,219,0,211,159,193,0,55,121,105,254,183,20,129,0,169,119,170,255,203,178,139,255,135,40,182,255,172,13,202,255,65,178,148,0,8,207,43,0,122,53,127,1,74,161,48,0,227,214,128,254,86,11,243,255,100,86,7,1,245,68,134,255,61,43,21,1,152,84,94,255,190,60,250,254,239,118,232,255,214,136,37,1,113,76,107,255,93,104,100,1,144,206,23,255,110,150,154,1,228,103,185,0,218,49,50,254,135,77,139,255,185,1,78,0,0,161,148,255,97,29,233,255,207,148,149,255,160,168,0,0,91,128,171,255,6,28,19,254,11,111,247,0,39,187,150,255,138,232,149,0,117,62,68,255,63,216,188,255,235,234,32,254,29,57,160,255,25,12,241,1,169,60,191,0,32,131,141,255,237,159,123,255,94,197,94,254,116,254,3,255,92,179,97,254,121,97,92,255,170,112,14,0,21,149,248,0,248,227,3,0,80,96,109,0,75,192,74,1,12,90,226,255,161,106,68,1,208,114,127,255,114,42,255,254,74,26,74,255,247,179,150,254,121,140,60,0,147,70,200,255,214,40,161,255,161,188,201,255,141,65,135,255,242,115,252,0,62,47,202,0,180,149,255,254,130,55,237,0,165,17,186,255,10,169,194,0,156,109,218,255,112,140,123,255,104,128,223,254,177,142,108,255,121,37,219,255,128,77,18,255,111,108,23,1,91,192,75,0,174,245,22,255,4,236,62,255,43,64,153,1,227,173,254,0,237,122,132,1,127,89,186,255,142,82,128,254,252,84,174,0,90,179,177,1,243,214,87,255,103,60,162,255,208,130,14,255,11,130,139,0,206,129,219,255,94,217,157,255,239,230,230,255,116,115,159,254,164,107,95,0,51,218,2,1,216,125,198,255,140,202,128,254,11,95,68,255,55,9,93,254,174,153,6,255,204,172,96,0,69,160,110,0,213,38,49,254,27,80,213,0,118,125,114,0,70,70,67,255,15,142,73,255,131,122,185,255,243,20,50,254,130,237,40,0,210,159,140,1,197,151,65,255,84,153,66,0,195,126,90,0,16,238,236,1,118,187,102,255,3,24,133,255,187,69,230,0,56,197,92,1,213,69,94,255,80,138,229,1,206,7,230,0,222,111,230,1,91,233,119,255,9,89,7,1,2,98,1,0,148,74,133,255,51,246,180,255,228,177,112,1,58,189,108,255,194,203,237,254,21,209,195,0,147,10,35,1,86,157,226,0,31,163,139,254,56,7,75,255,62,90,116,0,181,60,169,0,138,162,212,254,81,167,31,0,205,90,112,255,33,112,227,0,83,151,117,1,177,224,73,255,174,144,217,255,230,204,79,255,22,77,232,255,114,78,234,0,224,57,126,254,9,49,141,0,242,147,165,1,104,182,140,255,167,132,12,1,123,68,127,0,225,87,39,1,251,108,8,0,198,193,143,1,121,135,207,255,172,22,70,0,50,68,116,255,101,175,40,255,248,105,233,0,166,203,7,0,110,197,218,0,215,254,26,254,168,226,253,0,31,143,96,0,11,103,41,0,183,129,203,254,100,247,74,255,213,126,132,0,210,147,44,0,199,234,27,1,148,47,181,0,155,91,158,1,54,105,175,255,2,78,145,254,102,154,95,0,128,207,127,254,52,124,236,255,130,84,71,0,221,243,211,0,152,170,207,0,222,106,199,0,183,84,94,254,92,200,56,255,138,182,115,1,142,96,146,0,133,136,228,0,97,18,150,0,55,251,66,0,140,102,4,0,202,103,151,0,30,19,248,255,51,184,207,0,202,198,89,0,55,197,225,254,169,95,249,255,66,65,68,255,188,234,126,0,166,223,100,1,112,239,244,0,144,23,194,0,58,39,182,0,244,44,24,254,175,68,179,255,152,118,154,1,176,162,130,0,217,114,204,254,173,126,78,255,33,222,30,255,36,2,91,255,2,143,243,0,9,235,215,0,3,171,151,1,24,215,245,255,168,47,164,254,241,146,207,0,69,129,180,0,68,243,113,0,144,53,72,254,251,45,14,0,23,110,168,0,68,68,79,255,110,70,95,254,174,91,144,255,33,206,95,255,137,41,7,255,19,187,153,254,35,255,112,255,9,145,185,254,50,157,37,0,11,112,49,1,102,8,190,255,234,243,169,1,60,85,23,0,74,39,189,0,116,49,239,0,173,213,210,0,46,161,108,255,159,150,37,0,196,120,185,255,34,98,6,255,153,195,62,255,97,230,71,255,102,61,76,0,26,212,236,255,164,97,16,0,198,59,146,0,163,23,196,0,56,24,61,0,181,98,193,0,251,147,229,255,98,189,24,255,46,54,206,255,234,82,246,0,183,103,38,1,109,62,204,0,10,240,224,0,146,22,117,255,142,154,120,0,69,212,35,0,208,99,118,1,121,255,3,255,72,6,194,0,117,17,197,255,125,15,23,0,154,79,153,0,214,94,197,255,185,55,147,255,62,254,78,254,127,82,153,0,110,102,63,255,108,82,161,255,105,187,212,1,80,138,39,0,60,255,93,255,72,12,186,0,210,251,31,1,190,167,144,255,228,44,19,254,128,67,232,0,214,249,107,254,136,145,86,255,132,46,176,0,189,187,227,255,208,22,140,0,217,211,116,0,50,81,186,254,139,250,31,0,30,64,198,1,135,155,100,0,160,206,23,254,187,162,211,255,16,188,63,0,254,208,49,0,85,84,191,0,241,192,242,255,153,126,145,1,234,162,162,255,230,97,216,1,64,135,126,0,190,148,223,1,52,0,43,255,28,39,189,1,64,136,238,0,175,196,185,0,98,226,213,255,127,159,244,1,226,175,60,0,160,233,142,1,180,243,207,255,69,152,89,1,31,101,21,0,144,25,164,254,139,191,209,0,91,25,121,0,32,147,5,0,39,186,123,255,63,115,230,255,93,167,198,255,143,213,220,255,179,156,19,255,25,66,122,0,214,160,217,255,2,45,62,255,106,79,146,254,51,137,99,255,87,100,231,255,175,145,232,255,101,184,1,255,174,9,125,0,82,37,161,1,36,114,141,255,48,222,142,255,245,186,154,0,5,174,221,254,63,114,155,255,135,55,160,1,80,31,135,0,126,250,179,1,236,218,45,0,20,28,145,1,16,147,73,0,249,189,132,1,17,189,192,255,223,142,198,255,72,20,15,255,250,53,237,254,15,11,18,0,27,211,113,254,213,107,56,255,174,147,146,255,96,126,48,0,23,193,109,1,37,162,94,0,199,157,249,254,24,128,187,255,205,49,178,254,93,164,42,255,43,119,235,1,88,183,237,255,218,210,1,255,107,254,42,0,230,10,99,255,162,0,226,0,219,237,91,0,129,178,203,0,208,50,95,254,206,208,95,255,247,191,89,254,110,234,79,255,165,61,243,0,20,122,112,255,246,246,185,254,103,4,123,0,233,99,230,1,219,91,252,255,199,222,22,255,179,245,233,255,211,241,234,0,111,250,192,255,85,84,136,0,101,58,50,255,131,173,156,254,119,45,51,255,118,233,16,254,242,90,214,0,94,159,219,1,3,3,234,255,98,76,92,254,80,54,230,0,5,228,231,254,53,24,223,255,113,56,118,1,20,132,1,255,171,210,236,0,56,241,158,255,186,115,19,255,8,229,174,0,48,44,0,1,114,114,166,255,6,73,226,255,205,89,244,0,137,227,75,1,248,173,56,0,74,120,246,254,119,3,11,255,81,120,198,255,136,122,98,255,146,241,221,1,109,194,78,255,223,241,70,1,214,200,169,255,97,190,47,255,47,103,174,255,99,92,72,254,118,233,180,255,193,35,233,254,26,229,32,255,222,252,198,0,204,43,71,255,199,84,172,0,134,102,190,0,111,238,97,254,230,40,230,0,227,205,64,254,200,12,225,0,166,25,222,0,113,69,51,255,143,159,24,0,167,184,74,0,29,224,116,254,158,208,233,0,193,116,126,255,212,11,133,255,22,58,140,1,204,36,51,255,232,30,43,0,235,70,181,255,64,56,146,254,169,18,84,255,226,1,13,255,200,50,176,255,52,213,245,254,168,209,97,0,191,71,55,0,34,78,156,0,232,144,58,1,185,74,189,0,186,142,149,254,64,69,127,255,161,203,147,255,176,151,191,0,136,231,203,254,163,182,137,0,161,126,251,254,233,32,66,0,68,207,66,0,30,28,37,0,93,114,96,1,254,92,247,255,44,171,69,0,202,119,11,255,188,118,50,1,255,83,136,255,71,82,26,0,70,227,2,0,32,235,121,1,181,41,154,0,71,134,229,254,202,255,36,0,41,152,5,0,154,63,73,255,34,182,124,0,121,221,150,255,26,204,213,1,41,172,87,0,90,157,146,255,109,130,20,0,71,107,200,255,243,102,189,0,1,195,145,254,46,88,117,0,8,206,227,0,191,110,253,255,109,128,20,254,134,85,51,255,137,177,112,1,216,34,22,255,131,16,208,255,121,149,170,0,114,19,23,1,166,80,31,255,113,240,122,0,232,179,250,0,68,110,180,254,210,170,119,0,223,108,164,255,207,79,233,255,27,229,226,254,209,98,81,255,79,68,7,0,131,185,100,0,170,29,162,255,17,162,107,255,57,21,11,1,100,200,181,255,127,65,166,1,165,134,204,0,104,167,168,0,1,164,79,0,146,135,59,1,70,50,128,255,102,119,13,254,227,6,135,0,162,142,179,255,160,100,222,0,27,224,219,1,158,93,195,255,234,141,137,0,16,24,125,255,238,206,47,255,97,17,98,255,116,110,12,255,96,115,77,0,91,227,232,255,248,254,79,255,92,229,6,254,88,198,139,0,206,75,129,0,250,77,206,255,141,244,123,1,138,69,220,0,32,151,6,1,131,167,22,255,237,68,167,254,199,189,150,0,163,171,138,255,51,188,6,255,95,29,137,254,148,226,179,0,181,107,208,255,134,31,82,255,151,101,45,255,129,202,225,0,224,72,147,0,48,138,151,255,195,64,206,254,237,218,158,0,106,29,137,254,253,189,233,255,103,15,17,255,194,97,255,0,178,45,169,254,198,225,155,0,39,48,117,255,135,106,115,0,97,38,181,0,150,47,65,255,83,130,229,254,246,38,129,0,92,239,154,254,91,99,127,0,161,111,33,255,238,217,242,255,131,185,195,255,213,191,158,255,41,150,218,0,132,169,131,0,89,84,252,1,171,70,128,255,163,248,203,254,1,50,180,255,124,76,85,1,251,111,80,0,99,66,239,255,154,237,182,255,221,126,133,254,74,204,99,255,65,147,119,255,99,56,167,255,79,248,149,255,116,155,228,255,237,43,14,254,69,137,11,255,22,250,241,1,91,122,143,255,205,249,243,0,212,26,60,255,48,182,176,1,48,23,191,255,203,121,152,254,45,74,213,255,62,90,18,254,245,163,230,255,185,106,116,255,83,35,159,0,12,33,2,255,80,34,62,0,16,87,174,255,173,101,85,0,202,36,81,254,160,69,204,255,64,225,187,0,58,206,94,0,86,144,47,0,229,86,245,0,63,145,190,1,37,5,39,0,109,251,26,0,137,147,234,0,162,121,145,255,144,116,206,255,197,232,185,255,183,190,140,255,73,12,254,255,139,20,242,255,170,90,239,255,97,66,187,255,245,181,135,254,222,136,52,0,245,5,51,254,203,47,78,0,152,101,216,0,73,23,125,0,254,96,33,1,235,210,73,255,43,209,88,1,7,129,109,0,122,104,228,254,170,242,203,0,242,204,135,255,202,28,233,255,65,6,127,0,159,144,71,0,100,140,95,0,78,150,13,0,251,107,118,1,182,58,125,255,1,38,108,255,141,189,209,255,8,155,125,1,113,163,91,255,121,79,190,255,134,239,108,255,76,47,248,0,163,228,239,0,17,111,10,0,88,149,75,255,215,235,239,0,167,159,24,255,47,151,108,255,107,209,188,0,233,231,99,254,28,202,148,255,174,35,138,255,110,24,68,255,2,69,181,0,107,102,82,0,102,237,7,0,92,36,237,255,221,162,83,1,55,202,6,255,135,234,135,255,24,250,222,0,65,94,168,254,245,248,210,255,167,108,201,254,255,161,111,0,205,8,254,0,136,13,116,0,100,176,132,255,43,215,126,255,177,133,130,255,158,79,148,0,67,224,37,1,12,206,21,255,62,34,110,1,237,104,175,255,80,132,111,255,142,174,72,0,84,229,180,254,105,179,140,0,64,248,15,255,233,138,16,0,245,67,123,254,218,121,212,255,63,95,218,1,213,133,137,255,143,182,82,255,48,28,11,0,244,114,141,1,209,175,76,255,157,181,150,255,186,229,3,255,164,157,111,1,231,189,139,0,119,202,190,255,218,106,64,255,68,235,63,254,96,26,172,255,187,47,11,1,215,18,251,255,81,84,89,0,68,58,128,0,94,113,5,1,92,129,208,255,97,15,83,254,9,28,188,0,239,9,164,0,60,205,152,0,192,163,98,255,184,18,60,0,217,182,139,0,109,59,120,255,4,192,251,0,169,210,240,255,37,172,92,254,148,211,245,255,179,65,52,0,253,13,115,0,185,174,206,1,114,188,149,255,237,90,173,0,43,199,192,255,88,108,113,0,52,35,76,0,66,25,148,255,221,4,7,255,151,241,114,255,190,209,232,0,98,50,199,0,151,150,213,255,18,74,36,1,53,40,7,0,19,135,65,255,26,172,69,0,174,237,85,0,99,95,41,0,3,56,16,0,39,160,177,255,200,106,218,254,185,68,84,255,91,186,61,254,67,143,141,255,13,244,166,255,99,114,198,0,199,110,163,255,193,18,186,0,124,239,246,1,110,68,22,0,2,235,46,1,212,60,107,0,105,42,105,1,14,230,152,0,7,5,131,0,141,104,154,255,213,3,6,0,131,228,162,255,179,100,28,1,231,123,85,255,206,14,223,1,253,96,230,0,38,152,149,1,98,137,122,0,214,205,3,255,226,152,179,255,6,133,137,0,158,69,140,255,113,162,154,255,180,243,172,255,27,189,115,255,143,46,220,255,213,134,225,255,126,29,69,0,188,43,137,1,242,70,9,0,90,204,255,255,231,170,147,0,23,56,19,254,56,125,157,255,48,179,218,255,79,182,253,255,38,212,191,1,41,235,124,0,96,151,28,0,135,148,190,0,205,249,39,254,52,96,136,255,212,44,136,255,67,209,131,255,252,130,23,255,219,128,20,255,198,129,118,0,108,101,11,0,178,5,146,1,62,7,100,255,181,236,94,254,28,26,164,0,76,22,112,255,120,102,79,0,202,192,229,1,200,176,215,0,41,64,244,255,206,184,78,0,167,45,63,1,160,35,0,255,59,12,142,255,204,9,144,255,219,94,229,1,122,27,112,0,189,105,109,255,64,208,74,255,251,127,55,1,2,226,198,0,44,76,209,0,151,152,77,255,210,23,46,1,201,171,69,255,44,211,231,0,190,37,224,255,245,196,62,255,169,181,222,255,34,211,17,0,119,241,197,255,229,35,152,1,21,69,40,255,178,226,161,0,148,179,193,0,219,194,254,1,40,206,51,255,231,92,250,1,67,153,170,0,21,148,241,0,170,69,82,255,121,18,231,255,92,114,3,0,184,62,230,0,225,201,87,255,146,96,162,255,181,242,220,0,173,187,221,1,226,62,170,255,56,126,217,1,117,13,227,255,179,44,239,0,157,141,155,255,144,221,83,0,235,209,208,0,42,17,165,1,251,81,133,0,124,245,201,254,97,211,24,255,83,214,166,0,154,36,9,255,248,47,127,0,90,219,140,255,161,217,38,254,212,147,63,255,66,84,148,1,207,3,1,0,230,134,89,1,127,78,122,255,224,155,1,255,82,136,74,0,178,156,208,255,186,25,49,255,222,3,210,1,229,150,190,255,85,162,52,255,41,84,141,255,73,123,84,254,93,17,150,0,119,19,28,1,32,22,215,255,28,23,204,255,142,241,52,255,228,52,125,0,29,76,207,0,215,167,250,254,175,164,230,0,55,207,105,1,109,187,245,255,161,44,220,1,41,101,128,255,167,16,94,0,93,214,107,255,118,72,0,254,80,61,234,255,121,175,125,0,139,169,251,0,97,39,147,254,250,196,49,255,165,179,110,254,223,70,187,255,22,142,125,1,154,179,138,255,118,176,42,1,10,174,153,0,156,92,102,0,168,13,161,255,143,16,32,0,250,197,180,255,203,163,44,1,87,32,36,0,161,153,20,255,123,252,15,0,25,227,80,0,60,88,142,0,17,22,201,1,154,205,77,255,39,63,47,0,8,122,141,0,128,23,182,254,204,39,19,255,4,112,29,255,23,36,140,255,210,234,116,254,53,50,63,255,121,171,104,255,160,219,94,0,87,82,14,254,231,42,5,0,165,139,127,254,86,78,38,0,130,60,66,254,203,30,45,255,46,196,122,1,249,53,162,255,136,143,103,254,215,210,114,0,231,7,160,254,169,152,42,255,111,45,246,0,142,131,135,255,131,71,204,255,36,226,11,0,0,28,242,255,225,138,213,255,247,46,216,254,245,3,183,0,108,252,74,1,206,26,48,255,205,54,246,255,211,198,36,255,121,35,50,0,52,216,202,255,38,139,129,254,242,73,148,0,67,231,141,255,42,47,204,0,78,116,25,1,4,225,191,255,6,147,228,0,58,88,177,0,122,165,229,255,252,83,201,255,224,167,96,1,177,184,158,255,242,105,179,1,248,198,240,0,133,66,203,1,254,36,47,0,45,24,115,255,119,62,254,0,196,225,186,254,123,141,172,0,26,85,41,255,226,111,183,0,213,231,151,0,4,59,7,255,238,138,148,0,66,147,33,255,31,246,141,255,209,141,116,255,104,112,31,0,88,161,172,0,83,215,230,254,47,111,151,0,45,38,52,1,132,45,204,0,138,128,109,254,233,117,134,255,243,190,173,254,241,236,240,0,82,127,236,254,40,223,161,255,110,182,225,255,123,174,239,0,135,242,145,1,51,209,154,0,150,3,115,254,217,164,252,255,55,156,69,1,84,94,255,255,232,73,45,1,20,19,212,255,96,197,59,254,96,251,33,0,38,199,73,1,64,172,247,255,117,116,56,255,228,17,18,0,62,138,103,1,246,229,164,255,244,118,201,254,86,32,159,255,109,34,137,1,85,211,186,0,10,193,193,254,122,194,177,0,122,238,102,255,162,218,171,0,108,217,161,1,158,170,34,0,176,47,155,1,181,228,11,255,8,156,0,0,16,75,93,0,206,98,255,1,58,154,35,0,12,243,184,254,67,117,66,255,230,229,123,0,201,42,110,0,134,228,178,254,186,108,118,255,58,19,154,255,82,169,62,255,114,143,115,1,239,196,50,255,173,48,193,255,147,2,84,255,150,134,147,254,95,232,73,0,109,227,52,254,191,137,10,0,40,204,30,254,76,52,97,255,164,235,126,0,254,124,188,0,74,182,21,1,121,29,35,255,241,30,7,254,85,218,214,255,7,84,150,254,81,27,117,255,160,159,152,254,66,24,221,255,227,10,60,1,141,135,102,0,208,189,150,1,117,179,92,0,132,22,136,255,120,199,28,0,21,129,79,254,182,9,65,0,218,163,169,0,246,147,198,255,107,38,144,1,78,175,205,255,214,5,250,254,47,88,29,255,164,47,204,255,43,55,6,255,131,134,207,254,116,100,214,0,96,140,75,1,106,220,144,0,195,32,28,1,172,81,5,255,199,179,52,255,37,84,203,0,170,112,174,0,11,4,91,0,69,244,27,1,117,131,92,0,33,152,175,255,140,153,107,255,251,135,43,254,87,138,4,255,198,234,147,254,121,152,84,255,205,101,155,1,157,9,25,0,72,106,17,254,108,153,0,255,189,229,186,0,193,8,176,255,174,149,209,0,238,130,29,0,233,214,126,1,61,226,102,0,57,163,4,1,198,111,51,255,45,79,78,1,115,210,10,255,218,9,25,255,158,139,198,255,211,82,187,254,80,133,83,0,157,129,230,1,243,133,134,255,40,136,16,0,77,107,79,255,183,85,92,1,177,204,202,0,163,71,147,255,152,69,190,0,172,51,188,1,250,210,172,255,211,242,113,1,89,89,26,255,64,66,111,254,116,152,42,0,161,39,27,255,54,80,254,0,106,209,115,1,103,124,97,0,221,230,98,255,31,231,6,0,178,192,120,254,15,217,203,255,124,158,79,0,112,145,247,0,92,250,48,1,163,181,193,255,37,47,142,254,144,189,165,255,46,146,240,0,6,75,128,0,41,157,200,254,87,121,213,0,1,113,236,0,5,45,250,0,144,12,82,0,31,108,231,0,225,239,119,255,167,7,189,255,187,228,132,255,110,189,34,0,94,44,204,1,162,52,197,0,78,188,241,254,57,20,141,0,244,146,47,1,206,100,51,0,125,107,148,254,27,195,77,0,152,253,90,1,7,143,144,255,51,37,31,0,34,119,38,255,7,197,118,0,153,188,211,0,151,20,116,254,245,65,52,255,180,253,110,1,47,177,209,0,161,99,17,255,118,222,202,0,125,179,252,1,123,54,126,255,145,57,191,0,55,186,121,0,10,243,138,0,205,211,229,255,125,156,241,254,148,156,185,255,227,19,188,255,124,41,32,255,31,34,206,254,17,57,83,0,204,22,37,255,42,96,98,0,119,102,184,1,3,190,28],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE+20480);allocate([110,82,218,255,200,204,192,255,201,145,118,0,117,204,146,0,132,32,98,1,192,194,121,0,106,161,248,1,237,88,124,0,23,212,26,0,205,171,90,255,248,48,216,1,141,37,230,255,124,203,0,254,158,168,30,255,214,248,21,0,112,187,7,255,75,133,239,255,74,227,243,255,250,147,70,0,214,120,162,0,167,9,179,255,22,158,18,0,218,77,209,1,97,109,81,255,244,33,179,255,57,52,57,255,65,172,210,255,249,71,209,255,142,169,238,0,158,189,153,255,174,254,103,254,98,33,14,0,141,76,230,255,113,139,52,255,15,58,212,0,168,215,201,255,248,204,215,1,223,68,160,255,57,154,183,254,47,231,121,0,106,166,137,0,81,136,138,0,165,43,51,0,231,139,61,0,57,95,59,254,118,98,25,255,151,63,236,1,94,190,250,255,169,185,114,1,5,250,58,255,75,105,97,1,215,223,134,0,113,99,163,1,128,62,112,0,99,106,147,0,163,195,10,0,33,205,182,0,214,14,174,255,129,38,231,255,53,182,223,0,98,42,159,255,247,13,40,0,188,210,177,1,6,21,0,255,255,61,148,254,137,45,129,255,89,26,116,254,126,38,114,0,251,50,242,254,121,134,128,255,204,249,167,254,165,235,215,0,202,177,243,0,133,141,62,0,240,130,190,1,110,175,255,0,0,20,146,1,37,210,121,255,7,39,130,0,142,250,84,255,141,200,207,0,9,95,104,255,11,244,174,0,134,232,126,0,167,1,123,254,16,193,149,255,232,233,239,1,213,70,112,255,252,116,160,254,242,222,220,255,205,85,227,0,7,185,58,0,118,247,63,1,116,77,177,255,62,245,200,254,63,18,37,255,107,53,232,254,50,221,211,0,162,219,7,254,2,94,43,0,182,62,182,254,160,78,200,255,135,140,170,0,235,184,228,0,175,53,138,254,80,58,77,255,152,201,2,1,63,196,34,0,5,30,184,0,171,176,154,0,121,59,206,0,38,99,39,0,172,80,77,254,0,134,151,0,186,33,241,254,94,253,223,255,44,114,252,0,108,126,57,255,201,40,13,255,39,229,27,255,39,239,23,1,151,121,51,255,153,150,248,0,10,234,174,255,118,246,4,254,200,245,38,0,69,161,242,1,16,178,150,0,113,56,130,0,171,31,105,0,26,88,108,255,49,42,106,0,251,169,66,0,69,93,149,0,20,57,254,0,164,25,111,0,90,188,90,255,204,4,197,0,40,213,50,1,212,96,132,255,88,138,180,254,228,146,124,255,184,246,247,0,65,117,86,255,253,102,210,254,254,121,36,0,137,115,3,255,60,24,216,0,134,18,29,0,59,226,97,0,176,142,71,0,7,209,161,0,189,84,51,254,155,250,72,0,213,84,235,255,45,222,224,0,238,148,143,255,170,42,53,255,78,167,117,0,186,0,40,255,125,177,103,255,69,225,66,0,227,7,88,1,75,172,6,0,169,45,227,1,16,36,70,255,50,2,9,255,139,193,22,0,143,183,231,254,218,69,50,0,236,56,161,1,213,131,42,0,138,145,44,254,136,229,40,255,49,63,35,255,61,145,245,255,101,192,2,254,232,167,113,0,152,104,38,1,121,185,218,0,121,139,211,254,119,240,35,0,65,189,217,254,187,179,162,255,160,187,230,0,62,248,14,255,60,78,97,0,255,247,163,255,225,59,91,255,107,71,58,255,241,47,33,1,50,117,236,0,219,177,63,254,244,90,179,0,35,194,215,255,189,67,50,255,23,135,129,0,104,189,37,255,185,57,194,0,35,62,231,255,220,248,108,0,12,231,178,0,143,80,91,1,131,93,101,255,144,39,2,1,255,250,178,0,5,17,236,254,139,32,46,0,204,188,38,254,245,115,52,255,191,113,73,254,191,108,69,255,22,69,245,1,23,203,178,0,170,99,170,0,65,248,111,0,37,108,153,255,64,37,69,0,0,88,62,254,89,148,144,255,191,68,224,1,241,39,53,0,41,203,237,255,145,126,194,255,221,42,253,255,25,99,151,0,97,253,223,1,74,115,49,255,6,175,72,255,59,176,203,0,124,183,249,1,228,228,99,0,129,12,207,254,168,192,195,255,204,176,16,254,152,234,171,0,77,37,85,255,33,120,135,255,142,194,227,1,31,214,58,0,213,187,125,255,232,46,60,255,190,116,42,254,151,178,19,255,51,62,237,254,204,236,193,0,194,232,60,0,172,34,157,255,189,16,184,254,103,3,95,255,141,233,36,254,41,25,11,255,21,195,166,0,118,245,45,0,67,213,149,255,159,12,18,255,187,164,227,1,160,25,5,0,12,78,195,1,43,197,225,0,48,142,41,254,196,155,60,255,223,199,18,1,145,136,156,0,252,117,169,254,145,226,238,0,239,23,107,0,109,181,188,255,230,112,49,254,73,170,237,255,231,183,227,255,80,220,20,0,194,107,127,1,127,205,101,0,46,52,197,1,210,171,36,255,88,3,90,255,56,151,141,0,96,187,255,255,42,78,200,0,254,70,70,1,244,125,168,0,204,68,138,1,124,215,70,0,102,66,200,254,17,52,228,0,117,220,143,254,203,248,123,0,56,18,174,255,186,151,164,255,51,232,208,1,160,228,43,255,249,29,25,1,68,190,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,224,124,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,19,0,0,0,65,132,0,0,0,4,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107,111,117,116,108,101,110,32,60,61,32,85,73,78,84,56,95,77,65,88,0,99,114,121,112,116,111,95,103,101,110,101,114,105,99,104,97,115,104,47,98,108,97,107,101,50,47,114,101,102,47,103,101,110,101,114,105,99,104,97,115,104,95,98,108,97,107,101,50,98,46,99,0,99,114,121,112,116,111,95,103,101,110,101,114,105,99,104,97,115,104,95,98,108,97,107,101,50,98,0,107,101,121,108,101,110,32,60,61,32,85,73,78,84,56,95,77,65,88,0,99,114,121,112,116,111,95,103,101,110,101,114,105,99,104,97,115,104,95,98,108,97,107,101,50,98,95,105,110,105,116,0,99,114,121,112,116,111,95,103,101,110,101,114,105,99,104,97,115,104,95,98,108,97,107,101,50,98,95,102,105,110,97,108,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,55,36,0,101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,32,114,101,116,117,114,110,32,77,111,100,117,108,101,46,103,101,116,82,97,110,100,111,109,86,97,108,117,101,40,41,59,32,125,0,123,32,105,102,32,40,77,111,100,117,108,101,46,103,101,116,82,97,110,100,111,109,86,97,108,117,101,32,61,61,61,32,117,110,100,101,102,105,110,101,100,41,32,123,32,116,114,121,32,123,32,118,97,114,32,119,105,110,100,111,119,95,32,61,32,34,111,98,106,101,99,116,34,32,61,61,61,32,116,121,112,101,111,102,32,119,105,110,100,111,119,32,63,32,119,105,110,100,111,119,32,58,32,115,101,108,102,44,32,99,114,121,112,116,111,95,32,61,32,116,121,112,101,111,102,32,119,105,110,100,111,119,95,46,99,114,121,112,116,111,32,33,61,61,32,34,117,110,100,101,102,105,110,101,100,34,32,63,32,119,105,110,100,111,119,95,46,99,114,121,112,116,111,32,58,32,119,105,110,100,111,119,95,46,109,115,67,114,121,112,116,111,44,32,114,97,110,100,111,109,86,97,108,117,101,115,83,116,97,110,100,97,114,100,32,61,32,102,117,110,99,116,105,111,110,40,41,32,123,32,118,97,114,32,98,117,102,32,61,32,110,101,119,32,85,105,110,116,51,50,65,114,114,97,121,40,49,41,59,32,99,114,121,112,116,111,95,46,103,101,116,82,97,110,100,111,109,86,97,108,117,101,115,40,98,117,102,41,59,32,114,101,116,117,114,110,32,98,117,102,91,48,93,32,62,62,62,32,48,59,32,125,59,32,114,97,110,100,111,109,86,97,108,117,101,115,83,116,97,110,100,97,114,100,40,41,59,32,77,111,100,117,108,101,46,103,101,116,82,97,110,100,111,109,86,97,108,117,101,32,61,32,114,97,110,100,111,109,86,97,108,117,101,115,83,116,97,110,100,97,114,100,59,32,125,32,99,97,116,99,104,32,40,101,41,32,123,32,116,114,121,32,123,32,118,97,114,32,99,114,121,112,116,111,32,61,32,114,101,113,117,105,114,101,40,39,99,114,121,112,116,111,39,41,44,32,114,97,110,100,111,109,86,97,108,117,101,78,111,100,101,74,83,32,61,32,102,117,110,99,116,105,111,110,40,41,32,123,32,118,97,114,32,98,117,102,32,61,32,99,114,121,112,116,111,46,114,97,110,100,111,109,66,121,116,101,115,40,52,41,59,32,114,101,116,117,114,110,32,40,98,117,102,91,48,93,32,60,60,32,50,52,32,124,32,98,117,102,91,49,93,32,60,60,32,49,54,32,124,32,98,117,102,91,50,93,32,60,60,32,56,32,124,32,98,117,102,91,51,93,41,32,62,62,62,32,48,59,32,125,59,32,114,97,110,100,111,109,86,97,108,117,101,78,111,100,101,74,83,40,41,59,32,77,111,100,117,108,101,46,103,101,116,82,97,110,100,111,109,86,97,108,117,101,32,61,32,114,97,110,100,111,109,86,97,108,117,101,78,111,100,101,74,83,59,32,125,32,99,97,116,99,104,32,40,101,41,32,123,32,116,104,114,111,119,32,39,78,111,32,115,101,99,117,114,101,32,114,97,110,100,111,109,32,110,117,109,98,101,114,32,103,101,110,101,114,97,116,111,114,32,102,111,117,110,100,39,59,32,125,32,125,32,125,32,125,0,49,46,48,46,54,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107,101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE+30720);allocate([46,47,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,0],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE+34873);var tempDoublePtr=Runtime.alignMemory(allocate(12,"i8",ALLOC_STATIC),8);assert(tempDoublePtr%8==0);function copyTempFloat(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3]}function copyTempDouble(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3];HEAP8[tempDoublePtr+4]=HEAP8[ptr+4];HEAP8[tempDoublePtr+5]=HEAP8[ptr+5];HEAP8[tempDoublePtr+6]=HEAP8[ptr+6];HEAP8[tempDoublePtr+7]=HEAP8[ptr+7]}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _sysconf(name){switch(name){case 30:return PAGE_SIZE;case 85:return totalMemory/PAGE_SIZE;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 79:return 0;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:{if(typeof navigator==="object")return navigator["hardwareConcurrency"]||1;return 1}}___setErrNo(ERRNO_CODES.EINVAL);return-1}Module["_i64Subtract"]=_i64Subtract;Module["_i64Add"]=_i64Add;Module["_bitshift64Ashr"]=_bitshift64Ashr;Module["_memset"]=_memset;function _pthread_cleanup_push(routine,arg){__ATEXIT__.push((function(){Runtime.dynCall("vi",routine,[arg])}));_pthread_cleanup_push.level=__ATEXIT__.length}Module["_bitshift64Lshr"]=_bitshift64Lshr;Module["_bitshift64Shl"]=_bitshift64Shl;function _pthread_cleanup_pop(){assert(_pthread_cleanup_push.level==__ATEXIT__.length,"cannot pop if something else added meanwhile!");__ATEXIT__.pop();_pthread_cleanup_push.level=__ATEXIT__.length}function _abort(){Module["abort"]()}function ___lock(){}function ___unlock(){}var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};var PATH={splitPath:(function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)}),normalizeArray:(function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1)}else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up--;up){parts.unshift("..")}}return parts}),normalize:(function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter((function(p){return!!p})),!isAbsolute).join("/");if(!path&&!isAbsolute){path="."}if(path&&trailingSlash){path+="/"}return(isAbsolute?"/":"")+path}),dirname:(function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return"."}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir}),basename:(function(path){if(path==="/")return"/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)}),extname:(function(path){return PATH.splitPath(path)[3]}),join:(function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))}),join2:(function(l,r){return PATH.normalize(l+"/"+r)}),resolve:(function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter((function(p){return!!p})),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."}),relative:(function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")})};var TTY={ttys:[],init:(function(){}),shutdown:(function(){}),register:(function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)}),stream_ops:{open:(function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}stream.tty=tty;stream.seekable=false}),close:(function(stream){stream.tty.ops.flush(stream.tty)}),flush:(function(stream){stream.tty.ops.flush(stream.tty)}),read:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead}),write:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}for(var i=0;i<length;i++){try{stream.tty.ops.put_char(stream.tty,buffer[offset+i])}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}}if(length){stream.node.timestamp=Date.now()}return i})},default_tty_ops:{get_char:(function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=new Buffer(BUFSIZE);var bytesRead=0;var fd=process.stdin.fd;var usingDevice=false;try{fd=fs.openSync("/dev/stdin","r");usingDevice=true}catch(e){}bytesRead=fs.readSync(fd,buf,0,BUFSIZE,null);if(usingDevice){fs.closeSync(fd)}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8")}else{result=null}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n"}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()}),put_char:(function(tty,val){if(val===null||val===10){Module["print"](UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}}),flush:(function(tty){if(tty.output&&tty.output.length>0){Module["print"](UTF8ArrayToString(tty.output,0));tty.output=[]}})},default_tty1_ops:{put_char:(function(tty,val){if(val===null||val===10){Module["printErr"](UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}}),flush:(function(tty){if(tty.output&&tty.output.length>0){Module["printErr"](UTF8ArrayToString(tty.output,0));tty.output=[]}})}};var MEMFS={ops_table:null,mount:(function(mount){return MEMFS.createNode(null,"/",16384|511,0)}),createNode:(function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node}return node}),getFileDataAsRegularArray:(function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents}),getFileDataAsTypedArray:(function(node){if(!node.contents)return new Uint8Array;if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)}),expandFileStorage:(function(node,newCapacity){if(node.contents&&node.contents.subarray&&newCapacity>node.contents.length){node.contents=MEMFS.getFileDataAsRegularArray(node);node.usedBytes=node.contents.length}if(!node.contents||node.contents.subarray){var prevCapacity=node.contents?node.contents.buffer.byteLength:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return}if(!node.contents&&newCapacity>0)node.contents=[];while(node.contents.length<newCapacity)node.contents.push(0)}),resizeFileStorage:(function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize}),node_ops:{getattr:(function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}}),lookup:(function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT]}),mknod:(function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)}),rename:(function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir}),unlink:(function(parent,name){delete parent.contents[name]}),rmdir:(function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}delete parent.contents[name]}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries}),symlink:(function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node}),readlink:(function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return node.link})},stream_ops:{read:(function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size}),write:(function(stream,buffer,offset,length,position,canOwn){if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position}),allocate:(function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<stream.node.usedBytes){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=_malloc(length);if(!ptr){throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)}buffer.set(contents,ptr)}return{ptr:ptr,allocated:allocated}}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0})}};var IDBFS={dbs:{},indexedDB:(function(){if(typeof indexedDB!=="undefined")return indexedDB;var ret=null;if(typeof window==="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;assert(ret,"IDBFS used, but indexedDB not supported");return ret}),DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:(function(mount){return MEMFS.mount.apply(null,arguments)}),syncfs:(function(mount,populate,callback){IDBFS.getLocalSet(mount,(function(err,local){if(err)return callback(err);IDBFS.getRemoteSet(mount,(function(err,remote){if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,callback)}))}))}),getDB:(function(name,callback){var db=IDBFS.dbs[name];if(db){return callback(null,db)}var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION)}catch(e){return callback(e)}req.onupgradeneeded=(function(e){var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME)}else{fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME)}if(!fileStore.indexNames.contains("timestamp")){fileStore.createIndex("timestamp","timestamp",{unique:false})}});req.onsuccess=(function(){db=req.result;IDBFS.dbs[name]=db;callback(null,db)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),getLocalSet:(function(mount,callback){var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return(function(p){return PATH.join2(root,p)})}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode)){check.push.apply(check,FS.readdir(path).filter(isRealDir).map(toAbsolute(path)))}entries[path]={timestamp:stat.mtime}}return callback(null,{type:"local",entries:entries})}),getRemoteSet:(function(mount,callback){var entries={};IDBFS.getDB(mount.mountpoint,(function(err,db){if(err)return callback(err);var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=(function(e){callback(this.error);e.preventDefault()});var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=(function(event){var cursor=event.target.result;if(!cursor){return callback(null,{type:"remote",db:db,entries:entries})}entries[cursor.primaryKey]={timestamp:cursor.key};cursor.continue()})}))}),loadLocalEntry:(function(path,callback){var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode)){return callback(null,{timestamp:stat.mtime,mode:stat.mode})}else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);return callback(null,{timestamp:stat.mtime,mode:stat.mode,contents:node.contents})}else{return callback(new Error("node type not supported"))}}),storeLocalEntry:(function(path,entry,callback){try{if(FS.isDir(entry.mode)){FS.mkdir(path,entry.mode)}else if(FS.isFile(entry.mode)){FS.writeFile(path,entry.contents,{encoding:"binary",canOwn:true})}else{return callback(new Error("node type not supported"))}FS.chmod(path,entry.mode);FS.utime(path,entry.timestamp,entry.timestamp)}catch(e){return callback(e)}callback(null)}),removeLocalEntry:(function(path,callback){try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode)){FS.rmdir(path)}else if(FS.isFile(stat.mode)){FS.unlink(path)}}catch(e){return callback(e)}callback(null)}),loadRemoteEntry:(function(store,path,callback){var req=store.get(path);req.onsuccess=(function(event){callback(null,event.target.result)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),storeRemoteEntry:(function(store,path,entry,callback){var req=store.put(entry,path);req.onsuccess=(function(){callback(null)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),removeRemoteEntry:(function(store,path,callback){var req=store.delete(path);req.onsuccess=(function(){callback(null)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),reconcile:(function(src,dst,callback){var total=0;var create=[];Object.keys(src.entries).forEach((function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e.timestamp>e2.timestamp){create.push(key);total++}}));var remove=[];Object.keys(dst.entries).forEach((function(key){var e=dst.entries[key];var e2=src.entries[key];if(!e2){remove.push(key);total++}}));if(!total){return callback(null)}var errored=false;var completed=0;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=total){return callback(null)}}transaction.onerror=(function(e){done(this.error);e.preventDefault()});create.sort().forEach((function(path){if(dst.type==="local"){IDBFS.loadRemoteEntry(store,path,(function(err,entry){if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done)}))}else{IDBFS.loadLocalEntry(path,(function(err,entry){if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done)}))}}));remove.sort().reverse().forEach((function(path){if(dst.type==="local"){IDBFS.removeLocalEntry(path,done)}else{IDBFS.removeRemoteEntry(store,path,done)}}))})};var NODEFS={isWindows:false,staticInit:(function(){NODEFS.isWindows=!!process.platform.match(/^win/)}),mount:(function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)}),createNode:(function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node}),getMode:(function(path){var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&146)>>1}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return stat.mode}),realPath:(function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)}),flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:(function(flags){flags&=~32768;if(flags in NODEFS.flagsToPermissionStringMap){return NODEFS.flagsToPermissionStringMap[flags]}else{throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}}),node_ops:{getattr:(function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0}return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}}),setattr:(function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date)}if(attr.size!==undefined){fs.truncateSync(path,attr.size)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),lookup:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)}),mknod:(function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode)}else{fs.writeFileSync(path,"",{mode:node.mode})}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return node}),rename:(function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),unlink:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),rmdir:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readdir:(function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),symlink:(function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readlink:(function(node){var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}})},stream_ops:{open:(function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsToPermissionString(stream.flags))}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),close:(function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),read:(function(stream,buffer,offset,length,position){if(length===0)return 0;var nbuffer=new Buffer(length);var res;try{res=fs.readSync(stream.nfd,nbuffer,0,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(res>0){for(var i=0;i<res;i++){buffer[offset+i]=nbuffer[i]}}return res}),write:(function(stream,buffer,offset,length,position){var nbuffer=new Buffer(buffer.subarray(offset,offset+length));var res;try{res=fs.writeSync(stream.nfd,nbuffer,0,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}return res}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:(function(mount){assert(ENVIRONMENT_IS_WORKER);if(!WORKERFS.reader)WORKERFS.reader=new FileReaderSync;var root=WORKERFS.createNode(null,"/",WORKERFS.DIR_MODE,0);var createdParents={};function ensureParent(path){var parts=path.split("/");var parent=root;for(var i=0;i<parts.length-1;i++){var curr=parts.slice(0,i+1).join("/");if(!createdParents[curr]){createdParents[curr]=WORKERFS.createNode(parent,curr,WORKERFS.DIR_MODE,0)}parent=createdParents[curr]}return parent}function base(path){var parts=path.split("/");return parts[parts.length-1]}Array.prototype.forEach.call(mount.opts["files"]||[],(function(file){WORKERFS.createNode(ensureParent(file.name),base(file.name),WORKERFS.FILE_MODE,0,file,file.lastModifiedDate)}));(mount.opts["blobs"]||[]).forEach((function(obj){WORKERFS.createNode(ensureParent(obj["name"]),base(obj["name"]),WORKERFS.FILE_MODE,0,obj["data"])}));(mount.opts["packages"]||[]).forEach((function(pack){pack["metadata"].files.forEach((function(file){var name=file.filename.substr(1);WORKERFS.createNode(ensureParent(name),base(name),WORKERFS.FILE_MODE,0,pack["blob"].slice(file.start,file.end))}))}));return root}),createNode:(function(parent,name,mode,dev,contents,mtime){var node=FS.createNode(parent,name,mode);node.mode=mode;node.node_ops=WORKERFS.node_ops;node.stream_ops=WORKERFS.stream_ops;node.timestamp=(mtime||new Date).getTime();assert(WORKERFS.FILE_MODE!==WORKERFS.DIR_MODE);if(mode===WORKERFS.FILE_MODE){node.size=contents.size;node.contents=contents}else{node.size=4096;node.contents={}}if(parent){parent.contents[name]=node}return node}),node_ops:{getattr:(function(node){return{dev:1,ino:undefined,mode:node.mode,nlink:1,uid:0,gid:0,rdev:undefined,size:node.size,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:Math.ceil(node.size/4096)}}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}}),lookup:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}),mknod:(function(parent,name,mode,dev){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rename:(function(oldNode,newDir,newName){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),unlink:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rmdir:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readdir:(function(node){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),symlink:(function(parent,newName,oldPath){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readlink:(function(node){throw new FS.ErrnoError(ERRNO_CODES.EPERM)})},stream_ops:{read:(function(stream,buffer,offset,length,position){if(position>=stream.node.size)return 0;var chunk=stream.node.contents.slice(position,position+length);var ab=WORKERFS.reader.readAsArrayBuffer(chunk);buffer.set(new Uint8Array(ab),offset);return chunk.size}),write:(function(stream,buffer,offset,length,position){throw new FS.ErrnoError(ERRNO_CODES.EIO)}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.size}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};var _stdin=allocate(1,"i32*",ALLOC_STATIC);var _stdout=allocate(1,"i32*",ALLOC_STATIC);var _stderr=allocate(1,"i32*",ALLOC_STATIC);var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,handleFSError:(function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)}),lookupPath:(function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key]}}if(opts.recurse_count>8){throw new FS.ErrnoError(ERRNO_CODES.ELOOP)}var parts=PATH.normalizeArray(path.split("/").filter((function(p){return!!p})),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(ERRNO_CODES.ELOOP)}}}}return{path:current_path,node:current}}),getPath:(function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent}}),hashName:(function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length}),hashAddNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node}),hashRemoveNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}}),lookupNode:(function(parent,name){var err=FS.mayLookup(parent);if(err){throw new FS.ErrnoError(err,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)}),createNode:(function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=(function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev});FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:(function(){return(this.mode&readMode)===readMode}),set:(function(val){val?this.mode|=readMode:this.mode&=~readMode})},write:{get:(function(){return(this.mode&writeMode)===writeMode}),set:(function(val){val?this.mode|=writeMode:this.mode&=~writeMode})},isFolder:{get:(function(){return FS.isDir(this.mode)})},isDevice:{get:(function(){return FS.isChrdev(this.mode)})}})}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node}),destroyNode:(function(node){FS.hashRemoveNode(node)}),isRoot:(function(node){return node===node.parent}),isMountpoint:(function(node){return!!node.mounted}),isFile:(function(mode){return(mode&61440)===32768}),isDir:(function(mode){return(mode&61440)===16384}),isLink:(function(mode){return(mode&61440)===40960}),isChrdev:(function(mode){return(mode&61440)===8192}),isBlkdev:(function(mode){return(mode&61440)===24576}),isFIFO:(function(mode){return(mode&61440)===4096}),isSocket:(function(mode){return(mode&49152)===49152}),flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:(function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags}),flagsToPermissionString:(function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w"}return perms}),nodePermissions:(function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return ERRNO_CODES.EACCES}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return ERRNO_CODES.EACCES}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return ERRNO_CODES.EACCES}return 0}),mayLookup:(function(dir){var err=FS.nodePermissions(dir,"x");if(err)return err;if(!dir.node_ops.lookup)return ERRNO_CODES.EACCES;return 0}),mayCreate:(function(dir,name){try{var node=FS.lookupNode(dir,name);return ERRNO_CODES.EEXIST}catch(e){}return FS.nodePermissions(dir,"wx")}),mayDelete:(function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err){return err}if(isdir){if(!FS.isDir(node.mode)){return ERRNO_CODES.ENOTDIR}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return ERRNO_CODES.EBUSY}}else{if(FS.isDir(node.mode)){return ERRNO_CODES.EISDIR}}return 0}),mayOpen:(function(node,flags){if(!node){return ERRNO_CODES.ENOENT}if(FS.isLink(node.mode)){return ERRNO_CODES.ELOOP}else if(FS.isDir(node.mode)){if((flags&2097155)!==0||flags&512){return ERRNO_CODES.EISDIR}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))}),MAX_OPEN_FDS:4096,nextfd:(function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(ERRNO_CODES.EMFILE)}),getStream:(function(fd){return FS.streams[fd]}),createStream:(function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=(function(){});FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:(function(){return this.node}),set:(function(val){this.node=val})},isRead:{get:(function(){return(this.flags&2097155)!==1})},isWrite:{get:(function(){return(this.flags&2097155)!==0})},isAppend:{get:(function(){return this.flags&1024})}})}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p]}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream}),closeStream:(function(fd){FS.streams[fd]=null}),chrdev_stream_ops:{open:(function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}}),llseek:(function(){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)})},major:(function(dev){return dev>>8}),minor:(function(dev){return dev&255}),makedev:(function(ma,mi){return ma<<8|mi}),registerDevice:(function(dev,ops){FS.devices[dev]={stream_ops:ops}}),getDevice:(function(dev){return FS.devices[dev]}),getMounts:(function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts}),syncfs:(function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false}var mounts=FS.getMounts(FS.root.mount);var completed=0;function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=mounts.length){callback(null)}}mounts.forEach((function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)}))}),mount:(function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot}),unmount:(function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach((function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current)}current=next}}));node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1)}),lookup:(function(parent,name){return parent.node_ops.lookup(parent,name)}),mknod:(function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var err=FS.mayCreate(parent,name);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return parent.node_ops.mknod(parent,name,mode,dev)}),create:(function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)}),mkdir:(function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)}),mkdev:(function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)}),symlink:(function(oldpath,newpath){if(!PATH.resolve(oldpath)){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return parent.node_ops.symlink(parent,newname,oldpath)}),rename:(function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(!old_dir||!new_dir)throw new FS.ErrnoError(ERRNO_CODES.ENOENT);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(ERRNO_CODES.EXDEV)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err){throw new FS.ErrnoError(err)}err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err){throw new FS.ErrnoError(err)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err){throw new FS.ErrnoError(err)}}try{if(FS.trackingDelegate["willMovePath"]){FS.trackingDelegate["willMovePath"](old_path,new_path)}}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}}),rmdir:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}}),readdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}return node.node_ops.readdir(node)}),unlink:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){if(err===ERRNO_CODES.EISDIR)err=ERRNO_CODES.EPERM;throw new FS.ErrnoError(err)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(ERRNO_CODES.EBUSY)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}}),readlink:(function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!link.node_ops.readlink){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return PATH.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))}),stat:(function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(!node.node_ops.getattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}return node.node_ops.getattr(node)}),lstat:(function(path){return FS.stat(path,true)}),chmod:(function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})}),lchmod:(function(path,mode){FS.chmod(path,mode,true)}),fchmod:(function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}FS.chmod(stream.node,mode)}),chown:(function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}node.node_ops.setattr(node,{timestamp:Date.now()})}),lchown:(function(path,uid,gid){FS.chown(path,uid,gid,true)}),fchown:(function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}FS.chown(stream.node,uid,gid)}),truncate:(function(path,len){if(len<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var err=FS.nodePermissions(node,"w");if(err){throw new FS.ErrnoError(err)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})}),ftruncate:(function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}FS.truncate(stream.node,len)}),utime:(function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})}),open:(function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==="object"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(ERRNO_CODES.EEXIST)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}if(!created){var err=FS.mayOpen(node,flags);if(err){throw new FS.ErrnoError(err)}}if(flags&512){FS.truncate(node,0)}flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;Module["printErr"]("read file: "+path)}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1){trackingFlags|=FS.tracking.openFlags.READ}if((flags&2097155)!==0){trackingFlags|=FS.tracking.openFlags.WRITE}FS.trackingDelegate["onOpenFile"](path,trackingFlags)}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message)}return stream}),close:(function(stream){if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}}),llseek:(function(stream,offset,whence){if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position}),read:(function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!stream.stream_ops.read){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false}else if(!stream.seekable){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead}),write:(function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EISDIR)}if(!stream.stream_ops.write){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(stream.flags&1024){FS.llseek(stream,0,2)}var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false}else if(!stream.seekable){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path)}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: "+e.message)}return bytesWritten}),allocate:(function(stream,offset,length){if(offset<0||length<=0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(ERRNO_CODES.EBADF)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)}stream.stream_ops.allocate(stream,offset,length)}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1){throw new FS.ErrnoError(ERRNO_CODES.EACCES)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)}),munmap:(function(stream){return 0}),ioctl:(function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)}return stream.stream_ops.ioctl(stream,cmd,arg)}),readFile:(function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding==="binary"){ret=buf}FS.close(stream);return ret}),writeFile:(function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";opts.encoding=opts.encoding||"utf8";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var stream=FS.open(path,opts.flags,opts.mode);if(opts.encoding==="utf8"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,0,opts.canOwn)}else if(opts.encoding==="binary"){FS.write(stream,data,0,data.length,0,opts.canOwn)}FS.close(stream)}),cwd:(function(){return FS.currentPath}),chdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR)}var err=FS.nodePermissions(lookup.node,"x");if(err){throw new FS.ErrnoError(err)}FS.currentPath=lookup.path}),createDefaultDirectories:(function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user")}),createDefaultDevices:(function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:(function(){return 0}),write:(function(stream,buffer,offset,length,pos){return length})});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device;if(typeof crypto!=="undefined"){var randomBuffer=new Uint8Array(1);random_device=(function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]})}else if(ENVIRONMENT_IS_NODE){random_device=(function(){return require("crypto").randomBytes(1)[0]})}else{random_device=(function(){return Math.random()*256|0})}FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")}),createSpecialDirectories:(function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:(function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:(function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:(function(){return stream.path})}};ret.parent=ret;return ret})};return node})},{},"/proc/self/fd")}),createStandardStreams:(function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"])}else{FS.symlink("/dev/tty","/dev/stdin")}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"])}else{FS.symlink("/dev/tty","/dev/stdout")}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"])}else{FS.symlink("/dev/tty1","/dev/stderr")}var stdin=FS.open("/dev/stdin","r");assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");var stdout=FS.open("/dev/stdout","w");assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");var stderr=FS.open("/dev/stderr","w");assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")")}),ensureErrnoError:(function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=(function(errno){this.errno=errno;for(var key in ERRNO_CODES){if(ERRNO_CODES[key]===errno){this.code=key;break}}});this.setErrno(errno);this.message=ERRNO_MESSAGES[errno]};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[ERRNO_CODES.ENOENT].forEach((function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"}))}),staticInit:(function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"IDBFS":IDBFS,"NODEFS":NODEFS,"WORKERFS":WORKERFS}}),init:(function(input,output,error){assert(!FS.init.initialized,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()}),quit:(function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}}),getMode:(function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode}),joinPath:(function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path}),absolutePath:(function(relative,base){return PATH.resolve(base,relative)}),standardizePath:(function(path){return PATH.normalize(path)}),findObject:(function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{___setErrNo(ret.error);return null}}),analyzePath:(function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret}),createFolder:(function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)}),createPath:(function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current}),createFile:(function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)}),createDataFile:(function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node}),createDevice:(function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:(function(stream){stream.seekable=false}),close:(function(stream){if(output&&output.buffer&&output.buffer.length){output(10)}}),read:(function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead}),write:(function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}}if(length){stream.node.timestamp=Date.now()}return i})});return FS.mkdev(path,mode,dev)}),createLink:(function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)}),forceLoadFile:(function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(Module["read"]){try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length}catch(e){success=false}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)___setErrNo(ERRNO_CODES.EIO);return success}),createLazyFile:(function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||"",true)}});var lazyArray=this;lazyArray.setDataGetter((function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]}));this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperty(lazyArray,"length",{get:(function(){if(!this.lengthKnown){this.cacheLength()}return this._length})});Object.defineProperty(lazyArray,"chunkSize",{get:(function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize})});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperty(node,"usedBytes",{get:(function(){return this.contents.length})});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach((function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(ERRNO_CODES.EIO)}return fn.apply(null,arguments)}}));stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(ERRNO_CODES.EIO)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size};node.stream_ops=stream_ops;return node}),createPreloadedFile:(function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}var handled=false;Module["preloadPlugins"].forEach((function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,(function(){if(onerror)onerror();removeRunDependency(dep)}));handled=true}}));if(!handled)finish(byteArray)}addRunDependency(dep);if(typeof url=="string"){Browser.asyncLoad(url,(function(byteArray){processData(byteArray)}),onerror)}else{processData(url)}}),indexedDB:(function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB}),DB_NAME:(function(){return"EM_FS_"+window.location.pathname}),DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach((function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish()};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish()}}));transaction.onerror=onerror};openRequest.onerror=onerror}),loadFilesFromDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach((function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish()}}));transaction.onerror=onerror};openRequest.onerror=onerror})};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:(function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);dir=dirstream.path}path=PATH.join2(dir,path)}return path}),doStat:(function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-ERRNO_CODES.ENOTDIR}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;HEAP32[buf+36>>2]=stat.size;HEAP32[buf+40>>2]=4096;HEAP32[buf+44>>2]=stat.blocks;HEAP32[buf+48>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+52>>2]=0;HEAP32[buf+56>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ino;return 0}),doMsync:(function(addr,stream,len,flags){var buffer=new Uint8Array(HEAPU8.subarray(addr,addr+len));FS.msync(stream,buffer,0,len,flags)}),doMkdir:(function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0}),doMknod:(function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-ERRNO_CODES.EINVAL}FS.mknod(path,mode,dev);return 0}),doReadlink:(function(path,buf,bufsize){if(bufsize<=0)return-ERRNO_CODES.EINVAL;var ret=FS.readlink(path);ret=ret.slice(0,Math.max(0,bufsize));writeStringToMemory(ret,buf,true);return ret.length}),doAccess:(function(path,amode){if(amode&~7){return-ERRNO_CODES.EINVAL}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return-ERRNO_CODES.EACCES}return 0}),doDup:(function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd}),doReadv:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret}),doWritev:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret}),varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=Pointer_stringify(SYSCALLS.get());return ret}),getStreamFromFD:(function(){var stream=FS.getStream(SYSCALLS.get());if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return stream}),getSocketFromFD:(function(){var socket=SOCKFS.getSocket(SYSCALLS.get());if(!socket)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return socket}),getSocketAddress:(function(allowNull){var addrp=SYSCALLS.get(),addrlen=SYSCALLS.get();if(allowNull&&addrp===0)return null;var info=__read_sockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}var _emscripten_asm_const=true;function ___assert_fail(condition,filename,line,func){ABORT=true;throw"Assertion failed: "+Pointer_stringify(condition)+", at: "+[filename?Pointer_stringify(filename):"unknown filename",line,func?Pointer_stringify(func):"unknown function"]+" at "+stackTrace()}function _sbrk(bytes){var self=_sbrk;if(!self.called){DYNAMICTOP=alignMemoryPage(DYNAMICTOP);self.called=true;assert(Runtime.dynamicAlloc);self.alloc=Runtime.dynamicAlloc;Runtime.dynamicAlloc=(function(){abort("cannot dynamically allocate, sbrk now has control")})}var ret=DYNAMICTOP;if(bytes!=0){var success=self.alloc(bytes);if(!success)return-1>>>0}return ret}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}Module["_memcpy"]=_memcpy;Module["_memmove"]=_memmove;var _emscripten_asm_const_int=true;function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){HEAP32[ptr>>2]=ret}return ret}function _pthread_self(){return 0}function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;assert(offset_high===0);FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doWritev(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),op=SYSCALLS.get();switch(op){case 21505:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0};case 21506:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0};case 21519:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0};case 21520:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return-ERRNO_CODES.EINVAL};case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)};default:abort("bad ioctl syscall "+op)}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}FS.staticInit();__ATINIT__.unshift((function(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init()}));__ATMAIN__.push((function(){FS.ignorePermissions=false}));__ATEXIT__.push((function(){FS.quit()}));Module["FS_createFolder"]=FS.createFolder;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createLink"]=FS.createLink;Module["FS_createDevice"]=FS.createDevice;Module["FS_unlink"]=FS.unlink;__ATINIT__.unshift((function(){TTY.init()}));__ATEXIT__.push((function(){TTY.shutdown()}));if(ENVIRONMENT_IS_NODE){var fs=require("fs");var NODEJS_PATH=require("path");NODEFS.staticInit()}STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);staticSealed=true;STACK_MAX=STACK_BASE+TOTAL_STACK;DYNAMIC_BASE=DYNAMICTOP=Runtime.alignMemory(STACK_MAX);assert(DYNAMIC_BASE<TOTAL_MEMORY,"TOTAL_MEMORY not big enough for stack");var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",ALLOC_DYNAMIC);function invoke_i(index){try{return Module["dynCall_i"](index)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function jsCall_i(index){return Runtime.functionPointers[index]()}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function jsCall_ii(index,a1){return Runtime.functionPointers[index](a1)}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function jsCall_iiii(index,a1,a2,a3){return Runtime.functionPointers[index](a1,a2,a3)}function invoke_vi(index,a1){try{Module["dynCall_vi"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function jsCall_vi(index,a1){Runtime.functionPointers[index](a1)}Module.asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array,"NaN":NaN,"Infinity":Infinity};Module.asmLibraryArg={"abort":abort,"assert":assert,"invoke_i":invoke_i,"jsCall_i":jsCall_i,"invoke_ii":invoke_ii,"jsCall_ii":jsCall_ii,"invoke_iiii":invoke_iiii,"jsCall_iiii":jsCall_iiii,"invoke_vi":invoke_vi,"jsCall_vi":jsCall_vi,"_pthread_cleanup_pop":_pthread_cleanup_pop,"___lock":___lock,"_sysconf":_sysconf,"_pthread_self":_pthread_self,"___syscall6":___syscall6,"___setErrNo":___setErrNo,"_abort":_abort,"_sbrk":_sbrk,"_time":_time,"_pthread_cleanup_push":_pthread_cleanup_push,"_emscripten_memcpy_big":_emscripten_memcpy_big,"___syscall54":___syscall54,"___unlock":___unlock,"___syscall140":___syscall140,"___assert_fail":___assert_fail,"___syscall146":___syscall146,"_emscripten_asm_const_0":_emscripten_asm_const_0,"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"cttz_i8":cttz_i8};// EMSCRIPTEN_START_ASM
var asm=(function(global,env,buffer) {
"use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.STACKTOP|0;var j=env.STACK_MAX|0;var k=env.tempDoublePtr|0;var l=env.ABORT|0;var m=env.cttz_i8|0;var n=0;var o=0;var p=0;var q=0;var r=global.NaN,s=global.Infinity;var t=0,u=0,v=0,w=0,x=0.0,y=0,z=0,A=0,B=0.0;var C=0;var D=0;var E=0;var F=0;var G=0;var H=0;var I=0;var J=0;var K=0;var L=0;var M=global.Math.floor;var N=global.Math.abs;var O=global.Math.sqrt;var P=global.Math.pow;var Q=global.Math.cos;var R=global.Math.sin;var S=global.Math.tan;var T=global.Math.acos;var U=global.Math.asin;var V=global.Math.atan;var W=global.Math.atan2;var X=global.Math.exp;var Y=global.Math.log;var Z=global.Math.ceil;var _=global.Math.imul;var $=global.Math.min;var aa=global.Math.clz32;var ba=env.abort;var ca=env.assert;var da=env.invoke_i;var ea=env.jsCall_i;var fa=env.invoke_ii;var ga=env.jsCall_ii;var ha=env.invoke_iiii;var ia=env.jsCall_iiii;var ja=env.invoke_vi;var ka=env.jsCall_vi;var la=env._pthread_cleanup_pop;var ma=env.___lock;var na=env._sysconf;var oa=env._pthread_self;var pa=env.___syscall6;var qa=env.___setErrNo;var ra=env._abort;var sa=env._sbrk;var ta=env._time;var ua=env._pthread_cleanup_push;var va=env._emscripten_memcpy_big;var wa=env.___syscall54;var xa=env.___unlock;var ya=env.___syscall140;var za=env.___assert_fail;var Aa=env.___syscall146;var Ba=env._emscripten_asm_const_0;var Ca=0.0;
// EMSCRIPTEN_START_FUNCS
function Nc(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0;R=i;P=i=i+63&-64;i=i+320|0;Q=P+280|0;k=P+240|0;j=P+200|0;q=P+160|0;l=P+120|0;m=P+80|0;o=P+40|0;O=b+40|0;T=d[e>>0]|0;M=Hd(d[e+1>>0]|0|0,0,8)|0;J=C;r=Hd(d[e+2>>0]|0|0,0,16)|0;J=J|C;s=Hd(d[e+3>>0]|0|0,0,24)|0;J=J|C;I=a[e+6>>0]|0;L=d[e+4>>0]|0;p=Hd(d[e+5>>0]|0|0,0,8)|0;K=C;I=Hd(I&255|0,0,16)|0;K=Hd(p|L|I|0,K|C|0,6)|0;I=C;L=a[e+9>>0]|0;p=d[e+7>>0]|0;f=Hd(d[e+8>>0]|0|0,0,8)|0;w=C;L=Hd(L&255|0,0,16)|0;w=Hd(f|p|L|0,w|C|0,5)|0;L=C;p=a[e+12>>0]|0;f=d[e+10>>0]|0;y=Hd(d[e+11>>0]|0|0,0,8)|0;n=C;p=Hd(p&255|0,0,16)|0;n=Hd(y|f|p|0,n|C|0,3)|0;p=C;f=a[e+15>>0]|0;y=d[e+13>>0]|0;F=Hd(d[e+14>>0]|0|0,0,8)|0;A=C;f=Hd(f&255|0,0,16)|0;A=Hd(F|y|f|0,A|C|0,2)|0;f=C;y=d[e+16>>0]|0;F=Hd(d[e+17>>0]|0|0,0,8)|0;u=C;h=Hd(d[e+18>>0]|0|0,0,16)|0;u=u|C;t=Hd(d[e+19>>0]|0|0,0,24)|0;t=F|y|h|t;u=u|C;h=a[e+22>>0]|0;y=d[e+20>>0]|0;F=Hd(d[e+21>>0]|0|0,0,8)|0;E=C;h=Hd(h&255|0,0,16)|0;E=Hd(F|y|h|0,E|C|0,7)|0;h=C;y=a[e+25>>0]|0;F=d[e+23>>0]|0;N=Hd(d[e+24>>0]|0|0,0,8)|0;x=C;y=Hd(y&255|0,0,16)|0;x=Hd(N|F|y|0,x|C|0,5)|0;y=C;F=a[e+28>>0]|0;N=d[e+26>>0]|0;g=Hd(d[e+27>>0]|0|0,0,8)|0;G=C;F=Hd(F&255|0,0,16)|0;G=Hd(g|N|F|0,G|C|0,4)|0;F=C;N=e+31|0;g=a[N>>0]|0;D=d[e+29>>0]|0;v=Hd(d[e+30>>0]|0|0,0,8)|0;B=C;g=Hd(g&255|0,0,16)|0;B=Hd(v|D|g|0,B|C|0,2)|0;B=B&33554428;g=Dd(B|0,0,16777216,0)|0;g=Gd(g|0,C|0,25)|0;D=C;v=Cd(0,0,g|0,D|0)|0;J=Dd(v&19|0,0,M|T|r|s|0,J|0)|0;s=C;D=Hd(g|0,D|0,25)|0;g=C;r=Dd(K|0,I|0,16777216,0)|0;r=Gd(r|0,C|0,25)|0;T=C;L=Dd(w|0,L|0,r|0,T|0)|0;w=C;T=Hd(r|0,T|0,25)|0;T=Cd(K|0,I|0,T|0,C|0)|0;I=C;K=Dd(n|0,p|0,16777216,0)|0;K=Gd(K|0,C|0,25)|0;r=C;f=Dd(A|0,f|0,K|0,r|0)|0;A=C;r=Hd(K|0,r|0,25)|0;K=C;M=Dd(t|0,u|0,16777216,0)|0;M=Gd(M|0,C|0,25)|0;v=C;h=Dd(E|0,h|0,M|0,v|0)|0;E=C;v=Hd(M|0,v|0,25)|0;M=C;e=Dd(x|0,y|0,16777216,0)|0;e=Gd(e|0,C|0,25)|0;z=C;F=Dd(G|0,F|0,e|0,z|0)|0;G=C;z=Hd(e|0,z|0,25)|0;e=C;S=Dd(J|0,s|0,33554432,0)|0;S=Ed(S|0,C|0,26)|0;H=C;I=Dd(T|0,I|0,S|0,H|0)|0;H=Hd(S|0,H|0,26)|0;H=Cd(J|0,s|0,H|0,C|0)|0;s=Dd(L|0,w|0,33554432,0)|0;s=Ed(s|0,C|0,26)|0;J=C;p=Dd(s|0,J|0,n|0,p|0)|0;K=Cd(p|0,C|0,r|0,K|0)|0;J=Hd(s|0,J|0,26)|0;J=Cd(L|0,w|0,J|0,C|0)|0;w=Dd(f|0,A|0,33554432,0)|0;w=Ed(w|0,C|0,26)|0;L=C;u=Dd(w|0,L|0,t|0,u|0)|0;M=Cd(u|0,C|0,v|0,M|0)|0;L=Hd(w|0,L|0,26)|0;L=Cd(f|0,A|0,L|0,C|0)|0;A=Dd(h|0,E|0,33554432,0)|0;A=Ed(A|0,C|0,26)|0;f=C;y=Dd(A|0,f|0,x|0,y|0)|0;e=Cd(y|0,C|0,z|0,e|0)|0;f=Hd(A|0,f|0,26)|0;f=Cd(h|0,E|0,f|0,C|0)|0;E=Dd(F|0,G|0,33554432,0)|0;E=Ed(E|0,C|0,26)|0;h=C;B=Dd(B|0,0,E|0,h|0)|0;g=Cd(B|0,C|0,D|0,g|0)|0;h=Hd(E|0,h|0,26)|0;h=Cd(F|0,G|0,h|0,C|0)|0;c[O>>2]=H;c[b+44>>2]=I;c[b+48>>2]=J;c[b+52>>2]=K;c[b+56>>2]=L;c[b+60>>2]=M;c[b+64>>2]=f;c[b+68>>2]=e;c[b+72>>2]=h;c[b+76>>2]=g;g=b+80|0;c[g>>2]=1;h=b+84|0;e=h;f=e+36|0;do{c[e>>2]=0;e=e+4|0}while((e|0)<(f|0));Kc(q,O);Jc(l,q,1064);f=q+4|0;n=q+8|0;p=q+12|0;r=q+16|0;s=q+20|0;v=q+24|0;x=q+28|0;z=q+32|0;B=q+36|0;g=c[g>>2]|0;t=c[h>>2]|0;w=c[b+88>>2]|0;A=c[b+92>>2]|0;E=c[b+96>>2]|0;G=c[b+100>>2]|0;I=c[b+104>>2]|0;K=c[b+108>>2]|0;M=c[b+112>>2]|0;T=c[b+116>>2]|0;e=(c[f>>2]|0)-t|0;S=(c[n>>2]|0)-w|0;L=(c[p>>2]|0)-A|0;J=(c[r>>2]|0)-E|0;H=(c[s>>2]|0)-G|0;F=(c[v>>2]|0)-I|0;D=(c[x>>2]|0)-K|0;y=(c[z>>2]|0)-M|0;u=(c[B>>2]|0)-T|0;c[q>>2]=(c[q>>2]|0)-g;c[f>>2]=e;c[n>>2]=S;c[p>>2]=L;c[r>>2]=J;c[s>>2]=H;c[v>>2]=F;c[x>>2]=D;c[z>>2]=y;c[B>>2]=u;u=l+4|0;y=l+8|0;D=l+12|0;F=l+16|0;H=l+20|0;J=l+24|0;L=l+28|0;S=l+32|0;e=l+36|0;t=t+(c[u>>2]|0)|0;w=w+(c[y>>2]|0)|0;A=A+(c[D>>2]|0)|0;E=E+(c[F>>2]|0)|0;G=G+(c[H>>2]|0)|0;I=I+(c[J>>2]|0)|0;K=K+(c[L>>2]|0)|0;M=M+(c[S>>2]|0)|0;T=T+(c[e>>2]|0)|0;c[l>>2]=g+(c[l>>2]|0);c[u>>2]=t;c[y>>2]=w;c[D>>2]=A;c[F>>2]=E;c[H>>2]=G;c[J>>2]=I;c[L>>2]=K;c[S>>2]=M;c[e>>2]=T;Kc(m,l);Jc(m,m,l);Kc(b,m);Jc(b,b,l);Jc(b,b,q);Kc(Q,b);Kc(k,Q);Kc(k,k);Jc(k,b,k);Jc(Q,Q,k);Kc(Q,Q);Jc(Q,k,Q);Kc(k,Q);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Jc(Q,k,Q);Kc(k,Q);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Jc(k,k,Q);Kc(j,k);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Kc(j,j);Jc(k,j,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Kc(k,k);Jc(Q,k,Q);Kc(k,Q);e=1;do{Kc(k,k);e=e+1|0}while((e|0)!=50);Jc(k,k,Q);Kc(j,k);e=1;do{Kc(j,j);e=e+1|0}while((e|0)!=100);Jc(k,j,k);Kc(k,k);e=1;do{Kc(k,k);e=e+1|0}while((e|0)!=50);Jc(Q,k,Q);Kc(Q,Q);Kc(Q,Q);Jc(b,Q,b);Jc(b,b,m);Jc(b,b,q);Kc(o,b);Jc(o,o,l);E=c[o>>2]|0;F=c[o+4>>2]|0;G=c[o+8>>2]|0;H=c[o+12>>2]|0;I=c[o+16>>2]|0;J=c[o+20>>2]|0;K=c[o+24>>2]|0;L=c[o+28>>2]|0;M=c[o+32>>2]|0;D=c[o+36>>2]|0;A=c[q>>2]|0;y=c[f>>2]|0;w=c[n>>2]|0;u=c[p>>2]|0;t=c[r>>2]|0;s=c[s>>2]|0;r=c[v>>2]|0;q=c[x>>2]|0;p=c[z>>2]|0;e=c[B>>2]|0;c[P>>2]=E-A;f=P+4|0;c[f>>2]=F-y;g=P+8|0;c[g>>2]=G-w;h=P+12|0;c[h>>2]=H-u;j=P+16|0;c[j>>2]=I-t;k=P+20|0;c[k>>2]=J-s;l=P+24|0;c[l>>2]=K-r;m=P+28|0;c[m>>2]=L-q;n=P+32|0;c[n>>2]=M-p;o=P+36|0;c[o>>2]=D-e;Lc(Q,P);do if(Yc(Q,33004)|0){c[P>>2]=A+E;c[f>>2]=y+F;c[g>>2]=w+G;c[h>>2]=u+H;c[j>>2]=t+I;c[k>>2]=s+J;c[l>>2]=r+K;c[m>>2]=q+L;c[n>>2]=p+M;c[o>>2]=e+D;Lc(Q,P);if(!(Yc(Q,33004)|0)){Jc(b,b,1104);break}else{T=-1;i=R;return T|0}}while(0);Lc(Q,b);if(((d[Q>>0]|0)&1|0)==((d[N>>0]|0)>>>7|0)){A=b+4|0;D=b+8|0;F=b+12|0;H=b+16|0;J=b+20|0;L=b+24|0;N=b+28|0;Q=b+32|0;T=b+36|0;z=0-(c[A>>2]|0)|0;B=0-(c[D>>2]|0)|0;E=0-(c[F>>2]|0)|0;G=0-(c[H>>2]|0)|0;I=0-(c[J>>2]|0)|0;K=0-(c[L>>2]|0)|0;M=0-(c[N>>2]|0)|0;P=0-(c[Q>>2]|0)|0;S=0-(c[T>>2]|0)|0;c[b>>2]=0-(c[b>>2]|0);c[A>>2]=z;c[D>>2]=B;c[F>>2]=E;c[H>>2]=G;c[J>>2]=I;c[L>>2]=K;c[N>>2]=M;c[Q>>2]=P;c[T>>2]=S}Jc(b+120|0,b,O);T=0;i=R;return T|0}function Oc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0;V=b+40|0;j=b+44|0;m=b+48|0;p=b+52|0;s=b+56|0;v=b+60|0;y=b+64|0;B=b+68|0;E=b+72|0;C=b+76|0;S=b+4|0;P=b+8|0;e=b+12|0;l=b+16|0;n=b+20|0;u=b+24|0;w=b+28|0;D=b+32|0;O=b+36|0;ga=(c[S>>2]|0)+(c[j>>2]|0)|0;fa=(c[P>>2]|0)+(c[m>>2]|0)|0;ea=(c[e>>2]|0)+(c[p>>2]|0)|0;da=(c[l>>2]|0)+(c[s>>2]|0)|0;ca=(c[n>>2]|0)+(c[v>>2]|0)|0;ba=(c[u>>2]|0)+(c[y>>2]|0)|0;aa=(c[w>>2]|0)+(c[B>>2]|0)|0;$=(c[D>>2]|0)+(c[E>>2]|0)|0;Y=(c[O>>2]|0)+(c[C>>2]|0)|0;c[a>>2]=(c[b>>2]|0)+(c[V>>2]|0);ha=a+4|0;c[ha>>2]=ga;ga=a+8|0;c[ga>>2]=fa;fa=a+12|0;c[fa>>2]=ea;ea=a+16|0;c[ea>>2]=da;da=a+20|0;c[da>>2]=ca;ca=a+24|0;c[ca>>2]=ba;ba=a+28|0;c[ba>>2]=aa;aa=a+32|0;c[aa>>2]=$;$=a+36|0;c[$>>2]=Y;Y=a+40|0;S=(c[j>>2]|0)-(c[S>>2]|0)|0;P=(c[m>>2]|0)-(c[P>>2]|0)|0;e=(c[p>>2]|0)-(c[e>>2]|0)|0;l=(c[s>>2]|0)-(c[l>>2]|0)|0;n=(c[v>>2]|0)-(c[n>>2]|0)|0;u=(c[y>>2]|0)-(c[u>>2]|0)|0;w=(c[B>>2]|0)-(c[w>>2]|0)|0;D=(c[E>>2]|0)-(c[D>>2]|0)|0;O=(c[C>>2]|0)-(c[O>>2]|0)|0;c[Y>>2]=(c[V>>2]|0)-(c[b>>2]|0);V=a+44|0;c[V>>2]=S;S=a+48|0;c[S>>2]=P;P=a+52|0;c[P>>2]=e;e=a+56|0;c[e>>2]=l;l=a+60|0;c[l>>2]=n;n=a+64|0;c[n>>2]=u;u=a+68|0;c[u>>2]=w;w=a+72|0;c[w>>2]=D;D=a+76|0;c[D>>2]=O;O=a+80|0;Jc(O,a,d);Jc(Y,Y,d+40|0);C=a+120|0;Jc(C,d+80|0,b+120|0);E=c[b+80>>2]<<1;B=c[b+84>>2]<<1;y=c[b+88>>2]<<1;v=c[b+92>>2]<<1;s=c[b+96>>2]<<1;p=c[b+100>>2]<<1;m=c[b+104>>2]<<1;j=c[b+108>>2]<<1;g=c[b+112>>2]<<1;b=c[b+116>>2]<<1;Z=c[O>>2]|0;N=a+84|0;W=c[N>>2]|0;M=a+88|0;T=c[M>>2]|0;L=a+92|0;Q=c[L>>2]|0;K=a+96|0;f=c[K>>2]|0;J=a+100|0;h=c[J>>2]|0;I=a+104|0;o=c[I>>2]|0;H=a+108|0;q=c[H>>2]|0;G=a+112|0;x=c[G>>2]|0;F=a+116|0;z=c[F>>2]|0;_=c[Y>>2]|0;X=c[V>>2]|0;U=c[S>>2]|0;R=c[P>>2]|0;d=c[e>>2]|0;i=c[l>>2]|0;k=c[n>>2]|0;r=c[u>>2]|0;t=c[w>>2]|0;A=c[D>>2]|0;c[a>>2]=Z-_;c[ha>>2]=W-X;c[ga>>2]=T-U;c[fa>>2]=Q-R;c[ea>>2]=f-d;c[da>>2]=h-i;c[ca>>2]=o-k;c[ba>>2]=q-r;c[aa>>2]=x-t;c[$>>2]=z-A;c[Y>>2]=_+Z;c[V>>2]=X+W;c[S>>2]=U+T;c[P>>2]=R+Q;c[e>>2]=d+f;c[l>>2]=i+h;c[n>>2]=k+o;c[u>>2]=r+q;c[w>>2]=t+x;c[D>>2]=A+z;D=c[C>>2]|0;z=a+124|0;A=c[z>>2]|0;w=a+128|0;x=c[w>>2]|0;t=a+132|0;u=c[t>>2]|0;q=a+136|0;r=c[q>>2]|0;n=a+140|0;o=c[n>>2]|0;k=a+144|0;l=c[k>>2]|0;h=a+148|0;i=c[h>>2]|0;e=a+152|0;f=c[e>>2]|0;a=a+156|0;d=c[a>>2]|0;c[O>>2]=D+E;c[N>>2]=A+B;c[M>>2]=x+y;c[L>>2]=u+v;c[K>>2]=r+s;c[J>>2]=o+p;c[I>>2]=l+m;c[H>>2]=i+j;c[G>>2]=f+g;c[F>>2]=d+b;c[C>>2]=E-D;c[z>>2]=B-A;c[w>>2]=y-x;c[t>>2]=v-u;c[q>>2]=s-r;c[n>>2]=p-o;c[k>>2]=m-l;c[h>>2]=j-i;c[e>>2]=g-f;c[a>>2]=b-d;return}function Pc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0;d=i;S=i=i+63&-64;i=i+48|0;Kc(a,b);aa=a+80|0;ta=b+40|0;Kc(aa,ta);v=a+120|0;ib=c[b+80>>2]|0;Sa=c[b+84>>2]|0;p=c[b+88>>2]|0;x=c[b+92>>2]|0;f=c[b+96>>2]|0;kb=c[b+100>>2]|0;_=c[b+104>>2]|0;wa=c[b+108>>2]|0;l=c[b+112>>2]|0;ua=c[b+116>>2]|0;t=ib<<1;ra=Sa<<1;cb=p<<1;g=x<<1;Ma=f<<1;e=kb<<1;va=_<<1;n=wa<<1;bb=kb*38|0;Qa=_*19|0;Q=wa*38|0;H=l*19|0;nb=ua*38|0;jb=((ib|0)<0)<<31>>31;jb=Od(ib|0,jb|0,ib|0,jb|0)|0;ib=C;qa=((t|0)<0)<<31>>31;Ta=((Sa|0)<0)<<31>>31;$a=Od(t|0,qa|0,Sa|0,Ta|0)|0;_a=C;r=((p|0)<0)<<31>>31;Va=Od(p|0,r|0,t|0,qa|0)|0;Ua=C;R=((x|0)<0)<<31>>31;La=Od(x|0,R|0,t|0,qa|0)|0;Ka=C;ka=((f|0)<0)<<31>>31;za=Od(f|0,ka|0,t|0,qa|0)|0;ya=C;lb=((kb|0)<0)<<31>>31;K=Od(kb|0,lb|0,t|0,qa|0)|0;M=C;j=((_|0)<0)<<31>>31;k=Od(_|0,j|0,t|0,qa|0)|0;F=C;xa=((wa|0)<0)<<31>>31;u=Od(wa|0,xa|0,t|0,qa|0)|0;P=C;ma=((l|0)<0)<<31>>31;W=Od(l|0,ma|0,t|0,qa|0)|0;fa=C;oa=((ua|0)<0)<<31>>31;qa=Od(ua|0,oa|0,t|0,qa|0)|0;t=C;pa=((ra|0)<0)<<31>>31;Ta=Od(ra|0,pa|0,Sa|0,Ta|0)|0;Sa=C;Ja=Od(ra|0,pa|0,p|0,r|0)|0;Ia=C;ja=((g|0)<0)<<31>>31;Da=Od(g|0,ja|0,ra|0,pa|0)|0;Ca=C;B=Od(f|0,ka|0,ra|0,pa|0)|0;E=C;la=((e|0)<0)<<31>>31;h=Od(e|0,la|0,ra|0,pa|0)|0;D=C;s=Od(_|0,j|0,ra|0,pa|0)|0;N=C;$=((n|0)<0)<<31>>31;V=Od(n|0,$|0,ra|0,pa|0)|0;ea=C;sa=Od(l|0,ma|0,ra|0,pa|0)|0;na=C;mb=((nb|0)<0)<<31>>31;pa=Od(nb|0,mb|0,ra|0,pa|0)|0;ra=C;Ba=Od(p|0,r|0,p|0,r|0)|0;Aa=C;db=((cb|0)<0)<<31>>31;G=Od(cb|0,db|0,x|0,R|0)|0;I=C;y=Od(f|0,ka|0,cb|0,db|0)|0;A=C;o=Od(kb|0,lb|0,cb|0,db|0)|0;J=C;w=Od(_|0,j|0,cb|0,db|0)|0;ba=C;Z=Od(wa|0,xa|0,cb|0,db|0)|0;ia=C;m=((H|0)<0)<<31>>31;db=Od(H|0,m|0,cb|0,db|0)|0;cb=C;r=Od(nb|0,mb|0,p|0,r|0)|0;p=C;R=Od(g|0,ja|0,x|0,R|0)|0;x=C;q=Od(g|0,ja|0,f|0,ka|0)|0;L=C;U=Od(e|0,la|0,g|0,ja|0)|0;da=C;X=Od(_|0,j|0,g|0,ja|0)|0;ga=C;O=((Q|0)<0)<<31>>31;fb=Od(Q|0,O|0,g|0,ja|0)|0;eb=C;Xa=Od(H|0,m|0,g|0,ja|0)|0;Wa=C;ja=Od(nb|0,mb|0,g|0,ja|0)|0;g=C;T=Od(f|0,ka|0,f|0,ka|0)|0;ca=C;Na=((Ma|0)<0)<<31>>31;Y=Od(Ma|0,Na|0,kb|0,lb|0)|0;ha=C;Ra=((Qa|0)<0)<<31>>31;hb=Od(Qa|0,Ra|0,Ma|0,Na|0)|0;gb=C;Za=Od(Q|0,O|0,f|0,ka|0)|0;Ya=C;Na=Od(H|0,m|0,Ma|0,Na|0)|0;Ma=C;ka=Od(nb|0,mb|0,f|0,ka|0)|0;f=C;lb=Od(bb|0,((bb|0)<0)<<31>>31|0,kb|0,lb|0)|0;kb=C;bb=Od(Qa|0,Ra|0,e|0,la|0)|0;ab=C;Pa=Od(Q|0,O|0,e|0,la|0)|0;Oa=C;Fa=Od(H|0,m|0,e|0,la|0)|0;Ea=C;la=Od(nb|0,mb|0,e|0,la|0)|0;e=C;Ra=Od(Qa|0,Ra|0,_|0,j|0)|0;Qa=C;Ha=Od(Q|0,O|0,_|0,j|0)|0;Ga=C;va=Od(H|0,m|0,va|0,((va|0)<0)<<31>>31|0)|0;z=C;j=Od(nb|0,mb|0,_|0,j|0)|0;_=C;xa=Od(Q|0,O|0,wa|0,xa|0)|0;wa=C;O=Od(H|0,m|0,n|0,$|0)|0;Q=C;$=Od(nb|0,mb|0,n|0,$|0)|0;n=C;m=Od(H|0,m|0,l|0,ma|0)|0;H=C;ma=Od(nb|0,mb|0,l|0,ma|0)|0;l=C;oa=Od(nb|0,mb|0,ua|0,oa|0)|0;ua=C;ib=Dd(lb|0,kb|0,jb|0,ib|0)|0;gb=Dd(ib|0,C|0,hb|0,gb|0)|0;eb=Dd(gb|0,C|0,fb|0,eb|0)|0;cb=Dd(eb|0,C|0,db|0,cb|0)|0;ra=Dd(cb|0,C|0,pa|0,ra|0)|0;pa=C;_a=Dd(bb|0,ab|0,$a|0,_a|0)|0;Ya=Dd(_a|0,C|0,Za|0,Ya|0)|0;Wa=Dd(Ya|0,C|0,Xa|0,Wa|0)|0;p=Dd(Wa|0,C|0,r|0,p|0)|0;r=C;Sa=Dd(Va|0,Ua|0,Ta|0,Sa|0)|0;Qa=Dd(Sa|0,C|0,Ra|0,Qa|0)|0;Oa=Dd(Qa|0,C|0,Pa|0,Oa|0)|0;Ma=Dd(Oa|0,C|0,Na|0,Ma|0)|0;g=Dd(Ma|0,C|0,ja|0,g|0)|0;ja=C;Ia=Dd(La|0,Ka|0,Ja|0,Ia|0)|0;Ga=Dd(Ia|0,C|0,Ha|0,Ga|0)|0;Ea=Dd(Ga|0,C|0,Fa|0,Ea|0)|0;f=Dd(Ea|0,C|0,ka|0,f|0)|0;ka=C;Aa=Dd(Da|0,Ca|0,Ba|0,Aa|0)|0;ya=Dd(Aa|0,C|0,za|0,ya|0)|0;wa=Dd(ya|0,C|0,xa|0,wa|0)|0;z=Dd(wa|0,C|0,va|0,z|0)|0;e=Dd(z|0,C|0,la|0,e|0)|0;la=C;I=Dd(B|0,E|0,G|0,I|0)|0;M=Dd(I|0,C|0,K|0,M|0)|0;Q=Dd(M|0,C|0,O|0,Q|0)|0;_=Dd(Q|0,C|0,j|0,_|0)|0;j=C;A=Dd(R|0,x|0,y|0,A|0)|0;D=Dd(A|0,C|0,h|0,D|0)|0;F=Dd(D|0,C|0,k|0,F|0)|0;H=Dd(F|0,C|0,m|0,H|0)|0;n=Dd(H|0,C|0,$|0,n|0)|0;$=C;L=Dd(o|0,J|0,q|0,L|0)|0;N=Dd(L|0,C|0,s|0,N|0)|0;P=Dd(N|0,C|0,u|0,P|0)|0;l=Dd(P|0,C|0,ma|0,l|0)|0;ma=C;ca=Dd(w|0,ba|0,T|0,ca|0)|0;da=Dd(ca|0,C|0,U|0,da|0)|0;ea=Dd(da|0,C|0,V|0,ea|0)|0;fa=Dd(ea|0,C|0,W|0,fa|0)|0;ua=Dd(fa|0,C|0,oa|0,ua|0)|0;oa=C;ha=Dd(X|0,ga|0,Y|0,ha|0)|0;ia=Dd(ha|0,C|0,Z|0,ia|0)|0;na=Dd(ia|0,C|0,sa|0,na|0)|0;t=Dd(na|0,C|0,qa|0,t|0)|0;qa=C;pa=Hd(ra|0,pa|0,1)|0;ra=C;r=Hd(p|0,r|0,1)|0;p=C;ja=Hd(g|0,ja|0,1)|0;g=C;ka=Hd(f|0,ka|0,1)|0;f=C;la=Hd(e|0,la|0,1)|0;e=C;j=Hd(_|0,j|0,1)|0;_=C;$=Hd(n|0,$|0,1)|0;n=C;ma=Hd(l|0,ma|0,1)|0;l=C;oa=Hd(ua|0,oa|0,1)|0;ua=C;qa=Hd(t|0,qa|0,1)|0;t=C;na=Dd(pa|0,ra|0,33554432,0)|0;na=Ed(na|0,C|0,26)|0;sa=C;p=Dd(na|0,sa|0,r|0,p|0)|0;r=C;sa=Hd(na|0,sa|0,26)|0;sa=Cd(pa|0,ra|0,sa|0,C|0)|0;ra=C;pa=Dd(la|0,e|0,33554432,0)|0;pa=Ed(pa|0,C|0,26)|0;na=C;_=Dd(pa|0,na|0,j|0,_|0)|0;j=C;na=Hd(pa|0,na|0,26)|0;na=Cd(la|0,e|0,na|0,C|0)|0;e=C;la=Dd(p|0,r|0,16777216,0)|0;la=Ed(la|0,C|0,25)|0;pa=C;g=Dd(la|0,pa|0,ja|0,g|0)|0;ja=C;pa=Hd(la|0,pa|0,25)|0;pa=Cd(p|0,r|0,pa|0,C|0)|0;r=C;p=Dd(_|0,j|0,16777216,0)|0;p=Ed(p|0,C|0,25)|0;la=C;n=Dd(p|0,la|0,$|0,n|0)|0;$=C;la=Hd(p|0,la|0,25)|0;la=Cd(_|0,j|0,la|0,C|0)|0;j=C;_=Dd(g|0,ja|0,33554432,0)|0;_=Ed(_|0,C|0,26)|0;p=C;f=Dd(_|0,p|0,ka|0,f|0)|0;ka=C;p=Hd(_|0,p|0,26)|0;p=Cd(g|0,ja|0,p|0,C|0)|0;ja=Dd(n|0,$|0,33554432,0)|0;ja=Ed(ja|0,C|0,26)|0;g=C;l=Dd(ja|0,g|0,ma|0,l|0)|0;ma=C;g=Hd(ja|0,g|0,26)|0;g=Cd(n|0,$|0,g|0,C|0)|0;$=Dd(f|0,ka|0,16777216,0)|0;$=Ed($|0,C|0,25)|0;n=C;e=Dd($|0,n|0,na|0,e|0)|0;na=C;n=Hd($|0,n|0,25)|0;n=Cd(f|0,ka|0,n|0,C|0)|0;ka=Dd(l|0,ma|0,16777216,0)|0;ka=Ed(ka|0,C|0,25)|0;f=C;ua=Dd(ka|0,f|0,oa|0,ua|0)|0;oa=C;f=Hd(ka|0,f|0,25)|0;f=Cd(l|0,ma|0,f|0,C|0)|0;ma=Dd(e|0,na|0,33554432,0)|0;ma=Ed(ma|0,C|0,26)|0;l=C;j=Dd(la|0,j|0,ma|0,l|0)|0;l=Hd(ma|0,l|0,26)|0;l=Cd(e|0,na|0,l|0,C|0)|0;na=Dd(ua|0,oa|0,33554432,0)|0;na=Ed(na|0,C|0,26)|0;e=C;t=Dd(na|0,e|0,qa|0,t|0)|0;qa=C;e=Hd(na|0,e|0,26)|0;e=Cd(ua|0,oa|0,e|0,C|0)|0;oa=Dd(t|0,qa|0,16777216,0)|0;oa=Ed(oa|0,C|0,25)|0;ua=C;na=Od(oa|0,ua|0,19,0)|0;ra=Dd(na|0,C|0,sa|0,ra|0)|0;sa=C;ua=Hd(oa|0,ua|0,25)|0;ua=Cd(t|0,qa|0,ua|0,C|0)|0;qa=Dd(ra|0,sa|0,33554432,0)|0;qa=Ed(qa|0,C|0,26)|0;t=C;r=Dd(pa|0,r|0,qa|0,t|0)|0;t=Hd(qa|0,t|0,26)|0;t=Cd(ra|0,sa|0,t|0,C|0)|0;c[v>>2]=t;t=a+124|0;c[t>>2]=r;r=a+128|0;c[r>>2]=p;p=a+132|0;c[p>>2]=n;n=a+136|0;c[n>>2]=l;l=a+140|0;c[l>>2]=j;j=a+144|0;c[j>>2]=g;g=a+148|0;c[g>>2]=f;f=a+152|0;c[f>>2]=e;e=a+156|0;c[e>>2]=ua;ua=a+40|0;sa=(c[b+44>>2]|0)+(c[b+4>>2]|0)|0;ra=(c[b+48>>2]|0)+(c[b+8>>2]|0)|0;qa=(c[b+52>>2]|0)+(c[b+12>>2]|0)|0;pa=(c[b+56>>2]|0)+(c[b+16>>2]|0)|0;oa=(c[b+60>>2]|0)+(c[b+20>>2]|0)|0;na=(c[b+64>>2]|0)+(c[b+24>>2]|0)|0;ma=(c[b+68>>2]|0)+(c[b+28>>2]|0)|0;la=(c[b+72>>2]|0)+(c[b+32>>2]|0)|0;ka=(c[b+76>>2]|0)+(c[b+36>>2]|0)|0;c[ua>>2]=(c[ta>>2]|0)+(c[b>>2]|0);ta=a+44|0;c[ta>>2]=sa;sa=a+48|0;c[sa>>2]=ra;ra=a+52|0;c[ra>>2]=qa;qa=a+56|0;c[qa>>2]=pa;pa=a+60|0;c[pa>>2]=oa;oa=a+64|0;c[oa>>2]=na;na=a+68|0;c[na>>2]=ma;ma=a+72|0;c[ma>>2]=la;la=a+76|0;c[la>>2]=ka;Kc(S,ua);ka=c[aa>>2]|0;$=a+84|0;ja=c[$>>2]|0;_=a+88|0;ia=c[_>>2]|0;Z=a+92|0;ha=c[Z>>2]|0;Y=a+96|0;ga=c[Y>>2]|0;X=a+100|0;fa=c[X>>2]|0;W=a+104|0;ea=c[W>>2]|0;V=a+108|0;da=c[V>>2]|0;U=a+112|0;ca=c[U>>2]|0;T=a+116|0;ba=c[T>>2]|0;w=c[a>>2]|0;P=a+4|0;u=c[P>>2]|0;N=a+8|0;s=c[N>>2]|0;L=a+12|0;q=c[L>>2]|0;J=a+16|0;o=c[J>>2]|0;H=a+20|0;m=c[H>>2]|0;F=a+24|0;k=c[F>>2]|0;D=a+28|0;h=c[D>>2]|0;A=a+32|0;b=c[A>>2]|0;y=a+36|0;x=c[y>>2]|0;R=w+ka|0;Q=u+ja|0;O=s+ia|0;M=q+ha|0;K=o+ga|0;I=m+fa|0;G=k+ea|0;E=h+da|0;B=b+ca|0;z=x+ba|0;c[ua>>2]=R;c[ta>>2]=Q;c[sa>>2]=O;c[ra>>2]=M;c[qa>>2]=K;c[pa>>2]=I;c[oa>>2]=G;c[na>>2]=E;c[ma>>2]=B;c[la>>2]=z;w=ka-w|0;u=ja-u|0;s=ia-s|0;q=ha-q|0;o=ga-o|0;m=fa-m|0;k=ea-k|0;h=da-h|0;b=ca-b|0;x=ba-x|0;c[aa>>2]=w;c[$>>2]=u;c[_>>2]=s;c[Z>>2]=q;c[Y>>2]=o;c[X>>2]=m;c[W>>2]=k;c[V>>2]=h;c[U>>2]=b;c[T>>2]=x;Q=(c[S+4>>2]|0)-Q|0;O=(c[S+8>>2]|0)-O|0;M=(c[S+12>>2]|0)-M|0;K=(c[S+16>>2]|0)-K|0;I=(c[S+20>>2]|0)-I|0;G=(c[S+24>>2]|0)-G|0;E=(c[S+28>>2]|0)-E|0;B=(c[S+32>>2]|0)-B|0;z=(c[S+36>>2]|0)-z|0;c[a>>2]=(c[S>>2]|0)-R;c[P>>2]=Q;c[N>>2]=O;c[L>>2]=M;c[J>>2]=K;c[H>>2]=I;c[F>>2]=G;c[D>>2]=E;c[A>>2]=B;c[y>>2]=z;u=(c[t>>2]|0)-u|0;s=(c[r>>2]|0)-s|0;q=(c[p>>2]|0)-q|0;o=(c[n>>2]|0)-o|0;m=(c[l>>2]|0)-m|0;k=(c[j>>2]|0)-k|0;h=(c[g>>2]|0)-h|0;b=(c[f>>2]|0)-b|0;a=(c[e>>2]|0)-x|0;c[v>>2]=(c[v>>2]|0)-w;c[t>>2]=u;c[r>>2]=s;c[p>>2]=q;c[n>>2]=o;c[l>>2]=m;c[j>>2]=k;c[g>>2]=h;c[f>>2]=b;c[e>>2]=a;i=d;return}function Qc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;m=b+40|0;v=b+44|0;u=b+48|0;t=b+52|0;s=b+56|0;r=b+60|0;q=b+64|0;p=b+68|0;o=b+72|0;n=b+76|0;d=b+4|0;e=b+8|0;f=b+12|0;g=b+16|0;h=b+20|0;i=b+24|0;j=b+28|0;k=b+32|0;l=b+36|0;E=(c[d>>2]|0)+(c[v>>2]|0)|0;D=(c[e>>2]|0)+(c[u>>2]|0)|0;C=(c[f>>2]|0)+(c[t>>2]|0)|0;B=(c[g>>2]|0)+(c[s>>2]|0)|0;A=(c[h>>2]|0)+(c[r>>2]|0)|0;z=(c[i>>2]|0)+(c[q>>2]|0)|0;y=(c[j>>2]|0)+(c[p>>2]|0)|0;x=(c[k>>2]|0)+(c[o>>2]|0)|0;w=(c[l>>2]|0)+(c[n>>2]|0)|0;c[a>>2]=(c[b>>2]|0)+(c[m>>2]|0);c[a+4>>2]=E;c[a+8>>2]=D;c[a+12>>2]=C;c[a+16>>2]=B;c[a+20>>2]=A;c[a+24>>2]=z;c[a+28>>2]=y;c[a+32>>2]=x;c[a+36>>2]=w;d=(c[v>>2]|0)-(c[d>>2]|0)|0;e=(c[u>>2]|0)-(c[e>>2]|0)|0;f=(c[t>>2]|0)-(c[f>>2]|0)|0;g=(c[s>>2]|0)-(c[g>>2]|0)|0;h=(c[r>>2]|0)-(c[h>>2]|0)|0;i=(c[q>>2]|0)-(c[i>>2]|0)|0;j=(c[p>>2]|0)-(c[j>>2]|0)|0;k=(c[o>>2]|0)-(c[k>>2]|0)|0;l=(c[n>>2]|0)-(c[l>>2]|0)|0;c[a+40>>2]=(c[m>>2]|0)-(c[b>>2]|0);c[a+44>>2]=d;c[a+48>>2]=e;c[a+52>>2]=f;c[a+56>>2]=g;c[a+60>>2]=h;c[a+64>>2]=i;c[a+68>>2]=j;c[a+72>>2]=k;c[a+76>>2]=l;l=c[b+84>>2]|0;k=c[b+88>>2]|0;j=c[b+92>>2]|0;i=c[b+96>>2]|0;h=c[b+100>>2]|0;g=c[b+104>>2]|0;f=c[b+108>>2]|0;e=c[b+112>>2]|0;d=c[b+116>>2]|0;c[a+80>>2]=c[b+80>>2];c[a+84>>2]=l;c[a+88>>2]=k;c[a+92>>2]=j;c[a+96>>2]=i;c[a+100>>2]=h;c[a+104>>2]=g;c[a+108>>2]=f;c[a+112>>2]=e;c[a+116>>2]=d;Jc(a+120|0,b+120|0,1144);return}function Rc(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;u=i;t=i=i+63&-64;i=i+592|0;p=t+400|0;r=t+520|0;s=t+240|0;q=t+120|0;f=0;do{n=a[e+f>>0]|0;o=f<<1;a[r+o>>0]=n&15;a[r+(o|1)>>0]=(n&255)>>>4;f=f+1|0}while((f|0)!=32);e=0;f=0;do{o=r+f|0;n=(d[o>>0]|0)+e|0;e=(n<<24)+134217728>>28;a[o>>0]=n-(e<<4);f=f+1|0}while((f|0)!=63);f=r+63|0;a[f>>0]=(d[f>>0]|0)+e;e=b;f=e+40|0;do{c[e>>2]=0;e=e+4|0}while((e|0)<(f|0));j=b+40|0;c[j>>2]=1;g=b+44|0;e=g;f=e+36|0;do{c[e>>2]=0;e=e+4|0}while((e|0)<(f|0));k=b+80|0;c[k>>2]=1;h=b+84|0;l=b+120|0;m=s+120|0;n=s+40|0;o=s+80|0;e=h;f=e+76|0;do{c[e>>2]=0;e=e+4|0}while((e|0)<(f|0));e=1;do{Sc(t,(e|0)/2|0,a[r+e>>0]|0);Oc(s,b,t);Jc(b,s,m);Jc(j,n,o);Jc(k,o,m);Jc(l,s,n);e=e+2|0}while((e|0)<64);B=c[b+4>>2]|0;z=c[b+8>>2]|0;y=c[b+12>>2]|0;x=c[b+16>>2]|0;w=c[b+20>>2]|0;v=c[b+24>>2]|0;f=c[b+28>>2]|0;e=c[b+32>>2]|0;A=c[b+36>>2]|0;c[p>>2]=c[b>>2];c[p+4>>2]=B;c[p+8>>2]=z;c[p+12>>2]=y;c[p+16>>2]=x;c[p+20>>2]=w;c[p+24>>2]=v;c[p+28>>2]=f;c[p+32>>2]=e;c[p+36>>2]=A;A=c[g>>2]|0;e=c[b+48>>2]|0;g=c[b+52>>2]|0;f=c[b+56>>2]|0;v=c[b+60>>2]|0;w=c[b+64>>2]|0;x=c[b+68>>2]|0;y=c[b+72>>2]|0;z=c[b+76>>2]|0;c[p+40>>2]=c[j>>2];c[p+44>>2]=A;c[p+48>>2]=e;c[p+52>>2]=g;c[p+56>>2]=f;c[p+60>>2]=v;c[p+64>>2]=w;c[p+68>>2]=x;c[p+72>>2]=y;c[p+76>>2]=z;z=c[h>>2]|0;y=c[b+88>>2]|0;x=c[b+92>>2]|0;w=c[b+96>>2]|0;v=c[b+100>>2]|0;f=c[b+104>>2]|0;g=c[b+108>>2]|0;h=c[b+112>>2]|0;e=c[b+116>>2]|0;c[p+80>>2]=c[k>>2];c[p+84>>2]=z;c[p+88>>2]=y;c[p+92>>2]=x;c[p+96>>2]=w;c[p+100>>2]=v;c[p+104>>2]=f;c[p+108>>2]=g;c[p+112>>2]=h;c[p+116>>2]=e;Pc(s,p);Jc(q,s,m);p=q+40|0;Jc(p,n,o);e=q+80|0;Jc(e,o,m);Pc(s,q);Jc(q,s,m);Jc(p,n,o);Jc(e,o,m);Pc(s,q);Jc(q,s,m);Jc(p,n,o);Jc(e,o,m);Pc(s,q);Jc(b,s,m);Jc(j,n,o);Jc(k,o,m);Jc(l,s,n);e=0;do{Sc(t,(e|0)/2|0,a[r+e>>0]|0);Oc(s,b,t);Jc(b,s,m);Jc(j,n,o);Jc(k,o,m);Jc(l,s,n);e=e+2|0}while((e|0)<64);i=u;return}function Sc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0;s=d<<24>>24;s=Gd(s|0,((s|0)<0)<<31>>31|0,63)|0;h=d<<24>>24;s=0-s|0;d=a+4|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;e=a+40|0;c[e>>2]=1;f=a+44|0;g=a+80|0;h=h-((h&s)<<1)&255;i=(h^1)+-1|0;j=1184+(b*960|0)|0;k=a+8|0;l=a+12|0;m=a+16|0;n=a+20|0;o=a+24|0;p=a+28|0;q=a+32|0;r=a+36|0;t=f;u=t+76|0;do{c[t>>2]=0;t=t+4|0}while((t|0)<(u|0));H=i>>31;A=c[1184+(b*960|0)+4>>2]&H;I=c[1184+(b*960|0)+8>>2]&H;K=c[1184+(b*960|0)+12>>2]&H;M=c[1184+(b*960|0)+16>>2]&H;O=c[1184+(b*960|0)+20>>2]&H;Q=c[1184+(b*960|0)+24>>2]&H;S=c[1184+(b*960|0)+28>>2]&H;U=c[1184+(b*960|0)+32>>2]&H;W=c[1184+(b*960|0)+36>>2]&H;c[a>>2]=(c[j>>2]^1)&H^1;c[d>>2]=A;c[k>>2]=I;c[l>>2]=K;c[m>>2]=M;c[n>>2]=O;c[o>>2]=Q;c[p>>2]=S;c[q>>2]=U;c[r>>2]=W;W=a+48|0;U=a+52|0;S=a+56|0;Q=a+60|0;O=a+64|0;M=a+68|0;K=a+72|0;I=a+76|0;A=c[1184+(b*960|0)+44>>2]&H;z=c[1184+(b*960|0)+48>>2]&H;w=c[1184+(b*960|0)+52>>2]&H;B=c[1184+(b*960|0)+56>>2]&H;ia=c[1184+(b*960|0)+60>>2]&H;D=c[1184+(b*960|0)+64>>2]&H;ea=c[1184+(b*960|0)+68>>2]&H;F=c[1184+(b*960|0)+72>>2]&H;ga=c[1184+(b*960|0)+76>>2]&H;c[e>>2]=(c[1184+(b*960|0)+40>>2]^1)&H^1;c[f>>2]=A;c[W>>2]=z;c[U>>2]=w;c[S>>2]=B;c[Q>>2]=ia;c[O>>2]=D;c[M>>2]=ea;c[K>>2]=F;c[I>>2]=ga;ga=c[g>>2]|0;F=a+84|0;ea=c[F>>2]|0;D=a+88|0;ia=c[D>>2]|0;B=a+92|0;w=c[B>>2]|0;z=a+96|0;A=c[z>>2]|0;x=a+100|0;fa=c[x>>2]|0;v=a+104|0;ba=c[v>>2]|0;i=a+108|0;G=c[i>>2]|0;t=a+112|0;_=c[t>>2]|0;u=a+116|0;da=c[u>>2]|0;$=(c[1184+(b*960|0)+84>>2]^ea)&H;aa=(c[1184+(b*960|0)+88>>2]^ia)&H;y=(c[1184+(b*960|0)+92>>2]^w)&H;j=(c[1184+(b*960|0)+96>>2]^A)&H;ha=(c[1184+(b*960|0)+100>>2]^fa)&H;Z=(c[1184+(b*960|0)+104>>2]^ba)&H;ca=(c[1184+(b*960|0)+108>>2]^G)&H;C=(c[1184+(b*960|0)+112>>2]^_)&H;E=(c[1184+(b*960|0)+116>>2]^da)&H;c[g>>2]=(c[1184+(b*960|0)+80>>2]^ga)&H^ga;c[F>>2]=$^ea;c[D>>2]=aa^ia;c[B>>2]=y^w;c[z>>2]=j^A;c[x>>2]=ha^fa;c[v>>2]=Z^ba;c[i>>2]=ca^G;c[t>>2]=C^_;c[u>>2]=E^da;da=c[a>>2]|0;E=c[d>>2]|0;_=c[k>>2]|0;C=c[l>>2]|0;G=c[m>>2]|0;ca=c[n>>2]|0;ba=c[o>>2]|0;Z=c[p>>2]|0;fa=c[q>>2]|0;ha=c[r>>2]|0;A=(h^2)+-1>>31;j=(c[1184+(b*960|0)+124>>2]^E)&A;w=(c[1184+(b*960|0)+128>>2]^_)&A;y=(c[1184+(b*960|0)+132>>2]^C)&A;ia=(c[1184+(b*960|0)+136>>2]^G)&A;aa=(c[1184+(b*960|0)+140>>2]^ca)&A;ea=(c[1184+(b*960|0)+144>>2]^ba)&A;$=(c[1184+(b*960|0)+148>>2]^Z)&A;ga=(c[1184+(b*960|0)+152>>2]^fa)&A;H=(c[1184+(b*960|0)+156>>2]^ha)&A;c[a>>2]=(c[1184+(b*960|0)+120>>2]^da)&A^da;c[d>>2]=j^E;c[k>>2]=w^_;c[l>>2]=y^C;c[m>>2]=ia^G;c[n>>2]=aa^ca;c[o>>2]=ea^ba;c[p>>2]=$^Z;c[q>>2]=ga^fa;c[r>>2]=H^ha;ha=c[e>>2]|0;H=c[f>>2]|0;fa=c[W>>2]|0;ga=c[U>>2]|0;Z=c[S>>2]|0;$=c[Q>>2]|0;ba=c[O>>2]|0;ea=c[M>>2]|0;ca=c[K>>2]|0;aa=c[I>>2]|0;G=(c[1184+(b*960|0)+164>>2]^H)&A;ia=(c[1184+(b*960|0)+168>>2]^fa)&A;C=(c[1184+(b*960|0)+172>>2]^ga)&A;y=(c[1184+(b*960|0)+176>>2]^Z)&A;_=(c[1184+(b*960|0)+180>>2]^$)&A;w=(c[1184+(b*960|0)+184>>2]^ba)&A;E=(c[1184+(b*960|0)+188>>2]^ea)&A;j=(c[1184+(b*960|0)+192>>2]^ca)&A;da=(c[1184+(b*960|0)+196>>2]^aa)&A;c[e>>2]=(c[1184+(b*960|0)+160>>2]^ha)&A^ha;c[f>>2]=G^H;c[W>>2]=ia^fa;c[U>>2]=C^ga;c[S>>2]=y^Z;c[Q>>2]=_^$;c[O>>2]=w^ba;c[M>>2]=E^ea;c[K>>2]=j^ca;c[I>>2]=da^aa;aa=c[g>>2]|0;da=c[F>>2]|0;ca=c[D>>2]|0;j=c[B>>2]|0;ea=c[z>>2]|0;E=c[x>>2]|0;ba=c[v>>2]|0;w=c[i>>2]|0;$=c[t>>2]|0;_=c[u>>2]|0;Z=(c[1184+(b*960|0)+204>>2]^da)&A;y=(c[1184+(b*960|0)+208>>2]^ca)&A;ga=(c[1184+(b*960|0)+212>>2]^j)&A;C=(c[1184+(b*960|0)+216>>2]^ea)&A;fa=(c[1184+(b*960|0)+220>>2]^E)&A;ia=(c[1184+(b*960|0)+224>>2]^ba)&A;H=(c[1184+(b*960|0)+228>>2]^w)&A;G=(c[1184+(b*960|0)+232>>2]^$)&A;ha=(c[1184+(b*960|0)+236>>2]^_)&A;c[g>>2]=(c[1184+(b*960|0)+200>>2]^aa)&A^aa;c[F>>2]=Z^da;c[D>>2]=y^ca;c[B>>2]=ga^j;c[z>>2]=C^ea;c[x>>2]=fa^E;c[v>>2]=ia^ba;c[i>>2]=H^w;c[t>>2]=G^$;c[u>>2]=ha^_;_=c[a>>2]|0;ha=c[d>>2]|0;$=c[k>>2]|0;G=c[l>>2]|0;w=c[m>>2]|0;H=c[n>>2]|0;ba=c[o>>2]|0;ia=c[p>>2]|0;E=c[q>>2]|0;fa=c[r>>2]|0;ea=(h^3)+-1>>31;C=(c[1184+(b*960|0)+244>>2]^ha)&ea;j=(c[1184+(b*960|0)+248>>2]^$)&ea;ga=(c[1184+(b*960|0)+252>>2]^G)&ea;ca=(c[1184+(b*960|0)+256>>2]^w)&ea;y=(c[1184+(b*960|0)+260>>2]^H)&ea;da=(c[1184+(b*960|0)+264>>2]^ba)&ea;Z=(c[1184+(b*960|0)+268>>2]^ia)&ea;aa=(c[1184+(b*960|0)+272>>2]^E)&ea;A=(c[1184+(b*960|0)+276>>2]^fa)&ea;c[a>>2]=(c[1184+(b*960|0)+240>>2]^_)&ea^_;c[d>>2]=C^ha;c[k>>2]=j^$;c[l>>2]=ga^G;c[m>>2]=ca^w;c[n>>2]=y^H;c[o>>2]=da^ba;c[p>>2]=Z^ia;c[q>>2]=aa^E;c[r>>2]=A^fa;fa=c[e>>2]|0;A=c[f>>2]|0;E=c[W>>2]|0;aa=c[U>>2]|0;ia=c[S>>2]|0;Z=c[Q>>2]|0;ba=c[O>>2]|0;da=c[M>>2]|0;H=c[K>>2]|0;y=c[I>>2]|0;w=(c[1184+(b*960|0)+284>>2]^A)&ea;ca=(c[1184+(b*960|0)+288>>2]^E)&ea;G=(c[1184+(b*960|0)+292>>2]^aa)&ea;ga=(c[1184+(b*960|0)+296>>2]^ia)&ea;$=(c[1184+(b*960|0)+300>>2]^Z)&ea;j=(c[1184+(b*960|0)+304>>2]^ba)&ea;ha=(c[1184+(b*960|0)+308>>2]^da)&ea;C=(c[1184+(b*960|0)+312>>2]^H)&ea;_=(c[1184+(b*960|0)+316>>2]^y)&ea;c[e>>2]=(c[1184+(b*960|0)+280>>2]^fa)&ea^fa;c[f>>2]=w^A;c[W>>2]=ca^E;c[U>>2]=G^aa;c[S>>2]=ga^ia;c[Q>>2]=$^Z;c[O>>2]=j^ba;c[M>>2]=ha^da;c[K>>2]=C^H;c[I>>2]=_^y;y=c[g>>2]|0;_=c[F>>2]|0;H=c[D>>2]|0;C=c[B>>2]|0;da=c[z>>2]|0;ha=c[x>>2]|0;ba=c[v>>2]|0;j=c[i>>2]|0;Z=c[t>>2]|0;$=c[u>>2]|0;ia=(c[1184+(b*960|0)+324>>2]^_)&ea;ga=(c[1184+(b*960|0)+328>>2]^H)&ea;aa=(c[1184+(b*960|0)+332>>2]^C)&ea;G=(c[1184+(b*960|0)+336>>2]^da)&ea;E=(c[1184+(b*960|0)+340>>2]^ha)&ea;ca=(c[1184+(b*960|0)+344>>2]^ba)&ea;A=(c[1184+(b*960|0)+348>>2]^j)&ea;w=(c[1184+(b*960|0)+352>>2]^Z)&ea;fa=(c[1184+(b*960|0)+356>>2]^$)&ea;c[g>>2]=(c[1184+(b*960|0)+320>>2]^y)&ea^y;c[F>>2]=ia^_;c[D>>2]=ga^H;c[B>>2]=aa^C;c[z>>2]=G^da;c[x>>2]=E^ha;c[v>>2]=ca^ba;c[i>>2]=A^j;c[t>>2]=w^Z;c[u>>2]=fa^$;$=c[a>>2]|0;fa=c[d>>2]|0;Z=c[k>>2]|0;w=c[l>>2]|0;j=c[m>>2]|0;A=c[n>>2]|0;ba=c[o>>2]|0;ca=c[p>>2]|0;ha=c[q>>2]|0;E=c[r>>2]|0;da=(h^4)+-1>>31;G=(c[1184+(b*960|0)+364>>2]^fa)&da;C=(c[1184+(b*960|0)+368>>2]^Z)&da;aa=(c[1184+(b*960|0)+372>>2]^w)&da;H=(c[1184+(b*960|0)+376>>2]^j)&da;ga=(c[1184+(b*960|0)+380>>2]^A)&da;_=(c[1184+(b*960|0)+384>>2]^ba)&da;ia=(c[1184+(b*960|0)+388>>2]^ca)&da;y=(c[1184+(b*960|0)+392>>2]^ha)&da;ea=(c[1184+(b*960|0)+396>>2]^E)&da;c[a>>2]=(c[1184+(b*960|0)+360>>2]^$)&da^$;c[d>>2]=G^fa;c[k>>2]=C^Z;c[l>>2]=aa^w;c[m>>2]=H^j;c[n>>2]=ga^A;c[o>>2]=_^ba;c[p>>2]=ia^ca;c[q>>2]=y^ha;c[r>>2]=ea^E;E=c[e>>2]|0;ea=c[f>>2]|0;ha=c[W>>2]|0;y=c[U>>2]|0;ca=c[S>>2]|0;ia=c[Q>>2]|0;ba=c[O>>2]|0;_=c[M>>2]|0;A=c[K>>2]|0;ga=c[I>>2]|0;j=(c[1184+(b*960|0)+404>>2]^ea)&da;H=(c[1184+(b*960|0)+408>>2]^ha)&da;w=(c[1184+(b*960|0)+412>>2]^y)&da;aa=(c[1184+(b*960|0)+416>>2]^ca)&da;Z=(c[1184+(b*960|0)+420>>2]^ia)&da;C=(c[1184+(b*960|0)+424>>2]^ba)&da;fa=(c[1184+(b*960|0)+428>>2]^_)&da;G=(c[1184+(b*960|0)+432>>2]^A)&da;$=(c[1184+(b*960|0)+436>>2]^ga)&da;c[e>>2]=(c[1184+(b*960|0)+400>>2]^E)&da^E;c[f>>2]=j^ea;c[W>>2]=H^ha;c[U>>2]=w^y;c[S>>2]=aa^ca;c[Q>>2]=Z^ia;c[O>>2]=C^ba;c[M>>2]=fa^_;c[K>>2]=G^A;c[I>>2]=$^ga;ga=c[g>>2]|0;$=c[F>>2]|0;A=c[D>>2]|0;G=c[B>>2]|0;_=c[z>>2]|0;fa=c[x>>2]|0;ba=c[v>>2]|0;C=c[i>>2]|0;ia=c[t>>2]|0;Z=c[u>>2]|0;ca=(c[1184+(b*960|0)+444>>2]^$)&da;aa=(c[1184+(b*960|0)+448>>2]^A)&da;y=(c[1184+(b*960|0)+452>>2]^G)&da;w=(c[1184+(b*960|0)+456>>2]^_)&da;ha=(c[1184+(b*960|0)+460>>2]^fa)&da;H=(c[1184+(b*960|0)+464>>2]^ba)&da;ea=(c[1184+(b*960|0)+468>>2]^C)&da;j=(c[1184+(b*960|0)+472>>2]^ia)&da;E=(c[1184+(b*960|0)+476>>2]^Z)&da;c[g>>2]=(c[1184+(b*960|0)+440>>2]^ga)&da^ga;c[F>>2]=ca^$;c[D>>2]=aa^A;c[B>>2]=y^G;c[z>>2]=w^_;c[x>>2]=ha^fa;c[v>>2]=H^ba;c[i>>2]=ea^C;c[t>>2]=j^ia;c[u>>2]=E^Z;Z=c[a>>2]|0;E=c[d>>2]|0;ia=c[k>>2]|0;j=c[l>>2]|0;C=c[m>>2]|0;ea=c[n>>2]|0;ba=c[o>>2]|0;H=c[p>>2]|0;fa=c[q>>2]|0;ha=c[r>>2]|0;_=(h^5)+-1>>31;w=(c[1184+(b*960|0)+484>>2]^E)&_;G=(c[1184+(b*960|0)+488>>2]^ia)&_;y=(c[1184+(b*960|0)+492>>2]^j)&_;A=(c[1184+(b*960|0)+496>>2]^C)&_;aa=(c[1184+(b*960|0)+500>>2]^ea)&_;$=(c[1184+(b*960|0)+504>>2]^ba)&_;ca=(c[1184+(b*960|0)+508>>2]^H)&_;ga=(c[1184+(b*960|0)+512>>2]^fa)&_;da=(c[1184+(b*960|0)+516>>2]^ha)&_;c[a>>2]=(c[1184+(b*960|0)+480>>2]^Z)&_^Z;c[d>>2]=w^E;c[k>>2]=G^ia;c[l>>2]=y^j;c[m>>2]=A^C;c[n>>2]=aa^ea;c[o>>2]=$^ba;c[p>>2]=ca^H;c[q>>2]=ga^fa;c[r>>2]=da^ha;ha=c[e>>2]|0;da=c[f>>2]|0;fa=c[W>>2]|0;ga=c[U>>2]|0;H=c[S>>2]|0;ca=c[Q>>2]|0;ba=c[O>>2]|0;$=c[M>>2]|0;ea=c[K>>2]|0;aa=c[I>>2]|0;C=(c[1184+(b*960|0)+524>>2]^da)&_;A=(c[1184+(b*960|0)+528>>2]^fa)&_;j=(c[1184+(b*960|0)+532>>2]^ga)&_;y=(c[1184+(b*960|0)+536>>2]^H)&_;ia=(c[1184+(b*960|0)+540>>2]^ca)&_;G=(c[1184+(b*960|0)+544>>2]^ba)&_;E=(c[1184+(b*960|0)+548>>2]^$)&_;w=(c[1184+(b*960|0)+552>>2]^ea)&_;Z=(c[1184+(b*960|0)+556>>2]^aa)&_;c[e>>2]=(c[1184+(b*960|0)+520>>2]^ha)&_^ha;c[f>>2]=C^da;c[W>>2]=A^fa;c[U>>2]=j^ga;c[S>>2]=y^H;c[Q>>2]=ia^ca;c[O>>2]=G^ba;c[M>>2]=E^$;c[K>>2]=w^ea;c[I>>2]=Z^aa;aa=c[g>>2]|0;Z=c[F>>2]|0;ea=c[D>>2]|0;w=c[B>>2]|0;$=c[z>>2]|0;E=c[x>>2]|0;ba=c[v>>2]|0;G=c[i>>2]|0;ca=c[t>>2]|0;ia=c[u>>2]|0;H=(c[1184+(b*960|0)+564>>2]^Z)&_;y=(c[1184+(b*960|0)+568>>2]^ea)&_;ga=(c[1184+(b*960|0)+572>>2]^w)&_;j=(c[1184+(b*960|0)+576>>2]^$)&_;fa=(c[1184+(b*960|0)+580>>2]^E)&_;A=(c[1184+(b*960|0)+584>>2]^ba)&_;da=(c[1184+(b*960|0)+588>>2]^G)&_;C=(c[1184+(b*960|0)+592>>2]^ca)&_;ha=(c[1184+(b*960|0)+596>>2]^ia)&_;c[g>>2]=(c[1184+(b*960|0)+560>>2]^aa)&_^aa;c[F>>2]=H^Z;c[D>>2]=y^ea;c[B>>2]=ga^w;c[z>>2]=j^$;c[x>>2]=fa^E;c[v>>2]=A^ba;c[i>>2]=da^G;c[t>>2]=C^ca;c[u>>2]=ha^ia;ia=c[a>>2]|0;ha=c[d>>2]|0;ca=c[k>>2]|0;C=c[l>>2]|0;G=c[m>>2]|0;da=c[n>>2]|0;ba=c[o>>2]|0;A=c[p>>2]|0;E=c[q>>2]|0;fa=c[r>>2]|0;$=(h^6)+-1>>31;j=(c[1184+(b*960|0)+604>>2]^ha)&$;w=(c[1184+(b*960|0)+608>>2]^ca)&$;ga=(c[1184+(b*960|0)+612>>2]^C)&$;ea=(c[1184+(b*960|0)+616>>2]^G)&$;y=(c[1184+(b*960|0)+620>>2]^da)&$;Z=(c[1184+(b*960|0)+624>>2]^ba)&$;H=(c[1184+(b*960|0)+628>>2]^A)&$;aa=(c[1184+(b*960|0)+632>>2]^E)&$;_=(c[1184+(b*960|0)+636>>2]^fa)&$;c[a>>2]=(c[1184+(b*960|0)+600>>2]^ia)&$^ia;c[d>>2]=j^ha;c[k>>2]=w^ca;c[l>>2]=ga^C;c[m>>2]=ea^G;c[n>>2]=y^da;c[o>>2]=Z^ba;c[p>>2]=H^A;c[q>>2]=aa^E;c[r>>2]=_^fa;fa=c[e>>2]|0;_=c[f>>2]|0;E=c[W>>2]|0;aa=c[U>>2]|0;A=c[S>>2]|0;H=c[Q>>2]|0;ba=c[O>>2]|0;Z=c[M>>2]|0;da=c[K>>2]|0;y=c[I>>2]|0;G=(c[1184+(b*960|0)+644>>2]^_)&$;ea=(c[1184+(b*960|0)+648>>2]^E)&$;C=(c[1184+(b*960|0)+652>>2]^aa)&$;ga=(c[1184+(b*960|0)+656>>2]^A)&$;ca=(c[1184+(b*960|0)+660>>2]^H)&$;w=(c[1184+(b*960|0)+664>>2]^ba)&$;ha=(c[1184+(b*960|0)+668>>2]^Z)&$;j=(c[1184+(b*960|0)+672>>2]^da)&$;ia=(c[1184+(b*960|0)+676>>2]^y)&$;c[e>>2]=(c[1184+(b*960|0)+640>>2]^fa)&$^fa;c[f>>2]=G^_;c[W>>2]=ea^E;c[U>>2]=C^aa;c[S>>2]=ga^A;c[Q>>2]=ca^H;c[O>>2]=w^ba;c[M>>2]=ha^Z;c[K>>2]=j^da;c[I>>2]=ia^y;y=c[g>>2]|0;ia=c[F>>2]|0;da=c[D>>2]|0;j=c[B>>2]|0;Z=c[z>>2]|0;ha=c[x>>2]|0;ba=c[v>>2]|0;w=c[i>>2]|0;H=c[t>>2]|0;ca=c[u>>2]|0;A=(c[1184+(b*960|0)+684>>2]^ia)&$;ga=(c[1184+(b*960|0)+688>>2]^da)&$;aa=(c[1184+(b*960|0)+692>>2]^j)&$;C=(c[1184+(b*960|0)+696>>2]^Z)&$;E=(c[1184+(b*960|0)+700>>2]^ha)&$;ea=(c[1184+(b*960|0)+704>>2]^ba)&$;_=(c[1184+(b*960|0)+708>>2]^w)&$;G=(c[1184+(b*960|0)+712>>2]^H)&$;fa=(c[1184+(b*960|0)+716>>2]^ca)&$;c[g>>2]=(c[1184+(b*960|0)+680>>2]^y)&$^y;c[F>>2]=A^ia;c[D>>2]=ga^da;c[B>>2]=aa^j;c[z>>2]=C^Z;c[x>>2]=E^ha;c[v>>2]=ea^ba;c[i>>2]=_^w;c[t>>2]=G^H;c[u>>2]=fa^ca;ca=c[a>>2]|0;fa=c[d>>2]|0;H=c[k>>2]|0;G=c[l>>2]|0;w=c[m>>2]|0;_=c[n>>2]|0;ba=c[o>>2]|0;ea=c[p>>2]|0;ha=c[q>>2]|0;E=c[r>>2]|0;Z=(h^7)+-1>>31;C=(c[1184+(b*960|0)+724>>2]^fa)&Z;j=(c[1184+(b*960|0)+728>>2]^H)&Z;aa=(c[1184+(b*960|0)+732>>2]^G)&Z;da=(c[1184+(b*960|0)+736>>2]^w)&Z;ga=(c[1184+(b*960|0)+740>>2]^_)&Z;ia=(c[1184+(b*960|0)+744>>2]^ba)&Z;A=(c[1184+(b*960|0)+748>>2]^ea)&Z;y=(c[1184+(b*960|0)+752>>2]^ha)&Z;$=(c[1184+(b*960|0)+756>>2]^E)&Z;c[a>>2]=(c[1184+(b*960|0)+720>>2]^ca)&Z^ca;c[d>>2]=C^fa;c[k>>2]=j^H;c[l>>2]=aa^G;c[m>>2]=da^w;c[n>>2]=ga^_;c[o>>2]=ia^ba;c[p>>2]=A^ea;c[q>>2]=y^ha;c[r>>2]=$^E;E=c[e>>2]|0;$=c[f>>2]|0;ha=c[W>>2]|0;y=c[U>>2]|0;ea=c[S>>2]|0;A=c[Q>>2]|0;ba=c[O>>2]|0;ia=c[M>>2]|0;_=c[K>>2]|0;ga=c[I>>2]|0;w=(c[1184+(b*960|0)+764>>2]^$)&Z;da=(c[1184+(b*960|0)+768>>2]^ha)&Z;G=(c[1184+(b*960|0)+772>>2]^y)&Z;aa=(c[1184+(b*960|0)+776>>2]^ea)&Z;H=(c[1184+(b*960|0)+780>>2]^A)&Z;j=(c[1184+(b*960|0)+784>>2]^ba)&Z;fa=(c[1184+(b*960|0)+788>>2]^ia)&Z;C=(c[1184+(b*960|0)+792>>2]^_)&Z;ca=(c[1184+(b*960|0)+796>>2]^ga)&Z;c[e>>2]=(c[1184+(b*960|0)+760>>2]^E)&Z^E;c[f>>2]=w^$;c[W>>2]=da^ha;c[U>>2]=G^y;c[S>>2]=aa^ea;c[Q>>2]=H^A;c[O>>2]=j^ba;c[M>>2]=fa^ia;c[K>>2]=C^_;c[I>>2]=ca^ga;ga=c[g>>2]|0;ca=c[F>>2]|0;_=c[D>>2]|0;C=c[B>>2]|0;ia=c[z>>2]|0;fa=c[x>>2]|0;ba=c[v>>2]|0;j=c[i>>2]|0;A=c[t>>2]|0;H=c[u>>2]|0;ea=(c[1184+(b*960|0)+804>>2]^ca)&Z;aa=(c[1184+(b*960|0)+808>>2]^_)&Z;y=(c[1184+(b*960|0)+812>>2]^C)&Z;G=(c[1184+(b*960|0)+816>>2]^ia)&Z;ha=(c[1184+(b*960|0)+820>>2]^fa)&Z;da=(c[1184+(b*960|0)+824>>2]^ba)&Z;$=(c[1184+(b*960|0)+828>>2]^j)&Z;w=(c[1184+(b*960|0)+832>>2]^A)&Z;E=(c[1184+(b*960|0)+836>>2]^H)&Z;c[g>>2]=(c[1184+(b*960|0)+800>>2]^ga)&Z^ga;c[F>>2]=ea^ca;c[D>>2]=aa^_;c[B>>2]=y^C;c[z>>2]=G^ia;c[x>>2]=ha^fa;c[v>>2]=da^ba;c[i>>2]=$^j;c[t>>2]=w^A;c[u>>2]=E^H;H=c[a>>2]|0;E=c[d>>2]|0;A=c[k>>2]|0;w=c[l>>2]|0;j=c[m>>2]|0;$=c[n>>2]|0;ba=c[o>>2]|0;da=c[p>>2]|0;fa=c[q>>2]|0;ha=c[r>>2]|0;ia=(h^8)+-1>>31;G=(c[1184+(b*960|0)+844>>2]^E)&ia;C=(c[1184+(b*960|0)+848>>2]^A)&ia;y=(c[1184+(b*960|0)+852>>2]^w)&ia;h=(c[1184+(b*960|0)+856>>2]^j)&ia;_=(c[1184+(b*960|0)+860>>2]^$)&ia;aa=(c[1184+(b*960|0)+864>>2]^ba)&ia;ca=(c[1184+(b*960|0)+868>>2]^da)&ia;ea=(c[1184+(b*960|0)+872>>2]^fa)&ia;ga=(c[1184+(b*960|0)+876>>2]^ha)&ia;c[a>>2]=(c[1184+(b*960|0)+840>>2]^H)&ia^H;c[d>>2]=G^E;c[k>>2]=C^A;c[l>>2]=y^w;c[m>>2]=h^j;c[n>>2]=_^$;c[o>>2]=aa^ba;c[p>>2]=ca^da;c[q>>2]=ea^fa;c[r>>2]=ga^ha;ha=c[e>>2]|0;ga=c[f>>2]|0;fa=c[W>>2]|0;ea=c[U>>2]|0;da=c[S>>2]|0;ca=c[Q>>2]|0;ba=c[O>>2]|0;aa=c[M>>2]|0;$=c[K>>2]|0;_=c[I>>2]|0;j=(c[1184+(b*960|0)+884>>2]^ga)&ia;h=(c[1184+(b*960|0)+888>>2]^fa)&ia;w=(c[1184+(b*960|0)+892>>2]^ea)&ia;y=(c[1184+(b*960|0)+896>>2]^da)&ia;A=(c[1184+(b*960|0)+900>>2]^ca)&ia;C=(c[1184+(b*960|0)+904>>2]^ba)&ia;E=(c[1184+(b*960|0)+908>>2]^aa)&ia;G=(c[1184+(b*960|0)+912>>2]^$)&ia;H=(c[1184+(b*960|0)+916>>2]^_)&ia;ha=(c[1184+(b*960|0)+880>>2]^ha)&ia^ha;c[e>>2]=ha;ga=j^ga;c[f>>2]=ga;fa=h^fa;c[W>>2]=fa;ea=w^ea;c[U>>2]=ea;da=y^da;c[S>>2]=da;ca=A^ca;c[Q>>2]=ca;ba=C^ba;c[O>>2]=ba;aa=E^aa;c[M>>2]=aa;$=G^$;c[K>>2]=$;_=H^_;c[I>>2]=_;H=c[g>>2]|0;G=c[F>>2]|0;E=c[D>>2]|0;C=c[B>>2]|0;A=c[z>>2]|0;y=c[x>>2]|0;w=c[v>>2]|0;h=c[i>>2]|0;j=c[t>>2]|0;Z=c[u>>2]|0;J=(c[1184+(b*960|0)+924>>2]^G)&ia;L=(c[1184+(b*960|0)+928>>2]^E)&ia;N=(c[1184+(b*960|0)+932>>2]^C)&ia;P=(c[1184+(b*960|0)+936>>2]^A)&ia;R=(c[1184+(b*960|0)+940>>2]^y)&ia;T=(c[1184+(b*960|0)+944>>2]^w)&ia;V=(c[1184+(b*960|0)+948>>2]^h)&ia;X=(c[1184+(b*960|0)+952>>2]^j)&ia;Y=(c[1184+(b*960|0)+956>>2]^Z)&ia;H=(c[1184+(b*960|0)+920>>2]^H)&ia^H;c[g>>2]=H;G=J^G;c[F>>2]=G;E=L^E;c[D>>2]=E;C=N^C;c[B>>2]=C;A=P^A;c[z>>2]=A;y=R^y;c[x>>2]=y;w=T^w;c[v>>2]=w;h=V^h;c[i>>2]=h;j=X^j;c[t>>2]=j;b=Y^Z;c[u>>2]=b;Z=c[a>>2]|0;Y=c[d>>2]|0;X=c[k>>2]|0;V=c[l>>2]|0;T=c[m>>2]|0;R=c[n>>2]|0;P=c[o>>2]|0;N=c[p>>2]|0;L=c[q>>2]|0;J=c[r>>2]|0;c[a>>2]=(ha^Z)&s^Z;c[d>>2]=(ga^Y)&s^Y;c[k>>2]=(fa^X)&s^X;c[l>>2]=(ea^V)&s^V;c[m>>2]=(da^T)&s^T;c[n>>2]=(ca^R)&s^R;c[o>>2]=(ba^P)&s^P;c[p>>2]=(aa^N)&s^N;c[q>>2]=($^L)&s^L;c[r>>2]=(_^J)&s^J;d=c[e>>2]|0;a=c[f>>2]|0;r=c[W>>2]|0;q=c[U>>2]|0;p=c[S>>2]|0;o=c[Q>>2]|0;n=c[O>>2]|0;m=c[M>>2]|0;l=c[K>>2]|0;k=c[I>>2]|0;c[e>>2]=(Z^d)&s^d;c[f>>2]=(Y^a)&s^a;c[W>>2]=(X^r)&s^r;c[U>>2]=(V^q)&s^q;c[S>>2]=(T^p)&s^p;c[Q>>2]=(R^o)&s^o;c[O>>2]=(P^n)&s^n;c[M>>2]=(N^m)&s^m;c[K>>2]=(L^l)&s^l;c[I>>2]=(J^k)&s^k;f=c[g>>2]|0;k=c[F>>2]|0;l=c[D>>2]|0;m=c[B>>2]|0;n=c[z>>2]|0;o=c[x>>2]|0;p=c[v>>2]|0;q=c[i>>2]|0;r=c[t>>2]|0;a=c[u>>2]|0;c[g>>2]=(f^0-H)&s^f;c[F>>2]=(k^0-G)&s^k;c[D>>2]=(l^0-E)&s^l;c[B>>2]=(m^0-C)&s^m;c[z>>2]=(n^0-A)&s^n;c[x>>2]=(o^0-y)&s^o;c[v>>2]=(p^0-w)&s^p;c[i>>2]=(q^0-h)&s^q;c[t>>2]=(r^0-j)&s^r;c[u>>2]=(a^0-b)&s^a;return}function Tc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;g=i;e=i=i+63&-64;i=i+240|0;d=e+80|0;f=e+40|0;if(Nc(d,b)|0){f=-1;i=g;return f|0}y=e+4|0;c[y>>2]=0;c[y+4>>2]=0;c[y+8>>2]=0;c[y+12>>2]=0;c[y+16>>2]=0;c[y+20>>2]=0;c[y+24>>2]=0;c[y+28>>2]=0;q=d+40|0;p=d+44|0;n=d+48|0;m=d+52|0;l=d+56|0;k=d+60|0;j=d+64|0;h=d+68|0;r=d+72|0;b=d+76|0;z=0-(c[p>>2]|0)|0;x=0-(c[n>>2]|0)|0;w=0-(c[m>>2]|0)|0;v=0-(c[l>>2]|0)|0;u=0-(c[k>>2]|0)|0;t=0-(c[j>>2]|0)|0;s=0-(c[h>>2]|0)|0;d=0-(c[r>>2]|0)|0;o=0-(c[b>>2]|0)|0;c[e>>2]=1-(c[q>>2]|0);c[y>>2]=z;c[e+8>>2]=x;c[e+12>>2]=w;c[e+16>>2]=v;c[e+20>>2]=u;c[e+24>>2]=t;c[e+28>>2]=s;c[e+32>>2]=d;c[e+36>>2]=o;Ic(e,e);o=f+4|0;c[o>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;c[o+16>>2]=0;c[o+20>>2]=0;c[o+24>>2]=0;c[o+28>>2]=0;p=c[p>>2]|0;n=c[n>>2]|0;m=c[m>>2]|0;l=c[l>>2]|0;k=c[k>>2]|0;j=c[j>>2]|0;h=c[h>>2]|0;d=c[r>>2]|0;b=c[b>>2]|0;c[f>>2]=(c[q>>2]|0)+1;c[o>>2]=p;c[f+8>>2]=n;c[f+12>>2]=m;c[f+16>>2]=l;c[f+20>>2]=k;c[f+24>>2]=j;c[f+28>>2]=h;c[f+32>>2]=d;c[f+36>>2]=b;Jc(f,f,e);Lc(a,f);f=0;i=g;return f|0}function Uc(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;k=i;g=i=i+63&-64;i=i+272|0;h=g;g=g+208|0;f=h+64|0;j=h;l=8;m=j+64|0;do{c[j>>2]=c[l>>2];j=j+4|0;l=l+4|0}while((j|0)<(m|0));j=h+72|0;c[j>>2]=256;c[j+4>>2]=0;j=f;c[j>>2]=0;c[j+4>>2]=0;j=h+80|0;l=e;m=j+32|0;do{a[j>>0]=a[l>>0]|0;j=j+1|0;l=l+1|0}while((j|0)<(m|0));Gb(h,g);a[g>>0]=(d[g>>0]|0)&248;j=g+31|0;a[j>>0]=(d[j>>0]|0)&63|64;j=b;l=g;m=j+32|0;do{a[j>>0]=a[l>>0]|0;j=j+1|0;l=l+1|0}while((j|0)<(m|0));i=k;return 0}function Vc(b,e,f,g,h){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0;Qa=i;j=i=i+63&-64;i=i+3024|0;Ma=j+2800|0;Na=j+2544|0;Oa=j+2288|0;k=j+2248|0;Ja=j+968|0;Ka=j+808|0;La=j+648|0;t=j+488|0;n=j;p=j+2952|0;Pa=j+2920|0;s=j+328|0;j=j+208|0;if((d[b+63>>0]|0)>31){b=-1;i=Qa;return b|0}if(Nc(s,h)|0){b=-1;i=Qa;return b|0}if(!((a[h+31>>0]|(a[h+30>>0]|(a[h+29>>0]|(a[h+28>>0]|(a[h+27>>0]|(a[h+26>>0]|(a[h+25>>0]|(a[h+24>>0]|(a[h+23>>0]|(a[h+22>>0]|(a[h+21>>0]|(a[h+20>>0]|(a[h+19>>0]|(a[h+18>>0]|(a[h+17>>0]|(a[h+16>>0]|(a[h+15>>0]|(a[h+14>>0]|(a[h+13>>0]|(a[h+12>>0]|(a[h+11>>0]|(a[h+10>>0]|(a[h+9>>0]|(a[h+8>>0]|(a[h+7>>0]|(a[h+6>>0]|(a[h+5>>0]|(a[h+4>>0]|(a[h+3>>0]|(a[h+2>>0]|(a[h+1>>0]|a[h>>0])))))))))))))))))))))))))))))))<<24>>24)){b=-1;i=Qa;return b|0}l=n+64|0;q=l;c[q>>2]=0;c[q+4>>2]=0;q=n;o=8;r=q+64|0;do{c[q>>2]=c[o>>2];q=q+4|0;o=o+4|0}while((q|0)<(r|0));m=n+72|0;q=m;c[q>>2]=256;c[q+4>>2]=0;q=l;c[q>>2]=0;c[q+4>>2]=0;q=n+80|0;o=b;r=q+32|0;do{a[q>>0]=a[o>>0]|0;q=q+1|0;o=o+1|0}while((q|0)<(r|0));q=m;c[q>>2]=512;c[q+4>>2]=0;q=l;c[q>>2]=0;c[q+4>>2]=0;q=n+112|0;o=h;r=q+32|0;do{a[q>>0]=a[o>>0]|0;q=q+1|0;o=o+1|0}while((q|0)<(r|0));Fb(n,e,f,g);Gb(n,p);Wc(p);f=0;do{a[Na+f>>0]=(d[p+(f>>3)>>0]|0)>>>(f&7)&1;f=f+1|0}while((f|0)!=256);p=b+32|0;o=0;while(1){e=Na+o|0;a:do if(a[e>>0]|0){h=1;do{g=h+o|0;if((g|0)>=256)break a;m=Na+g|0;f=a[m>>0]|0;b:do if(f<<24>>24){n=a[e>>0]|0;f=f<<24>>24<<h;l=n+f|0;if((l|0)<16){a[e>>0]=l;a[m>>0]=0;break}f=n-f|0;if((f|0)<=-16)break a;a[e>>0]=f;while(1){f=Na+g|0;if(!(a[f>>0]|0))break;a[f>>0]=0;g=g+1|0;if((g|0)>=256)break b}a[f>>0]=1}while(0);h=h+1|0}while((h|0)<7)}while(0);o=o+1|0;if((o|0)==256){f=0;break}}do{a[Oa+f>>0]=(d[p+(f>>3)>>0]|0)>>>(f&7)&1;f=f+1|0}while((f|0)!=256);o=0;do{e=Oa+o|0;c:do if(a[e>>0]|0){h=1;do{g=h+o|0;if((g|0)>=256)break c;m=Oa+g|0;f=a[m>>0]|0;d:do if(f<<24>>24){n=a[e>>0]|0;f=f<<24>>24<<h;l=n+f|0;if((l|0)<16){a[e>>0]=l;a[m>>0]=0;break}f=n-f|0;if((f|0)<=-16)break c;a[e>>0]=f;while(1){f=Oa+g|0;if(!(a[f>>0]|0))break;a[f>>0]=0;g=g+1|0;if((g|0)>=256)break d}a[f>>0]=1}while(0);h=h+1|0}while((h|0)<7)}while(0);o=o+1|0}while((o|0)!=256);Qc(Ja,s);Ia=c[s+4>>2]|0;r=c[s+8>>2]|0;q=c[s+12>>2]|0;Ga=c[s+16>>2]|0;Fa=c[s+20>>2]|0;Ea=c[s+24>>2]|0;Da=c[s+28>>2]|0;Ca=c[s+32>>2]|0;Ba=c[s+36>>2]|0;c[Ma>>2]=c[s>>2];c[Ma+4>>2]=Ia;c[Ma+8>>2]=r;c[Ma+12>>2]=q;c[Ma+16>>2]=Ga;c[Ma+20>>2]=Fa;c[Ma+24>>2]=Ea;c[Ma+28>>2]=Da;c[Ma+32>>2]=Ca;c[Ma+36>>2]=Ba;Ba=c[s+44>>2]|0;Ca=c[s+48>>2]|0;Da=c[s+52>>2]|0;Ea=c[s+56>>2]|0;Fa=c[s+60>>2]|0;Ga=c[s+64>>2]|0;q=c[s+68>>2]|0;r=c[s+72>>2]|0;Ia=c[s+76>>2]|0;c[Ma+40>>2]=c[s+40>>2];c[Ma+44>>2]=Ba;c[Ma+48>>2]=Ca;c[Ma+52>>2]=Da;c[Ma+56>>2]=Ea;c[Ma+60>>2]=Fa;c[Ma+64>>2]=Ga;c[Ma+68>>2]=q;c[Ma+72>>2]=r;c[Ma+76>>2]=Ia;Ia=c[s+84>>2]|0;r=c[s+88>>2]|0;q=c[s+92>>2]|0;Ga=c[s+96>>2]|0;Fa=c[s+100>>2]|0;Ea=c[s+104>>2]|0;Da=c[s+108>>2]|0;Ca=c[s+112>>2]|0;Ba=c[s+116>>2]|0;c[Ma+80>>2]=c[s+80>>2];c[Ma+84>>2]=Ia;c[Ma+88>>2]=r;c[Ma+92>>2]=q;c[Ma+96>>2]=Ga;c[Ma+100>>2]=Fa;c[Ma+104>>2]=Ea;c[Ma+108>>2]=Da;c[Ma+112>>2]=Ca;c[Ma+116>>2]=Ba;Pc(Ka,Ma);Ba=Ka+120|0;Jc(t,Ka,Ba);Ca=Ka+40|0;Da=Ka+80|0;Jc(t+40|0,Ca,Da);Jc(t+80|0,Da,Ba);Jc(t+120|0,Ka,Ca);Mc(Ka,t,Ja);Jc(La,Ka,Ba);Ea=La+40|0;Jc(Ea,Ca,Da);Fa=La+80|0;Jc(Fa,Da,Ba);Ga=La+120|0;Jc(Ga,Ka,Ca);q=Ja+160|0;Qc(q,La);Mc(Ka,t,q);Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);q=Ja+320|0;Qc(q,La);Mc(Ka,t,q);Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);q=Ja+480|0;Qc(q,La);Mc(Ka,t,q);Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);q=Ja+640|0;Qc(q,La);Mc(Ka,t,q);Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);q=Ja+800|0;Qc(q,La);Mc(Ka,t,q);Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);q=Ja+960|0;Qc(q,La);Mc(Ka,t,q);Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);Qc(Ja+1120|0,La);q=j;r=q+40|0;do{c[q>>2]=0;q=q+4|0}while((q|0)<(r|0));Ha=j+40|0;c[Ha>>2]=1;q=j+44|0;r=q+36|0;do{c[q>>2]=0;q=q+4|0}while((q|0)<(r|0));Ia=j+80|0;c[Ia>>2]=1;q=j+84|0;r=q+36|0;do{c[q>>2]=0;q=q+4|0}while((q|0)<(r|0));g=255;while(1){if(a[Na+g>>0]|0){f=g;break}if(a[Oa+g>>0]|0){f=g;break}f=g+-1|0;if((g|0)>0)g=f;else break}if((f|0)>-1){l=La+44|0;m=La+48|0;n=La+52|0;e=La+56|0;h=La+60|0;o=La+64|0;p=La+68|0;q=La+72|0;r=La+76|0;s=La+4|0;t=La+8|0;u=La+12|0;v=La+16|0;w=La+20|0;x=La+24|0;y=La+28|0;z=La+32|0;A=La+36|0;B=Ka+4|0;C=Ka+8|0;D=Ka+12|0;E=Ka+16|0;F=Ka+20|0;G=Ka+24|0;H=Ka+28|0;I=Ka+32|0;J=Ka+36|0;K=Ka+44|0;L=Ka+48|0;M=Ka+52|0;N=Ka+56|0;O=Ka+60|0;P=Ka+64|0;Q=Ka+68|0;R=Ka+72|0;S=Ka+76|0;T=La+84|0;U=La+88|0;V=La+92|0;W=La+96|0;X=La+100|0;Y=La+104|0;Z=La+108|0;_=La+112|0;$=La+116|0;aa=k+4|0;ba=k+8|0;ca=k+12|0;da=k+16|0;ea=k+20|0;fa=k+24|0;ga=k+28|0;ha=k+32|0;ia=k+36|0;ja=Ka+84|0;ka=Ka+88|0;la=Ka+92|0;ma=Ka+96|0;na=Ka+100|0;oa=Ka+104|0;pa=Ka+108|0;qa=Ka+112|0;ra=Ka+116|0;sa=Ka+124|0;ta=Ka+128|0;ua=Ka+132|0;va=Ka+136|0;wa=Ka+140|0;xa=Ka+144|0;ya=Ka+148|0;za=Ka+152|0;Aa=Ka+156|0;while(1){Pc(Ka,j);g=a[Na+f>>0]|0;if(g<<24>>24<=0){if(g<<24>>24<0){Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);hb=(g<<24>>24|0)/-2|0;rb=c[Ea>>2]|0;Xa=c[l>>2]|0;Ta=c[m>>2]|0;ib=c[n>>2]|0;mb=c[e>>2]|0;qb=c[h>>2]|0;$a=c[o>>2]|0;bb=c[p>>2]|0;db=c[q>>2]|0;fb=c[r>>2]|0;Za=c[La>>2]|0;Va=c[s>>2]|0;Ra=c[t>>2]|0;kb=c[u>>2]|0;ob=c[v>>2]|0;_a=c[w>>2]|0;ab=c[x>>2]|0;cb=c[y>>2]|0;eb=c[z>>2]|0;gb=c[A>>2]|0;c[Ka>>2]=Za+rb;c[B>>2]=Va+Xa;c[C>>2]=Ra+Ta;c[D>>2]=kb+ib;c[E>>2]=ob+mb;c[F>>2]=_a+qb;c[G>>2]=ab+$a;c[H>>2]=cb+bb;c[I>>2]=eb+db;c[J>>2]=gb+fb;c[Ca>>2]=rb-Za;c[K>>2]=Xa-Va;c[L>>2]=Ta-Ra;c[M>>2]=ib-kb;c[N>>2]=mb-ob;c[O>>2]=qb-_a;c[P>>2]=$a-ab;c[Q>>2]=bb-cb;c[R>>2]=db-eb;c[S>>2]=fb-gb;Jc(Da,Ka,Ja+(hb*160|0)+40|0);Jc(Ca,Ca,Ja+(hb*160|0)|0);Jc(Ba,Ja+(hb*160|0)+120|0,Ga);Jc(Ka,Fa,Ja+(hb*160|0)+80|0);hb=c[Ka>>2]<<1;gb=c[B>>2]<<1;fb=c[C>>2]<<1;eb=c[D>>2]<<1;db=c[E>>2]<<1;cb=c[F>>2]<<1;bb=c[G>>2]<<1;ab=c[H>>2]<<1;$a=c[I>>2]<<1;_a=c[J>>2]<<1;c[k>>2]=hb;c[aa>>2]=gb;c[ba>>2]=fb;c[ca>>2]=eb;c[da>>2]=db;c[ea>>2]=cb;c[fa>>2]=bb;c[ga>>2]=ab;c[ha>>2]=$a;c[ia>>2]=_a;qb=c[Da>>2]|0;ob=c[ja>>2]|0;mb=c[ka>>2]|0;kb=c[la>>2]|0;ib=c[ma>>2]|0;Ra=c[na>>2]|0;Ta=c[oa>>2]|0;Va=c[pa>>2]|0;Xa=c[qa>>2]|0;Za=c[ra>>2]|0;rb=c[Ca>>2]|0;pb=c[K>>2]|0;nb=c[L>>2]|0;lb=c[M>>2]|0;jb=c[N>>2]|0;g=c[O>>2]|0;Sa=c[P>>2]|0;Ua=c[Q>>2]|0;Wa=c[R>>2]|0;Ya=c[S>>2]|0;c[Ka>>2]=qb-rb;c[B>>2]=ob-pb;c[C>>2]=mb-nb;c[D>>2]=kb-lb;c[E>>2]=ib-jb;c[F>>2]=Ra-g;c[G>>2]=Ta-Sa;c[H>>2]=Va-Ua;c[I>>2]=Xa-Wa;c[J>>2]=Za-Ya;c[Ca>>2]=rb+qb;c[K>>2]=pb+ob;c[L>>2]=nb+mb;c[M>>2]=lb+kb;c[N>>2]=jb+ib;c[O>>2]=g+Ra;c[P>>2]=Sa+Ta;c[Q>>2]=Ua+Va;c[R>>2]=Wa+Xa;c[S>>2]=Ya+Za;Za=c[Ba>>2]|0;Ya=c[sa>>2]|0;Xa=c[ta>>2]|0;Wa=c[ua>>2]|0;Va=c[va>>2]|0;Ua=c[wa>>2]|0;Ta=c[xa>>2]|0;Sa=c[ya>>2]|0;Ra=c[za>>2]|0;g=c[Aa>>2]|0;c[Da>>2]=hb-Za;c[ja>>2]=gb-Ya;c[ka>>2]=fb-Xa;c[la>>2]=eb-Wa;c[ma>>2]=db-Va;c[na>>2]=cb-Ua;c[oa>>2]=bb-Ta;c[pa>>2]=ab-Sa;c[qa>>2]=$a-Ra;c[ra>>2]=_a-g;Ya=Ya+(c[aa>>2]|0)|0;Xa=Xa+(c[ba>>2]|0)|0;Wa=Wa+(c[ca>>2]|0)|0;Va=Va+(c[da>>2]|0)|0;Ua=Ua+(c[ea>>2]|0)|0;Ta=Ta+(c[fa>>2]|0)|0;Sa=Sa+(c[ga>>2]|0)|0;Ra=Ra+(c[ha>>2]|0)|0;g=g+(c[ia>>2]|0)|0;c[Ba>>2]=Za+(c[k>>2]|0);c[sa>>2]=Ya;c[ta>>2]=Xa;c[ua>>2]=Wa;c[va>>2]=Va;c[wa>>2]=Ua;c[xa>>2]=Ta;c[ya>>2]=Sa;c[za>>2]=Ra;c[Aa>>2]=g}}else{Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);Mc(Ka,La,Ja+(((g<<24>>24|0)/2|0)*160|0)|0)}g=a[Oa+f>>0]|0;if(g<<24>>24<=0){if(g<<24>>24<0){Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);_a=(g<<24>>24|0)/-2|0;g=c[Ea>>2]|0;kb=c[l>>2]|0;ob=c[m>>2]|0;Za=c[n>>2]|0;Va=c[e>>2]|0;Ra=c[h>>2]|0;gb=c[o>>2]|0;eb=c[p>>2]|0;cb=c[q>>2]|0;ab=c[r>>2]|0;ib=c[La>>2]|0;mb=c[s>>2]|0;qb=c[t>>2]|0;Xa=c[u>>2]|0;Ta=c[v>>2]|0;hb=c[w>>2]|0;fb=c[x>>2]|0;db=c[y>>2]|0;bb=c[z>>2]|0;$a=c[A>>2]|0;c[Ka>>2]=ib+g;c[B>>2]=mb+kb;c[C>>2]=qb+ob;c[D>>2]=Xa+Za;c[E>>2]=Ta+Va;c[F>>2]=hb+Ra;c[G>>2]=fb+gb;c[H>>2]=db+eb;c[I>>2]=bb+cb;c[J>>2]=$a+ab;c[Ca>>2]=g-ib;c[K>>2]=kb-mb;c[L>>2]=ob-qb;c[M>>2]=Za-Xa;c[N>>2]=Va-Ta;c[O>>2]=Ra-hb;c[P>>2]=gb-fb;c[Q>>2]=eb-db;c[R>>2]=cb-bb;c[S>>2]=ab-$a;Jc(Da,Ka,104+(_a*120|0)+40|0);Jc(Ca,Ca,104+(_a*120|0)|0);Jc(Ba,104+(_a*120|0)+80|0,Ga);_a=c[Fa>>2]<<1;$a=c[T>>2]<<1;ab=c[U>>2]<<1;bb=c[V>>2]<<1;cb=c[W>>2]<<1;db=c[X>>2]<<1;eb=c[Y>>2]<<1;fb=c[Z>>2]<<1;gb=c[_>>2]<<1;hb=c[$>>2]<<1;c[k>>2]=_a;c[aa>>2]=$a;c[ba>>2]=ab;c[ca>>2]=bb;c[da>>2]=cb;c[ea>>2]=db;c[fa>>2]=eb;c[ga>>2]=fb;c[ha>>2]=gb;c[ia>>2]=hb;Ra=c[Da>>2]|0;Ta=c[ja>>2]|0;Va=c[ka>>2]|0;Xa=c[la>>2]|0;Za=c[ma>>2]|0;qb=c[na>>2]|0;ob=c[oa>>2]|0;mb=c[pa>>2]|0;kb=c[qa>>2]|0;ib=c[ra>>2]|0;g=c[Ca>>2]|0;Sa=c[K>>2]|0;Ua=c[L>>2]|0;Wa=c[M>>2]|0;Ya=c[N>>2]|0;rb=c[O>>2]|0;pb=c[P>>2]|0;nb=c[Q>>2]|0;lb=c[R>>2]|0;jb=c[S>>2]|0;c[Ka>>2]=Ra-g;c[B>>2]=Ta-Sa;c[C>>2]=Va-Ua;c[D>>2]=Xa-Wa;c[E>>2]=Za-Ya;c[F>>2]=qb-rb;c[G>>2]=ob-pb;c[H>>2]=mb-nb;c[I>>2]=kb-lb;c[J>>2]=ib-jb;c[Ca>>2]=g+Ra;c[K>>2]=Sa+Ta;c[L>>2]=Ua+Va;c[M>>2]=Wa+Xa;c[N>>2]=Ya+Za;c[O>>2]=rb+qb;c[P>>2]=pb+ob;c[Q>>2]=nb+mb;c[R>>2]=lb+kb;c[S>>2]=jb+ib;ib=c[Ba>>2]|0;jb=c[sa>>2]|0;kb=c[ta>>2]|0;lb=c[ua>>2]|0;mb=c[va>>2]|0;nb=c[wa>>2]|0;ob=c[xa>>2]|0;pb=c[ya>>2]|0;qb=c[za>>2]|0;rb=c[Aa>>2]|0;c[Da>>2]=_a-ib;c[ja>>2]=$a-jb;c[ka>>2]=ab-kb;c[la>>2]=bb-lb;c[ma>>2]=cb-mb;c[na>>2]=db-nb;c[oa>>2]=eb-ob;c[pa>>2]=fb-pb;c[qa>>2]=gb-qb;c[ra>>2]=hb-rb;jb=jb+(c[aa>>2]|0)|0;kb=kb+(c[ba>>2]|0)|0;lb=lb+(c[ca>>2]|0)|0;mb=mb+(c[da>>2]|0)|0;nb=nb+(c[ea>>2]|0)|0;ob=ob+(c[fa>>2]|0)|0;pb=pb+(c[ga>>2]|0)|0;qb=qb+(c[ha>>2]|0)|0;rb=rb+(c[ia>>2]|0)|0;c[Ba>>2]=ib+(c[k>>2]|0);c[sa>>2]=jb;c[ta>>2]=kb;c[ua>>2]=lb;c[va>>2]=mb;c[wa>>2]=nb;c[xa>>2]=ob;c[ya>>2]=pb;c[za>>2]=qb;c[Aa>>2]=rb}}else{Jc(La,Ka,Ba);Jc(Ea,Ca,Da);Jc(Fa,Da,Ba);Jc(Ga,Ka,Ca);Oc(Ka,La,104+(((g<<24>>24|0)/2|0)*120|0)|0)}Jc(j,Ka,Ba);Jc(Ha,Ca,Da);Jc(Ia,Da,Ba);if((f|0)>0)f=f+-1|0;else break}}Ic(k,Ia);Jc(Na,j,k);Jc(Oa,Ha,k);Lc(Pa,Oa);Lc(Ma,Na);j=Pa+31|0;a[j>>0]=d[j>>0]^d[Ma>>0]<<7;j=Yc(Pa,b)|0;k=(Pa|0)==(b|0);f=0;g=0;do{f=a[Pa+g>>0]^a[b+g>>0]|f;g=g+1|0}while((g|0)!=32);rb=(k?-1:j)|(((f&255)+511|0)>>>8&1)+-1;i=Qa;return rb|0}function Wc(b){b=b|0;var c=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0;ea=b+1|0;ba=b+2|0;D=a[ba>>0]|0;f=d[b>>0]|0;n=Hd(d[ea>>0]|0|0,0,8)|0;va=C;D=D&255;V=Hd(D|0,0,16)|0;aa=b+3|0;y=Hd(d[aa>>0]|0|0,0,8)|0;ga=C;$=b+4|0;U=Hd(d[$>>0]|0|0,0,16)|0;ga=ga|C;Y=b+5|0;N=d[Y>>0]|0;X=Hd(N|0,0,24)|0;ga=Gd(y|D|U|X|0,ga|C|0,5)|0;X=b+6|0;U=b+7|0;D=a[U>>0]|0;y=Hd(d[X>>0]|0|0,0,8)|0;Ba=C;D=D&255;T=Hd(D|0,0,16)|0;Ba=Gd(y|N|T|0,Ba|C|0,2)|0;T=b+8|0;N=Hd(d[T>>0]|0|0,0,8)|0;y=C;S=b+9|0;Ca=Hd(d[S>>0]|0|0,0,16)|0;y=y|C;P=b+10|0;Sa=d[P>>0]|0;O=Hd(Sa|0,0,24)|0;y=Gd(N|D|Ca|O|0,y|C|0,7)|0;O=b+11|0;Ca=Hd(d[O>>0]|0|0,0,8)|0;D=C;N=b+12|0;G=Hd(d[N>>0]|0|0,0,16)|0;D=D|C;K=b+13|0;u=d[K>>0]|0;J=Hd(u|0,0,24)|0;D=Gd(Ca|Sa|G|J|0,D|C|0,4)|0;J=b+14|0;G=b+15|0;Sa=a[G>>0]|0;Ca=Hd(d[J>>0]|0|0,0,8)|0;Da=C;Sa=Sa&255;F=Hd(Sa|0,0,16)|0;Da=Gd(Ca|u|F|0,Da|C|0,1)|0;F=b+16|0;u=Hd(d[F>>0]|0|0,0,8)|0;Ca=C;E=b+17|0;w=Hd(d[E>>0]|0|0,0,16)|0;Ca=Ca|C;A=b+18|0;v=d[A>>0]|0;z=Hd(v|0,0,24)|0;Ca=Gd(u|Sa|w|z|0,Ca|C|0,6)|0;z=b+19|0;w=b+20|0;Sa=a[w>>0]|0;u=Hd(d[z>>0]|0|0,0,8)|0;Ta=C;Sa=Hd(Sa&255|0,0,16)|0;Ta=Gd(u|v|Sa|0,Ta|C|0,3)|0;Sa=C;v=b+21|0;u=b+22|0;r=b+23|0;na=a[r>>0]|0;ab=d[v>>0]|0;bb=Hd(d[u>>0]|0|0,0,8)|0;_a=C;na=na&255;$a=Hd(na|0,0,16)|0;q=b+24|0;Ka=Hd(d[q>>0]|0|0,0,8)|0;Pa=C;p=b+25|0;i=Hd(d[p>>0]|0|0,0,16)|0;Pa=Pa|C;m=b+26|0;xa=d[m>>0]|0;l=Hd(xa|0,0,24)|0;Pa=Gd(Ka|na|i|l|0,Pa|C|0,5)|0;l=b+27|0;i=b+28|0;na=a[i>>0]|0;Ka=Hd(d[l>>0]|0|0,0,8)|0;Za=C;na=na&255;h=Hd(na|0,0,16)|0;Za=Gd(Ka|xa|h|0,Za|C|0,2)|0;h=b+29|0;xa=Hd(d[h>>0]|0|0,0,8)|0;Ka=C;g=b+30|0;fb=Hd(d[g>>0]|0|0,0,16)|0;Ka=Ka|C;c=b+31|0;qa=d[c>>0]|0;oa=Hd(qa|0,0,24)|0;Ka=Gd(xa|na|fb|oa|0,Ka|C|0,7)|0;oa=Hd(d[b+32>>0]|0|0,0,8)|0;fb=C;na=Hd(d[b+33>>0]|0|0,0,16)|0;fb=fb|C;xa=d[b+34>>0]|0;la=Hd(xa|0,0,24)|0;fb=Gd(oa|qa|na|la|0,fb|C|0,4)|0;la=a[b+36>>0]|0;na=Hd(d[b+35>>0]|0|0,0,8)|0;qa=C;la=la&255;oa=Hd(la|0,0,16)|0;qa=Gd(na|xa|oa|0,qa|C|0,1)|0;oa=Hd(d[b+37>>0]|0|0,0,8)|0;xa=C;na=Hd(d[b+38>>0]|0|0,0,16)|0;xa=xa|C;Ma=d[b+39>>0]|0;fa=Hd(Ma|0,0,24)|0;xa=Gd(oa|la|na|fa|0,xa|C|0,6)|0;fa=a[b+41>>0]|0;na=Hd(d[b+40>>0]|0|0,0,8)|0;la=C;fa=Hd(fa&255|0,0,16)|0;la=Gd(na|Ma|fa|0,la|C|0,3)|0;fa=C;Ma=a[b+44>>0]|0;na=d[b+42>>0]|0;oa=Hd(d[b+43>>0]|0|0,0,8)|0;j=C;Ma=Ma&255;za=Hd(Ma|0,0,16)|0;ja=Hd(d[b+45>>0]|0|0,0,8)|0;L=C;W=Hd(d[b+46>>0]|0|0,0,16)|0;L=L|C;gb=d[b+47>>0]|0;o=Hd(gb|0,0,24)|0;L=Gd(ja|Ma|W|o|0,L|C|0,5)|0;o=a[b+49>>0]|0;W=Hd(d[b+48>>0]|0|0,0,8)|0;Ma=C;o=o&255;ja=Hd(o|0,0,16)|0;Ma=Gd(W|gb|ja|0,Ma|C|0,2)|0;Ma=Ma&2097151;ja=Hd(d[b+50>>0]|0|0,0,8)|0;gb=C;W=Hd(d[b+51>>0]|0|0,0,16)|0;gb=gb|C;Aa=d[b+52>>0]|0;M=Hd(Aa|0,0,24)|0;gb=Gd(ja|o|W|M|0,gb|C|0,7)|0;gb=gb&2097151;M=Hd(d[b+53>>0]|0|0,0,8)|0;W=C;o=Hd(d[b+54>>0]|0|0,0,16)|0;W=W|C;ja=d[b+55>>0]|0;R=Hd(ja|0,0,24)|0;W=Gd(M|Aa|o|R|0,W|C|0,4)|0;W=W&2097151;R=a[b+57>>0]|0;o=Hd(d[b+56>>0]|0|0,0,8)|0;Aa=C;R=R&255;M=Hd(R|0,0,16)|0;Aa=Gd(o|ja|M|0,Aa|C|0,1)|0;Aa=Aa&2097151;M=Hd(d[b+58>>0]|0|0,0,8)|0;ja=C;o=Hd(d[b+59>>0]|0|0,0,16)|0;ja=ja|C;ha=d[b+60>>0]|0;Q=Hd(ha|0,0,24)|0;ja=Gd(M|R|o|Q|0,ja|C|0,6)|0;ja=ja&2097151;Q=Hd(d[b+61>>0]|0|0,0,8)|0;o=C;R=Hd(d[b+62>>0]|0|0,0,16)|0;o=o|C;M=Hd(d[b+63>>0]|0|0,0,24)|0;o=Gd(Q|ha|R|M|0,o|C|0,3)|0;M=C;R=Od(o|0,M|0,666643,0)|0;ha=C;Q=Od(o|0,M|0,470296,0)|0;I=C;ca=Od(o|0,M|0,654183,0)|0;ta=C;Ea=Od(o|0,M|0,-997805,-1)|0;t=C;k=Od(o|0,M|0,136657,0)|0;B=C;M=Od(o|0,M|0,-683901,-1)|0;j=Dd(M|0,C|0,oa|na|za&2031616|0,j|0)|0;za=C;na=Od(ja|0,0,666643,0)|0;oa=C;M=Od(ja|0,0,470296,0)|0;o=C;Va=Od(ja|0,0,654183,0)|0;s=C;ma=Od(ja|0,0,-997805,-1)|0;_=C;ya=Od(ja|0,0,136657,0)|0;sa=C;ja=Od(ja|0,0,-683901,-1)|0;H=C;e=Od(Aa|0,0,666643,0)|0;ra=C;wa=Od(Aa|0,0,470296,0)|0;La=C;Fa=Od(Aa|0,0,654183,0)|0;da=C;cb=Od(Aa|0,0,-997805,-1)|0;Ua=C;ka=Od(Aa|0,0,136657,0)|0;x=C;Aa=Od(Aa|0,0,-683901,-1)|0;xa=Dd(Aa|0,C|0,xa&2097151|0,0)|0;sa=Dd(xa|0,C|0,ya|0,sa|0)|0;t=Dd(sa|0,C|0,Ea|0,t|0)|0;Ea=C;sa=Od(W|0,0,666643,0)|0;ya=C;xa=Od(W|0,0,470296,0)|0;Aa=C;Wa=Od(W|0,0,654183,0)|0;Z=C;Ha=Od(W|0,0,-997805,-1)|0;Ga=C;eb=Od(W|0,0,136657,0)|0;db=C;W=Od(W|0,0,-683901,-1)|0;pa=C;ia=Od(gb|0,0,666643,0)|0;ua=C;Qa=Od(gb|0,0,470296,0)|0;Ra=C;Oa=Od(gb|0,0,654183,0)|0;Na=C;Ya=Od(gb|0,0,-997805,-1)|0;Xa=C;Ja=Od(gb|0,0,136657,0)|0;Ia=C;gb=Od(gb|0,0,-683901,-1)|0;fb=Dd(gb|0,C|0,fb&2097151|0,0)|0;db=Dd(fb|0,C|0,eb|0,db|0)|0;Ua=Dd(db|0,C|0,cb|0,Ua|0)|0;s=Dd(Ua|0,C|0,Va|0,s|0)|0;I=Dd(s|0,C|0,Q|0,I|0)|0;Q=C;s=Od(Ma|0,0,666643,0)|0;Ca=Dd(s|0,C|0,Ca&2097151|0,0)|0;s=C;Va=Od(Ma|0,0,470296,0)|0;Ua=C;cb=Od(Ma|0,0,654183,0)|0;_a=Dd(cb|0,C|0,bb|ab|$a&2031616|0,_a|0)|0;Ra=Dd(_a|0,C|0,Qa|0,Ra|0)|0;ya=Dd(Ra|0,C|0,sa|0,ya|0)|0;sa=C;Ra=Od(Ma|0,0,-997805,-1)|0;Qa=C;_a=Od(Ma|0,0,136657,0)|0;Za=Dd(_a|0,C|0,Za&2097151|0,0)|0;Xa=Dd(Za|0,C|0,Ya|0,Xa|0)|0;Z=Dd(Xa|0,C|0,Wa|0,Z|0)|0;La=Dd(Z|0,C|0,wa|0,La|0)|0;oa=Dd(La|0,C|0,na|0,oa|0)|0;na=C;Ma=Od(Ma|0,0,-683901,-1)|0;La=C;wa=Dd(Ca|0,s|0,1048576,0)|0;wa=Gd(wa|0,C|0,21)|0;Z=C;Sa=Dd(Va|0,Ua|0,Ta|0,Sa|0)|0;Sa=Dd(Sa|0,C|0,wa|0,Z|0)|0;ua=Dd(Sa|0,C|0,ia|0,ua|0)|0;ia=C;Z=Hd(wa|0,Z|0,21)|0;Z=Cd(Ca|0,s|0,Z|0,C|0)|0;s=C;Ca=Dd(ya|0,sa|0,1048576,0)|0;Ca=Gd(Ca|0,C|0,21)|0;wa=C;Pa=Dd(Ra|0,Qa|0,Pa&2097151|0,0)|0;Na=Dd(Pa|0,C|0,Oa|0,Na|0)|0;Aa=Dd(Na|0,C|0,xa|0,Aa|0)|0;ra=Dd(Aa|0,C|0,e|0,ra|0)|0;ra=Dd(ra|0,C|0,Ca|0,wa|0)|0;e=C;wa=Hd(Ca|0,wa|0,21)|0;Ca=C;Aa=Dd(oa|0,na|0,1048576,0)|0;Aa=Ed(Aa|0,C|0,21)|0;xa=C;Ka=Dd(Ma|0,La|0,Ka&2097151|0,0)|0;Ia=Dd(Ka|0,C|0,Ja|0,Ia|0)|0;Ga=Dd(Ia|0,C|0,Ha|0,Ga|0)|0;da=Dd(Ga|0,C|0,Fa|0,da|0)|0;o=Dd(da|0,C|0,M|0,o|0)|0;ha=Dd(o|0,C|0,R|0,ha|0)|0;ha=Dd(ha|0,C|0,Aa|0,xa|0)|0;R=C;xa=Hd(Aa|0,xa|0,21)|0;Aa=C;o=Dd(I|0,Q|0,1048576,0)|0;o=Ed(o|0,C|0,21)|0;M=C;qa=Dd(W|0,pa|0,qa&2097151|0,0)|0;x=Dd(qa|0,C|0,ka|0,x|0)|0;_=Dd(x|0,C|0,ma|0,_|0)|0;ta=Dd(_|0,C|0,ca|0,ta|0)|0;ta=Dd(ta|0,C|0,o|0,M|0)|0;ca=C;M=Hd(o|0,M|0,21)|0;M=Cd(I|0,Q|0,M|0,C|0)|0;Q=C;I=Dd(t|0,Ea|0,1048576,0)|0;I=Ed(I|0,C|0,21)|0;o=C;fa=Dd(ja|0,H|0,la|0,fa|0)|0;B=Dd(fa|0,C|0,k|0,B|0)|0;B=Dd(B|0,C|0,I|0,o|0)|0;k=C;o=Hd(I|0,o|0,21)|0;o=Cd(t|0,Ea|0,o|0,C|0)|0;Ea=C;t=Dd(j|0,za|0,1048576,0)|0;t=Ed(t|0,C|0,21)|0;I=C;L=Dd(t|0,I|0,L&2097151|0,0)|0;fa=C;I=Hd(t|0,I|0,21)|0;I=Cd(j|0,za|0,I|0,C|0)|0;za=C;j=Dd(ua|0,ia|0,1048576,0)|0;j=Gd(j|0,C|0,21)|0;t=C;la=Hd(j|0,t|0,21)|0;la=Cd(ua|0,ia|0,la|0,C|0)|0;ia=C;ua=Dd(ra|0,e|0,1048576,0)|0;ua=Ed(ua|0,C|0,21)|0;H=C;ja=Hd(ua|0,H|0,21)|0;ja=Cd(ra|0,e|0,ja|0,C|0)|0;e=C;ra=Dd(ha|0,R|0,1048576,0)|0;ra=Ed(ra|0,C|0,21)|0;_=C;Q=Dd(M|0,Q|0,ra|0,_|0)|0;M=C;_=Hd(ra|0,_|0,21)|0;_=Cd(ha|0,R|0,_|0,C|0)|0;R=C;ha=Dd(ta|0,ca|0,1048576,0)|0;ha=Ed(ha|0,C|0,21)|0;ra=C;Ea=Dd(ha|0,ra|0,o|0,Ea|0)|0;o=C;ra=Hd(ha|0,ra|0,21)|0;ra=Cd(ta|0,ca|0,ra|0,C|0)|0;ca=C;ta=Dd(B|0,k|0,1048576,0)|0;ta=Ed(ta|0,C|0,21)|0;ha=C;za=Dd(ta|0,ha|0,I|0,za|0)|0;I=C;ha=Hd(ta|0,ha|0,21)|0;ha=Cd(B|0,k|0,ha|0,C|0)|0;k=C;B=Od(L|0,fa|0,666643,0)|0;Da=Dd(B|0,C|0,Da&2097151|0,0)|0;B=C;ta=Od(L|0,fa|0,470296,0)|0;ta=Dd(Z|0,s|0,ta|0,C|0)|0;s=C;Z=Od(L|0,fa|0,654183,0)|0;Z=Dd(la|0,ia|0,Z|0,C|0)|0;ia=C;la=Od(L|0,fa|0,-997805,-1)|0;ma=C;x=Od(L|0,fa|0,136657,0)|0;x=Dd(ja|0,e|0,x|0,C|0)|0;e=C;fa=Od(L|0,fa|0,-683901,-1)|0;L=C;H=Dd(oa|0,na|0,ua|0,H|0)|0;Aa=Cd(H|0,C|0,xa|0,Aa|0)|0;L=Dd(Aa|0,C|0,fa|0,L|0)|0;fa=C;Aa=Od(za|0,I|0,666643,0)|0;D=Dd(Aa|0,C|0,D&2097151|0,0)|0;Aa=C;xa=Od(za|0,I|0,470296,0)|0;xa=Dd(Da|0,B|0,xa|0,C|0)|0;B=C;Da=Od(za|0,I|0,654183,0)|0;Da=Dd(ta|0,s|0,Da|0,C|0)|0;s=C;ta=Od(za|0,I|0,-997805,-1)|0;ta=Dd(Z|0,ia|0,ta|0,C|0)|0;ia=C;Z=Od(za|0,I|0,136657,0)|0;H=C;I=Od(za|0,I|0,-683901,-1)|0;I=Dd(x|0,e|0,I|0,C|0)|0;e=C;x=Od(ha|0,k|0,666643,0)|0;y=Dd(x|0,C|0,y&2097151|0,0)|0;x=C;za=Od(ha|0,k|0,470296,0)|0;za=Dd(D|0,Aa|0,za|0,C|0)|0;Aa=C;D=Od(ha|0,k|0,654183,0)|0;D=Dd(xa|0,B|0,D|0,C|0)|0;B=C;xa=Od(ha|0,k|0,-997805,-1)|0;xa=Dd(Da|0,s|0,xa|0,C|0)|0;s=C;Da=Od(ha|0,k|0,136657,0)|0;Da=Dd(ta|0,ia|0,Da|0,C|0)|0;ia=C;k=Od(ha|0,k|0,-683901,-1)|0;ha=C;t=Dd(ya|0,sa|0,j|0,t|0)|0;Ca=Cd(t|0,C|0,wa|0,Ca|0)|0;ma=Dd(Ca|0,C|0,la|0,ma|0)|0;H=Dd(ma|0,C|0,Z|0,H|0)|0;ha=Dd(H|0,C|0,k|0,ha|0)|0;k=C;H=Od(Ea|0,o|0,666643,0)|0;Z=C;ma=Od(Ea|0,o|0,470296,0)|0;la=C;Ca=Od(Ea|0,o|0,654183,0)|0;wa=C;t=Od(Ea|0,o|0,-997805,-1)|0;j=C;sa=Od(Ea|0,o|0,136657,0)|0;sa=Dd(xa|0,s|0,sa|0,C|0)|0;s=C;o=Od(Ea|0,o|0,-683901,-1)|0;o=Dd(Da|0,ia|0,o|0,C|0)|0;ia=C;Da=Od(ra|0,ca|0,666643,0)|0;Ea=C;xa=Od(ra|0,ca|0,470296,0)|0;ya=C;ta=Od(ra|0,ca|0,654183,0)|0;ua=C;na=Od(ra|0,ca|0,-997805,-1)|0;oa=C;ja=Od(ra|0,ca|0,136657,0)|0;ka=C;ca=Od(ra|0,ca|0,-683901,-1)|0;ca=Dd(sa|0,s|0,ca|0,C|0)|0;s=C;sa=Od(Q|0,M|0,666643,0)|0;va=Dd(sa|0,C|0,n|f|V&2031616|0,va|0)|0;V=C;f=Od(Q|0,M|0,470296,0)|0;n=C;sa=Od(Q|0,M|0,654183,0)|0;Ba=Dd(sa|0,C|0,Ba&2097151|0,0)|0;Z=Dd(Ba|0,C|0,H|0,Z|0)|0;ya=Dd(Z|0,C|0,xa|0,ya|0)|0;xa=C;Z=Od(Q|0,M|0,-997805,-1)|0;H=C;Ba=Od(Q|0,M|0,136657,0)|0;Ba=Dd(za|0,Aa|0,Ba|0,C|0)|0;wa=Dd(Ba|0,C|0,Ca|0,wa|0)|0;oa=Dd(wa|0,C|0,na|0,oa|0)|0;na=C;M=Od(Q|0,M|0,-683901,-1)|0;Q=C;wa=Dd(va|0,V|0,1048576,0)|0;wa=Ed(wa|0,C|0,21)|0;Ca=C;ga=Dd(f|0,n|0,ga&2097151|0,0)|0;Ea=Dd(ga|0,C|0,Da|0,Ea|0)|0;Ea=Dd(Ea|0,C|0,wa|0,Ca|0)|0;Da=C;Ca=Hd(wa|0,Ca|0,21)|0;Ca=Cd(va|0,V|0,Ca|0,C|0)|0;V=C;va=Dd(ya|0,xa|0,1048576,0)|0;va=Ed(va|0,C|0,21)|0;wa=C;H=Dd(y|0,x|0,Z|0,H|0)|0;la=Dd(H|0,C|0,ma|0,la|0)|0;ua=Dd(la|0,C|0,ta|0,ua|0)|0;ua=Dd(ua|0,C|0,va|0,wa|0)|0;ta=C;wa=Hd(va|0,wa|0,21)|0;va=C;la=Dd(oa|0,na|0,1048576,0)|0;la=Ed(la|0,C|0,21)|0;ma=C;Q=Dd(D|0,B|0,M|0,Q|0)|0;j=Dd(Q|0,C|0,t|0,j|0)|0;ka=Dd(j|0,C|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,la|0,ma|0)|0;ja=C;ma=Hd(la|0,ma|0,21)|0;la=C;j=Dd(ca|0,s|0,1048576,0)|0;j=Ed(j|0,C|0,21)|0;t=C;ia=Dd(o|0,ia|0,j|0,t|0)|0;o=C;t=Hd(j|0,t|0,21)|0;t=Cd(ca|0,s|0,t|0,C|0)|0;s=C;ca=Dd(ha|0,k|0,1048576,0)|0;ca=Ed(ca|0,C|0,21)|0;j=C;e=Dd(I|0,e|0,ca|0,j|0)|0;I=C;j=Hd(ca|0,j|0,21)|0;j=Cd(ha|0,k|0,j|0,C|0)|0;k=C;ha=Dd(L|0,fa|0,1048576,0)|0;ha=Ed(ha|0,C|0,21)|0;ca=C;R=Dd(_|0,R|0,ha|0,ca|0)|0;_=C;ca=Hd(ha|0,ca|0,21)|0;ca=Cd(L|0,fa|0,ca|0,C|0)|0;fa=C;L=Dd(Ea|0,Da|0,1048576,0)|0;L=Ed(L|0,C|0,21)|0;ha=C;Q=Hd(L|0,ha|0,21)|0;M=C;B=Dd(ua|0,ta|0,1048576,0)|0;B=Ed(B|0,C|0,21)|0;D=C;H=Hd(B|0,D|0,21)|0;Z=C;x=Dd(ka|0,ja|0,1048576,0)|0;x=Ed(x|0,C|0,21)|0;y=C;s=Dd(t|0,s|0,x|0,y|0)|0;t=C;y=Hd(x|0,y|0,21)|0;x=C;ga=Dd(ia|0,o|0,1048576,0)|0;ga=Ed(ga|0,C|0,21)|0;n=C;k=Dd(j|0,k|0,ga|0,n|0)|0;j=C;n=Hd(ga|0,n|0,21)|0;n=Cd(ia|0,o|0,n|0,C|0)|0;o=C;ia=Dd(e|0,I|0,1048576,0)|0;ia=Ed(ia|0,C|0,21)|0;ga=C;fa=Dd(ca|0,fa|0,ia|0,ga|0)|0;ca=C;ga=Hd(ia|0,ga|0,21)|0;ga=Cd(e|0,I|0,ga|0,C|0)|0;I=C;e=Dd(R|0,_|0,1048576,0)|0;e=Ed(e|0,C|0,21)|0;ia=C;f=Hd(e|0,ia|0,21)|0;f=Cd(R|0,_|0,f|0,C|0)|0;_=C;R=Od(e|0,ia|0,666643,0)|0;R=Dd(Ca|0,V|0,R|0,C|0)|0;V=C;Ca=Od(e|0,ia|0,470296,0)|0;Ba=C;Aa=Od(e|0,ia|0,654183,0)|0;za=C;sa=Od(e|0,ia|0,-997805,-1)|0;ra=C;qa=Od(e|0,ia|0,136657,0)|0;pa=C;ia=Od(e|0,ia|0,-683901,-1)|0;e=C;W=Ed(R|0,V|0,21)|0;da=C;Ba=Dd(Ea|0,Da|0,Ca|0,Ba|0)|0;Ba=Dd(Ba|0,C|0,W|0,da|0)|0;M=Cd(Ba|0,C|0,Q|0,M|0)|0;Q=C;da=Hd(W|0,da|0,21)|0;da=Cd(R|0,V|0,da|0,C|0)|0;V=C;R=Ed(M|0,Q|0,21)|0;W=C;xa=Dd(Aa|0,za|0,ya|0,xa|0)|0;va=Cd(xa|0,C|0,wa|0,va|0)|0;ha=Dd(va|0,C|0,L|0,ha|0)|0;ha=Dd(ha|0,C|0,R|0,W|0)|0;L=C;W=Hd(R|0,W|0,21)|0;W=Cd(M|0,Q|0,W|0,C|0)|0;Q=C;M=Ed(ha|0,L|0,21)|0;R=C;ra=Dd(ua|0,ta|0,sa|0,ra|0)|0;Z=Cd(ra|0,C|0,H|0,Z|0)|0;Z=Dd(Z|0,C|0,M|0,R|0)|0;H=C;R=Hd(M|0,R|0,21)|0;R=Cd(ha|0,L|0,R|0,C|0)|0;L=C;ha=Ed(Z|0,H|0,21)|0;M=C;na=Dd(qa|0,pa|0,oa|0,na|0)|0;la=Cd(na|0,C|0,ma|0,la|0)|0;D=Dd(la|0,C|0,B|0,D|0)|0;D=Dd(D|0,C|0,ha|0,M|0)|0;B=C;M=Hd(ha|0,M|0,21)|0;M=Cd(Z|0,H|0,M|0,C|0)|0;H=C;Z=Ed(D|0,B|0,21)|0;ha=C;e=Dd(ka|0,ja|0,ia|0,e|0)|0;x=Cd(e|0,C|0,y|0,x|0)|0;x=Dd(x|0,C|0,Z|0,ha|0)|0;y=C;ha=Hd(Z|0,ha|0,21)|0;ha=Cd(D|0,B|0,ha|0,C|0)|0;B=C;D=Ed(x|0,y|0,21)|0;Z=C;t=Dd(s|0,t|0,D|0,Z|0)|0;s=C;Z=Hd(D|0,Z|0,21)|0;Z=Cd(x|0,y|0,Z|0,C|0)|0;y=C;x=Ed(t|0,s|0,21)|0;D=C;o=Dd(x|0,D|0,n|0,o|0)|0;n=C;D=Hd(x|0,D|0,21)|0;D=Cd(t|0,s|0,D|0,C|0)|0;s=C;t=Ed(o|0,n|0,21)|0;x=C;j=Dd(k|0,j|0,t|0,x|0)|0;k=C;x=Hd(t|0,x|0,21)|0;x=Cd(o|0,n|0,x|0,C|0)|0;n=C;o=Ed(j|0,k|0,21)|0;t=C;I=Dd(o|0,t|0,ga|0,I|0)|0;ga=C;t=Hd(o|0,t|0,21)|0;t=Cd(j|0,k|0,t|0,C|0)|0;k=C;j=Ed(I|0,ga|0,21)|0;o=C;ca=Dd(fa|0,ca|0,j|0,o|0)|0;fa=C;o=Hd(j|0,o|0,21)|0;o=Cd(I|0,ga|0,o|0,C|0)|0;ga=C;I=Ed(ca|0,fa|0,21)|0;j=C;_=Dd(I|0,j|0,f|0,_|0)|0;f=C;j=Hd(I|0,j|0,21)|0;j=Cd(ca|0,fa|0,j|0,C|0)|0;fa=C;ca=Ed(_|0,f|0,21)|0;I=C;e=Hd(ca|0,I|0,21)|0;e=Cd(_|0,f|0,e|0,C|0)|0;f=C;_=Od(ca|0,I|0,666643,0)|0;V=Dd(_|0,C|0,da|0,V|0)|0;da=C;_=Od(ca|0,I|0,470296,0)|0;_=Dd(W|0,Q|0,_|0,C|0)|0;Q=C;W=Od(ca|0,I|0,654183,0)|0;W=Dd(R|0,L|0,W|0,C|0)|0;L=C;R=Od(ca|0,I|0,-997805,-1)|0;R=Dd(M|0,H|0,R|0,C|0)|0;H=C;M=Od(ca|0,I|0,136657,0)|0;M=Dd(ha|0,B|0,M|0,C|0)|0;B=C;I=Od(ca|0,I|0,-683901,-1)|0;I=Dd(Z|0,y|0,I|0,C|0)|0;y=C;Z=Ed(V|0,da|0,21)|0;ca=C;Q=Dd(_|0,Q|0,Z|0,ca|0)|0;_=C;ca=Hd(Z|0,ca|0,21)|0;ca=Cd(V|0,da|0,ca|0,C|0)|0;da=C;V=Ed(Q|0,_|0,21)|0;Z=C;L=Dd(W|0,L|0,V|0,Z|0)|0;W=C;Z=Hd(V|0,Z|0,21)|0;Z=Cd(Q|0,_|0,Z|0,C|0)|0;_=C;Q=Ed(L|0,W|0,21)|0;V=C;H=Dd(R|0,H|0,Q|0,V|0)|0;R=C;V=Hd(Q|0,V|0,21)|0;V=Cd(L|0,W|0,V|0,C|0)|0;W=C;L=Ed(H|0,R|0,21)|0;Q=C;B=Dd(M|0,B|0,L|0,Q|0)|0;M=C;Q=Hd(L|0,Q|0,21)|0;Q=Cd(H|0,R|0,Q|0,C|0)|0;R=C;H=Ed(B|0,M|0,21)|0;L=C;y=Dd(I|0,y|0,H|0,L|0)|0;I=C;L=Hd(H|0,L|0,21)|0;L=Cd(B|0,M|0,L|0,C|0)|0;M=C;B=Ed(y|0,I|0,21)|0;H=C;s=Dd(B|0,H|0,D|0,s|0)|0;D=C;H=Hd(B|0,H|0,21)|0;H=Cd(y|0,I|0,H|0,C|0)|0;I=C;y=Ed(s|0,D|0,21)|0;B=C;n=Dd(y|0,B|0,x|0,n|0)|0;x=C;B=Hd(y|0,B|0,21)|0;B=Cd(s|0,D|0,B|0,C|0)|0;D=C;s=Ed(n|0,x|0,21)|0;y=C;k=Dd(s|0,y|0,t|0,k|0)|0;t=C;y=Hd(s|0,y|0,21)|0;y=Cd(n|0,x|0,y|0,C|0)|0;x=C;n=Ed(k|0,t|0,21)|0;s=C;ga=Dd(n|0,s|0,o|0,ga|0)|0;o=C;s=Hd(n|0,s|0,21)|0;s=Cd(k|0,t|0,s|0,C|0)|0;t=C;k=Ed(ga|0,o|0,21)|0;n=C;fa=Dd(k|0,n|0,j|0,fa|0)|0;j=C;n=Hd(k|0,n|0,21)|0;n=Cd(ga|0,o|0,n|0,C|0)|0;o=C;ga=Ed(fa|0,j|0,21)|0;k=C;f=Dd(ga|0,k|0,e|0,f|0)|0;e=C;k=Hd(ga|0,k|0,21)|0;k=Cd(fa|0,j|0,k|0,C|0)|0;j=C;a[b>>0]=ca;b=Gd(ca|0,da|0,8)|0;a[ea>>0]=b;b=Gd(ca|0,da|0,16)|0;da=C;ca=Hd(Z|0,_|0,5)|0;a[ba>>0]=ca|b;b=Gd(Z|0,_|0,3)|0;a[aa>>0]=b;b=Gd(Z|0,_|0,11)|0;a[$>>0]=b;b=Gd(Z|0,_|0,19)|0;_=C;Z=Hd(V|0,W|0,2)|0;a[Y>>0]=Z|b;b=Gd(V|0,W|0,6)|0;a[X>>0]=b;b=Gd(V|0,W|0,14)|0;W=C;V=Hd(Q|0,R|0,7)|0;a[U>>0]=V|b;b=Gd(Q|0,R|0,1)|0;a[T>>0]=b;b=Gd(Q|0,R|0,9)|0;a[S>>0]=b;b=Gd(Q|0,R|0,17)|0;R=C;Q=Hd(L|0,M|0,4)|0;a[P>>0]=Q|b;b=Gd(L|0,M|0,4)|0;a[O>>0]=b;b=Gd(L|0,M|0,12)|0;a[N>>0]=b;b=Gd(L|0,M|0,20)|0;M=C;L=Hd(H|0,I|0,1)|0;a[K>>0]=L|b;b=Gd(H|0,I|0,7)|0;a[J>>0]=b;b=Gd(H|0,I|0,15)|0;I=C;H=Hd(B|0,D|0,6)|0;a[G>>0]=H|b;b=Gd(B|0,D|0,2)|0;a[F>>0]=b;b=Gd(B|0,D|0,10)|0;a[E>>0]=b;b=Gd(B|0,D|0,18)|0;D=C;B=Hd(y|0,x|0,3)|0;a[A>>0]=B|b;b=Gd(y|0,x|0,5)|0;a[z>>0]=b;b=Gd(y|0,x|0,13)|0;a[w>>0]=b;a[v>>0]=s;b=Gd(s|0,t|0,8)|0;a[u>>0]=b;b=Gd(s|0,t|0,16)|0;t=C;s=Hd(n|0,o|0,5)|0;a[r>>0]=s|b;b=Gd(n|0,o|0,3)|0;a[q>>0]=b;b=Gd(n|0,o|0,11)|0;a[p>>0]=b;b=Gd(n|0,o|0,19)|0;o=C;n=Hd(k|0,j|0,2)|0;a[m>>0]=n|b;b=Gd(k|0,j|0,6)|0;a[l>>0]=b;j=Gd(k|0,j|0,14)|0;k=C;b=Hd(f|0,e|0,7)|0;a[i>>0]=j|b;b=Gd(f|0,e|0,1)|0;a[h>>0]=b;b=Gd(f|0,e|0,9)|0;a[g>>0]=b;b=Gd(f|0,e|0,17)|0;a[c>>0]=b;return}function Xc(b,e,f,g,h,j){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0,Yb=0,Zb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0,kc=0,lc=0,mc=0,nc=0,oc=0,pc=0,qc=0,rc=0,sc=0,tc=0,uc=0,vc=0,wc=0,xc=0,yc=0,zc=0,Ac=0,Bc=0,Cc=0,Dc=0,Ec=0;z=i;p=i=i+63&-64;i=i+896|0;v=p+208|0;u=p+656|0;w=p+616|0;x=p+576|0;s=p;q=p+824|0;t=p+760|0;r=p+696|0;p=p+416|0;k=v+64|0;y=v;A=8;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0}while((y|0)<(B|0));y=v+72|0;c[y>>2]=256;c[y+4>>2]=0;y=k;c[y>>2]=0;c[y+4>>2]=0;y=v+80|0;A=j;B=y+32|0;do{a[y>>0]=a[A>>0]|0;y=y+1|0;A=A+1|0}while((y|0)<(B|0));Gb(v,q);a[q>>0]=(d[q>>0]|0)&248;k=q+31|0;a[k>>0]=(d[k>>0]|0)&63|64;l=s+64|0;y=l;c[y>>2]=0;c[y+4>>2]=0;y=s;A=8;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0}while((y|0)<(B|0));m=s+72|0;n=m;c[n>>2]=256;c[n+4>>2]=0;n=l;c[n>>2]=0;c[n+4>>2]=0;n=s+80|0;y=n;A=q+32|0;B=y+32|0;do{a[y>>0]=a[A>>0]|0;y=y+1|0;A=A+1|0}while((y|0)<(B|0));Fb(s,f,g,h);Gb(s,t);o=b+32|0;Jd(o|0,j+32|0,32)|0;Wc(t);Rc(p,t);Ic(u,p+80|0);Jc(w,p,u);Jc(x,p+40|0,u);Lc(b,x);Lc(v,w);y=b+31|0;a[y>>0]=(d[y>>0]|0)^(d[v>>0]|0)<<7;y=l;c[y>>2]=0;c[y+4>>2]=0;y=s;A=8;B=y+64|0;do{c[y>>2]=c[A>>2];y=y+4|0;A=A+4|0}while((y|0)<(B|0));y=m;c[y>>2]=512;c[y+4>>2]=0;y=l;c[y>>2]=0;c[y+4>>2]=0;y=n;A=b;B=y+64|0;do{a[y>>0]=a[A>>0]|0;y=y+1|0;A=A+1|0}while((y|0)<(B|0));Fb(s,f,g,h);Gb(s,r);Wc(r);J=a[r+2>>0]|0;Ta=d[r>>0]|0;xb=Hd(d[r+1>>0]|0|0,0,8)|0;qb=C;J=J&255;kb=Hd(J|0,0,16)|0;kb=xb|Ta|kb&2031616;Ta=Hd(d[r+3>>0]|0|0,0,8)|0;xb=C;F=Hd(d[r+4>>0]|0|0,0,16)|0;xb=xb|C;ub=d[r+5>>0]|0;db=Hd(ub|0,0,24)|0;xb=Gd(Ta|J|F|db|0,xb|C|0,5)|0;xb=xb&2097151;db=a[r+7>>0]|0;F=Hd(d[r+6>>0]|0|0,0,8)|0;J=C;db=db&255;Ta=Hd(db|0,0,16)|0;J=Gd(F|ub|Ta|0,J|C|0,2)|0;J=J&2097151;Ta=Hd(d[r+8>>0]|0|0,0,8)|0;ub=C;F=Hd(d[r+9>>0]|0|0,0,16)|0;ub=ub|C;v=d[r+10>>0]|0;Sa=Hd(v|0,0,24)|0;ub=Gd(Ta|db|F|Sa|0,ub|C|0,7)|0;ub=ub&2097151;Sa=Hd(d[r+11>>0]|0|0,0,8)|0;F=C;db=Hd(d[r+12>>0]|0|0,0,16)|0;F=F|C;Ta=d[r+13>>0]|0;y=Hd(Ta|0,0,24)|0;F=Gd(Sa|v|db|y|0,F|C|0,4)|0;F=F&2097151;y=a[r+15>>0]|0;db=Hd(d[r+14>>0]|0|0,0,8)|0;v=C;y=y&255;Sa=Hd(y|0,0,16)|0;v=Gd(db|Ta|Sa|0,v|C|0,1)|0;v=v&2097151;Sa=Hd(d[r+16>>0]|0|0,0,8)|0;Ta=C;db=Hd(d[r+17>>0]|0|0,0,16)|0;Ta=Ta|C;Bc=d[r+18>>0]|0;ja=Hd(Bc|0,0,24)|0;Ta=Gd(Sa|y|db|ja|0,Ta|C|0,6)|0;Ta=Ta&2097151;ja=a[r+20>>0]|0;db=Hd(d[r+19>>0]|0|0,0,8)|0;y=C;ja=Hd(ja&255|0,0,16)|0;y=Gd(db|Bc|ja|0,y|C|0,3)|0;ja=C;Bc=a[r+23>>0]|0;db=d[r+21>>0]|0;Sa=Hd(d[r+22>>0]|0|0,0,8)|0;sb=C;Bc=Bc&255;Qa=Hd(Bc|0,0,16)|0;Qa=Sa|db|Qa&2031616;db=Hd(d[r+24>>0]|0|0,0,8)|0;Sa=C;m=Hd(d[r+25>>0]|0|0,0,16)|0;Sa=Sa|C;p=d[r+26>>0]|0;s=Hd(p|0,0,24)|0;Sa=Gd(db|Bc|m|s|0,Sa|C|0,5)|0;Sa=Sa&2097151;s=a[r+28>>0]|0;m=Hd(d[r+27>>0]|0|0,0,8)|0;Bc=C;s=s&255;db=Hd(s|0,0,16)|0;Bc=Gd(m|p|db|0,Bc|C|0,2)|0;Bc=Bc&2097151;db=Hd(d[r+29>>0]|0|0,0,8)|0;p=C;m=Hd(d[r+30>>0]|0|0,0,16)|0;p=p|C;Ka=Hd(d[r+31>>0]|0|0,0,24)|0;p=Gd(db|s|m|Ka|0,p|C|0,7)|0;Ka=C;m=a[q+2>>0]|0;s=d[q>>0]|0;db=Hd(d[q+1>>0]|0|0,0,8)|0;ia=C;m=m&255;ha=Hd(m|0,0,16)|0;ha=db|s|ha&2031616;s=Hd(d[q+3>>0]|0|0,0,8)|0;db=C;la=Hd(d[q+4>>0]|0|0,0,16)|0;db=db|C;h=d[q+5>>0]|0;yc=Hd(h|0,0,24)|0;db=Gd(s|m|la|yc|0,db|C|0,5)|0;db=db&2097151;yc=a[q+7>>0]|0;la=Hd(d[q+6>>0]|0|0,0,8)|0;m=C;yc=yc&255;s=Hd(yc|0,0,16)|0;m=Gd(la|h|s|0,m|C|0,2)|0;m=m&2097151;s=Hd(d[q+8>>0]|0|0,0,8)|0;h=C;la=Hd(d[q+9>>0]|0|0,0,16)|0;h=h|C;_a=d[q+10>>0]|0;Pa=Hd(_a|0,0,24)|0;h=Gd(s|yc|la|Pa|0,h|C|0,7)|0;h=h&2097151;Pa=Hd(d[q+11>>0]|0|0,0,8)|0;la=C;yc=Hd(d[q+12>>0]|0|0,0,16)|0;la=la|C;s=d[q+13>>0]|0;Ec=Hd(s|0,0,24)|0;la=Gd(Pa|_a|yc|Ec|0,la|C|0,4)|0;la=la&2097151;Ec=a[q+15>>0]|0;yc=Hd(d[q+14>>0]|0|0,0,8)|0;_a=C;Ec=Ec&255;Pa=Hd(Ec|0,0,16)|0;_a=Gd(yc|s|Pa|0,_a|C|0,1)|0;_a=_a&2097151;Pa=Hd(d[q+16>>0]|0|0,0,8)|0;s=C;yc=Hd(d[q+17>>0]|0|0,0,16)|0;s=s|C;R=d[q+18>>0]|0;Bb=Hd(R|0,0,24)|0;s=Gd(Pa|Ec|yc|Bb|0,s|C|0,6)|0;s=s&2097151;Bb=a[q+20>>0]|0;yc=Hd(d[q+19>>0]|0|0,0,8)|0;Ec=C;Bb=Hd(Bb&255|0,0,16)|0;Ec=Gd(yc|R|Bb|0,Ec|C|0,3)|0;Bb=C;R=a[q+23>>0]|0;yc=d[q+21>>0]|0;Pa=Hd(d[q+22>>0]|0|0,0,8)|0;Da=C;R=R&255;ua=Hd(R|0,0,16)|0;ua=Pa|yc|ua&2031616;yc=Hd(d[q+24>>0]|0|0,0,8)|0;Pa=C;Ma=Hd(d[q+25>>0]|0|0,0,16)|0;Pa=Pa|C;D=d[q+26>>0]|0;zc=Hd(D|0,0,24)|0;Pa=Gd(yc|R|Ma|zc|0,Pa|C|0,5)|0;Pa=Pa&2097151;zc=a[q+28>>0]|0;Ma=Hd(d[q+27>>0]|0|0,0,8)|0;R=C;zc=zc&255;yc=Hd(zc|0,0,16)|0;R=Gd(Ma|D|yc|0,R|C|0,2)|0;R=R&2097151;yc=Hd(d[q+29>>0]|0|0,0,8)|0;D=C;Ma=Hd(d[q+30>>0]|0|0,0,16)|0;D=D|C;Ia=Hd(d[k>>0]|0|0,0,24)|0;D=Gd(yc|zc|Ma|Ia|0,D|C|0,7)|0;Ia=C;Ma=a[t+2>>0]|0;zc=d[t>>0]|0;yc=Hd(d[t+1>>0]|0|0,0,8)|0;ba=C;Ma=Ma&255;Ac=Hd(Ma|0,0,16)|0;Xa=Hd(d[t+3>>0]|0|0,0,8)|0;Ea=C;Ga=Hd(d[t+4>>0]|0|0,0,16)|0;Ea=Ea|C;pb=d[t+5>>0]|0;za=Hd(pb|0,0,24)|0;Ea=Gd(Xa|Ma|Ga|za|0,Ea|C|0,5)|0;za=a[t+7>>0]|0;Ga=Hd(d[t+6>>0]|0|0,0,8)|0;Ma=C;za=za&255;Xa=Hd(za|0,0,16)|0;Ma=Gd(Ga|pb|Xa|0,Ma|C|0,2)|0;Xa=Hd(d[t+8>>0]|0|0,0,8)|0;pb=C;Ga=Hd(d[t+9>>0]|0|0,0,16)|0;pb=pb|C;X=d[t+10>>0]|0;O=Hd(X|0,0,24)|0;pb=Gd(Xa|za|Ga|O|0,pb|C|0,7)|0;O=Hd(d[t+11>>0]|0|0,0,8)|0;Ga=C;za=Hd(d[t+12>>0]|0|0,0,16)|0;Ga=Ga|C;Xa=d[t+13>>0]|0;H=Hd(Xa|0,0,24)|0;Ga=Gd(O|X|za|H|0,Ga|C|0,4)|0;H=a[t+15>>0]|0;za=Hd(d[t+14>>0]|0|0,0,8)|0;X=C;H=H&255;O=Hd(H|0,0,16)|0;X=Gd(za|Xa|O|0,X|C|0,1)|0;O=Hd(d[t+16>>0]|0|0,0,8)|0;Xa=C;za=Hd(d[t+17>>0]|0|0,0,16)|0;Xa=Xa|C;U=d[t+18>>0]|0;w=Hd(U|0,0,24)|0;Xa=Gd(O|H|za|w|0,Xa|C|0,6)|0;w=a[t+20>>0]|0;za=Hd(d[t+19>>0]|0|0,0,8)|0;H=C;w=Hd(w&255|0,0,16)|0;H=Gd(za|U|w|0,H|C|0,3)|0;w=C;U=a[t+23>>0]|0;za=d[t+21>>0]|0;O=Hd(d[t+22>>0]|0|0,0,8)|0;da=C;U=U&255;ea=Hd(U|0,0,16)|0;Ba=Hd(d[t+24>>0]|0|0,0,8)|0;N=C;Ha=Hd(d[t+25>>0]|0|0,0,16)|0;N=N|C;A=d[t+26>>0]|0;ta=Hd(A|0,0,24)|0;N=Gd(Ba|U|Ha|ta|0,N|C|0,5)|0;ta=a[t+28>>0]|0;Ha=Hd(d[t+27>>0]|0|0,0,8)|0;U=C;ta=ta&255;Ba=Hd(ta|0,0,16)|0;U=Gd(Ha|A|Ba|0,U|C|0,2)|0;Ba=Hd(d[t+29>>0]|0|0,0,8)|0;A=C;Ha=Hd(d[t+30>>0]|0|0,0,16)|0;A=A|C;j=Hd(d[t+31>>0]|0|0,0,24)|0;A=Gd(Ba|ta|Ha|j|0,A|C|0,7)|0;j=C;Ha=Od(ha|0,ia|0,kb|0,qb|0)|0;Ha=Dd(yc|zc|Ac&2031616|0,ba|0,Ha|0,C|0)|0;ba=C;Ac=Od(db|0,0,kb|0,qb|0)|0;zc=C;yc=Od(ha|0,ia|0,xb|0,0)|0;ta=C;Ba=Od(m|0,0,kb|0,qb|0)|0;La=C;Ca=Od(db|0,0,xb|0,0)|0;tc=C;pa=Od(ha|0,ia|0,J|0,0)|0;pa=Dd(Ca|0,tc|0,pa|0,C|0)|0;La=Dd(pa|0,C|0,Ba|0,La|0)|0;Ma=Dd(La|0,C|0,Ma&2097151|0,0)|0;La=C;Ba=Od(h|0,0,kb|0,qb|0)|0;pa=C;tc=Od(m|0,0,xb|0,0)|0;Ca=C;xc=Od(db|0,0,J|0,0)|0;wc=C;vc=Od(ha|0,ia|0,ub|0,0)|0;uc=C;Oa=Od(la|0,0,kb|0,qb|0)|0;Fa=C;kc=Od(h|0,0,xb|0,0)|0;Y=C;mc=Od(m|0,0,J|0,0)|0;Na=C;nc=Od(db|0,0,ub|0,0)|0;oc=C;lc=Od(ha|0,ia|0,F|0,0)|0;lc=Dd(nc|0,oc|0,lc|0,C|0)|0;Na=Dd(lc|0,C|0,mc|0,Na|0)|0;Y=Dd(Na|0,C|0,kc|0,Y|0)|0;Fa=Dd(Y|0,C|0,Oa|0,Fa|0)|0;Ga=Dd(Fa|0,C|0,Ga&2097151|0,0)|0;Fa=C;Oa=Od(_a|0,0,kb|0,qb|0)|0;Y=C;kc=Od(la|0,0,xb|0,0)|0;Na=C;mc=Od(h|0,0,J|0,0)|0;lc=C;oc=Od(m|0,0,ub|0,0)|0;nc=C;sc=Od(db|0,0,F|0,0)|0;rc=C;qc=Od(ha|0,ia|0,v|0,0)|0;pc=C;ca=Od(s|0,0,kb|0,qb|0)|0;Ya=C;Zb=Od(_a|0,0,xb|0,0)|0;ka=C;$b=Od(la|0,0,J|0,0)|0;Yb=C;bc=Od(h|0,0,ub|0,0)|0;_b=C;dc=Od(m|0,0,F|0,0)|0;ac=C;ec=Od(db|0,0,v|0,0)|0;fc=C;cc=Od(ha|0,ia|0,Ta|0,0)|0;cc=Dd(ec|0,fc|0,cc|0,C|0)|0;ac=Dd(cc|0,C|0,dc|0,ac|0)|0;_b=Dd(ac|0,C|0,bc|0,_b|0)|0;Yb=Dd(_b|0,C|0,$b|0,Yb|0)|0;ka=Dd(Yb|0,C|0,Zb|0,ka|0)|0;Ya=Dd(ka|0,C|0,ca|0,Ya|0)|0;Xa=Dd(Ya|0,C|0,Xa&2097151|0,0)|0;Ya=C;ca=Od(Ec|0,Bb|0,kb|0,qb|0)|0;ka=C;Zb=Od(s|0,0,xb|0,0)|0;Yb=C;$b=Od(_a|0,0,J|0,0)|0;_b=C;bc=Od(la|0,0,ub|0,0)|0;ac=C;dc=Od(h|0,0,F|0,0)|0;cc=C;fc=Od(m|0,0,v|0,0)|0;ec=C;jc=Od(db|0,0,Ta|0,0)|0;ic=C;hc=Od(ha|0,ia|0,y|0,ja|0)|0;gc=C;Aa=Od(ua|0,Da|0,kb|0,qb|0)|0;Hb=C;Ib=Od(Ec|0,Bb|0,xb|0,0)|0;Jb=C;Kb=Od(s|0,0,J|0,0)|0;Lb=C;Mb=Od(_a|0,0,ub|0,0)|0;Nb=C;Ob=Od(la|0,0,F|0,0)|0;Pb=C;Qb=Od(h|0,0,v|0,0)|0;Rb=C;Sb=Od(m|0,0,Ta|0,0)|0;Tb=C;Vb=Od(db|0,0,y|0,ja|0)|0;Wb=C;Xb=Od(ha|0,ia|0,Qa|0,sb|0)|0;Xb=Dd(Vb|0,Wb|0,Xb|0,C|0)|0;Tb=Dd(Xb|0,C|0,Sb|0,Tb|0)|0;Rb=Dd(Tb|0,C|0,Qb|0,Rb|0)|0;Pb=Dd(Rb|0,C|0,Ob|0,Pb|0)|0;Nb=Dd(Pb|0,C|0,Mb|0,Nb|0)|0;Lb=Dd(Nb|0,C|0,Kb|0,Lb|0)|0;Jb=Dd(Lb|0,C|0,Ib|0,Jb|0)|0;Hb=Dd(Jb|0,C|0,Aa|0,Hb|0)|0;da=Dd(Hb|0,C|0,O|za|ea&2031616|0,da|0)|0;ea=C;za=Od(Pa|0,0,kb|0,qb|0)|0;O=C;Hb=Od(ua|0,Da|0,xb|0,0)|0;Aa=C;Jb=Od(Ec|0,Bb|0,J|0,0)|0;Ib=C;Lb=Od(s|0,0,ub|0,0)|0;Kb=C;Nb=Od(_a|0,0,F|0,0)|0;Mb=C;Pb=Od(la|0,0,v|0,0)|0;Ob=C;Rb=Od(h|0,0,Ta|0,0)|0;Qb=C;Tb=Od(m|0,0,y|0,ja|0)|0;Sb=C;Xb=Od(db|0,0,Qa|0,sb|0)|0;Wb=C;Vb=Od(ha|0,ia|0,Sa|0,0)|0;Ub=C;V=Od(R|0,0,kb|0,qb|0)|0;T=C;hb=Od(Pa|0,0,xb|0,0)|0;W=C;I=Od(ua|0,Da|0,J|0,0)|0;ib=C;vb=Od(Ec|0,Bb|0,ub|0,0)|0;E=C;Q=Od(s|0,0,F|0,0)|0;wb=C;Va=Od(_a|0,0,v|0,0)|0;K=C;nb=Od(la|0,0,Ta|0,0)|0;Wa=C;$=Od(h|0,0,y|0,ja|0)|0;ob=C;bb=Od(m|0,0,Qa|0,sb|0)|0;aa=C;Db=Od(db|0,0,Sa|0,0)|0;Eb=C;cb=Od(ha|0,ia|0,Bc|0,0)|0;cb=Dd(Db|0,Eb|0,cb|0,C|0)|0;aa=Dd(cb|0,C|0,bb|0,aa|0)|0;ob=Dd(aa|0,C|0,$|0,ob|0)|0;Wa=Dd(ob|0,C|0,nb|0,Wa|0)|0;K=Dd(Wa|0,C|0,Va|0,K|0)|0;wb=Dd(K|0,C|0,Q|0,wb|0)|0;E=Dd(wb|0,C|0,vb|0,E|0)|0;ib=Dd(E|0,C|0,I|0,ib|0)|0;W=Dd(ib|0,C|0,hb|0,W|0)|0;T=Dd(W|0,C|0,V|0,T|0)|0;U=Dd(T|0,C|0,U&2097151|0,0)|0;T=C;qb=Od(D|0,Ia|0,kb|0,qb|0)|0;kb=C;V=Od(R|0,0,xb|0,0)|0;W=C;hb=Od(Pa|0,0,J|0,0)|0;ib=C;I=Od(ua|0,Da|0,ub|0,0)|0;E=C;vb=Od(Ec|0,Bb|0,F|0,0)|0;wb=C;Q=Od(s|0,0,v|0,0)|0;K=C;Va=Od(_a|0,0,Ta|0,0)|0;Wa=C;nb=Od(la|0,0,y|0,ja|0)|0;ob=C;$=Od(h|0,0,Qa|0,sb|0)|0;aa=C;bb=Od(m|0,0,Sa|0,0)|0;cb=C;Eb=Od(db|0,0,Bc|0,0)|0;Db=C;ia=Od(ha|0,ia|0,p|0,Ka|0)|0;ha=C;xb=Od(D|0,Ia|0,xb|0,0)|0;yb=C;lb=Od(R|0,0,J|0,0)|0;G=C;ma=Od(Pa|0,0,ub|0,0)|0;mb=C;oa=Od(ua|0,Da|0,F|0,0)|0;ga=C;zb=Od(Ec|0,Bb|0,v|0,0)|0;rb=C;sa=Od(s|0,0,Ta|0,0)|0;Ab=C;xa=Od(_a|0,0,y|0,ja|0)|0;ra=C;Ua=Od(la|0,0,Qa|0,sb|0)|0;wa=C;eb=Od(h|0,0,Sa|0,0)|0;na=C;tb=Od(m|0,0,Bc|0,0)|0;l=C;db=Od(db|0,0,p|0,Ka|0)|0;db=Dd(tb|0,l|0,db|0,C|0)|0;na=Dd(db|0,C|0,eb|0,na|0)|0;wa=Dd(na|0,C|0,Ua|0,wa|0)|0;ra=Dd(wa|0,C|0,xa|0,ra|0)|0;Ab=Dd(ra|0,C|0,sa|0,Ab|0)|0;rb=Dd(Ab|0,C|0,zb|0,rb|0)|0;ga=Dd(rb|0,C|0,oa|0,ga|0)|0;mb=Dd(ga|0,C|0,ma|0,mb|0)|0;G=Dd(mb|0,C|0,lb|0,G|0)|0;yb=Dd(G|0,C|0,xb|0,yb|0)|0;xb=C;J=Od(D|0,Ia|0,J|0,0)|0;G=C;lb=Od(R|0,0,ub|0,0)|0;mb=C;ma=Od(Pa|0,0,F|0,0)|0;ga=C;oa=Od(ua|0,Da|0,v|0,0)|0;rb=C;zb=Od(Ec|0,Bb|0,Ta|0,0)|0;Ab=C;sa=Od(s|0,0,y|0,ja|0)|0;ra=C;xa=Od(_a|0,0,Qa|0,sb|0)|0;wa=C;Ua=Od(la|0,0,Sa|0,0)|0;na=C;eb=Od(h|0,0,Bc|0,0)|0;db=C;m=Od(m|0,0,p|0,Ka|0)|0;l=C;ub=Od(D|0,Ia|0,ub|0,0)|0;tb=C;fb=Od(R|0,0,F|0,0)|0;g=C;L=Od(Pa|0,0,v|0,0)|0;gb=C;r=Od(ua|0,Da|0,Ta|0,0)|0;n=C;fa=Od(Ec|0,Bb|0,y|0,ja|0)|0;x=C;qa=Od(s|0,0,Qa|0,sb|0)|0;k=C;va=Od(_a|0,0,Sa|0,0)|0;M=C;Cb=Od(la|0,0,Bc|0,0)|0;f=C;h=Od(h|0,0,p|0,Ka|0)|0;h=Dd(Cb|0,f|0,h|0,C|0)|0;M=Dd(h|0,C|0,va|0,M|0)|0;k=Dd(M|0,C|0,qa|0,k|0)|0;x=Dd(k|0,C|0,fa|0,x|0)|0;n=Dd(x|0,C|0,r|0,n|0)|0;gb=Dd(n|0,C|0,L|0,gb|0)|0;g=Dd(gb|0,C|0,fb|0,g|0)|0;tb=Dd(g|0,C|0,ub|0,tb|0)|0;ub=C;F=Od(D|0,Ia|0,F|0,0)|0;g=C;fb=Od(R|0,0,v|0,0)|0;gb=C;L=Od(Pa|0,0,Ta|0,0)|0;n=C;r=Od(ua|0,Da|0,y|0,ja|0)|0;x=C;fa=Od(Ec|0,Bb|0,Qa|0,sb|0)|0;k=C;qa=Od(s|0,0,Sa|0,0)|0;M=C;va=Od(_a|0,0,Bc|0,0)|0;h=C;la=Od(la|0,0,p|0,Ka|0)|0;f=C;v=Od(D|0,Ia|0,v|0,0)|0;Cb=C;B=Od(R|0,0,Ta|0,0)|0;S=C;_=Od(Pa|0,0,y|0,ja|0)|0;Ra=C;ab=Od(ua|0,Da|0,Qa|0,sb|0)|0;Z=C;Za=Od(Ec|0,Bb|0,Sa|0,0)|0;$a=C;P=Od(s|0,0,Bc|0,0)|0;u=C;_a=Od(_a|0,0,p|0,Ka|0)|0;_a=Dd(P|0,u|0,_a|0,C|0)|0;$a=Dd(_a|0,C|0,Za|0,$a|0)|0;Z=Dd($a|0,C|0,ab|0,Z|0)|0;Ra=Dd(Z|0,C|0,_|0,Ra|0)|0;S=Dd(Ra|0,C|0,B|0,S|0)|0;Cb=Dd(S|0,C|0,v|0,Cb|0)|0;v=C;Ta=Od(D|0,Ia|0,Ta|0,0)|0;S=C;B=Od(R|0,0,y|0,ja|0)|0;Ra=C;_=Od(Pa|0,0,Qa|0,sb|0)|0;Z=C;ab=Od(ua|0,Da|0,Sa|0,0)|0;$a=C;Za=Od(Ec|0,Bb|0,Bc|0,0)|0;_a=C;s=Od(s|0,0,p|0,Ka|0)|0;u=C;ja=Od(D|0,Ia|0,y|0,ja|0)|0;y=C;P=Od(R|0,0,Qa|0,sb|0)|0;Ja=C;ya=Od(Pa|0,0,Sa|0,0)|0;jb=C;Cc=Od(ua|0,Da|0,Bc|0,0)|0;Dc=C;Bb=Od(Ec|0,Bb|0,p|0,Ka|0)|0;Bb=Dd(Cc|0,Dc|0,Bb|0,C|0)|0;jb=Dd(Bb|0,C|0,ya|0,jb|0)|0;Ja=Dd(jb|0,C|0,P|0,Ja|0)|0;y=Dd(Ja|0,C|0,ja|0,y|0)|0;ja=C;sb=Od(D|0,Ia|0,Qa|0,sb|0)|0;Qa=C;Ja=Od(R|0,0,Sa|0,0)|0;P=C;jb=Od(Pa|0,0,Bc|0,0)|0;ya=C;Da=Od(ua|0,Da|0,p|0,Ka|0)|0;ua=C;Sa=Od(D|0,Ia|0,Sa|0,0)|0;Bb=C;Dc=Od(R|0,0,Bc|0,0)|0;Cc=C;Pa=Od(Pa|0,0,p|0,Ka|0)|0;Pa=Dd(Dc|0,Cc|0,Pa|0,C|0)|0;Bb=Dd(Pa|0,C|0,Sa|0,Bb|0)|0;Sa=C;Bc=Od(D|0,Ia|0,Bc|0,0)|0;Pa=C;R=Od(R|0,0,p|0,Ka|0)|0;R=Dd(Bc|0,Pa|0,R|0,C|0)|0;Pa=C;Ka=Od(D|0,Ia|0,p|0,Ka|0)|0;p=C;Ia=Dd(Ha|0,ba|0,1048576,0)|0;Ia=Gd(Ia|0,C|0,21)|0;D=C;ta=Dd(Ac|0,zc|0,yc|0,ta|0)|0;ta=Dd(ta|0,C|0,Ia|0,D|0)|0;Ea=Dd(ta|0,C|0,Ea&2097151|0,0)|0;ta=C;D=Hd(Ia|0,D|0,21)|0;D=Cd(Ha|0,ba|0,D|0,C|0)|0;ba=C;Ha=Dd(Ma|0,La|0,1048576,0)|0;Ha=Gd(Ha|0,C|0,21)|0;Ia=C;uc=Dd(xc|0,wc|0,vc|0,uc|0)|0;Ca=Dd(uc|0,C|0,tc|0,Ca|0)|0;pa=Dd(Ca|0,C|0,Ba|0,pa|0)|0;pb=Dd(pa|0,C|0,pb&2097151|0,0)|0;pb=Dd(pb|0,C|0,Ha|0,Ia|0)|0;pa=C;Ia=Hd(Ha|0,Ia|0,21)|0;Ha=C;Ba=Dd(Ga|0,Fa|0,1048576,0)|0;Ba=Ed(Ba|0,C|0,21)|0;Ca=C;pc=Dd(sc|0,rc|0,qc|0,pc|0)|0;nc=Dd(pc|0,C|0,oc|0,nc|0)|0;lc=Dd(nc|0,C|0,mc|0,lc|0)|0;Na=Dd(lc|0,C|0,kc|0,Na|0)|0;Y=Dd(Na|0,C|0,Oa|0,Y|0)|0;X=Dd(Y|0,C|0,X&2097151|0,0)|0;X=Dd(X|0,C|0,Ba|0,Ca|0)|0;Y=C;Ca=Hd(Ba|0,Ca|0,21)|0;Ba=C;Oa=Dd(Xa|0,Ya|0,1048576,0)|0;Oa=Ed(Oa|0,C|0,21)|0;Na=C;gc=Dd(jc|0,ic|0,hc|0,gc|0)|0;ec=Dd(gc|0,C|0,fc|0,ec|0)|0;cc=Dd(ec|0,C|0,dc|0,cc|0)|0;ac=Dd(cc|0,C|0,bc|0,ac|0)|0;_b=Dd(ac|0,C|0,$b|0,_b|0)|0;Yb=Dd(_b|0,C|0,Zb|0,Yb|0)|0;ka=Dd(Yb|0,C|0,ca|0,ka|0)|0;w=Dd(ka|0,C|0,H|0,w|0)|0;w=Dd(w|0,C|0,Oa|0,Na|0)|0;H=C;Na=Hd(Oa|0,Na|0,21)|0;Oa=C;ka=Dd(da|0,ea|0,1048576,0)|0;ka=Ed(ka|0,C|0,21)|0;ca=C;Ub=Dd(Xb|0,Wb|0,Vb|0,Ub|0)|0;Sb=Dd(Ub|0,C|0,Tb|0,Sb|0)|0;Qb=Dd(Sb|0,C|0,Rb|0,Qb|0)|0;Ob=Dd(Qb|0,C|0,Pb|0,Ob|0)|0;Mb=Dd(Ob|0,C|0,Nb|0,Mb|0)|0;Kb=Dd(Mb|0,C|0,Lb|0,Kb|0)|0;Ib=Dd(Kb|0,C|0,Jb|0,Ib|0)|0;Aa=Dd(Ib|0,C|0,Hb|0,Aa|0)|0;O=Dd(Aa|0,C|0,za|0,O|0)|0;N=Dd(O|0,C|0,N&2097151|0,0)|0;N=Dd(N|0,C|0,ka|0,ca|0)|0;O=C;ca=Hd(ka|0,ca|0,21)|0;ka=C;za=Dd(U|0,T|0,1048576,0)|0;za=Ed(za|0,C|0,21)|0;Aa=C;ha=Dd(Eb|0,Db|0,ia|0,ha|0)|0;cb=Dd(ha|0,C|0,bb|0,cb|0)|0;aa=Dd(cb|0,C|0,$|0,aa|0)|0;ob=Dd(aa|0,C|0,nb|0,ob|0)|0;Wa=Dd(ob|0,C|0,Va|0,Wa|0)|0;K=Dd(Wa|0,C|0,Q|0,K|0)|0;wb=Dd(K|0,C|0,vb|0,wb|0)|0;E=Dd(wb|0,C|0,I|0,E|0)|0;ib=Dd(E|0,C|0,hb|0,ib|0)|0;W=Dd(ib|0,C|0,V|0,W|0)|0;kb=Dd(W|0,C|0,qb|0,kb|0)|0;j=Dd(kb|0,C|0,A|0,j|0)|0;j=Dd(j|0,C|0,za|0,Aa|0)|0;A=C;Aa=Hd(za|0,Aa|0,21)|0;za=C;kb=Dd(yb|0,xb|0,1048576,0)|0;kb=Ed(kb|0,C|0,21)|0;qb=C;l=Dd(eb|0,db|0,m|0,l|0)|0;na=Dd(l|0,C|0,Ua|0,na|0)|0;wa=Dd(na|0,C|0,xa|0,wa|0)|0;ra=Dd(wa|0,C|0,sa|0,ra|0)|0;Ab=Dd(ra|0,C|0,zb|0,Ab|0)|0;rb=Dd(Ab|0,C|0,oa|0,rb|0)|0;ga=Dd(rb|0,C|0,ma|0,ga|0)|0;mb=Dd(ga|0,C|0,lb|0,mb|0)|0;G=Dd(mb|0,C|0,J|0,G|0)|0;G=Dd(G|0,C|0,kb|0,qb|0)|0;J=C;qb=Hd(kb|0,qb|0,21)|0;kb=C;mb=Dd(tb|0,ub|0,1048576,0)|0;mb=Ed(mb|0,C|0,21)|0;lb=C;f=Dd(va|0,h|0,la|0,f|0)|0;M=Dd(f|0,C|0,qa|0,M|0)|0;k=Dd(M|0,C|0,fa|0,k|0)|0;x=Dd(k|0,C|0,r|0,x|0)|0;n=Dd(x|0,C|0,L|0,n|0)|0;gb=Dd(n|0,C|0,fb|0,gb|0)|0;g=Dd(gb|0,C|0,F|0,g|0)|0;g=Dd(g|0,C|0,mb|0,lb|0)|0;F=C;lb=Hd(mb|0,lb|0,21)|0;mb=C;gb=Dd(Cb|0,v|0,1048576,0)|0;gb=Ed(gb|0,C|0,21)|0;fb=C;u=Dd(Za|0,_a|0,s|0,u|0)|0;$a=Dd(u|0,C|0,ab|0,$a|0)|0;Z=Dd($a|0,C|0,_|0,Z|0)|0;Ra=Dd(Z|0,C|0,B|0,Ra|0)|0;S=Dd(Ra|0,C|0,Ta|0,S|0)|0;S=Dd(S|0,C|0,gb|0,fb|0)|0;Ta=C;fb=Hd(gb|0,fb|0,21)|0;gb=C;Ra=Dd(y|0,ja|0,1048576,0)|0;Ra=Ed(Ra|0,C|0,21)|0;B=C;ua=Dd(jb|0,ya|0,Da|0,ua|0)|0;P=Dd(ua|0,C|0,Ja|0,P|0)|0;Qa=Dd(P|0,C|0,sb|0,Qa|0)|0;Qa=Dd(Qa|0,C|0,Ra|0,B|0)|0;sb=C;B=Hd(Ra|0,B|0,21)|0;B=Cd(y|0,ja|0,B|0,C|0)|0;ja=C;y=Dd(Bb|0,Sa|0,1048576,0)|0;y=Ed(y|0,C|0,21)|0;Ra=C;Pa=Dd(R|0,Pa|0,y|0,Ra|0)|0;R=C;Ra=Hd(y|0,Ra|0,21)|0;Ra=Cd(Bb|0,Sa|0,Ra|0,C|0)|0;Sa=C;Bb=Dd(Ka|0,p|0,1048576,0)|0;Bb=Ed(Bb|0,C|0,21)|0;y=C;P=Hd(Bb|0,y|0,21)|0;P=Cd(Ka|0,p|0,P|0,C|0)|0;p=C;Ka=Dd(Ea|0,ta|0,1048576,0)|0;Ka=Gd(Ka|0,C|0,21)|0;Ja=C;ua=Hd(Ka|0,Ja|0,21)|0;ua=Cd(Ea|0,ta|0,ua|0,C|0)|0;ta=C;Ea=Dd(pb|0,pa|0,1048576,0)|0;Ea=Ed(Ea|0,C|0,21)|0;Da=C;ya=Hd(Ea|0,Da|0,21)|0;ya=Cd(pb|0,pa|0,ya|0,C|0)|0;pa=C;pb=Dd(X|0,Y|0,1048576,0)|0;pb=Ed(pb|0,C|0,21)|0;jb=C;Z=Hd(pb|0,jb|0,21)|0;_=C;$a=Dd(w|0,H|0,1048576,0)|0;$a=Ed($a|0,C|0,21)|0;ab=C;u=Hd($a|0,ab|0,21)|0;s=C;_a=Dd(N|0,O|0,1048576,0)|0;_a=Ed(_a|0,C|0,21)|0;Za=C;n=Hd(_a|0,Za|0,21)|0;L=C;x=Dd(j|0,A|0,1048576,0)|0;x=Ed(x|0,C|0,21)|0;r=C;k=Hd(x|0,r|0,21)|0;fa=C;M=Dd(G|0,J|0,1048576,0)|0;M=Ed(M|0,C|0,21)|0;qa=C;f=Hd(M|0,qa|0,21)|0;la=C;h=Dd(g|0,F|0,1048576,0)|0;h=Ed(h|0,C|0,21)|0;va=C;ga=Hd(h|0,va|0,21)|0;ma=C;rb=Dd(S|0,Ta|0,1048576,0)|0;rb=Ed(rb|0,C|0,21)|0;oa=C;ja=Dd(rb|0,oa|0,B|0,ja|0)|0;B=C;oa=Hd(rb|0,oa|0,21)|0;oa=Cd(S|0,Ta|0,oa|0,C|0)|0;Ta=C;S=Dd(Qa|0,sb|0,1048576,0)|0;S=Ed(S|0,C|0,21)|0;rb=C;Sa=Dd(S|0,rb|0,Ra|0,Sa|0)|0;Ra=C;rb=Hd(S|0,rb|0,21)|0;rb=Cd(Qa|0,sb|0,rb|0,C|0)|0;sb=C;Qa=Dd(Pa|0,R|0,1048576,0)|0;Qa=Ed(Qa|0,C|0,21)|0;S=C;p=Dd(Qa|0,S|0,P|0,p|0)|0;P=C;S=Hd(Qa|0,S|0,21)|0;S=Cd(Pa|0,R|0,S|0,C|0)|0;R=C;Pa=Od(Bb|0,y|0,666643,0)|0;Qa=C;Ab=Od(Bb|0,y|0,470296,0)|0;zb=C;ra=Od(Bb|0,y|0,654183,0)|0;sa=C;wa=Od(Bb|0,y|0,-997805,-1)|0;xa=C;na=Od(Bb|0,y|0,136657,0)|0;Ua=C;y=Od(Bb|0,y|0,-683901,-1)|0;y=Dd(Cb|0,v|0,y|0,C|0)|0;gb=Cd(y|0,C|0,fb|0,gb|0)|0;va=Dd(gb|0,C|0,h|0,va|0)|0;h=C;gb=Od(p|0,P|0,666643,0)|0;fb=C;y=Od(p|0,P|0,470296,0)|0;v=C;Cb=Od(p|0,P|0,654183,0)|0;Bb=C;l=Od(p|0,P|0,-997805,-1)|0;m=C;db=Od(p|0,P|0,136657,0)|0;eb=C;P=Od(p|0,P|0,-683901,-1)|0;p=C;W=Od(S|0,R|0,666643,0)|0;V=C;ib=Od(S|0,R|0,470296,0)|0;hb=C;E=Od(S|0,R|0,654183,0)|0;I=C;wb=Od(S|0,R|0,-997805,-1)|0;vb=C;K=Od(S|0,R|0,136657,0)|0;Q=C;R=Od(S|0,R|0,-683901,-1)|0;S=C;xa=Dd(tb|0,ub|0,wa|0,xa|0)|0;eb=Dd(xa|0,C|0,db|0,eb|0)|0;S=Dd(eb|0,C|0,R|0,S|0)|0;mb=Cd(S|0,C|0,lb|0,mb|0)|0;qa=Dd(mb|0,C|0,M|0,qa|0)|0;M=C;mb=Od(Sa|0,Ra|0,666643,0)|0;lb=C;S=Od(Sa|0,Ra|0,470296,0)|0;R=C;eb=Od(Sa|0,Ra|0,654183,0)|0;db=C;xa=Od(Sa|0,Ra|0,-997805,-1)|0;wa=C;ub=Od(Sa|0,Ra|0,136657,0)|0;tb=C;Ra=Od(Sa|0,Ra|0,-683901,-1)|0;Sa=C;Wa=Od(rb|0,sb|0,666643,0)|0;Va=C;ob=Od(rb|0,sb|0,470296,0)|0;nb=C;aa=Od(rb|0,sb|0,654183,0)|0;$=C;cb=Od(rb|0,sb|0,-997805,-1)|0;bb=C;ha=Od(rb|0,sb|0,136657,0)|0;ia=C;sb=Od(rb|0,sb|0,-683901,-1)|0;rb=C;zb=Dd(Cb|0,Bb|0,Ab|0,zb|0)|0;xb=Dd(zb|0,C|0,yb|0,xb|0)|0;vb=Dd(xb|0,C|0,wb|0,vb|0)|0;tb=Dd(vb|0,C|0,ub|0,tb|0)|0;rb=Dd(tb|0,C|0,sb|0,rb|0)|0;kb=Cd(rb|0,C|0,qb|0,kb|0)|0;r=Dd(kb|0,C|0,x|0,r|0)|0;x=C;kb=Od(ja|0,B|0,666643,0)|0;kb=Dd(pb|0,jb|0,kb|0,C|0)|0;Ya=Dd(kb|0,C|0,Xa|0,Ya|0)|0;Oa=Cd(Ya|0,C|0,Na|0,Oa|0)|0;Na=C;Ya=Od(ja|0,B|0,470296,0)|0;Xa=C;kb=Od(ja|0,B|0,654183,0)|0;jb=C;lb=Dd(ob|0,nb|0,mb|0,lb|0)|0;jb=Dd(lb|0,C|0,kb|0,jb|0)|0;ab=Dd(jb|0,C|0,$a|0,ab|0)|0;ea=Dd(ab|0,C|0,da|0,ea|0)|0;ka=Cd(ea|0,C|0,ca|0,ka|0)|0;ca=C;ea=Od(ja|0,B|0,-997805,-1)|0;da=C;ab=Od(ja|0,B|0,136657,0)|0;$a=C;fb=Dd(ib|0,hb|0,gb|0,fb|0)|0;db=Dd(fb|0,C|0,eb|0,db|0)|0;bb=Dd(db|0,C|0,cb|0,bb|0)|0;$a=Dd(bb|0,C|0,ab|0,$a|0)|0;Za=Dd($a|0,C|0,_a|0,Za|0)|0;T=Dd(Za|0,C|0,U|0,T|0)|0;za=Cd(T|0,C|0,Aa|0,za|0)|0;Aa=C;B=Od(ja|0,B|0,-683901,-1)|0;ja=C;T=Dd(Oa|0,Na|0,1048576,0)|0;T=Ed(T|0,C|0,21)|0;U=C;Va=Dd(Ya|0,Xa|0,Wa|0,Va|0)|0;H=Dd(Va|0,C|0,w|0,H|0)|0;s=Cd(H|0,C|0,u|0,s|0)|0;s=Dd(s|0,C|0,T|0,U|0)|0;u=C;U=Hd(T|0,U|0,21)|0;T=C;H=Dd(ka|0,ca|0,1048576,0)|0;H=Ed(H|0,C|0,21)|0;w=C;V=Dd(S|0,R|0,W|0,V|0)|0;$=Dd(V|0,C|0,aa|0,$|0)|0;da=Dd($|0,C|0,ea|0,da|0)|0;O=Dd(da|0,C|0,N|0,O|0)|0;L=Cd(O|0,C|0,n|0,L|0)|0;L=Dd(L|0,C|0,H|0,w|0)|0;n=C;w=Hd(H|0,w|0,21)|0;H=C;O=Dd(za|0,Aa|0,1048576,0)|0;O=Ed(O|0,C|0,21)|0;N=C;Qa=Dd(y|0,v|0,Pa|0,Qa|0)|0;I=Dd(Qa|0,C|0,E|0,I|0)|0;wa=Dd(I|0,C|0,xa|0,wa|0)|0;ia=Dd(wa|0,C|0,ha|0,ia|0)|0;ja=Dd(ia|0,C|0,B|0,ja|0)|0;A=Dd(ja|0,C|0,j|0,A|0)|0;fa=Cd(A|0,C|0,k|0,fa|0)|0;fa=Dd(fa|0,C|0,O|0,N|0)|0;k=C;N=Hd(O|0,N|0,21)|0;O=C;A=Dd(r|0,x|0,1048576,0)|0;A=Ed(A|0,C|0,21)|0;j=C;sa=Dd(l|0,m|0,ra|0,sa|0)|0;Q=Dd(sa|0,C|0,K|0,Q|0)|0;Sa=Dd(Q|0,C|0,Ra|0,Sa|0)|0;J=Dd(Sa|0,C|0,G|0,J|0)|0;la=Cd(J|0,C|0,f|0,la|0)|0;la=Dd(la|0,C|0,A|0,j|0)|0;f=C;j=Hd(A|0,j|0,21)|0;j=Cd(r|0,x|0,j|0,C|0)|0;x=C;r=Dd(qa|0,M|0,1048576,0)|0;r=Ed(r|0,C|0,21)|0;A=C;Ua=Dd(P|0,p|0,na|0,Ua|0)|0;F=Dd(Ua|0,C|0,g|0,F|0)|0;ma=Cd(F|0,C|0,ga|0,ma|0)|0;ma=Dd(ma|0,C|0,r|0,A|0)|0;ga=C;A=Hd(r|0,A|0,21)|0;A=Cd(qa|0,M|0,A|0,C|0)|0;M=C;qa=Dd(va|0,h|0,1048576,0)|0;qa=Ed(qa|0,C|0,21)|0;r=C;Ta=Dd(qa|0,r|0,oa|0,Ta|0)|0;oa=C;r=Hd(qa|0,r|0,21)|0;r=Cd(va|0,h|0,r|0,C|0)|0;h=C;va=Dd(s|0,u|0,1048576,0)|0;va=Ed(va|0,C|0,21)|0;qa=C;F=Hd(va|0,qa|0,21)|0;g=C;Ua=Dd(L|0,n|0,1048576,0)|0;Ua=Ed(Ua|0,C|0,21)|0;na=C;p=Hd(Ua|0,na|0,21)|0;P=C;J=Dd(fa|0,k|0,1048576,0)|0;J=Ed(J|0,C|0,21)|0;G=C;x=Dd(J|0,G|0,j|0,x|0)|0;j=C;G=Hd(J|0,G|0,21)|0;G=Cd(fa|0,k|0,G|0,C|0)|0;k=C;fa=Dd(la|0,f|0,1048576,0)|0;fa=Ed(fa|0,C|0,21)|0;J=C;M=Dd(fa|0,J|0,A|0,M|0)|0;A=C;J=Hd(fa|0,J|0,21)|0;J=Cd(la|0,f|0,J|0,C|0)|0;f=C;la=Dd(ma|0,ga|0,1048576,0)|0;la=Ed(la|0,C|0,21)|0;fa=C;h=Dd(la|0,fa|0,r|0,h|0)|0;r=C;fa=Hd(la|0,fa|0,21)|0;fa=Cd(ma|0,ga|0,fa|0,C|0)|0;ga=C;ma=Od(Ta|0,oa|0,666643,0)|0;la=C;Sa=Od(Ta|0,oa|0,470296,0)|0;Ra=C;Q=Od(Ta|0,oa|0,654183,0)|0;K=C;sa=Od(Ta|0,oa|0,-997805,-1)|0;ra=C;m=Od(Ta|0,oa|0,136657,0)|0;l=C;oa=Od(Ta|0,oa|0,-683901,-1)|0;oa=Dd(Ua|0,na|0,oa|0,C|0)|0;Aa=Dd(oa|0,C|0,za|0,Aa|0)|0;O=Cd(Aa|0,C|0,N|0,O|0)|0;N=C;Aa=Od(h|0,r|0,666643,0)|0;za=C;oa=Od(h|0,r|0,470296,0)|0;na=C;Ua=Od(h|0,r|0,654183,0)|0;Ta=C;ja=Od(h|0,r|0,-997805,-1)|0;B=C;ia=Od(h|0,r|0,136657,0)|0;ha=C;r=Od(h|0,r|0,-683901,-1)|0;h=C;wa=Od(fa|0,ga|0,666643,0)|0;wa=Dd(ya|0,pa|0,wa|0,C|0)|0;pa=C;ya=Od(fa|0,ga|0,470296,0)|0;xa=C;I=Od(fa|0,ga|0,654183,0)|0;E=C;Qa=Od(fa|0,ga|0,-997805,-1)|0;Pa=C;v=Od(fa|0,ga|0,136657,0)|0;y=C;ga=Od(fa|0,ga|0,-683901,-1)|0;fa=C;ra=Dd(ia|0,ha|0,sa|0,ra|0)|0;fa=Dd(ra|0,C|0,ga|0,fa|0)|0;qa=Dd(fa|0,C|0,va|0,qa|0)|0;ca=Dd(qa|0,C|0,ka|0,ca|0)|0;H=Cd(ca|0,C|0,w|0,H|0)|0;w=C;ca=Od(M|0,A|0,666643,0)|0;ka=C;qa=Od(M|0,A|0,470296,0)|0;qa=Dd(wa|0,pa|0,qa|0,C|0)|0;pa=C;wa=Od(M|0,A|0,654183,0)|0;va=C;fa=Od(M|0,A|0,-997805,-1)|0;ga=C;ra=Od(M|0,A|0,136657,0)|0;sa=C;A=Od(M|0,A|0,-683901,-1)|0;M=C;ha=Od(J|0,f|0,666643,0)|0;ia=C;da=Od(J|0,f|0,470296,0)|0;ea=C;$=Od(J|0,f|0,654183,0)|0;aa=C;V=Od(J|0,f|0,-997805,-1)|0;W=C;R=Od(J|0,f|0,136657,0)|0;S=C;f=Od(J|0,f|0,-683901,-1)|0;J=C;Ra=Dd(Ua|0,Ta|0,Sa|0,Ra|0)|0;Pa=Dd(Ra|0,C|0,Qa|0,Pa|0)|0;Na=Dd(Pa|0,C|0,Oa|0,Na|0)|0;T=Cd(Na|0,C|0,U|0,T|0)|0;sa=Dd(T|0,C|0,ra|0,sa|0)|0;J=Dd(sa|0,C|0,f|0,J|0)|0;f=C;sa=Od(x|0,j|0,666643,0)|0;ba=Dd(sa|0,C|0,D|0,ba|0)|0;D=C;sa=Od(x|0,j|0,470296,0)|0;ra=C;T=Od(x|0,j|0,654183,0)|0;U=C;Ja=Dd(Ma|0,La|0,Ka|0,Ja|0)|0;Ha=Cd(Ja|0,C|0,Ia|0,Ha|0)|0;ka=Dd(Ha|0,C|0,ca|0,ka|0)|0;U=Dd(ka|0,C|0,T|0,U|0)|0;ea=Dd(U|0,C|0,da|0,ea|0)|0;da=C;U=Od(x|0,j|0,-997805,-1)|0;T=C;ka=Od(x|0,j|0,136657,0)|0;ca=C;Da=Dd(Ga|0,Fa|0,Ea|0,Da|0)|0;Ba=Cd(Da|0,C|0,Ca|0,Ba|0)|0;za=Dd(Ba|0,C|0,Aa|0,za|0)|0;xa=Dd(za|0,C|0,ya|0,xa|0)|0;va=Dd(xa|0,C|0,wa|0,va|0)|0;ca=Dd(va|0,C|0,ka|0,ca|0)|0;W=Dd(ca|0,C|0,V|0,W|0)|0;V=C;j=Od(x|0,j|0,-683901,-1)|0;x=C;ca=Dd(ba|0,D|0,1048576,0)|0;ca=Ed(ca|0,C|0,21)|0;ka=C;ra=Dd(ua|0,ta|0,sa|0,ra|0)|0;ia=Dd(ra|0,C|0,ha|0,ia|0)|0;ia=Dd(ia|0,C|0,ca|0,ka|0)|0;ha=C;ka=Hd(ca|0,ka|0,21)|0;ka=Cd(ba|0,D|0,ka|0,C|0)|0;D=C;ba=Dd(ea|0,da|0,1048576,0)|0;ba=Ed(ba|0,C|0,21)|0;ca=C;T=Dd(qa|0,pa|0,U|0,T|0)|0;aa=Dd(T|0,C|0,$|0,aa|0)|0;aa=Dd(aa|0,C|0,ba|0,ca|0)|0;$=C;ca=Hd(ba|0,ca|0,21)|0;ba=C;T=Dd(W|0,V|0,1048576,0)|0;T=Ed(T|0,C|0,21)|0;U=C;la=Dd(oa|0,na|0,ma|0,la|0)|0;E=Dd(la|0,C|0,I|0,E|0)|0;Y=Dd(E|0,C|0,X|0,Y|0)|0;_=Cd(Y|0,C|0,Z|0,_|0)|0;ga=Dd(_|0,C|0,fa|0,ga|0)|0;x=Dd(ga|0,C|0,j|0,x|0)|0;S=Dd(x|0,C|0,R|0,S|0)|0;S=Dd(S|0,C|0,T|0,U|0)|0;R=C;U=Hd(T|0,U|0,21)|0;T=C;x=Dd(J|0,f|0,1048576,0)|0;x=Ed(x|0,C|0,21)|0;j=C;K=Dd(ja|0,B|0,Q|0,K|0)|0;y=Dd(K|0,C|0,v|0,y|0)|0;u=Dd(y|0,C|0,s|0,u|0)|0;g=Cd(u|0,C|0,F|0,g|0)|0;M=Dd(g|0,C|0,A|0,M|0)|0;M=Dd(M|0,C|0,x|0,j|0)|0;A=C;j=Hd(x|0,j|0,21)|0;j=Cd(J|0,f|0,j|0,C|0)|0;f=C;J=Dd(H|0,w|0,1048576,0)|0;J=Ed(J|0,C|0,21)|0;x=C;l=Dd(r|0,h|0,m|0,l|0)|0;n=Dd(l|0,C|0,L|0,n|0)|0;n=Dd(n|0,C|0,J|0,x|0)|0;P=Cd(n|0,C|0,p|0,P|0)|0;p=C;x=Hd(J|0,x|0,21)|0;x=Cd(H|0,w|0,x|0,C|0)|0;w=C;H=Dd(O|0,N|0,1048576,0)|0;H=Ed(H|0,C|0,21)|0;J=C;k=Dd(G|0,k|0,H|0,J|0)|0;G=C;J=Hd(H|0,J|0,21)|0;H=C;n=Dd(ia|0,ha|0,1048576,0)|0;n=Ed(n|0,C|0,21)|0;L=C;l=Hd(n|0,L|0,21)|0;m=C;h=Dd(aa|0,$|0,1048576,0)|0;h=Ed(h|0,C|0,21)|0;r=C;g=Hd(h|0,r|0,21)|0;F=C;u=Dd(S|0,R|0,1048576,0)|0;u=Ed(u|0,C|0,21)|0;s=C;f=Dd(j|0,f|0,u|0,s|0)|0;j=C;s=Hd(u|0,s|0,21)|0;u=C;y=Dd(M|0,A|0,1048576,0)|0;y=Ed(y|0,C|0,21)|0;v=C;w=Dd(x|0,w|0,y|0,v|0)|0;x=C;v=Hd(y|0,v|0,21)|0;v=Cd(M|0,A|0,v|0,C|0)|0;A=C;M=Dd(P|0,p|0,1048576,0)|0;M=Ed(M|0,C|0,21)|0;y=C;K=Hd(M|0,y|0,21)|0;K=Cd(P|0,p|0,K|0,C|0)|0;p=C;P=Dd(k|0,G|0,1048576,0)|0;P=Ed(P|0,C|0,21)|0;Q=C;B=Hd(P|0,Q|0,21)|0;B=Cd(k|0,G|0,B|0,C|0)|0;G=C;k=Od(P|0,Q|0,666643,0)|0;k=Dd(ka|0,D|0,k|0,C|0)|0;D=C;ka=Od(P|0,Q|0,470296,0)|0;ja=C;ga=Od(P|0,Q|0,654183,0)|0;fa=C;_=Od(P|0,Q|0,-997805,-1)|0;Z=C;Y=Od(P|0,Q|0,136657,0)|0;X=C;Q=Od(P|0,Q|0,-683901,-1)|0;P=C;E=Ed(k|0,D|0,21)|0;I=C;ha=Dd(ka|0,ja|0,ia|0,ha|0)|0;m=Cd(ha|0,C|0,l|0,m|0)|0;m=Dd(m|0,C|0,E|0,I|0)|0;l=C;I=Hd(E|0,I|0,21)|0;I=Cd(k|0,D|0,I|0,C|0)|0;D=C;k=Ed(m|0,l|0,21)|0;E=C;da=Dd(ga|0,fa|0,ea|0,da|0)|0;ba=Cd(da|0,C|0,ca|0,ba|0)|0;L=Dd(ba|0,C|0,n|0,L|0)|0;L=Dd(L|0,C|0,k|0,E|0)|0;n=C;E=Hd(k|0,E|0,21)|0;E=Cd(m|0,l|0,E|0,C|0)|0;l=C;m=Ed(L|0,n|0,21)|0;k=C;Z=Dd(aa|0,$|0,_|0,Z|0)|0;F=Cd(Z|0,C|0,g|0,F|0)|0;F=Dd(F|0,C|0,m|0,k|0)|0;g=C;k=Hd(m|0,k|0,21)|0;k=Cd(L|0,n|0,k|0,C|0)|0;n=C;L=Ed(F|0,g|0,21)|0;m=C;V=Dd(Y|0,X|0,W|0,V|0)|0;T=Cd(V|0,C|0,U|0,T|0)|0;r=Dd(T|0,C|0,h|0,r|0)|0;r=Dd(r|0,C|0,L|0,m|0)|0;h=C;m=Hd(L|0,m|0,21)|0;m=Cd(F|0,g|0,m|0,C|0)|0;g=C;F=Ed(r|0,h|0,21)|0;L=C;P=Dd(S|0,R|0,Q|0,P|0)|0;u=Cd(P|0,C|0,s|0,u|0)|0;u=Dd(u|0,C|0,F|0,L|0)|0;s=C;L=Hd(F|0,L|0,21)|0;L=Cd(r|0,h|0,L|0,C|0)|0;h=C;r=Ed(u|0,s|0,21)|0;F=C;j=Dd(f|0,j|0,r|0,F|0)|0;f=C;F=Hd(r|0,F|0,21)|0;F=Cd(u|0,s|0,F|0,C|0)|0;s=C;u=Ed(j|0,f|0,21)|0;r=C;A=Dd(u|0,r|0,v|0,A|0)|0;v=C;r=Hd(u|0,r|0,21)|0;r=Cd(j|0,f|0,r|0,C|0)|0;f=C;j=Ed(A|0,v|0,21)|0;u=C;x=Dd(w|0,x|0,j|0,u|0)|0;w=C;u=Hd(j|0,u|0,21)|0;u=Cd(A|0,v|0,u|0,C|0)|0;v=C;A=Ed(x|0,w|0,21)|0;j=C;p=Dd(A|0,j|0,K|0,p|0)|0;K=C;j=Hd(A|0,j|0,21)|0;j=Cd(x|0,w|0,j|0,C|0)|0;w=C;x=Ed(p|0,K|0,21)|0;A=C;y=Dd(O|0,N|0,M|0,y|0)|0;H=Cd(y|0,C|0,J|0,H|0)|0;H=Dd(H|0,C|0,x|0,A|0)|0;J=C;A=Hd(x|0,A|0,21)|0;A=Cd(p|0,K|0,A|0,C|0)|0;K=C;p=Ed(H|0,J|0,21)|0;x=C;G=Dd(p|0,x|0,B|0,G|0)|0;B=C;x=Hd(p|0,x|0,21)|0;x=Cd(H|0,J|0,x|0,C|0)|0;J=C;H=Ed(G|0,B|0,21)|0;p=C;y=Hd(H|0,p|0,21)|0;y=Cd(G|0,B|0,y|0,C|0)|0;B=C;G=Od(H|0,p|0,666643,0)|0;D=Dd(G|0,C|0,I|0,D|0)|0;I=C;G=Od(H|0,p|0,470296,0)|0;G=Dd(E|0,l|0,G|0,C|0)|0;l=C;E=Od(H|0,p|0,654183,0)|0;E=Dd(k|0,n|0,E|0,C|0)|0;n=C;k=Od(H|0,p|0,-997805,-1)|0;k=Dd(m|0,g|0,k|0,C|0)|0;g=C;m=Od(H|0,p|0,136657,0)|0;m=Dd(L|0,h|0,m|0,C|0)|0;h=C;p=Od(H|0,p|0,-683901,-1)|0;p=Dd(F|0,s|0,p|0,C|0)|0;s=C;F=Ed(D|0,I|0,21)|0;H=C;l=Dd(G|0,l|0,F|0,H|0)|0;G=C;H=Hd(F|0,H|0,21)|0;H=Cd(D|0,I|0,H|0,C|0)|0;I=C;D=Ed(l|0,G|0,21)|0;F=C;n=Dd(E|0,n|0,D|0,F|0)|0;E=C;F=Hd(D|0,F|0,21)|0;F=Cd(l|0,G|0,F|0,C|0)|0;G=C;l=Ed(n|0,E|0,21)|0;D=C;g=Dd(k|0,g|0,l|0,D|0)|0;k=C;D=Hd(l|0,D|0,21)|0;D=Cd(n|0,E|0,D|0,C|0)|0;E=C;n=Ed(g|0,k|0,21)|0;l=C;h=Dd(m|0,h|0,n|0,l|0)|0;m=C;l=Hd(n|0,l|0,21)|0;l=Cd(g|0,k|0,l|0,C|0)|0;k=C;g=Ed(h|0,m|0,21)|0;n=C;s=Dd(p|0,s|0,g|0,n|0)|0;p=C;n=Hd(g|0,n|0,21)|0;n=Cd(h|0,m|0,n|0,C|0)|0;m=C;h=Ed(s|0,p|0,21)|0;g=C;f=Dd(h|0,g|0,r|0,f|0)|0;r=C;g=Hd(h|0,g|0,21)|0;g=Cd(s|0,p|0,g|0,C|0)|0;p=C;s=Ed(f|0,r|0,21)|0;h=C;v=Dd(s|0,h|0,u|0,v|0)|0;u=C;h=Hd(s|0,h|0,21)|0;h=Cd(f|0,r|0,h|0,C|0)|0;r=C;f=Ed(v|0,u|0,21)|0;s=C;w=Dd(f|0,s|0,j|0,w|0)|0;j=C;s=Hd(f|0,s|0,21)|0;s=Cd(v|0,u|0,s|0,C|0)|0;u=C;v=Ed(w|0,j|0,21)|0;f=C;K=Dd(v|0,f|0,A|0,K|0)|0;A=C;f=Hd(v|0,f|0,21)|0;f=Cd(w|0,j|0,f|0,C|0)|0;j=C;w=Ed(K|0,A|0,21)|0;v=C;J=Dd(w|0,v|0,x|0,J|0)|0;x=C;v=Hd(w|0,v|0,21)|0;v=Cd(K|0,A|0,v|0,C|0)|0;A=C;K=Ed(J|0,x|0,21)|0;w=C;B=Dd(K|0,w|0,y|0,B|0)|0;y=C;w=Hd(K|0,w|0,21)|0;w=Cd(J|0,x|0,w|0,C|0)|0;x=C;a[o>>0]=H;o=Gd(H|0,I|0,8)|0;a[b+33>>0]=o;o=Gd(H|0,I|0,16)|0;I=C;H=Hd(F|0,G|0,5)|0;a[b+34>>0]=H|o;o=Gd(F|0,G|0,3)|0;a[b+35>>0]=o;o=Gd(F|0,G|0,11)|0;a[b+36>>0]=o;o=Gd(F|0,G|0,19)|0;G=C;F=Hd(D|0,E|0,2)|0;a[b+37>>0]=F|o;o=Gd(D|0,E|0,6)|0;a[b+38>>0]=o;o=Gd(D|0,E|0,14)|0;E=C;D=Hd(l|0,k|0,7)|0;a[b+39>>0]=D|o;o=Gd(l|0,k|0,1)|0;a[b+40>>0]=o;o=Gd(l|0,k|0,9)|0;a[b+41>>0]=o;o=Gd(l|0,k|0,17)|0;k=C;l=Hd(n|0,m|0,4)|0;a[b+42>>0]=l|o;o=Gd(n|0,m|0,4)|0;a[b+43>>0]=o;o=Gd(n|0,m|0,12)|0;a[b+44>>0]=o;o=Gd(n|0,m|0,20)|0;m=C;n=Hd(g|0,p|0,1)|0;a[b+45>>0]=n|o;o=Gd(g|0,p|0,7)|0;a[b+46>>0]=o;p=Gd(g|0,p|0,15)|0;o=C;g=Hd(h|0,r|0,6)|0;a[b+47>>0]=g|p;p=Gd(h|0,r|0,2)|0;a[b+48>>0]=p;p=Gd(h|0,r|0,10)|0;a[b+49>>0]=p;r=Gd(h|0,r|0,18)|0;h=C;p=Hd(s|0,u|0,3)|0;a[b+50>>0]=p|r;r=Gd(s|0,u|0,5)|0;a[b+51>>0]=r;u=Gd(s|0,u|0,13)|0;a[b+52>>0]=u;a[b+53>>0]=f;u=Gd(f|0,j|0,8)|0;a[b+54>>0]=u;j=Gd(f|0,j|0,16)|0;f=C;u=Hd(v|0,A|0,5)|0;a[b+55>>0]=u|j;j=Gd(v|0,A|0,3)|0;a[b+56>>0]=j;j=Gd(v|0,A|0,11)|0;a[b+57>>0]=j;A=Gd(v|0,A|0,19)|0;v=C;j=Hd(w|0,x|0,2)|0;a[b+58>>0]=j|A;A=Gd(w|0,x|0,6)|0;a[b+59>>0]=A;x=Gd(w|0,x|0,14)|0;w=C;A=Hd(B|0,y|0,7)|0;a[b+60>>0]=x|A;A=Gd(B|0,y|0,1)|0;a[b+61>>0]=A;A=Gd(B|0,y|0,9)|0;a[b+62>>0]=A;y=Gd(B|0,y|0,17)|0;a[b+63>>0]=y;y=q;B=y+64|0;do{a[y>>0]=0;y=y+1|0}while((y|0)<(B|0));y=t;B=y+64|0;do{a[y>>0]=0;y=y+1|0}while((y|0)<(B|0));if(!e){i=z;return}Ec=e;c[Ec>>2]=64;c[Ec+4>>2]=0;i=z;return}function Yc(b,c){b=b|0;c=c|0;return ((((a[c+1>>0]^a[b+1>>0]|a[c>>0]^a[b>>0]|a[c+2>>0]^a[b+2>>0]|a[c+3>>0]^a[b+3>>0]|a[c+4>>0]^a[b+4>>0]|a[c+5>>0]^a[b+5>>0]|a[c+6>>0]^a[b+6>>0]|a[c+7>>0]^a[b+7>>0]|a[c+8>>0]^a[b+8>>0]|a[c+9>>0]^a[b+9>>0]|a[c+10>>0]^a[b+10>>0]|a[c+11>>0]^a[b+11>>0]|a[c+12>>0]^a[b+12>>0]|a[c+13>>0]^a[b+13>>0]|a[c+14>>0]^a[b+14>>0]|a[c+15>>0]^a[b+15>>0]|a[c+16>>0]^a[b+16>>0]|a[c+17>>0]^a[b+17>>0]|a[c+18>>0]^a[b+18>>0]|a[c+19>>0]^a[b+19>>0]|a[c+20>>0]^a[b+20>>0]|a[c+21>>0]^a[b+21>>0]|a[c+22>>0]^a[b+22>>0]|a[c+23>>0]^a[b+23>>0]|a[c+24>>0]^a[b+24>>0]|a[c+25>>0]^a[b+25>>0]|a[c+26>>0]^a[b+26>>0]|a[c+27>>0]^a[b+27>>0]|a[c+28>>0]^a[b+28>>0]|a[c+29>>0]^a[b+29>>0]|a[c+30>>0]^a[b+30>>0]|a[c+31>>0]^a[b+31>>0])&255)+511|0)>>>8&1)+-1|0}function Zc(a){a=a|0;c[7976]=a;return 0}function _c(){return Ba(0)|0}function $c(){Ba(1);return}function ad(a){a=a|0;var b=0,d=0;b=c[7976]|0;if((b|0)!=0?(d=c[b+12>>2]|0,(d|0)!=0):0){a=Ea[d&31](a)|0;return a|0}if(a>>>0<2){a=0;return a|0}b=((0-a|0)>>>0)%(a>>>0)|0;do d=Ba(0)|0;while(d>>>0<b>>>0);a=(d>>>0)%(a>>>0)|0;return a|0}function bd(b,c){b=b|0;c=c|0;var d=0;if(!c)return;else d=0;do{a[b+d>>0]=Ba(0)|0;d=d+1|0}while((d|0)!=(c|0));return}function cd(){var a=0;a=c[7976]|0;if(!a){a=0;return a|0}a=c[a+20>>2]|0;if(!a){a=0;return a|0}a=Da[a&31]()|0;return a|0}function dd(){var a=0,b=0;if(c[7977]|0){b=1;return b|0}Ba(1);a=na(30)|0;if((a|0)>0)c[7978]=a;else a=c[7978]|0;if(a>>>0<16)ra();else b=0;do{Ba(0)|0;b=b+1|0}while((b|0)!=16);c[7977]=1;b=0;return b|0}function ed(a,b){a=a|0;b=b|0;Fd(a|0,0,b|0)|0;return}function fd(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;g=f<<1;if(!(f>>>0<2147483647&g>>>0<c>>>0))ra();if(!f){f=0;f=b+f|0;a[f>>0]=0;return b|0}else c=0;do{j=d[e+c>>0]|0;i=j&15;j=j>>>4;h=c<<1;a[b+h>>0]=j+87+((j+65526|0)>>>8&217);a[b+(h|1)>>0]=((i<<8)+22272+(i+65526&55552)|0)>>>8;c=c+1|0}while((c|0)!=(f|0));j=b+g|0;a[j>>0]=0;return b|0}function gd(b,e,f,g,h,i,j){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;a:do if(!g){n=0;l=0;o=0;k=0}else{b:do if(!h){n=0;r=0;l=0;k=0;while(1){p=d[f+l>>0]|0;m=p^48;o=(m+65526|0)>>>8;p=(p&223)+201|0;q=p&255;q=(q+65526^q+65520)>>>8;if(!((q|o)&255)){o=0;break a}m=q&p|o&m;if(n>>>0>=e>>>0){m=k;break b}if(!(k<<24>>24))m=m<<4&255;else{a[b+n>>0]=m|r&255;n=n+1|0;m=r}k=(k&255^255)&255;l=l+1|0;if(l>>>0<g>>>0)r=m;else{o=0;break a}}}else{n=0;u=0;l=0;k=0;while(1){t=k<<24>>24==0;c:do if(!t){q=d[f+l>>0]|0;m=q^48;o=(m+65526|0)>>>8;q=(q&223)+201|0;p=q&255;p=(p+65526^p+65520)>>>8;if(!((p|o)&255)){o=0;break a}}else while(1){q=a[f+l>>0]|0;r=q&255;m=r^48;o=(m+65526|0)>>>8;s=(r&223)+201|0;p=s&255;p=(p+65526^p+65520)>>>8;if((p|o)&255){q=s;break c}s=ud(h,r)|0;if((s|0)==0?1:(a[s>>0]|0)!=q<<24>>24){o=0;k=0;break a}l=l+1|0;if(l>>>0>=g>>>0){o=0;k=0;break a}}while(0);m=p&q|o&m;if(n>>>0>=e>>>0){m=k;break b}if(t)m=m<<4&255;else{a[b+n>>0]=m|u&255;n=n+1|0;m=u}k=(k&255^255)&255;l=l+1|0;if(l>>>0<g>>>0)u=m;else{o=0;break a}}}while(0);if(!(c[7979]|0))k=31964;else k=c[(oa()|0)+60>>2]|0;c[k>>2]=34;o=-1;k=m}while(0);if(j)c[j>>2]=f+(((k<<24>>24!=0)<<31>>31)+l);if(!i)return o|0;c[i>>2]=n;return o|0}function hd(){return 33779}function id(){return 8}function jd(){return 0}function kd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0,Yb=0,Zb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0,kc=0,lc=0,mc=0,nc=0,oc=0,pc=0,qc=0,rc=0,sc=0,tc=0,uc=0,vc=0,wc=0,xc=0,yc=0,zc=0,Ac=0,Bc=0,Cc=0,Dc=0,Ec=0,Fc=0,Gc=0,Hc=0,Ic=0,Jc=0,Kc=0,Lc=0,Mc=0,Nc=0,Oc=0,Pc=0,Qc=0,Rc=0,Sc=0;l=c[b>>2]|0;s=c[b+4>>2]|0;j=c[b+8>>2]|0;Rb=c[b+12>>2]|0;e=c[b+16>>2]|0;za=c[b+20>>2]|0;ya=c[b+24>>2]|0;zb=c[b+28>>2]|0;h=c[b+32>>2]|0;ga=c[b+36>>2]|0;H=c[d>>2]|0;J=c[d+4>>2]|0;F=c[d+8>>2]|0;D=c[d+12>>2]|0;A=c[d+16>>2]|0;y=c[d+20>>2]|0;w=c[d+24>>2]|0;u=c[d+28>>2]|0;k=c[d+32>>2]|0;t=c[d+36>>2]|0;Oc=J*19|0;bc=F*19|0;rb=D*19|0;Ha=A*19|0;jc=y*19|0;Db=w*19|0;Ta=u*19|0;Sc=k*19|0;Qc=t*19|0;p=s<<1;f=Rb<<1;M=za<<1;i=zb<<1;d=ga<<1;o=((l|0)<0)<<31>>31;I=((H|0)<0)<<31>>31;Mc=Od(H|0,I|0,l|0,o|0)|0;Lc=C;K=((J|0)<0)<<31>>31;wc=Od(J|0,K|0,l|0,o|0)|0;vc=C;G=((F|0)<0)<<31>>31;ub=Od(F|0,G|0,l|0,o|0)|0;tb=C;E=((D|0)<0)<<31>>31;Ka=Od(D|0,E|0,l|0,o|0)|0;Ja=C;B=((A|0)<0)<<31>>31;mc=Od(A|0,B|0,l|0,o|0)|0;lc=C;z=((y|0)<0)<<31>>31;Gb=Od(y|0,z|0,l|0,o|0)|0;Fb=C;x=((w|0)<0)<<31>>31;Wa=Od(w|0,x|0,l|0,o|0)|0;Va=C;v=((u|0)<0)<<31>>31;ja=Od(u|0,v|0,l|0,o|0)|0;ia=C;Pc=((k|0)<0)<<31>>31;P=Od(k|0,Pc|0,l|0,o|0)|0;O=C;o=Od(t|0,((t|0)<0)<<31>>31|0,l|0,o|0)|0;l=C;t=((s|0)<0)<<31>>31;dc=Od(H|0,I|0,s|0,t|0)|0;ec=C;n=((p|0)<0)<<31>>31;yb=Od(J|0,K|0,p|0,n|0)|0;xb=C;Ma=Od(F|0,G|0,s|0,t|0)|0;La=C;oc=Od(D|0,E|0,p|0,n|0)|0;nc=C;Ib=Od(A|0,B|0,s|0,t|0)|0;Hb=C;Ya=Od(y|0,z|0,p|0,n|0)|0;Xa=C;la=Od(w|0,x|0,s|0,t|0)|0;ka=C;R=Od(u|0,v|0,p|0,n|0)|0;Q=C;t=Od(k|0,Pc|0,s|0,t|0)|0;s=C;Pc=((Qc|0)<0)<<31>>31;n=Od(Qc|0,Pc|0,p|0,n|0)|0;p=C;k=((j|0)<0)<<31>>31;wb=Od(H|0,I|0,j|0,k|0)|0;vb=C;Qa=Od(J|0,K|0,j|0,k|0)|0;Pa=C;qc=Od(F|0,G|0,j|0,k|0)|0;pc=C;Kb=Od(D|0,E|0,j|0,k|0)|0;Jb=C;_a=Od(A|0,B|0,j|0,k|0)|0;Za=C;na=Od(y|0,z|0,j|0,k|0)|0;ma=C;T=Od(w|0,x|0,j|0,k|0)|0;S=C;v=Od(u|0,v|0,j|0,k|0)|0;u=C;Rc=((Sc|0)<0)<<31>>31;yc=Od(Sc|0,Rc|0,j|0,k|0)|0;xc=C;k=Od(Qc|0,Pc|0,j|0,k|0)|0;j=C;Sb=((Rb|0)<0)<<31>>31;Oa=Od(H|0,I|0,Rb|0,Sb|0)|0;Na=C;fa=((f|0)<0)<<31>>31;uc=Od(J|0,K|0,f|0,fa|0)|0;tc=C;Mb=Od(F|0,G|0,Rb|0,Sb|0)|0;Lb=C;ab=Od(D|0,E|0,f|0,fa|0)|0;$a=C;pa=Od(A|0,B|0,Rb|0,Sb|0)|0;oa=C;V=Od(y|0,z|0,f|0,fa|0)|0;U=C;x=Od(w|0,x|0,Rb|0,Sb|0)|0;w=C;Ua=((Ta|0)<0)<<31>>31;Ac=Od(Ta|0,Ua|0,f|0,fa|0)|0;zc=C;Sb=Od(Sc|0,Rc|0,Rb|0,Sb|0)|0;Rb=C;fa=Od(Qc|0,Pc|0,f|0,fa|0)|0;f=C;N=((e|0)<0)<<31>>31;sc=Od(H|0,I|0,e|0,N|0)|0;rc=C;Qb=Od(J|0,K|0,e|0,N|0)|0;Pb=C;cb=Od(F|0,G|0,e|0,N|0)|0;bb=C;ra=Od(D|0,E|0,e|0,N|0)|0;qa=C;X=Od(A|0,B|0,e|0,N|0)|0;W=C;z=Od(y|0,z|0,e|0,N|0)|0;y=C;Eb=((Db|0)<0)<<31>>31;Cc=Od(Db|0,Eb|0,e|0,N|0)|0;Bc=C;Ub=Od(Ta|0,Ua|0,e|0,N|0)|0;Tb=C;ib=Od(Sc|0,Rc|0,e|0,N|0)|0;hb=C;N=Od(Qc|0,Pc|0,e|0,N|0)|0;e=C;Aa=((za|0)<0)<<31>>31;Ob=Od(H|0,I|0,za|0,Aa|0)|0;Nb=C;b=((M|0)<0)<<31>>31;gb=Od(J|0,K|0,M|0,b|0)|0;fb=C;ta=Od(F|0,G|0,za|0,Aa|0)|0;sa=C;Z=Od(D|0,E|0,M|0,b|0)|0;Y=C;B=Od(A|0,B|0,za|0,Aa|0)|0;A=C;kc=((jc|0)<0)<<31>>31;Ec=Od(jc|0,kc|0,M|0,b|0)|0;Dc=C;Wb=Od(Db|0,Eb|0,za|0,Aa|0)|0;Vb=C;kb=Od(Ta|0,Ua|0,M|0,b|0)|0;jb=C;Aa=Od(Sc|0,Rc|0,za|0,Aa|0)|0;za=C;b=Od(Qc|0,Pc|0,M|0,b|0)|0;M=C;g=((ya|0)<0)<<31>>31;eb=Od(H|0,I|0,ya|0,g|0)|0;db=C;xa=Od(J|0,K|0,ya|0,g|0)|0;wa=C;$=Od(F|0,G|0,ya|0,g|0)|0;_=C;E=Od(D|0,E|0,ya|0,g|0)|0;D=C;Ia=((Ha|0)<0)<<31>>31;Gc=Od(Ha|0,Ia|0,ya|0,g|0)|0;Fc=C;Yb=Od(jc|0,kc|0,ya|0,g|0)|0;Xb=C;mb=Od(Db|0,Eb|0,ya|0,g|0)|0;lb=C;Ca=Od(Ta|0,Ua|0,ya|0,g|0)|0;Ba=C;m=Od(Sc|0,Rc|0,ya|0,g|0)|0;r=C;g=Od(Qc|0,Pc|0,ya|0,g|0)|0;ya=C;Ab=((zb|0)<0)<<31>>31;va=Od(H|0,I|0,zb|0,Ab|0)|0;ua=C;ea=((i|0)<0)<<31>>31;da=Od(J|0,K|0,i|0,ea|0)|0;ca=C;G=Od(F|0,G|0,zb|0,Ab|0)|0;F=C;sb=((rb|0)<0)<<31>>31;Ic=Od(rb|0,sb|0,i|0,ea|0)|0;Hc=C;_b=Od(Ha|0,Ia|0,zb|0,Ab|0)|0;Zb=C;ob=Od(jc|0,kc|0,i|0,ea|0)|0;nb=C;Ea=Od(Db|0,Eb|0,zb|0,Ab|0)|0;Da=C;gc=Od(Ta|0,Ua|0,i|0,ea|0)|0;fc=C;Ab=Od(Sc|0,Rc|0,zb|0,Ab|0)|0;zb=C;ea=Od(Qc|0,Pc|0,i|0,ea|0)|0;i=C;L=((h|0)<0)<<31>>31;ba=Od(H|0,I|0,h|0,L|0)|0;aa=C;K=Od(J|0,K|0,h|0,L|0)|0;J=C;cc=((bc|0)<0)<<31>>31;Kc=Od(bc|0,cc|0,h|0,L|0)|0;Jc=C;ac=Od(rb|0,sb|0,h|0,L|0)|0;$b=C;qb=Od(Ha|0,Ia|0,h|0,L|0)|0;pb=C;Ga=Od(jc|0,kc|0,h|0,L|0)|0;Fa=C;ic=Od(Db|0,Eb|0,h|0,L|0)|0;hc=C;Cb=Od(Ta|0,Ua|0,h|0,L|0)|0;Bb=C;Sa=Od(Sc|0,Rc|0,h|0,L|0)|0;Ra=C;L=Od(Qc|0,Pc|0,h|0,L|0)|0;h=C;ha=((ga|0)<0)<<31>>31;I=Od(H|0,I|0,ga|0,ha|0)|0;H=C;q=((d|0)<0)<<31>>31;Oc=Od(Oc|0,((Oc|0)<0)<<31>>31|0,d|0,q|0)|0;Nc=C;cc=Od(bc|0,cc|0,ga|0,ha|0)|0;bc=C;sb=Od(rb|0,sb|0,d|0,q|0)|0;rb=C;Ia=Od(Ha|0,Ia|0,ga|0,ha|0)|0;Ha=C;kc=Od(jc|0,kc|0,d|0,q|0)|0;jc=C;Eb=Od(Db|0,Eb|0,ga|0,ha|0)|0;Db=C;Ua=Od(Ta|0,Ua|0,d|0,q|0)|0;Ta=C;ha=Od(Sc|0,Rc|0,ga|0,ha|0)|0;ga=C;q=Od(Qc|0,Pc|0,d|0,q|0)|0;d=C;Lc=Dd(Oc|0,Nc|0,Mc|0,Lc|0)|0;Jc=Dd(Lc|0,C|0,Kc|0,Jc|0)|0;Hc=Dd(Jc|0,C|0,Ic|0,Hc|0)|0;Fc=Dd(Hc|0,C|0,Gc|0,Fc|0)|0;Dc=Dd(Fc|0,C|0,Ec|0,Dc|0)|0;Bc=Dd(Dc|0,C|0,Cc|0,Bc|0)|0;zc=Dd(Bc|0,C|0,Ac|0,zc|0)|0;xc=Dd(zc|0,C|0,yc|0,xc|0)|0;p=Dd(xc|0,C|0,n|0,p|0)|0;n=C;ec=Dd(wc|0,vc|0,dc|0,ec|0)|0;dc=C;rc=Dd(uc|0,tc|0,sc|0,rc|0)|0;pc=Dd(rc|0,C|0,qc|0,pc|0)|0;nc=Dd(pc|0,C|0,oc|0,nc|0)|0;lc=Dd(nc|0,C|0,mc|0,lc|0)|0;jc=Dd(lc|0,C|0,kc|0,jc|0)|0;hc=Dd(jc|0,C|0,ic|0,hc|0)|0;fc=Dd(hc|0,C|0,gc|0,fc|0)|0;r=Dd(fc|0,C|0,m|0,r|0)|0;M=Dd(r|0,C|0,b|0,M|0)|0;b=C;r=Dd(p|0,n|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;m=C;bc=Dd(ec|0,dc|0,cc|0,bc|0)|0;$b=Dd(bc|0,C|0,ac|0,$b|0)|0;Zb=Dd($b|0,C|0,_b|0,Zb|0)|0;Xb=Dd(Zb|0,C|0,Yb|0,Xb|0)|0;Vb=Dd(Xb|0,C|0,Wb|0,Vb|0)|0;Tb=Dd(Vb|0,C|0,Ub|0,Tb|0)|0;Rb=Dd(Tb|0,C|0,Sb|0,Rb|0)|0;j=Dd(Rb|0,C|0,k|0,j|0)|0;j=Dd(j|0,C|0,r|0,m|0)|0;k=C;m=Hd(r|0,m|0,26)|0;m=Cd(p|0,n|0,m|0,C|0)|0;n=C;p=Dd(M|0,b|0,33554432,0)|0;p=Ed(p|0,C|0,26)|0;r=C;Nb=Dd(Qb|0,Pb|0,Ob|0,Nb|0)|0;Lb=Dd(Nb|0,C|0,Mb|0,Lb|0)|0;Jb=Dd(Lb|0,C|0,Kb|0,Jb|0)|0;Hb=Dd(Jb|0,C|0,Ib|0,Hb|0)|0;Fb=Dd(Hb|0,C|0,Gb|0,Fb|0)|0;Db=Dd(Fb|0,C|0,Eb|0,Db|0)|0;Bb=Dd(Db|0,C|0,Cb|0,Bb|0)|0;zb=Dd(Bb|0,C|0,Ab|0,zb|0)|0;ya=Dd(zb|0,C|0,g|0,ya|0)|0;ya=Dd(ya|0,C|0,p|0,r|0)|0;g=C;r=Hd(p|0,r|0,26)|0;r=Cd(M|0,b|0,r|0,C|0)|0;b=C;M=Dd(j|0,k|0,16777216,0)|0;M=Ed(M|0,C|0,25)|0;p=C;vb=Dd(yb|0,xb|0,wb|0,vb|0)|0;tb=Dd(vb|0,C|0,ub|0,tb|0)|0;rb=Dd(tb|0,C|0,sb|0,rb|0)|0;pb=Dd(rb|0,C|0,qb|0,pb|0)|0;nb=Dd(pb|0,C|0,ob|0,nb|0)|0;lb=Dd(nb|0,C|0,mb|0,lb|0)|0;jb=Dd(lb|0,C|0,kb|0,jb|0)|0;hb=Dd(jb|0,C|0,ib|0,hb|0)|0;f=Dd(hb|0,C|0,fa|0,f|0)|0;f=Dd(f|0,C|0,M|0,p|0)|0;fa=C;p=Hd(M|0,p|0,25)|0;p=Cd(j|0,k|0,p|0,C|0)|0;k=C;j=Dd(ya|0,g|0,16777216,0)|0;j=Ed(j|0,C|0,25)|0;M=C;db=Dd(gb|0,fb|0,eb|0,db|0)|0;bb=Dd(db|0,C|0,cb|0,bb|0)|0;$a=Dd(bb|0,C|0,ab|0,$a|0)|0;Za=Dd($a|0,C|0,_a|0,Za|0)|0;Xa=Dd(Za|0,C|0,Ya|0,Xa|0)|0;Va=Dd(Xa|0,C|0,Wa|0,Va|0)|0;Ta=Dd(Va|0,C|0,Ua|0,Ta|0)|0;Ra=Dd(Ta|0,C|0,Sa|0,Ra|0)|0;i=Dd(Ra|0,C|0,ea|0,i|0)|0;i=Dd(i|0,C|0,j|0,M|0)|0;ea=C;M=Hd(j|0,M|0,25)|0;M=Cd(ya|0,g|0,M|0,C|0)|0;g=C;ya=Dd(f|0,fa|0,33554432,0)|0;ya=Ed(ya|0,C|0,26)|0;j=C;Na=Dd(Qa|0,Pa|0,Oa|0,Na|0)|0;La=Dd(Na|0,C|0,Ma|0,La|0)|0;Ja=Dd(La|0,C|0,Ka|0,Ja|0)|0;Ha=Dd(Ja|0,C|0,Ia|0,Ha|0)|0;Fa=Dd(Ha|0,C|0,Ga|0,Fa|0)|0;Da=Dd(Fa|0,C|0,Ea|0,Da|0)|0;Ba=Dd(Da|0,C|0,Ca|0,Ba|0)|0;za=Dd(Ba|0,C|0,Aa|0,za|0)|0;e=Dd(za|0,C|0,N|0,e|0)|0;e=Dd(e|0,C|0,ya|0,j|0)|0;N=C;j=Hd(ya|0,j|0,26)|0;j=Cd(f|0,fa|0,j|0,C|0)|0;fa=Dd(i|0,ea|0,33554432,0)|0;fa=Ed(fa|0,C|0,26)|0;f=C;ua=Dd(xa|0,wa|0,va|0,ua|0)|0;sa=Dd(ua|0,C|0,ta|0,sa|0)|0;qa=Dd(sa|0,C|0,ra|0,qa|0)|0;oa=Dd(qa|0,C|0,pa|0,oa|0)|0;ma=Dd(oa|0,C|0,na|0,ma|0)|0;ka=Dd(ma|0,C|0,la|0,ka|0)|0;ia=Dd(ka|0,C|0,ja|0,ia|0)|0;ga=Dd(ia|0,C|0,ha|0,ga|0)|0;h=Dd(ga|0,C|0,L|0,h|0)|0;h=Dd(h|0,C|0,fa|0,f|0)|0;L=C;f=Hd(fa|0,f|0,26)|0;f=Cd(i|0,ea|0,f|0,C|0)|0;ea=Dd(e|0,N|0,16777216,0)|0;ea=Ed(ea|0,C|0,25)|0;i=C;b=Dd(ea|0,i|0,r|0,b|0)|0;r=C;i=Hd(ea|0,i|0,25)|0;i=Cd(e|0,N|0,i|0,C|0)|0;N=Dd(h|0,L|0,16777216,0)|0;N=Ed(N|0,C|0,25)|0;e=C;aa=Dd(da|0,ca|0,ba|0,aa|0)|0;_=Dd(aa|0,C|0,$|0,_|0)|0;Y=Dd(_|0,C|0,Z|0,Y|0)|0;W=Dd(Y|0,C|0,X|0,W|0)|0;U=Dd(W|0,C|0,V|0,U|0)|0;S=Dd(U|0,C|0,T|0,S|0)|0;Q=Dd(S|0,C|0,R|0,Q|0)|0;O=Dd(Q|0,C|0,P|0,O|0)|0;d=Dd(O|0,C|0,q|0,d|0)|0;d=Dd(d|0,C|0,N|0,e|0)|0;q=C;e=Hd(N|0,e|0,25)|0;e=Cd(h|0,L|0,e|0,C|0)|0;L=Dd(b|0,r|0,33554432,0)|0;L=Ed(L|0,C|0,26)|0;h=C;g=Dd(M|0,g|0,L|0,h|0)|0;h=Hd(L|0,h|0,26)|0;h=Cd(b|0,r|0,h|0,C|0)|0;r=Dd(d|0,q|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;b=C;H=Dd(K|0,J|0,I|0,H|0)|0;F=Dd(H|0,C|0,G|0,F|0)|0;D=Dd(F|0,C|0,E|0,D|0)|0;A=Dd(D|0,C|0,B|0,A|0)|0;y=Dd(A|0,C|0,z|0,y|0)|0;w=Dd(y|0,C|0,x|0,w|0)|0;u=Dd(w|0,C|0,v|0,u|0)|0;s=Dd(u|0,C|0,t|0,s|0)|0;l=Dd(s|0,C|0,o|0,l|0)|0;l=Dd(l|0,C|0,r|0,b|0)|0;o=C;b=Hd(r|0,b|0,26)|0;b=Cd(d|0,q|0,b|0,C|0)|0;q=Dd(l|0,o|0,16777216,0)|0;q=Ed(q|0,C|0,25)|0;d=C;r=Od(q|0,d|0,19,0)|0;n=Dd(r|0,C|0,m|0,n|0)|0;m=C;d=Hd(q|0,d|0,25)|0;d=Cd(l|0,o|0,d|0,C|0)|0;o=Dd(n|0,m|0,33554432,0)|0;o=Ed(o|0,C|0,26)|0;l=C;k=Dd(p|0,k|0,o|0,l|0)|0;l=Hd(o|0,l|0,26)|0;l=Cd(n|0,m|0,l|0,C|0)|0;c[a>>2]=l;c[a+4>>2]=k;c[a+8>>2]=j;c[a+12>>2]=i;c[a+16>>2]=h;c[a+20>>2]=g;c[a+24>>2]=f;c[a+28>>2]=e;c[a+32>>2]=b;c[a+36>>2]=d;return}function ld(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0;bb=c[b>>2]|0;ua=c[b+4>>2]|0;j=c[b+8>>2]|0;la=c[b+12>>2]|0;e=c[b+16>>2]|0;db=c[b+20>>2]|0;Y=c[b+24>>2]|0;La=c[b+28>>2]|0;h=c[b+32>>2]|0;b=c[b+36>>2]|0;l=bb<<1;p=ua<<1;Xa=j<<1;f=la<<1;na=e<<1;B=db<<1;m=Y<<1;i=La<<1;Ka=db*38|0;ra=Y*19|0;va=La*38|0;da=h*19|0;gb=b*38|0;cb=((bb|0)<0)<<31>>31;cb=Od(bb|0,cb|0,bb|0,cb|0)|0;bb=C;o=((l|0)<0)<<31>>31;ta=((ua|0)<0)<<31>>31;Ia=Od(l|0,o|0,ua|0,ta|0)|0;Ha=C;k=((j|0)<0)<<31>>31;Wa=Od(j|0,k|0,l|0,o|0)|0;Va=C;ma=((la|0)<0)<<31>>31;Ua=Od(la|0,ma|0,l|0,o|0)|0;Ta=C;D=((e|0)<0)<<31>>31;Oa=Od(e|0,D|0,l|0,o|0)|0;Na=C;eb=((db|0)<0)<<31>>31;ya=Od(db|0,eb|0,l|0,o|0)|0;xa=C;g=((Y|0)<0)<<31>>31;ga=Od(Y|0,g|0,l|0,o|0)|0;fa=C;Ma=((La|0)<0)<<31>>31;R=Od(La|0,Ma|0,l|0,o|0)|0;Q=C;A=((h|0)<0)<<31>>31;F=Od(h|0,A|0,l|0,o|0)|0;E=C;q=((b|0)<0)<<31>>31;o=Od(b|0,q|0,l|0,o|0)|0;l=C;n=((p|0)<0)<<31>>31;ta=Od(p|0,n|0,ua|0,ta|0)|0;ua=C;ba=Od(p|0,n|0,j|0,k|0)|0;ca=C;P=((f|0)<0)<<31>>31;Sa=Od(f|0,P|0,p|0,n|0)|0;Ra=C;Ca=Od(e|0,D|0,p|0,n|0)|0;Ba=C;d=((B|0)<0)<<31>>31;ia=Od(B|0,d|0,p|0,n|0)|0;ha=C;T=Od(Y|0,g|0,p|0,n|0)|0;S=C;O=((i|0)<0)<<31>>31;H=Od(i|0,O|0,p|0,n|0)|0;G=C;t=Od(h|0,A|0,p|0,n|0)|0;s=C;fb=((gb|0)<0)<<31>>31;n=Od(gb|0,fb|0,p|0,n|0)|0;p=C;Qa=Od(j|0,k|0,j|0,k|0)|0;Pa=C;Ya=((Xa|0)<0)<<31>>31;Aa=Od(Xa|0,Ya|0,la|0,ma|0)|0;za=C;ka=Od(e|0,D|0,Xa|0,Ya|0)|0;ja=C;X=Od(db|0,eb|0,Xa|0,Ya|0)|0;W=C;N=Od(Y|0,g|0,Xa|0,Ya|0)|0;M=C;v=Od(La|0,Ma|0,Xa|0,Ya|0)|0;u=C;ea=((da|0)<0)<<31>>31;Ya=Od(da|0,ea|0,Xa|0,Ya|0)|0;Xa=C;k=Od(gb|0,fb|0,j|0,k|0)|0;j=C;ma=Od(f|0,P|0,la|0,ma|0)|0;la=C;V=Od(f|0,P|0,e|0,D|0)|0;U=C;J=Od(B|0,d|0,f|0,P|0)|0;I=C;z=Od(Y|0,g|0,f|0,P|0)|0;y=C;wa=((va|0)<0)<<31>>31;_a=Od(va|0,wa|0,f|0,P|0)|0;Za=C;Ea=Od(da|0,ea|0,f|0,P|0)|0;Da=C;P=Od(gb|0,fb|0,f|0,P|0)|0;f=C;L=Od(e|0,D|0,e|0,D|0)|0;K=C;oa=((na|0)<0)<<31>>31;x=Od(na|0,oa|0,db|0,eb|0)|0;w=C;sa=((ra|0)<0)<<31>>31;ab=Od(ra|0,sa|0,na|0,oa|0)|0;$a=C;Ga=Od(va|0,wa|0,e|0,D|0)|0;Fa=C;oa=Od(da|0,ea|0,na|0,oa|0)|0;na=C;D=Od(gb|0,fb|0,e|0,D|0)|0;e=C;eb=Od(Ka|0,((Ka|0)<0)<<31>>31|0,db|0,eb|0)|0;db=C;Ka=Od(ra|0,sa|0,B|0,d|0)|0;Ja=C;qa=Od(va|0,wa|0,B|0,d|0)|0;pa=C;_=Od(da|0,ea|0,B|0,d|0)|0;Z=C;d=Od(gb|0,fb|0,B|0,d|0)|0;B=C;sa=Od(ra|0,sa|0,Y|0,g|0)|0;ra=C;aa=Od(va|0,wa|0,Y|0,g|0)|0;$=C;m=Od(da|0,ea|0,m|0,((m|0)<0)<<31>>31|0)|0;r=C;g=Od(gb|0,fb|0,Y|0,g|0)|0;Y=C;Ma=Od(va|0,wa|0,La|0,Ma|0)|0;La=C;wa=Od(da|0,ea|0,i|0,O|0)|0;va=C;O=Od(gb|0,fb|0,i|0,O|0)|0;i=C;ea=Od(da|0,ea|0,h|0,A|0)|0;da=C;A=Od(gb|0,fb|0,h|0,A|0)|0;h=C;q=Od(gb|0,fb|0,b|0,q|0)|0;b=C;bb=Dd(eb|0,db|0,cb|0,bb|0)|0;$a=Dd(bb|0,C|0,ab|0,$a|0)|0;Za=Dd($a|0,C|0,_a|0,Za|0)|0;Xa=Dd(Za|0,C|0,Ya|0,Xa|0)|0;p=Dd(Xa|0,C|0,n|0,p|0)|0;n=C;ua=Dd(Wa|0,Va|0,ta|0,ua|0)|0;ta=C;ca=Dd(Ua|0,Ta|0,ba|0,ca|0)|0;ba=C;Pa=Dd(Sa|0,Ra|0,Qa|0,Pa|0)|0;Na=Dd(Pa|0,C|0,Oa|0,Na|0)|0;La=Dd(Na|0,C|0,Ma|0,La|0)|0;r=Dd(La|0,C|0,m|0,r|0)|0;B=Dd(r|0,C|0,d|0,B|0)|0;d=C;r=Dd(p|0,n|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;m=C;Ha=Dd(Ka|0,Ja|0,Ia|0,Ha|0)|0;Fa=Dd(Ha|0,C|0,Ga|0,Fa|0)|0;Da=Dd(Fa|0,C|0,Ea|0,Da|0)|0;j=Dd(Da|0,C|0,k|0,j|0)|0;j=Dd(j|0,C|0,r|0,m|0)|0;k=C;m=Hd(r|0,m|0,26)|0;m=Cd(p|0,n|0,m|0,C|0)|0;n=C;p=Dd(B|0,d|0,33554432,0)|0;p=Ed(p|0,C|0,26)|0;r=C;za=Dd(Ca|0,Ba|0,Aa|0,za|0)|0;xa=Dd(za|0,C|0,ya|0,xa|0)|0;va=Dd(xa|0,C|0,wa|0,va|0)|0;Y=Dd(va|0,C|0,g|0,Y|0)|0;Y=Dd(Y|0,C|0,p|0,r|0)|0;g=C;r=Hd(p|0,r|0,26)|0;r=Cd(B|0,d|0,r|0,C|0)|0;d=C;B=Dd(j|0,k|0,16777216,0)|0;B=Ed(B|0,C|0,25)|0;p=C;ra=Dd(ua|0,ta|0,sa|0,ra|0)|0;pa=Dd(ra|0,C|0,qa|0,pa|0)|0;na=Dd(pa|0,C|0,oa|0,na|0)|0;f=Dd(na|0,C|0,P|0,f|0)|0;f=Dd(f|0,C|0,B|0,p|0)|0;P=C;p=Hd(B|0,p|0,25)|0;p=Cd(j|0,k|0,p|0,C|0)|0;k=C;j=Dd(Y|0,g|0,16777216,0)|0;j=Ed(j|0,C|0,25)|0;B=C;ja=Dd(ma|0,la|0,ka|0,ja|0)|0;ha=Dd(ja|0,C|0,ia|0,ha|0)|0;fa=Dd(ha|0,C|0,ga|0,fa|0)|0;da=Dd(fa|0,C|0,ea|0,da|0)|0;i=Dd(da|0,C|0,O|0,i|0)|0;i=Dd(i|0,C|0,j|0,B|0)|0;O=C;B=Hd(j|0,B|0,25)|0;B=Cd(Y|0,g|0,B|0,C|0)|0;g=C;Y=Dd(f|0,P|0,33554432,0)|0;Y=Ed(Y|0,C|0,26)|0;j=C;$=Dd(ca|0,ba|0,aa|0,$|0)|0;Z=Dd($|0,C|0,_|0,Z|0)|0;e=Dd(Z|0,C|0,D|0,e|0)|0;e=Dd(e|0,C|0,Y|0,j|0)|0;D=C;j=Hd(Y|0,j|0,26)|0;j=Cd(f|0,P|0,j|0,C|0)|0;P=Dd(i|0,O|0,33554432,0)|0;P=Ed(P|0,C|0,26)|0;f=C;U=Dd(X|0,W|0,V|0,U|0)|0;S=Dd(U|0,C|0,T|0,S|0)|0;Q=Dd(S|0,C|0,R|0,Q|0)|0;h=Dd(Q|0,C|0,A|0,h|0)|0;h=Dd(h|0,C|0,P|0,f|0)|0;A=C;f=Hd(P|0,f|0,26)|0;f=Cd(i|0,O|0,f|0,C|0)|0;O=Dd(e|0,D|0,16777216,0)|0;O=Ed(O|0,C|0,25)|0;i=C;d=Dd(O|0,i|0,r|0,d|0)|0;r=C;i=Hd(O|0,i|0,25)|0;i=Cd(e|0,D|0,i|0,C|0)|0;D=Dd(h|0,A|0,16777216,0)|0;D=Ed(D|0,C|0,25)|0;e=C;K=Dd(N|0,M|0,L|0,K|0)|0;I=Dd(K|0,C|0,J|0,I|0)|0;G=Dd(I|0,C|0,H|0,G|0)|0;E=Dd(G|0,C|0,F|0,E|0)|0;b=Dd(E|0,C|0,q|0,b|0)|0;b=Dd(b|0,C|0,D|0,e|0)|0;q=C;e=Hd(D|0,e|0,25)|0;e=Cd(h|0,A|0,e|0,C|0)|0;A=Dd(d|0,r|0,33554432,0)|0;A=Ed(A|0,C|0,26)|0;h=C;g=Dd(B|0,g|0,A|0,h|0)|0;h=Hd(A|0,h|0,26)|0;h=Cd(d|0,r|0,h|0,C|0)|0;r=Dd(b|0,q|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;d=C;w=Dd(z|0,y|0,x|0,w|0)|0;u=Dd(w|0,C|0,v|0,u|0)|0;s=Dd(u|0,C|0,t|0,s|0)|0;l=Dd(s|0,C|0,o|0,l|0)|0;l=Dd(l|0,C|0,r|0,d|0)|0;o=C;d=Hd(r|0,d|0,26)|0;d=Cd(b|0,q|0,d|0,C|0)|0;q=Dd(l|0,o|0,16777216,0)|0;q=Ed(q|0,C|0,25)|0;b=C;r=Od(q|0,b|0,19,0)|0;n=Dd(r|0,C|0,m|0,n|0)|0;m=C;b=Hd(q|0,b|0,25)|0;b=Cd(l|0,o|0,b|0,C|0)|0;o=Dd(n|0,m|0,33554432,0)|0;o=Ed(o|0,C|0,26)|0;l=C;k=Dd(p|0,k|0,o|0,l|0)|0;l=Hd(o|0,l|0,26)|0;l=Cd(n|0,m|0,l|0,C|0)|0;c[a>>2]=l;c[a+4>>2]=k;c[a+8>>2]=j;c[a+12>>2]=i;c[a+16>>2]=h;c[a+20>>2]=g;c[a+24>>2]=f;c[a+28>>2]=e;c[a+32>>2]=d;c[a+36>>2]=b;return}function md(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0;Ya=i;Oa=i=i+63&-64;i=i+480|0;Ta=Oa+400|0;Ua=Oa+360|0;Va=Oa+320|0;Sa=Oa+280|0;Ma=Oa+440|0;Pa=Oa+240|0;Wa=Oa+200|0;Xa=Oa+160|0;Qa=Oa+120|0;Ra=Oa+80|0;Na=Oa+40|0;h=Ma;g=h+32|0;do{a[h>>0]=a[e>>0]|0;h=h+1|0;e=e+1|0}while((h|0)<(g|0));a[Ma>>0]=(d[Ma>>0]|0)&248;m=Ma+31|0;a[m>>0]=(d[m>>0]|0)&63|64;m=d[f>>0]|0;Da=Hd(d[f+1>>0]|0|0,0,8)|0;j=C;va=Hd(d[f+2>>0]|0|0,0,16)|0;j=j|C;Aa=Hd(d[f+3>>0]|0|0,0,24)|0;j=j|C;k=a[f+6>>0]|0;l=d[f+4>>0]|0;ya=Hd(d[f+5>>0]|0|0,0,8)|0;za=C;k=Hd(k&255|0,0,16)|0;za=Hd(ya|l|k|0,za|C|0,6)|0;k=C;l=a[f+9>>0]|0;ya=d[f+7>>0]|0;n=Hd(d[f+8>>0]|0|0,0,8)|0;Ea=C;l=Hd(l&255|0,0,16)|0;Ea=Hd(n|ya|l|0,Ea|C|0,5)|0;l=C;ya=a[f+12>>0]|0;n=d[f+10>>0]|0;Ga=Hd(d[f+11>>0]|0|0,0,8)|0;xa=C;ya=Hd(ya&255|0,0,16)|0;xa=Hd(Ga|n|ya|0,xa|C|0,3)|0;ya=C;n=a[f+15>>0]|0;Ga=d[f+13>>0]|0;h=Hd(d[f+14>>0]|0|0,0,8)|0;Ia=C;n=Hd(n&255|0,0,16)|0;Ia=Hd(h|Ga|n|0,Ia|C|0,2)|0;n=C;Ga=d[f+16>>0]|0;h=Hd(d[f+17>>0]|0|0,0,8)|0;Ca=C;p=Hd(d[f+18>>0]|0|0,0,16)|0;Ca=Ca|C;Ba=Hd(d[f+19>>0]|0|0,0,24)|0;Ba=h|Ga|p|Ba;Ca=Ca|C;p=a[f+22>>0]|0;Ga=d[f+20>>0]|0;h=Hd(d[f+21>>0]|0|0,0,8)|0;g=C;p=Hd(p&255|0,0,16)|0;g=Hd(h|Ga|p|0,g|C|0,7)|0;p=C;Ga=a[f+25>>0]|0;h=d[f+23>>0]|0;q=Hd(d[f+24>>0]|0|0,0,8)|0;Fa=C;Ga=Hd(Ga&255|0,0,16)|0;Fa=Hd(q|h|Ga|0,Fa|C|0,5)|0;Ga=C;h=a[f+28>>0]|0;q=d[f+26>>0]|0;Ka=Hd(d[f+27>>0]|0|0,0,8)|0;La=C;h=Hd(h&255|0,0,16)|0;La=Hd(Ka|q|h|0,La|C|0,4)|0;h=C;q=a[f+31>>0]|0;Ka=d[f+29>>0]|0;f=Hd(d[f+30>>0]|0|0,0,8)|0;Ja=C;q=Hd(q&255|0,0,16)|0;Ja=Hd(f|Ka|q|0,Ja|C|0,2)|0;Ja=Ja&33554428;q=Dd(Ja|0,0,16777216,0)|0;q=Gd(q|0,C|0,25)|0;Ka=C;f=Cd(0,0,q|0,Ka|0)|0;j=Dd(f&19|0,0,Da|m|va|Aa|0,j|0)|0;Aa=C;Ka=Hd(q|0,Ka|0,25)|0;q=C;f=Dd(za|0,k|0,16777216,0)|0;f=Gd(f|0,C|0,25)|0;va=C;l=Dd(Ea|0,l|0,f|0,va|0)|0;Ea=C;va=Hd(f|0,va|0,25)|0;va=Cd(za|0,k|0,va|0,C|0)|0;f=C;k=Dd(xa|0,ya|0,16777216,0)|0;k=Gd(k|0,C|0,25)|0;za=C;n=Dd(Ia|0,n|0,k|0,za|0)|0;Ia=C;za=Hd(k|0,za|0,25)|0;k=C;m=Dd(Ba|0,Ca|0,16777216,0)|0;m=Gd(m|0,C|0,25)|0;Da=C;p=Dd(g|0,p|0,m|0,Da|0)|0;g=C;Da=Hd(m|0,Da|0,25)|0;m=C;o=Dd(Fa|0,Ga|0,16777216,0)|0;o=Gd(o|0,C|0,25)|0;Ha=C;h=Dd(La|0,h|0,o|0,Ha|0)|0;La=C;Ha=Hd(o|0,Ha|0,25)|0;o=C;wa=Dd(j|0,Aa|0,33554432,0)|0;wa=Ed(wa|0,C|0,26)|0;e=C;f=Dd(va|0,f|0,wa|0,e|0)|0;e=Hd(wa|0,e|0,26)|0;e=Cd(j|0,Aa|0,e|0,C|0)|0;Aa=Dd(l|0,Ea|0,33554432,0)|0;Aa=Ed(Aa|0,C|0,26)|0;j=C;ya=Dd(Aa|0,j|0,xa|0,ya|0)|0;k=Cd(ya|0,C|0,za|0,k|0)|0;j=Hd(Aa|0,j|0,26)|0;j=Cd(l|0,Ea|0,j|0,C|0)|0;Ea=Dd(n|0,Ia|0,33554432,0)|0;Ea=Ed(Ea|0,C|0,26)|0;l=C;Ca=Dd(Ea|0,l|0,Ba|0,Ca|0)|0;m=Cd(Ca|0,C|0,Da|0,m|0)|0;l=Hd(Ea|0,l|0,26)|0;l=Cd(n|0,Ia|0,l|0,C|0)|0;Ia=Dd(p|0,g|0,33554432,0)|0;Ia=Ed(Ia|0,C|0,26)|0;n=C;Ga=Dd(Ia|0,n|0,Fa|0,Ga|0)|0;o=Cd(Ga|0,C|0,Ha|0,o|0)|0;n=Hd(Ia|0,n|0,26)|0;n=Cd(p|0,g|0,n|0,C|0)|0;g=Dd(h|0,La|0,33554432,0)|0;g=Ed(g|0,C|0,26)|0;p=C;Ja=Dd(Ja|0,0,g|0,p|0)|0;q=Cd(Ja|0,C|0,Ka|0,q|0)|0;p=Hd(g|0,p|0,26)|0;p=Cd(h|0,La|0,p|0,C|0)|0;c[Pa>>2]=e;c[Pa+4>>2]=f;c[Pa+8>>2]=j;c[Pa+12>>2]=k;c[Pa+16>>2]=l;c[Pa+20>>2]=m;c[Pa+24>>2]=n;c[Pa+28>>2]=o;c[Pa+32>>2]=p;c[Pa+36>>2]=q;c[Wa>>2]=1;La=Wa+4|0;h=La;g=h+36|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));h=Xa;g=h+40|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));c[Qa>>2]=e;ta=Qa+4|0;c[ta>>2]=f;ua=Qa+8|0;c[ua>>2]=j;va=Qa+12|0;c[va>>2]=k;wa=Qa+16|0;c[wa>>2]=l;xa=Qa+20|0;c[xa>>2]=m;ya=Qa+24|0;c[ya>>2]=n;za=Qa+28|0;c[za>>2]=o;Aa=Qa+32|0;c[Aa>>2]=p;Ba=Qa+36|0;c[Ba>>2]=q;c[Ra>>2]=1;Ca=Ra+4|0;h=Ca;g=h+36|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(g|0));Da=Wa+8|0;Ea=Wa+12|0;Fa=Wa+16|0;Ga=Wa+20|0;Ha=Wa+24|0;Ia=Wa+28|0;Ja=Wa+32|0;Ka=Wa+36|0;M=Xa+4|0;N=Xa+8|0;O=Xa+12|0;P=Xa+16|0;Q=Xa+20|0;R=Xa+24|0;S=Xa+28|0;T=Xa+32|0;U=Xa+36|0;V=Ra+8|0;W=Ra+12|0;X=Ra+16|0;Y=Ra+20|0;Z=Ra+24|0;_=Ra+28|0;$=Ra+32|0;aa=Ra+36|0;ba=Na+4|0;ca=Na+8|0;da=Na+12|0;ea=Na+16|0;fa=Na+20|0;ga=Na+24|0;ha=Na+28|0;ia=Na+32|0;ja=Na+36|0;ka=Oa+4|0;la=Oa+8|0;ma=Oa+12|0;na=Oa+16|0;oa=Oa+20|0;pa=Oa+24|0;qa=Oa+28|0;ra=Oa+32|0;sa=Oa+36|0;L=1;K=0;J=0;I=0;H=0;G=0;F=0;E=0;D=0;h=0;r=0;s=0;t=0;u=0;v=0;w=0;x=0;y=0;z=0;A=254;B=0;while(1){g=(d[Ma+((A|0)/8|0)>>0]|0)>>>(A&7)&1;nb=0-(g^B)|0;bb=(e^L)&nb;ab=(f^K)&nb;$a=(j^J)&nb;_a=(k^I)&nb;Za=(l^H)&nb;kb=(m^G)&nb;mb=(n^F)&nb;B=(o^E)&nb;jb=(p^D)&nb;lb=(q^h)&nb;c[Wa>>2]=bb^L;c[La>>2]=ab^K;c[Da>>2]=$a^J;c[Ea>>2]=_a^I;c[Fa>>2]=Za^H;c[Ga>>2]=kb^G;c[Ha>>2]=mb^F;c[Ia>>2]=B^E;c[Ja>>2]=jb^D;c[Ka>>2]=lb^h;bb=bb^e;c[Qa>>2]=bb;ab=ab^f;c[ta>>2]=ab;$a=$a^j;c[ua>>2]=$a;_a=_a^k;c[va>>2]=_a;Za=Za^l;c[wa>>2]=Za;I=kb^m;c[xa>>2]=I;E=mb^n;c[ya>>2]=E;l=B^o;c[za>>2]=l;j=jb^p;c[Aa>>2]=j;f=lb^q;c[Ba>>2]=f;K=c[U>>2]|0;lb=c[Ra>>2]|0;jb=c[Ca>>2]|0;B=c[V>>2]|0;p=c[W>>2]|0;q=c[X>>2]|0;D=c[Y>>2]|0;F=c[Z>>2]|0;H=c[_>>2]|0;J=c[$>>2]|0;L=c[aa>>2]|0;mb=(lb^r)&nb;kb=(jb^s)&nb;ib=(B^t)&nb;hb=(p^u)&nb;gb=(q^v)&nb;fb=(D^w)&nb;eb=(F^x)&nb;db=(H^y)&nb;cb=(J^z)&nb;o=(L^K)&nb;e=mb^r;c[Xa>>2]=e;h=kb^s;c[M>>2]=h;k=ib^t;c[N>>2]=k;m=hb^u;c[O>>2]=m;n=gb^v;c[P>>2]=n;r=fb^w;c[Q>>2]=r;v=eb^x;c[R>>2]=v;x=db^y;c[S>>2]=x;G=cb^z;c[T>>2]=G;K=o^K;c[U>>2]=K;s=mb^lb;c[Ra>>2]=s;u=kb^jb;c[Ca>>2]=u;B=ib^B;c[V>>2]=B;p=hb^p;c[W>>2]=p;q=gb^q;c[X>>2]=q;D=fb^D;c[Y>>2]=D;F=eb^F;c[Z>>2]=F;H=db^H;c[_>>2]=H;J=cb^J;c[$>>2]=J;L=o^L;c[aa>>2]=L;c[Na>>2]=bb-s;c[ba>>2]=ab-u;c[ca>>2]=$a-B;c[da>>2]=_a-p;c[ea>>2]=Za-q;c[fa>>2]=I-D;c[ga>>2]=E-F;c[ha>>2]=l-H;c[ia>>2]=j-J;c[ja>>2]=f-L;f=c[Wa>>2]|0;j=c[La>>2]|0;l=c[Da>>2]|0;w=c[Ea>>2]|0;o=c[Fa>>2]|0;t=c[Ga>>2]|0;z=c[Ha>>2]|0;E=c[Ia>>2]|0;I=c[Ja>>2]|0;y=c[Ka>>2]|0;c[Oa>>2]=f-e;c[ka>>2]=j-h;c[la>>2]=l-k;c[ma>>2]=w-m;c[na>>2]=o-n;c[oa>>2]=t-r;c[pa>>2]=z-v;c[qa>>2]=E-x;c[ra>>2]=I-G;c[sa>>2]=y-K;c[Wa>>2]=e+f;c[La>>2]=h+j;c[Da>>2]=k+l;c[Ea>>2]=m+w;c[Fa>>2]=n+o;c[Ga>>2]=r+t;c[Ha>>2]=v+z;c[Ia>>2]=x+E;c[Ja>>2]=G+I;c[Ka>>2]=K+y;u=u+(c[ta>>2]|0)|0;B=B+(c[ua>>2]|0)|0;p=p+(c[va>>2]|0)|0;q=q+(c[wa>>2]|0)|0;D=D+(c[xa>>2]|0)|0;F=F+(c[ya>>2]|0)|0;H=H+(c[za>>2]|0)|0;J=J+(c[Aa>>2]|0)|0;L=L+(c[Ba>>2]|0)|0;c[Xa>>2]=s+(c[Qa>>2]|0);c[M>>2]=u;c[N>>2]=B;c[O>>2]=p;c[P>>2]=q;c[Q>>2]=D;c[R>>2]=F;c[S>>2]=H;c[T>>2]=J;c[U>>2]=L;kd(Ra,Na,Wa);kd(Xa,Xa,Oa);ld(Na,Oa);ld(Oa,Wa);L=c[Ra>>2]|0;J=c[Ca>>2]|0;H=c[V>>2]|0;F=c[W>>2]|0;D=c[X>>2]|0;q=c[Y>>2]|0;p=c[Z>>2]|0;B=c[_>>2]|0;u=c[$>>2]|0;s=c[aa>>2]|0;y=c[Xa>>2]|0;K=c[M>>2]|0;I=c[N>>2]|0;G=c[O>>2]|0;E=c[P>>2]|0;z=c[Q>>2]|0;x=c[R>>2]|0;v=c[S>>2]|0;t=c[T>>2]|0;r=c[U>>2]|0;c[Qa>>2]=y+L;c[ta>>2]=K+J;c[ua>>2]=I+H;c[va>>2]=G+F;c[wa>>2]=E+D;c[xa>>2]=z+q;c[ya>>2]=x+p;c[za>>2]=v+B;c[Aa>>2]=t+u;c[Ba>>2]=r+s;c[Xa>>2]=L-y;c[M>>2]=J-K;c[N>>2]=H-I;c[O>>2]=F-G;c[P>>2]=D-E;c[Q>>2]=q-z;c[R>>2]=p-x;c[S>>2]=B-v;c[T>>2]=u-t;c[U>>2]=s-r;kd(Wa,Oa,Na);r=(c[Oa>>2]|0)-(c[Na>>2]|0)|0;s=(c[ka>>2]|0)-(c[ba>>2]|0)|0;t=(c[la>>2]|0)-(c[ca>>2]|0)|0;u=(c[ma>>2]|0)-(c[da>>2]|0)|0;v=(c[na>>2]|0)-(c[ea>>2]|0)|0;B=(c[oa>>2]|0)-(c[fa>>2]|0)|0;x=(c[pa>>2]|0)-(c[ga>>2]|0)|0;p=(c[qa>>2]|0)-(c[ha>>2]|0)|0;z=(c[ra>>2]|0)-(c[ia>>2]|0)|0;q=(c[sa>>2]|0)-(c[ja>>2]|0)|0;c[Oa>>2]=r;c[ka>>2]=s;c[la>>2]=t;c[ma>>2]=u;c[na>>2]=v;c[oa>>2]=B;c[pa>>2]=x;c[qa>>2]=p;c[ra>>2]=z;c[sa>>2]=q;ld(Xa,Xa);r=Od(r|0,((r|0)<0)<<31>>31|0,121666,0)|0;E=C;s=Od(s|0,((s|0)<0)<<31>>31|0,121666,0)|0;D=C;t=Od(t|0,((t|0)<0)<<31>>31|0,121666,0)|0;G=C;u=Od(u|0,((u|0)<0)<<31>>31|0,121666,0)|0;F=C;v=Od(v|0,((v|0)<0)<<31>>31|0,121666,0)|0;I=C;B=Od(B|0,((B|0)<0)<<31>>31|0,121666,0)|0;H=C;x=Od(x|0,((x|0)<0)<<31>>31|0,121666,0)|0;K=C;p=Od(p|0,((p|0)<0)<<31>>31|0,121666,0)|0;J=C;z=Od(z|0,((z|0)<0)<<31>>31|0,121666,0)|0;y=C;q=Od(q|0,((q|0)<0)<<31>>31|0,121666,0)|0;L=C;o=Dd(q|0,L|0,16777216,0)|0;o=Ed(o|0,C|0,25)|0;w=C;n=Od(o|0,w|0,19,0)|0;E=Dd(n|0,C|0,r|0,E|0)|0;r=C;w=Hd(o|0,w|0,25)|0;w=Cd(q|0,L|0,w|0,C|0)|0;L=C;q=Dd(s|0,D|0,16777216,0)|0;q=Ed(q|0,C|0,25)|0;o=C;G=Dd(q|0,o|0,t|0,G|0)|0;t=C;o=Hd(q|0,o|0,25)|0;o=Cd(s|0,D|0,o|0,C|0)|0;D=C;s=Dd(u|0,F|0,16777216,0)|0;s=Ed(s|0,C|0,25)|0;q=C;I=Dd(s|0,q|0,v|0,I|0)|0;v=C;q=Hd(s|0,q|0,25)|0;q=Cd(u|0,F|0,q|0,C|0)|0;F=C;u=Dd(B|0,H|0,16777216,0)|0;u=Ed(u|0,C|0,25)|0;s=C;K=Dd(u|0,s|0,x|0,K|0)|0;x=C;s=Hd(u|0,s|0,25)|0;s=Cd(B|0,H|0,s|0,C|0)|0;H=C;B=Dd(p|0,J|0,16777216,0)|0;B=Ed(B|0,C|0,25)|0;u=C;y=Dd(B|0,u|0,z|0,y|0)|0;z=C;u=Hd(B|0,u|0,25)|0;u=Cd(p|0,J|0,u|0,C|0)|0;J=C;p=Dd(E|0,r|0,33554432,0)|0;p=Ed(p|0,C|0,26)|0;B=C;D=Dd(o|0,D|0,p|0,B|0)|0;B=Hd(p|0,B|0,26)|0;B=Cd(E|0,r|0,B|0,C|0)|0;r=Dd(G|0,t|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;E=C;F=Dd(q|0,F|0,r|0,E|0)|0;E=Hd(r|0,E|0,26)|0;E=Cd(G|0,t|0,E|0,C|0)|0;t=Dd(I|0,v|0,33554432,0)|0;t=Ed(t|0,C|0,26)|0;G=C;H=Dd(s|0,H|0,t|0,G|0)|0;G=Hd(t|0,G|0,26)|0;G=Cd(I|0,v|0,G|0,C|0)|0;v=Dd(K|0,x|0,33554432,0)|0;v=Ed(v|0,C|0,26)|0;I=C;J=Dd(u|0,J|0,v|0,I|0)|0;I=Hd(v|0,I|0,26)|0;I=Cd(K|0,x|0,I|0,C|0)|0;x=Dd(y|0,z|0,33554432,0)|0;x=Ed(x|0,C|0,26)|0;K=C;L=Dd(w|0,L|0,x|0,K|0)|0;K=Hd(x|0,K|0,26)|0;K=Cd(y|0,z|0,K|0,C|0)|0;c[Ra>>2]=B;c[Ca>>2]=D;c[V>>2]=E;c[W>>2]=F;c[X>>2]=G;c[Y>>2]=H;c[Z>>2]=I;c[_>>2]=J;c[$>>2]=K;c[aa>>2]=L;ld(Qa,Qa);D=D+(c[ba>>2]|0)|0;E=E+(c[ca>>2]|0)|0;F=F+(c[da>>2]|0)|0;G=G+(c[ea>>2]|0)|0;H=H+(c[fa>>2]|0)|0;I=I+(c[ga>>2]|0)|0;J=J+(c[ha>>2]|0)|0;K=K+(c[ia>>2]|0)|0;L=L+(c[ja>>2]|0)|0;c[Na>>2]=B+(c[Na>>2]|0);c[ba>>2]=D;c[ca>>2]=E;c[da>>2]=F;c[ea>>2]=G;c[fa>>2]=H;c[ga>>2]=I;c[ha>>2]=J;c[ia>>2]=K;c[ja>>2]=L;kd(Ra,Pa,Xa);kd(Xa,Oa,Na);if((A|0)<=0)break;e=c[Qa>>2]|0;L=c[Wa>>2]|0;f=c[ta>>2]|0;K=c[La>>2]|0;j=c[ua>>2]|0;J=c[Da>>2]|0;k=c[va>>2]|0;I=c[Ea>>2]|0;l=c[wa>>2]|0;H=c[Fa>>2]|0;m=c[xa>>2]|0;G=c[Ga>>2]|0;n=c[ya>>2]|0;F=c[Ha>>2]|0;o=c[za>>2]|0;E=c[Ia>>2]|0;p=c[Aa>>2]|0;D=c[Ja>>2]|0;q=c[Ba>>2]|0;h=c[Ka>>2]|0;r=c[Xa>>2]|0;s=c[M>>2]|0;t=c[N>>2]|0;u=c[O>>2]|0;v=c[P>>2]|0;w=c[Q>>2]|0;x=c[R>>2]|0;y=c[S>>2]|0;z=c[T>>2]|0;A=A+-1|0;B=g}ka=c[Wa>>2]|0;la=c[La>>2]|0;ma=c[Da>>2]|0;na=c[Ea>>2]|0;oa=c[Fa>>2]|0;pa=c[Ga>>2]|0;qa=c[Ha>>2]|0;ra=c[Ia>>2]|0;sa=c[Ja>>2]|0;lb=c[Ka>>2]|0;hb=c[Qa>>2]|0;db=c[ta>>2]|0;$a=c[ua>>2]|0;Pa=c[va>>2]|0;mb=c[wa>>2]|0;ib=c[xa>>2]|0;eb=c[ya>>2]|0;ab=c[za>>2]|0;Oa=c[Aa>>2]|0;Ma=c[Ba>>2]|0;nb=0-g|0;jb=(hb^ka)&nb;fb=(db^la)&nb;bb=($a^ma)&nb;Za=(Pa^na)&nb;e=(mb^oa)&nb;kb=(ib^pa)&nb;gb=(eb^qa)&nb;cb=(ab^ra)&nb;_a=(Oa^sa)&nb;Na=(Ma^lb)&nb;c[Wa>>2]=jb^ka;c[La>>2]=fb^la;c[Da>>2]=bb^ma;c[Ea>>2]=Za^na;c[Fa>>2]=e^oa;c[Ga>>2]=kb^pa;c[Ha>>2]=gb^qa;c[Ia>>2]=cb^ra;c[Ja>>2]=_a^sa;c[Ka>>2]=Na^lb;c[Qa>>2]=jb^hb;c[ta>>2]=fb^db;c[ua>>2]=bb^$a;c[va>>2]=Za^Pa;c[wa>>2]=e^mb;c[xa>>2]=kb^ib;c[ya>>2]=gb^eb;c[za>>2]=cb^ab;c[Aa>>2]=_a^Oa;c[Ba>>2]=Na^Ma;va=c[Xa>>2]|0;wa=c[M>>2]|0;xa=c[N>>2]|0;ya=c[O>>2]|0;za=c[P>>2]|0;Aa=c[Q>>2]|0;Ba=c[R>>2]|0;Ma=c[S>>2]|0;Na=c[T>>2]|0;Oa=c[U>>2]|0;Qa=c[Ra>>2]|0;_a=c[Ca>>2]|0;ab=c[V>>2]|0;cb=c[W>>2]|0;eb=c[X>>2]|0;gb=c[Y>>2]|0;ib=c[Z>>2]|0;kb=c[_>>2]|0;mb=c[$>>2]|0;e=c[aa>>2]|0;Pa=(Qa^va)&nb;Za=(_a^wa)&nb;$a=(ab^xa)&nb;bb=(cb^ya)&nb;db=(eb^za)&nb;fb=(gb^Aa)&nb;hb=(ib^Ba)&nb;jb=(kb^Ma)&nb;lb=(mb^Na)&nb;nb=(e^Oa)&nb;c[Xa>>2]=Pa^va;c[M>>2]=Za^wa;c[N>>2]=$a^xa;c[O>>2]=bb^ya;c[P>>2]=db^za;c[Q>>2]=fb^Aa;c[R>>2]=hb^Ba;c[S>>2]=jb^Ma;c[T>>2]=lb^Na;c[U>>2]=nb^Oa;c[Ra>>2]=Pa^Qa;c[Ca>>2]=Za^_a;c[V>>2]=$a^ab;c[W>>2]=bb^cb;c[X>>2]=db^eb;c[Y>>2]=fb^gb;c[Z>>2]=hb^ib;c[_>>2]=jb^kb;c[$>>2]=lb^mb;c[aa>>2]=nb^e;ld(Ta,Xa);ld(Ua,Ta);ld(Ua,Ua);kd(Ua,Xa,Ua);kd(Ta,Ta,Ua);ld(Va,Ta);kd(Ua,Ua,Va);ld(Va,Ua);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);kd(Ua,Va,Ua);ld(Va,Ua);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);kd(Va,Va,Ua);ld(Sa,Va);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);ld(Sa,Sa);kd(Va,Sa,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);ld(Va,Va);kd(Ua,Va,Ua);ld(Va,Ua);e=1;do{ld(Va,Va);e=e+1|0}while((e|0)!=50);kd(Va,Va,Ua);ld(Sa,Va);e=1;do{ld(Sa,Sa);e=e+1|0}while((e|0)!=100);kd(Va,Sa,Va);ld(Va,Va);e=1;do{ld(Va,Va);e=e+1|0}while((e|0)!=50);kd(Ua,Va,Ua);ld(Ua,Ua);ld(Ua,Ua);ld(Ua,Ua);ld(Ua,Ua);ld(Ua,Ua);kd(Xa,Ua,Ta);kd(Wa,Wa,Xa);eb=c[Wa>>2]|0;fb=c[La>>2]|0;gb=c[Da>>2]|0;hb=c[Ea>>2]|0;ib=c[Fa>>2]|0;jb=c[Ga>>2]|0;kb=c[Ha>>2]|0;lb=c[Ia>>2]|0;nb=c[Ja>>2]|0;mb=c[Ka>>2]|0;eb=(((((((((((((mb*19|0)+16777216>>25)+eb>>26)+fb>>25)+gb>>26)+hb>>25)+ib>>26)+jb>>25)+kb>>26)+lb>>25)+nb>>26)+mb>>25)*19|0)+eb|0;db=eb>>26;fb=db+fb|0;db=eb-(db<<26)|0;eb=fb>>25;gb=eb+gb|0;eb=fb-(eb<<25)|0;fb=gb>>26;hb=fb+hb|0;fb=gb-(fb<<26)|0;gb=hb>>25;ib=gb+ib|0;gb=hb-(gb<<25)|0;hb=ib>>26;jb=hb+jb|0;hb=ib-(hb<<26)|0;ib=jb>>25;kb=ib+kb|0;ib=jb-(ib<<25)|0;jb=kb>>26;lb=jb+lb|0;jb=kb-(jb<<26)|0;kb=lb>>25;nb=kb+nb|0;kb=lb-(kb<<25)|0;lb=nb>>26;mb=lb+mb|0;lb=nb-(lb<<26)|0;nb=mb&33554431;a[b>>0]=db;a[b+1>>0]=db>>>8;a[b+2>>0]=db>>>16;a[b+3>>0]=eb<<2|db>>>24;a[b+4>>0]=eb>>>6;a[b+5>>0]=eb>>>14;a[b+6>>0]=fb<<3|eb>>>22;a[b+7>>0]=fb>>>5;a[b+8>>0]=fb>>>13;a[b+9>>0]=gb<<5|fb>>>21;a[b+10>>0]=gb>>>3;a[b+11>>0]=gb>>>11;a[b+12>>0]=hb<<6|gb>>>19;a[b+13>>0]=hb>>>2;a[b+14>>0]=hb>>>10;a[b+15>>0]=hb>>>18;a[b+16>>0]=ib;a[b+17>>0]=ib>>>8;a[b+18>>0]=ib>>>16;a[b+19>>0]=jb<<1|ib>>>24;a[b+20>>0]=jb>>>7;a[b+21>>0]=jb>>>15;a[b+22>>0]=kb<<3|jb>>>23;a[b+23>>0]=kb>>>5;a[b+24>>0]=kb>>>13;a[b+25>>0]=lb<<4|kb>>>21;a[b+26>>0]=lb>>>4;a[b+27>>0]=lb>>>12;a[b+28>>0]=lb>>>20|nb<<6;a[b+29>>0]=mb>>>2;a[b+30>>0]=mb>>>10;a[b+31>>0]=nb>>>18;i=Ya;return}function nd(b,e,f,g,h,j,k,l){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;l=l|0;var m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0;D=i;B=i=i+63&-64;i=i+112|0;v=B;A=B+48|0;B=B+16|0;if((f|0)==0&(g|0)==0){i=D;return}n=B;m=n+32|0;do{a[n>>0]=a[l>>0]|0;n=n+1|0;l=l+1|0}while((n|0)<(m|0));s=h;p=s;s=s+4|0;s=d[s>>0]|d[s+1>>0]<<8|d[s+2>>0]<<16|d[s+3>>0]<<24;o=v;c[o>>2]=d[p>>0]|d[p+1>>0]<<8|d[p+2>>0]<<16|d[p+3>>0]<<24;c[o+4>>2]=s;o=v+8|0;a[o>>0]=j;s=Gd(j|0,k|0,8)|0;p=v+9|0;a[p>>0]=s;s=Gd(j|0,k|0,16)|0;q=v+10|0;a[q>>0]=s;s=Gd(j|0,k|0,24)|0;r=v+11|0;a[r>>0]=s;s=v+12|0;a[s>>0]=k;n=Gd(j|0,k|0,40)|0;t=v+13|0;a[t>>0]=n;n=Gd(j|0,k|0,48)|0;u=v+14|0;a[u>>0]=n;k=Gd(j|0,k|0,56)|0;j=v+15|0;a[j>>0]=k;if(g>>>0>0|(g|0)==0&f>>>0>63){n=e;h=f;l=g;do{ob(A,v,B,33833);m=0;do{a[b+m>>0]=a[A+m>>0]^a[n+m>>0];m=m+1|0}while((m|0)!=64);f=c[o>>2]|0;g=(f&255)+1|0;a[o>>0]=g;g=(f>>>8&255)+(g>>>8)|0;a[p>>0]=g;g=(f>>>16&255)+(g>>>8)|0;a[q>>0]=g;g=(f>>>24)+(g>>>8)|0;a[r>>0]=g;f=c[s>>2]|0;g=(f&255)+(g>>>8)|0;a[s>>0]=g;g=(f>>>8&255)+(g>>>8)|0;a[t>>0]=g;g=(f>>>16&255)+(g>>>8)|0;a[u>>0]=g;a[j>>0]=(f>>>24)+(g>>>8);h=Dd(h|0,l|0,-64,-1)|0;l=C;b=b+64|0;n=n+64|0}while(l>>>0>0|(l|0)==0&h>>>0>63);if(!((h|0)==0&(l|0)==0)){x=b;y=h;z=n;w=8}}else{x=b;y=f;z=e;w=8}if((w|0)==8?(ob(A,v,B,33833),(y|0)!=0):0){l=0;do{a[x+l>>0]=a[A+l>>0]^a[z+l>>0];l=l+1|0}while((l|0)!=(y|0))}n=A;m=n+64|0;do{a[n>>0]=0;n=n+1|0}while((n|0)<(m|0));n=B;m=n+32|0;do{a[n>>0]=0;n=n+1|0}while((n|0)<(m|0));i=D;return}function od(){var a=0;if(!(c[7979]|0))a=31964;else a=c[(oa()|0)+60>>2]|0;return a|0}function pd(a){a=a|0;var b=0,d=0;d=i;b=i=i+63&-64;i=i+16|0;c[b>>2]=c[a+60>>2];a=pa(6,b|0)|0;if(a>>>0>4294963200){if(!(c[7979]|0))b=31964;else b=c[(oa()|0)+60>>2]|0;c[b>>2]=0-a;a=-1}i=d;return a|0}function qd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;g=i;e=i=i+63&-64;i=i+32|0;h=e;e=e+20|0;c[h>>2]=c[a+60>>2];c[h+4>>2]=0;c[h+8>>2]=b;c[h+12>>2]=e;c[h+16>>2]=d;b=ya(140,h|0)|0;if(b>>>0<=4294963200)if((b|0)<0)f=7;else a=c[e>>2]|0;else{if(!(c[7979]|0))a=31964;else a=c[(oa()|0)+60>>2]|0;c[a>>2]=0-b;f=7}if((f|0)==7){c[e>>2]=-1;a=-1}i=g;return a|0}function rd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;q=i;k=i=i+63&-64;i=i+48|0;n=k+16|0;m=k;k=k+32|0;o=a+28|0;g=c[o>>2]|0;c[k>>2]=g;p=a+20|0;g=(c[p>>2]|0)-g|0;c[k+4>>2]=g;c[k+8>>2]=b;c[k+12>>2]=d;j=a+60|0;l=a+44|0;f=2;g=g+d|0;while(1){if(!(c[7979]|0)){c[n>>2]=c[j>>2];c[n+4>>2]=k;c[n+8>>2]=f;b=Aa(146,n|0)|0;if(b>>>0>4294963200){if(!(c[7979]|0))e=31964;else e=c[(oa()|0)+60>>2]|0;c[e>>2]=0-b;b=-1}}else{ua(18,a|0);c[m>>2]=c[j>>2];c[m+4>>2]=k;c[m+8>>2]=f;b=Aa(146,m|0)|0;if(b>>>0>4294963200){if(!(c[7979]|0))e=31964;else e=c[(oa()|0)+60>>2]|0;c[e>>2]=0-b;b=-1}la(0)}if((g|0)==(b|0)){b=13;break}if((b|0)<0){b=15;break}g=g-b|0;e=c[k+4>>2]|0;if(b>>>0<=e>>>0)if((f|0)==2){c[o>>2]=(c[o>>2]|0)+b;h=e;e=k;f=2}else{h=e;e=k}else{h=c[l>>2]|0;c[o>>2]=h;c[p>>2]=h;h=c[k+12>>2]|0;b=b-e|0;e=k+8|0;f=f+-1|0}c[e>>2]=(c[e>>2]|0)+b;c[e+4>>2]=h-b;k=e}if((b|0)==13){n=c[l>>2]|0;c[a+16>>2]=n+(c[a+48>>2]|0);a=n;c[o>>2]=a;c[p>>2]=a}else if((b|0)==15){c[a+16>>2]=0;c[o>>2]=0;c[p>>2]=0;c[a>>2]=c[a>>2]|32;if((f|0)==2)d=0;else d=d-(c[k+4>>2]|0)|0}i=q;return d|0}function sd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;g=i;h=i=i+63&-64;i=i+80|0;f=h;c[b+36>>2]=20;if((c[b>>2]&64|0)==0?(c[f>>2]=c[b+60>>2],c[f+4>>2]=21505,c[f+8>>2]=h+12,(wa(54,f|0)|0)!=0):0)a[b+75>>0]=-1;h=rd(b,d,e)|0;i=g;return h|0}function td(a){a=a|0;var b=0;if(!a){if(!(c[7990]|0))a=0;else a=td(c[7990]|0)|0;ma(31944);b=c[7985]|0;if(b)do{if((c[b+20>>2]|0)>>>0>(c[b+28>>2]|0)>>>0)a=xd(b)|0|a;b=c[b+56>>2]|0}while((b|0)!=0);xa(31944)}else a=xd(a)|0;return a|0}function ud(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;f=d&255;a:do if(!f)b=b+(vd(b)|0)|0;else{if(b&3){e=d&255;do{g=a[b>>0]|0;if(g<<24>>24==0?1:g<<24>>24==e<<24>>24)break a;b=b+1|0}while((b&3|0)!=0)}f=_(f,16843009)|0;e=c[b>>2]|0;b:do if(!((e&-2139062144^-2139062144)&e+-16843009))do{g=e^f;if((g&-2139062144^-2139062144)&g+-16843009)break b;b=b+4|0;e=c[b>>2]|0}while(((e&-2139062144^-2139062144)&e+-16843009|0)==0);while(0);e=d&255;while(1){g=a[b>>0]|0;if(g<<24>>24==0?1:g<<24>>24==e<<24>>24)break;else b=b+1|0}}while(0);return b|0}function vd(b){b=b|0;var d=0,e=0,f=0;f=b;a:do if(!(f&3))e=4;else{d=b;b=f;while(1){if(!(a[d>>0]|0))break a;d=d+1|0;b=d;if(!(b&3)){b=d;e=4;break}}}while(0);if((e|0)==4){while(1){d=c[b>>2]|0;if(!((d&-2139062144^-2139062144)&d+-16843009))b=b+4|0;else break}if((d&255)<<24>>24)do b=b+1|0;while((a[b>>0]|0)!=0)}return b-f|0}function wd(a){a=a|0;return}function xd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;b=a+20|0;g=a+28|0;if((c[b>>2]|0)>>>0>(c[g>>2]|0)>>>0?(Fa[c[a+36>>2]&31](a,0,0)|0,(c[b>>2]|0)==0):0)b=-1;else{h=a+4|0;d=c[h>>2]|0;e=a+8|0;f=c[e>>2]|0;if(d>>>0<f>>>0)Fa[c[a+40>>2]&31](a,d-f|0,1)|0;c[a+16>>2]=0;c[g>>2]=0;c[b>>2]=0;c[e>>2]=0;c[h>>2]=0;b=0}return b|0}
function Hb(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0;h=i;g=i=i+63&-64;i=i+640|0;e=0;do{j=b+(e<<3)|0;o=d[j+7>>0]|0;p=Hd(d[j+6>>0]|0|0,0,8)|0;f=C;n=Hd(d[j+5>>0]|0|0,0,16)|0;f=f|C;m=Hd(d[j+4>>0]|0|0,0,24)|0;f=f|C|(d[j+3>>0]|0);l=Hd(d[j+2>>0]|0|0,0,40)|0;f=f|C;k=Hd(d[j+1>>0]|0|0,0,48)|0;k=Dd(p|o|n|m|l|0,f|0,k|0,C|0)|0;f=C;j=Hd(d[j>>0]|0|0,0,56)|0;j=Dd(k|0,f|0,j|0,C|0)|0;f=g+(e<<3)|0;c[f>>2]=j;c[f+4>>2]=C;e=e+1|0}while((e|0)!=16);e=g;b=c[e>>2]|0;e=c[e+4>>2]|0;f=16;do{s=g+(f+-2<<3)|0;w=c[s>>2]|0;s=c[s+4>>2]|0;r=Gd(w|0,s|0,19)|0;j=C;q=Hd(w|0,s|0,45)|0;j=j|C;u=Gd(w|0,s|0,61)|0;v=C;t=Hd(w|0,s|0,3)|0;v=v|C;s=Gd(w|0,s|0,6)|0;j=v^C^j;v=g+(f+-7<<3)|0;w=c[v>>2]|0;v=c[v+4>>2]|0;n=g+(f+-15<<3)|0;y=b;b=c[n>>2]|0;x=e;e=c[n+4>>2]|0;n=Gd(b|0,e|0,1)|0;o=C;p=Hd(b|0,e|0,63)|0;o=o|C;k=Gd(b|0,e|0,8)|0;z=C;l=Hd(b|0,e|0,56)|0;z=z|C;m=Gd(b|0,e|0,7)|0;o=z^C^o;v=Dd(y|0,x|0,w|0,v|0)|0;j=Dd(v|0,C|0,(u|t)^s^(r|q)|0,j|0)|0;o=Dd(j|0,C|0,(k|l)^m^(n|p)|0,o|0)|0;p=g+(f<<3)|0;c[p>>2]=o;c[p+4>>2]=C;f=f+1|0}while((f|0)!=80);K=a;I=c[K>>2]|0;K=c[K+4>>2]|0;e=a+8|0;A=e;B=c[A>>2]|0;A=c[A+4>>2]|0;k=a+16|0;f=k;b=c[f>>2]|0;f=c[f+4>>2]|0;n=a+24|0;l=n;j=c[l>>2]|0;l=c[l+4>>2]|0;q=a+32|0;m=q;p=c[m>>2]|0;m=c[m+4>>2]|0;t=a+40|0;o=t;s=c[o>>2]|0;o=c[o+4>>2]|0;w=a+48|0;r=w;v=c[r>>2]|0;r=c[r+4>>2]|0;z=a+56|0;u=z;y=c[u>>2]|0;u=c[u+4>>2]|0;H=Gd(p|0,m|0,14)|0;D=C;x=Hd(p|0,m|0,50)|0;D=D|C;M=Gd(p|0,m|0,18)|0;E=C;L=Hd(p|0,m|0,46)|0;E=D^(E|C);D=Gd(p|0,m|0,41)|0;G=C;J=Hd(p|0,m|0,23)|0;G=E^(G|C);E=g;F=c[E>>2]|0;E=c[E+4>>2]|0;u=Dd(y|0,u|0,-685199838,1116352408)|0;E=Dd(u|0,C|0,F|0,E|0)|0;G=Dd(E|0,C|0,(H|x)^(M|L)^(D|J)|0,G|0)|0;G=Dd(G|0,C|0,(v^s)&p^v|0,(r^o)&m^r|0)|0;J=C;D=Gd(I|0,K|0,28)|0;L=C;M=Hd(I|0,K|0,36)|0;L=L|C;x=Gd(I|0,K|0,34)|0;H=C;E=Hd(I|0,K|0,30)|0;H=L^(H|C);L=Gd(I|0,K|0,39)|0;F=C;u=Hd(I|0,K|0,25)|0;F=Dd((b|B)&I|b&B|0,(f|A)&K|f&A|0,(D|M)^(x|E)^(L|u)|0,H^(F|C)|0)|0;H=C;l=Dd(j|0,l|0,G|0,J|0)|0;j=C;J=Dd(F|0,H|0,G|0,J|0)|0;G=C;H=Gd(l|0,j|0,14)|0;F=C;u=Hd(l|0,j|0,50)|0;F=F|C;L=Gd(l|0,j|0,18)|0;E=C;x=Hd(l|0,j|0,46)|0;E=F^(E|C);F=Gd(l|0,j|0,41)|0;M=C;D=Hd(l|0,j|0,23)|0;M=E^(M|C);E=g+8|0;y=c[E>>2]|0;E=c[E+4>>2]|0;r=Dd(v|0,r|0,602891725,1899447441)|0;E=Dd(r|0,C|0,y|0,E|0)|0;M=Dd(E|0,C|0,(H|u)^(L|x)^(F|D)|0,M|0)|0;M=Dd(M|0,C|0,(s^p)&l^s|0,(o^m)&j^o|0)|0;D=C;F=Gd(J|0,G|0,28)|0;x=C;L=Hd(J|0,G|0,36)|0;x=x|C;u=Gd(J|0,G|0,34)|0;H=C;E=Hd(J|0,G|0,30)|0;H=x^(H|C);x=Gd(J|0,G|0,39)|0;y=C;r=Hd(J|0,G|0,25)|0;y=Dd((B|I)&J|B&I|0,(A|K)&G|A&K|0,(F|L)^(u|E)^(x|r)|0,H^(y|C)|0)|0;H=C;f=Dd(b|0,f|0,M|0,D|0)|0;b=C;D=Dd(y|0,H|0,M|0,D|0)|0;M=C;H=Gd(f|0,b|0,14)|0;y=C;r=Hd(f|0,b|0,50)|0;y=y|C;x=Gd(f|0,b|0,18)|0;E=C;u=Hd(f|0,b|0,46)|0;E=y^(E|C);y=Gd(f|0,b|0,41)|0;L=C;F=Hd(f|0,b|0,23)|0;L=E^(L|C);E=g+16|0;v=c[E>>2]|0;E=c[E+4>>2]|0;o=Dd(s|0,o|0,-330482897,-1245643825)|0;E=Dd(o|0,C|0,v|0,E|0)|0;L=Dd(E|0,C|0,(H|r)^(x|u)^(y|F)|0,L|0)|0;L=Dd(L|0,C|0,(p^l)&f^p|0,(m^j)&b^m|0)|0;F=C;y=Gd(D|0,M|0,28)|0;u=C;x=Hd(D|0,M|0,36)|0;u=u|C;r=Gd(D|0,M|0,34)|0;H=C;E=Hd(D|0,M|0,30)|0;H=u^(H|C);u=Gd(D|0,M|0,39)|0;v=C;o=Hd(D|0,M|0,25)|0;v=Dd((I|J)&D|I&J|0,(K|G)&M|K&G|0,(y|x)^(r|E)^(u|o)|0,H^(v|C)|0)|0;H=C;A=Dd(B|0,A|0,L|0,F|0)|0;B=C;F=Dd(v|0,H|0,L|0,F|0)|0;L=C;H=Gd(A|0,B|0,14)|0;v=C;o=Hd(A|0,B|0,50)|0;v=v|C;u=Gd(A|0,B|0,18)|0;E=C;r=Hd(A|0,B|0,46)|0;E=v^(E|C);v=Gd(A|0,B|0,41)|0;x=C;y=Hd(A|0,B|0,23)|0;x=E^(x|C);E=g+24|0;s=c[E>>2]|0;E=c[E+4>>2]|0;m=Dd(p|0,m|0,-2121671748,-373957723)|0;E=Dd(m|0,C|0,s|0,E|0)|0;x=Dd(E|0,C|0,(H|o)^(u|r)^(v|y)|0,x|0)|0;x=Dd(x|0,C|0,(l^f)&A^l|0,(j^b)&B^j|0)|0;y=C;v=Gd(F|0,L|0,28)|0;r=C;u=Hd(F|0,L|0,36)|0;r=r|C;o=Gd(F|0,L|0,34)|0;H=C;E=Hd(F|0,L|0,30)|0;H=r^(H|C);r=Gd(F|0,L|0,39)|0;s=C;m=Hd(F|0,L|0,25)|0;s=Dd((J|D)&F|J&D|0,(G|M)&L|G&M|0,(v|u)^(o|E)^(r|m)|0,H^(s|C)|0)|0;H=C;K=Dd(I|0,K|0,x|0,y|0)|0;I=C;y=Dd(s|0,H|0,x|0,y|0)|0;x=C;H=Gd(K|0,I|0,14)|0;s=C;m=Hd(K|0,I|0,50)|0;s=s|C;r=Gd(K|0,I|0,18)|0;E=C;o=Hd(K|0,I|0,46)|0;E=s^(E|C);s=Gd(K|0,I|0,41)|0;u=C;v=Hd(K|0,I|0,23)|0;u=E^(u|C);E=g+32|0;p=c[E>>2]|0;E=c[E+4>>2]|0;j=Dd(l|0,j|0,-213338824,961987163)|0;E=Dd(j|0,C|0,p|0,E|0)|0;u=Dd(E|0,C|0,(H|m)^(r|o)^(s|v)|0,u|0)|0;u=Dd(u|0,C|0,(f^A)&K^f|0,(b^B)&I^b|0)|0;v=C;s=Gd(y|0,x|0,28)|0;o=C;r=Hd(y|0,x|0,36)|0;o=o|C;m=Gd(y|0,x|0,34)|0;H=C;E=Hd(y|0,x|0,30)|0;H=o^(H|C);o=Gd(y|0,x|0,39)|0;p=C;j=Hd(y|0,x|0,25)|0;p=Dd((D|F)&y|D&F|0,(M|L)&x|M&L|0,(s|r)^(m|E)^(o|j)|0,H^(p|C)|0)|0;H=C;G=Dd(J|0,G|0,u|0,v|0)|0;J=C;v=Dd(p|0,H|0,u|0,v|0)|0;u=C;H=Gd(G|0,J|0,14)|0;p=C;j=Hd(G|0,J|0,50)|0;p=p|C;o=Gd(G|0,J|0,18)|0;E=C;m=Hd(G|0,J|0,46)|0;E=p^(E|C);p=Gd(G|0,J|0,41)|0;r=C;s=Hd(G|0,J|0,23)|0;r=E^(r|C);E=g+40|0;l=c[E>>2]|0;E=c[E+4>>2]|0;b=Dd(f|0,b|0,-1241133031,1508970993)|0;E=Dd(b|0,C|0,l|0,E|0)|0;r=Dd(E|0,C|0,(H|j)^(o|m)^(p|s)|0,r|0)|0;r=Dd(r|0,C|0,(A^K)&G^A|0,(B^I)&J^B|0)|0;s=C;p=Gd(v|0,u|0,28)|0;m=C;o=Hd(v|0,u|0,36)|0;m=m|C;j=Gd(v|0,u|0,34)|0;H=C;E=Hd(v|0,u|0,30)|0;H=m^(H|C);m=Gd(v|0,u|0,39)|0;l=C;b=Hd(v|0,u|0,25)|0;l=Dd((F|y)&v|F&y|0,(L|x)&u|L&x|0,(p|o)^(j|E)^(m|b)|0,H^(l|C)|0)|0;H=C;M=Dd(D|0,M|0,r|0,s|0)|0;D=C;s=Dd(l|0,H|0,r|0,s|0)|0;r=C;H=Gd(M|0,D|0,14)|0;l=C;b=Hd(M|0,D|0,50)|0;l=l|C;m=Gd(M|0,D|0,18)|0;E=C;j=Hd(M|0,D|0,46)|0;E=l^(E|C);l=Gd(M|0,D|0,41)|0;o=C;p=Hd(M|0,D|0,23)|0;o=E^(o|C);E=g+48|0;f=c[E>>2]|0;E=c[E+4>>2]|0;B=Dd(A|0,B|0,-1357295717,-1841331548)|0;E=Dd(B|0,C|0,f|0,E|0)|0;o=Dd(E|0,C|0,(H|b)^(m|j)^(l|p)|0,o|0)|0;o=Dd(o|0,C|0,(K^G)&M^K|0,(I^J)&D^I|0)|0;p=C;l=Gd(s|0,r|0,28)|0;j=C;m=Hd(s|0,r|0,36)|0;j=j|C;b=Gd(s|0,r|0,34)|0;H=C;E=Hd(s|0,r|0,30)|0;H=j^(H|C);j=Gd(s|0,r|0,39)|0;f=C;B=Hd(s|0,r|0,25)|0;f=Dd((y|v)&s|y&v|0,(x|u)&r|x&u|0,(l|m)^(b|E)^(j|B)|0,H^(f|C)|0)|0;H=C;L=Dd(F|0,L|0,o|0,p|0)|0;F=C;p=Dd(f|0,H|0,o|0,p|0)|0;o=C;H=Gd(L|0,F|0,14)|0;f=C;B=Hd(L|0,F|0,50)|0;f=f|C;j=Gd(L|0,F|0,18)|0;E=C;b=Hd(L|0,F|0,46)|0;E=f^(E|C);f=Gd(L|0,F|0,41)|0;m=C;l=Hd(L|0,F|0,23)|0;m=E^(m|C);E=g+56|0;A=c[E>>2]|0;E=c[E+4>>2]|0;I=Dd(K|0,I|0,-630357736,-1424204075)|0;E=Dd(I|0,C|0,A|0,E|0)|0;m=Dd(E|0,C|0,(H|B)^(j|b)^(f|l)|0,m|0)|0;m=Dd(m|0,C|0,(G^M)&L^G|0,(J^D)&F^J|0)|0;l=C;f=Gd(p|0,o|0,28)|0;b=C;j=Hd(p|0,o|0,36)|0;b=b|C;B=Gd(p|0,o|0,34)|0;H=C;E=Hd(p|0,o|0,30)|0;H=b^(H|C);b=Gd(p|0,o|0,39)|0;A=C;I=Hd(p|0,o|0,25)|0;A=Dd((v|s)&p|v&s|0,(u|r)&o|u&r|0,(f|j)^(B|E)^(b|I)|0,H^(A|C)|0)|0;H=C;x=Dd(y|0,x|0,m|0,l|0)|0;y=C;l=Dd(A|0,H|0,m|0,l|0)|0;m=C;H=Gd(x|0,y|0,14)|0;A=C;I=Hd(x|0,y|0,50)|0;A=A|C;b=Gd(x|0,y|0,18)|0;E=C;B=Hd(x|0,y|0,46)|0;E=A^(E|C);A=Gd(x|0,y|0,41)|0;j=C;f=Hd(x|0,y|0,23)|0;j=E^(j|C);E=g+64|0;K=c[E>>2]|0;E=c[E+4>>2]|0;J=Dd(G|0,J|0,-1560083902,-670586216)|0;E=Dd(J|0,C|0,K|0,E|0)|0;j=Dd(E|0,C|0,(H|I)^(b|B)^(A|f)|0,j|0)|0;j=Dd(j|0,C|0,(M^L)&x^M|0,(D^F)&y^D|0)|0;f=C;A=Gd(l|0,m|0,28)|0;B=C;b=Hd(l|0,m|0,36)|0;B=B|C;I=Gd(l|0,m|0,34)|0;H=C;E=Hd(l|0,m|0,30)|0;H=B^(H|C);B=Gd(l|0,m|0,39)|0;K=C;J=Hd(l|0,m|0,25)|0;K=Dd((s|p)&l|s&p|0,(r|o)&m|r&o|0,(A|b)^(I|E)^(B|J)|0,H^(K|C)|0)|0;H=C;u=Dd(v|0,u|0,j|0,f|0)|0;v=C;f=Dd(K|0,H|0,j|0,f|0)|0;j=C;H=Gd(u|0,v|0,14)|0;K=C;J=Hd(u|0,v|0,50)|0;K=K|C;B=Gd(u|0,v|0,18)|0;E=C;I=Hd(u|0,v|0,46)|0;E=K^(E|C);K=Gd(u|0,v|0,41)|0;b=C;A=Hd(u|0,v|0,23)|0;b=E^(b|C);E=g+72|0;G=c[E>>2]|0;E=c[E+4>>2]|0;D=Dd(M|0,D|0,1164996542,310598401)|0;E=Dd(D|0,C|0,G|0,E|0)|0;b=Dd(E|0,C|0,(H|J)^(B|I)^(K|A)|0,b|0)|0;b=Dd(b|0,C|0,(L^x)&u^L|0,(F^y)&v^F|0)|0;A=C;K=Gd(f|0,j|0,28)|0;I=C;B=Hd(f|0,j|0,36)|0;I=I|C;J=Gd(f|0,j|0,34)|0;H=C;E=Hd(f|0,j|0,30)|0;H=I^(H|C);I=Gd(f|0,j|0,39)|0;G=C;D=Hd(f|0,j|0,25)|0;G=Dd((p|l)&f|p&l|0,(o|m)&j|o&m|0,(K|B)^(J|E)^(I|D)|0,H^(G|C)|0)|0;H=C;r=Dd(s|0,r|0,b|0,A|0)|0;s=C;A=Dd(G|0,H|0,b|0,A|0)|0;b=C;H=Gd(r|0,s|0,14)|0;G=C;D=Hd(r|0,s|0,50)|0;G=G|C;I=Gd(r|0,s|0,18)|0;E=C;J=Hd(r|0,s|0,46)|0;E=G^(E|C);G=Gd(r|0,s|0,41)|0;B=C;K=Hd(r|0,s|0,23)|0;B=E^(B|C);E=g+80|0;M=c[E>>2]|0;E=c[E+4>>2]|0;F=Dd(L|0,F|0,1323610764,607225278)|0;E=Dd(F|0,C|0,M|0,E|0)|0;B=Dd(E|0,C|0,(H|D)^(I|J)^(G|K)|0,B|0)|0;B=Dd(B|0,C|0,(x^u)&r^x|0,(y^v)&s^y|0)|0;K=C;G=Gd(A|0,b|0,28)|0;J=C;I=Hd(A|0,b|0,36)|0;J=J|C;D=Gd(A|0,b|0,34)|0;H=C;E=Hd(A|0,b|0,30)|0;H=J^(H|C);J=Gd(A|0,b|0,39)|0;M=C;F=Hd(A|0,b|0,25)|0;M=Dd((l|f)&A|l&f|0,(m|j)&b|m&j|0,(G|I)^(D|E)^(J|F)|0,H^(M|C)|0)|0;H=C;o=Dd(p|0,o|0,B|0,K|0)|0;p=C;K=Dd(M|0,H|0,B|0,K|0)|0;B=C;H=Gd(o|0,p|0,14)|0;M=C;F=Hd(o|0,p|0,50)|0;M=M|C;J=Gd(o|0,p|0,18)|0;E=C;D=Hd(o|0,p|0,46)|0;E=M^(E|C);M=Gd(o|0,p|0,41)|0;I=C;G=Hd(o|0,p|0,23)|0;I=E^(I|C);E=g+88|0;L=c[E>>2]|0;E=c[E+4>>2]|0;y=Dd(x|0,y|0,-704662302,1426881987)|0;E=Dd(y|0,C|0,L|0,E|0)|0;I=Dd(E|0,C|0,(H|F)^(J|D)^(M|G)|0,I|0)|0;I=Dd(I|0,C|0,(u^r)&o^u|0,(v^s)&p^v|0)|0;G=C;M=Gd(K|0,B|0,28)|0;D=C;J=Hd(K|0,B|0,36)|0;D=D|C;F=Gd(K|0,B|0,34)|0;H=C;E=Hd(K|0,B|0,30)|0;H=D^(H|C);D=Gd(K|0,B|0,39)|0;L=C;y=Hd(K|0,B|0,25)|0;L=Dd((f|A)&K|f&A|0,(j|b)&B|j&b|0,(M|J)^(F|E)^(D|y)|0,H^(L|C)|0)|0;H=C;m=Dd(l|0,m|0,I|0,G|0)|0;l=C;G=Dd(L|0,H|0,I|0,G|0)|0;I=C;H=Gd(m|0,l|0,14)|0;L=C;y=Hd(m|0,l|0,50)|0;L=L|C;D=Gd(m|0,l|0,18)|0;E=C;F=Hd(m|0,l|0,46)|0;E=L^(E|C);L=Gd(m|0,l|0,41)|0;J=C;M=Hd(m|0,l|0,23)|0;J=E^(J|C);E=g+96|0;x=c[E>>2]|0;E=c[E+4>>2]|0;v=Dd(u|0,v|0,-226784913,1925078388)|0;E=Dd(v|0,C|0,x|0,E|0)|0;J=Dd(E|0,C|0,(H|y)^(D|F)^(L|M)|0,J|0)|0;J=Dd(J|0,C|0,(r^o)&m^r|0,(s^p)&l^s|0)|0;M=C;L=Gd(G|0,I|0,28)|0;F=C;D=Hd(G|0,I|0,36)|0;F=F|C;y=Gd(G|0,I|0,34)|0;H=C;E=Hd(G|0,I|0,30)|0;H=F^(H|C);F=Gd(G|0,I|0,39)|0;x=C;v=Hd(G|0,I|0,25)|0;x=Dd((A|K)&G|A&K|0,(b|B)&I|b&B|0,(L|D)^(y|E)^(F|v)|0,H^(x|C)|0)|0;H=C;j=Dd(f|0,j|0,J|0,M|0)|0;f=C;M=Dd(x|0,H|0,J|0,M|0)|0;J=C;H=Gd(j|0,f|0,14)|0;x=C;v=Hd(j|0,f|0,50)|0;x=x|C;F=Gd(j|0,f|0,18)|0;E=C;y=Hd(j|0,f|0,46)|0;E=x^(E|C);x=Gd(j|0,f|0,41)|0;D=C;L=Hd(j|0,f|0,23)|0;D=E^(D|C);E=g+104|0;u=c[E>>2]|0;E=c[E+4>>2]|0;s=Dd(r|0,s|0,991336113,-2132889090)|0;E=Dd(s|0,C|0,u|0,E|0)|0;D=Dd(E|0,C|0,(H|v)^(F|y)^(x|L)|0,D|0)|0;D=Dd(D|0,C|0,(o^m)&j^o|0,(p^l)&f^p|0)|0;L=C;x=Gd(M|0,J|0,28)|0;y=C;F=Hd(M|0,J|0,36)|0;y=y|C;v=Gd(M|0,J|0,34)|0;H=C;E=Hd(M|0,J|0,30)|0;H=y^(H|C);y=Gd(M|0,J|0,39)|0;u=C;s=Hd(M|0,J|0,25)|0;u=Dd((K|G)&M|K&G|0,(B|I)&J|B&I|0,(x|F)^(v|E)^(y|s)|0,H^(u|C)|0)|0;H=C;b=Dd(A|0,b|0,D|0,L|0)|0;A=C;L=Dd(u|0,H|0,D|0,L|0)|0;D=C;H=Gd(b|0,A|0,14)|0;u=C;s=Hd(b|0,A|0,50)|0;u=u|C;y=Gd(b|0,A|0,18)|0;E=C;v=Hd(b|0,A|0,46)|0;E=u^(E|C);u=Gd(b|0,A|0,41)|0;F=C;x=Hd(b|0,A|0,23)|0;F=E^(F|C);E=g+112|0;r=c[E>>2]|0;E=c[E+4>>2]|0;p=Dd(o|0,p|0,633803317,-1680079193)|0;E=Dd(p|0,C|0,r|0,E|0)|0;F=Dd(E|0,C|0,(H|s)^(y|v)^(u|x)|0,F|0)|0;F=Dd(F|0,C|0,(m^j)&b^m|0,(l^f)&A^l|0)|0;x=C;u=Gd(L|0,D|0,28)|0;v=C;y=Hd(L|0,D|0,36)|0;v=v|C;s=Gd(L|0,D|0,34)|0;H=C;E=Hd(L|0,D|0,30)|0;H=v^(H|C);v=Gd(L|0,D|0,39)|0;r=C;p=Hd(L|0,D|0,25)|0;r=Dd((G|M)&L|G&M|0,(I|J)&D|I&J|0,(u|y)^(s|E)^(v|p)|0,H^(r|C)|0)|0;H=C;B=Dd(K|0,B|0,F|0,x|0)|0;K=C;x=Dd(r|0,H|0,F|0,x|0)|0;F=C;H=Gd(B|0,K|0,14)|0;r=C;p=Hd(B|0,K|0,50)|0;r=r|C;v=Gd(B|0,K|0,18)|0;E=C;s=Hd(B|0,K|0,46)|0;E=r^(E|C);r=Gd(B|0,K|0,41)|0;y=C;u=Hd(B|0,K|0,23)|0;y=E^(y|C);E=g+120|0;o=c[E>>2]|0;E=c[E+4>>2]|0;l=Dd(m|0,l|0,-815192428,-1046744716)|0;E=Dd(l|0,C|0,o|0,E|0)|0;y=Dd(E|0,C|0,(H|p)^(v|s)^(r|u)|0,y|0)|0;y=Dd(y|0,C|0,(j^b)&B^j|0,(f^A)&K^f|0)|0;u=C;r=Gd(x|0,F|0,28)|0;s=C;v=Hd(x|0,F|0,36)|0;s=s|C;p=Gd(x|0,F|0,34)|0;H=C;E=Hd(x|0,F|0,30)|0;H=s^(H|C);s=Gd(x|0,F|0,39)|0;o=C;l=Hd(x|0,F|0,25)|0;o=Dd((M|L)&x|M&L|0,(J|D)&F|J&D|0,(r|v)^(p|E)^(s|l)|0,H^(o|C)|0)|0;H=C;I=Dd(G|0,I|0,y|0,u|0)|0;G=C;u=Dd(o|0,H|0,y|0,u|0)|0;y=C;H=Gd(I|0,G|0,14)|0;o=C;l=Hd(I|0,G|0,50)|0;o=o|C;s=Gd(I|0,G|0,18)|0;E=C;p=Hd(I|0,G|0,46)|0;E=o^(E|C);o=Gd(I|0,G|0,41)|0;v=C;r=Hd(I|0,G|0,23)|0;v=E^(v|C);E=g+128|0;m=c[E>>2]|0;E=c[E+4>>2]|0;f=Dd(j|0,f|0,-1628353838,-459576895)|0;E=Dd(f|0,C|0,m|0,E|0)|0;v=Dd(E|0,C|0,(H|l)^(s|p)^(o|r)|0,v|0)|0;v=Dd(v|0,C|0,(b^B)&I^b|0,(A^K)&G^A|0)|0;r=C;o=Gd(u|0,y|0,28)|0;p=C;s=Hd(u|0,y|0,36)|0;p=p|C;l=Gd(u|0,y|0,34)|0;H=C;E=Hd(u|0,y|0,30)|0;H=p^(H|C);p=Gd(u|0,y|0,39)|0;m=C;f=Hd(u|0,y|0,25)|0;m=Dd((L|x)&u|L&x|0,(D|F)&y|D&F|0,(o|s)^(l|E)^(p|f)|0,H^(m|C)|0)|0;H=C;J=Dd(M|0,J|0,v|0,r|0)|0;M=C;r=Dd(m|0,H|0,v|0,r|0)|0;v=C;H=Gd(J|0,M|0,14)|0;m=C;f=Hd(J|0,M|0,50)|0;m=m|C;p=Gd(J|0,M|0,18)|0;E=C;l=Hd(J|0,M|0,46)|0;E=m^(E|C);m=Gd(J|0,M|0,41)|0;s=C;o=Hd(J|0,M|0,23)|0;s=E^(s|C);E=g+136|0;j=c[E>>2]|0;E=c[E+4>>2]|0;A=Dd(b|0,A|0,944711139,-272742522)|0;E=Dd(A|0,C|0,j|0,E|0)|0;s=Dd(E|0,C|0,(H|f)^(p|l)^(m|o)|0,s|0)|0;s=Dd(s|0,C|0,(B^I)&J^B|0,(K^G)&M^K|0)|0;o=C;m=Gd(r|0,v|0,28)|0;l=C;p=Hd(r|0,v|0,36)|0;l=l|C;f=Gd(r|0,v|0,34)|0;H=C;E=Hd(r|0,v|0,30)|0;H=l^(H|C);l=Gd(r|0,v|0,39)|0;j=C;A=Hd(r|0,v|0,25)|0;j=Dd((x|u)&r|x&u|0,(F|y)&v|F&y|0,(m|p)^(f|E)^(l|A)|0,H^(j|C)|0)|0;H=C;D=Dd(L|0,D|0,s|0,o|0)|0;L=C;o=Dd(j|0,H|0,s|0,o|0)|0;s=C;H=Gd(D|0,L|0,14)|0;j=C;A=Hd(D|0,L|0,50)|0;j=j|C;l=Gd(D|0,L|0,18)|0;E=C;f=Hd(D|0,L|0,46)|0;E=j^(E|C);j=Gd(D|0,L|0,41)|0;p=C;m=Hd(D|0,L|0,23)|0;p=E^(p|C);E=g+144|0;b=c[E>>2]|0;E=c[E+4>>2]|0;K=Dd(B|0,K|0,-1953704523,264347078)|0;E=Dd(K|0,C|0,b|0,E|0)|0;p=Dd(E|0,C|0,(H|A)^(l|f)^(j|m)|0,p|0)|0;p=Dd(p|0,C|0,(I^J)&D^I|0,(G^M)&L^G|0)|0;m=C;j=Gd(o|0,s|0,28)|0;f=C;l=Hd(o|0,s|0,36)|0;f=f|C;A=Gd(o|0,s|0,34)|0;H=C;E=Hd(o|0,s|0,30)|0;H=f^(H|C);f=Gd(o|0,s|0,39)|0;b=C;K=Hd(o|0,s|0,25)|0;b=Dd((u|r)&o|u&r|0,(y|v)&s|y&v|0,(j|l)^(A|E)^(f|K)|0,H^(b|C)|0)|0;H=C;F=Dd(x|0,F|0,p|0,m|0)|0;x=C;m=Dd(b|0,H|0,p|0,m|0)|0;p=C;H=Gd(F|0,x|0,14)|0;b=C;K=Hd(F|0,x|0,50)|0;b=b|C;f=Gd(F|0,x|0,18)|0;E=C;A=Hd(F|0,x|0,46)|0;E=b^(E|C);b=Gd(F|0,x|0,41)|0;l=C;j=Hd(F|0,x|0,23)|0;l=E^(l|C);E=g+152|0;B=c[E>>2]|0;E=c[E+4>>2]|0;G=Dd(I|0,G|0,2007800933,604807628)|0;E=Dd(G|0,C|0,B|0,E|0)|0;l=Dd(E|0,C|0,(H|K)^(f|A)^(b|j)|0,l|0)|0;l=Dd(l|0,C|0,(J^D)&F^J|0,(M^L)&x^M|0)|0;j=C;b=Gd(m|0,p|0,28)|0;A=C;f=Hd(m|0,p|0,36)|0;A=A|C;K=Gd(m|0,p|0,34)|0;H=C;E=Hd(m|0,p|0,30)|0;H=A^(H|C);A=Gd(m|0,p|0,39)|0;B=C;G=Hd(m|0,p|0,25)|0;B=Dd((r|o)&m|r&o|0,(v|s)&p|v&s|0,(b|f)^(K|E)^(A|G)|0,H^(B|C)|0)|0;H=C;y=Dd(u|0,y|0,l|0,j|0)|0;u=C;j=Dd(B|0,H|0,l|0,j|0)|0;l=C;H=Gd(y|0,u|0,14)|0;B=C;G=Hd(y|0,u|0,50)|0;B=B|C;A=Gd(y|0,u|0,18)|0;E=C;K=Hd(y|0,u|0,46)|0;E=B^(E|C);B=Gd(y|0,u|0,41)|0;f=C;b=Hd(y|0,u|0,23)|0;f=E^(f|C);E=g+160|0;I=c[E>>2]|0;E=c[E+4>>2]|0;M=Dd(J|0,M|0,1495990901,770255983)|0;E=Dd(M|0,C|0,I|0,E|0)|0;f=Dd(E|0,C|0,(H|G)^(A|K)^(B|b)|0,f|0)|0;f=Dd(f|0,C|0,(D^F)&y^D|0,(L^x)&u^L|0)|0;b=C;B=Gd(j|0,l|0,28)|0;K=C;A=Hd(j|0,l|0,36)|0;K=K|C;G=Gd(j|0,l|0,34)|0;H=C;E=Hd(j|0,l|0,30)|0;H=K^(H|C);K=Gd(j|0,l|0,39)|0;I=C;M=Hd(j|0,l|0,25)|0;I=Dd((o|m)&j|o&m|0,(s|p)&l|s&p|0,(B|A)^(G|E)^(K|M)|0,H^(I|C)|0)|0;H=C;v=Dd(r|0,v|0,f|0,b|0)|0;r=C;b=Dd(I|0,H|0,f|0,b|0)|0;f=C;H=Gd(v|0,r|0,14)|0;I=C;M=Hd(v|0,r|0,50)|0;I=I|C;K=Gd(v|0,r|0,18)|0;E=C;G=Hd(v|0,r|0,46)|0;E=I^(E|C);I=Gd(v|0,r|0,41)|0;A=C;B=Hd(v|0,r|0,23)|0;A=E^(A|C);E=g+168|0;J=c[E>>2]|0;E=c[E+4>>2]|0;L=Dd(D|0,L|0,1856431235,1249150122)|0;E=Dd(L|0,C|0,J|0,E|0)|0;A=Dd(E|0,C|0,(H|M)^(K|G)^(I|B)|0,A|0)|0;A=Dd(A|0,C|0,(F^y)&v^F|0,(x^u)&r^x|0)|0;B=C;I=Gd(b|0,f|0,28)|0;G=C;K=Hd(b|0,f|0,36)|0;G=G|C;M=Gd(b|0,f|0,34)|0;H=C;E=Hd(b|0,f|0,30)|0;H=G^(H|C);G=Gd(b|0,f|0,39)|0;J=C;L=Hd(b|0,f|0,25)|0;J=Dd((m|j)&b|m&j|0,(p|l)&f|p&l|0,(I|K)^(M|E)^(G|L)|0,H^(J|C)|0)|0;H=C;s=Dd(o|0,s|0,A|0,B|0)|0;o=C;B=Dd(J|0,H|0,A|0,B|0)|0;A=C;H=Gd(s|0,o|0,14)|0;J=C;L=Hd(s|0,o|0,50)|0;J=J|C;G=Gd(s|0,o|0,18)|0;E=C;M=Hd(s|0,o|0,46)|0;E=J^(E|C);J=Gd(s|0,o|0,41)|0;K=C;I=Hd(s|0,o|0,23)|0;K=E^(K|C);E=g+176|0;D=c[E>>2]|0;E=c[E+4>>2]|0;x=Dd(F|0,x|0,-1119749164,1555081692)|0;E=Dd(x|0,C|0,D|0,E|0)|0;K=Dd(E|0,C|0,(H|L)^(G|M)^(J|I)|0,K|0)|0;K=Dd(K|0,C|0,(y^v)&s^y|0,(u^r)&o^u|0)|0;I=C;J=Gd(B|0,A|0,28)|0;M=C;G=Hd(B|0,A|0,36)|0;M=M|C;L=Gd(B|0,A|0,34)|0;H=C;E=Hd(B|0,A|0,30)|0;H=M^(H|C);M=Gd(B|0,A|0,39)|0;D=C;x=Hd(B|0,A|0,25)|0;D=Dd((j|b)&B|j&b|0,(l|f)&A|l&f|0,(J|G)^(L|E)^(M|x)|0,H^(D|C)|0)|0;H=C;p=Dd(m|0,p|0,K|0,I|0)|0;m=C;I=Dd(D|0,H|0,K|0,I|0)|0;K=C;H=Gd(p|0,m|0,14)|0;D=C;x=Hd(p|0,m|0,50)|0;D=D|C;M=Gd(p|0,m|0,18)|0;E=C;L=Hd(p|0,m|0,46)|0;E=D^(E|C);D=Gd(p|0,m|0,41)|0;G=C;J=Hd(p|0,m|0,23)|0;G=E^(G|C);E=g+184|0;F=c[E>>2]|0;E=c[E+4>>2]|0;u=Dd(y|0,u|0,-2096016459,1996064986)|0;E=Dd(u|0,C|0,F|0,E|0)|0;G=Dd(E|0,C|0,(H|x)^(M|L)^(D|J)|0,G|0)|0;G=Dd(G|0,C|0,(v^s)&p^v|0,(r^o)&m^r|0)|0;J=C;D=Gd(I|0,K|0,28)|0;L=C;M=Hd(I|0,K|0,36)|0;L=L|C;x=Gd(I|0,K|0,34)|0;H=C;E=Hd(I|0,K|0,30)|0;H=L^(H|C);L=Gd(I|0,K|0,39)|0;F=C;u=Hd(I|0,K|0,25)|0;F=Dd((b|B)&I|b&B|0,(f|A)&K|f&A|0,(D|M)^(x|E)^(L|u)|0,H^(F|C)|0)|0;H=C;l=Dd(j|0,l|0,G|0,J|0)|0;j=C;J=Dd(F|0,H|0,G|0,J|0)|0;G=C;H=Gd(l|0,j|0,14)|0;F=C;u=Hd(l|0,j|0,50)|0;F=F|C;L=Gd(l|0,j|0,18)|0;E=C;x=Hd(l|0,j|0,46)|0;E=F^(E|C);F=Gd(l|0,j|0,41)|0;M=C;D=Hd(l|0,j|0,23)|0;M=E^(M|C);E=g+192|0;y=c[E>>2]|0;E=c[E+4>>2]|0;r=Dd(v|0,r|0,-295247957,-1740746414)|0;E=Dd(r|0,C|0,y|0,E|0)|0;M=Dd(E|0,C|0,(H|u)^(L|x)^(F|D)|0,M|0)|0;M=Dd(M|0,C|0,(s^p)&l^s|0,(o^m)&j^o|0)|0;D=C;F=Gd(J|0,G|0,28)|0;x=C;L=Hd(J|0,G|0,36)|0;x=x|C;u=Gd(J|0,G|0,34)|0;H=C;E=Hd(J|0,G|0,30)|0;H=x^(H|C);x=Gd(J|0,G|0,39)|0;y=C;r=Hd(J|0,G|0,25)|0;y=Dd((B|I)&J|B&I|0,(A|K)&G|A&K|0,(F|L)^(u|E)^(x|r)|0,H^(y|C)|0)|0;H=C;f=Dd(b|0,f|0,M|0,D|0)|0;b=C;D=Dd(y|0,H|0,M|0,D|0)|0;M=C;H=Gd(f|0,b|0,14)|0;y=C;r=Hd(f|0,b|0,50)|0;y=y|C;x=Gd(f|0,b|0,18)|0;E=C;u=Hd(f|0,b|0,46)|0;E=y^(E|C);y=Gd(f|0,b|0,41)|0;L=C;F=Hd(f|0,b|0,23)|0;L=E^(L|C);E=g+200|0;v=c[E>>2]|0;E=c[E+4>>2]|0;o=Dd(s|0,o|0,766784016,-1473132947)|0;E=Dd(o|0,C|0,v|0,E|0)|0;L=Dd(E|0,C|0,(H|r)^(x|u)^(y|F)|0,L|0)|0;L=Dd(L|0,C|0,(p^l)&f^p|0,(m^j)&b^m|0)|0;F=C;y=Gd(D|0,M|0,28)|0;u=C;x=Hd(D|0,M|0,36)|0;u=u|C;r=Gd(D|0,M|0,34)|0;H=C;E=Hd(D|0,M|0,30)|0;H=u^(H|C);u=Gd(D|0,M|0,39)|0;v=C;o=Hd(D|0,M|0,25)|0;v=Dd((I|J)&D|I&J|0,(K|G)&M|K&G|0,(y|x)^(r|E)^(u|o)|0,H^(v|C)|0)|0;H=C;A=Dd(B|0,A|0,L|0,F|0)|0;B=C;F=Dd(v|0,H|0,L|0,F|0)|0;L=C;H=Gd(A|0,B|0,14)|0;v=C;o=Hd(A|0,B|0,50)|0;v=v|C;u=Gd(A|0,B|0,18)|0;E=C;r=Hd(A|0,B|0,46)|0;E=v^(E|C);v=Gd(A|0,B|0,41)|0;x=C;y=Hd(A|0,B|0,23)|0;x=E^(x|C);E=g+208|0;s=c[E>>2]|0;E=c[E+4>>2]|0;m=Dd(p|0,m|0,-1728372417,-1341970488)|0;E=Dd(m|0,C|0,s|0,E|0)|0;x=Dd(E|0,C|0,(H|o)^(u|r)^(v|y)|0,x|0)|0;x=Dd(x|0,C|0,(l^f)&A^l|0,(j^b)&B^j|0)|0;y=C;v=Gd(F|0,L|0,28)|0;r=C;u=Hd(F|0,L|0,36)|0;r=r|C;o=Gd(F|0,L|0,34)|0;H=C;E=Hd(F|0,L|0,30)|0;H=r^(H|C);r=Gd(F|0,L|0,39)|0;s=C;m=Hd(F|0,L|0,25)|0;s=Dd((J|D)&F|J&D|0,(G|M)&L|G&M|0,(v|u)^(o|E)^(r|m)|0,H^(s|C)|0)|0;H=C;K=Dd(I|0,K|0,x|0,y|0)|0;I=C;y=Dd(s|0,H|0,x|0,y|0)|0;x=C;H=Gd(K|0,I|0,14)|0;s=C;m=Hd(K|0,I|0,50)|0;s=s|C;r=Gd(K|0,I|0,18)|0;E=C;o=Hd(K|0,I|0,46)|0;E=s^(E|C);s=Gd(K|0,I|0,41)|0;u=C;v=Hd(K|0,I|0,23)|0;u=E^(u|C);E=g+216|0;p=c[E>>2]|0;E=c[E+4>>2]|0;j=Dd(l|0,j|0,-1091629340,-1084653625)|0;E=Dd(j|0,C|0,p|0,E|0)|0;u=Dd(E|0,C|0,(H|m)^(r|o)^(s|v)|0,u|0)|0;u=Dd(u|0,C|0,(f^A)&K^f|0,(b^B)&I^b|0)|0;v=C;s=Gd(y|0,x|0,28)|0;o=C;r=Hd(y|0,x|0,36)|0;o=o|C;m=Gd(y|0,x|0,34)|0;H=C;E=Hd(y|0,x|0,30)|0;H=o^(H|C);o=Gd(y|0,x|0,39)|0;p=C;j=Hd(y|0,x|0,25)|0;p=Dd((D|F)&y|D&F|0,(M|L)&x|M&L|0,(s|r)^(m|E)^(o|j)|0,H^(p|C)|0)|0;H=C;G=Dd(J|0,G|0,u|0,v|0)|0;J=C;v=Dd(p|0,H|0,u|0,v|0)|0;u=C;H=Gd(G|0,J|0,14)|0;p=C;j=Hd(G|0,J|0,50)|0;p=p|C;o=Gd(G|0,J|0,18)|0;E=C;m=Hd(G|0,J|0,46)|0;E=p^(E|C);p=Gd(G|0,J|0,41)|0;r=C;s=Hd(G|0,J|0,23)|0;r=E^(r|C);E=g+224|0;l=c[E>>2]|0;E=c[E+4>>2]|0;b=Dd(f|0,b|0,1034457026,-958395405)|0;E=Dd(b|0,C|0,l|0,E|0)|0;r=Dd(E|0,C|0,(H|j)^(o|m)^(p|s)|0,r|0)|0;r=Dd(r|0,C|0,(A^K)&G^A|0,(B^I)&J^B|0)|0;s=C;p=Gd(v|0,u|0,28)|0;m=C;o=Hd(v|0,u|0,36)|0;m=m|C;j=Gd(v|0,u|0,34)|0;H=C;E=Hd(v|0,u|0,30)|0;H=m^(H|C);m=Gd(v|0,u|0,39)|0;l=C;b=Hd(v|0,u|0,25)|0;l=Dd((F|y)&v|F&y|0,(L|x)&u|L&x|0,(p|o)^(j|E)^(m|b)|0,H^(l|C)|0)|0;H=C;M=Dd(D|0,M|0,r|0,s|0)|0;D=C;s=Dd(l|0,H|0,r|0,s|0)|0;r=C;H=Gd(M|0,D|0,14)|0;l=C;b=Hd(M|0,D|0,50)|0;l=l|C;m=Gd(M|0,D|0,18)|0;E=C;j=Hd(M|0,D|0,46)|0;E=l^(E|C);l=Gd(M|0,D|0,41)|0;o=C;p=Hd(M|0,D|0,23)|0;o=E^(o|C);E=g+232|0;f=c[E>>2]|0;E=c[E+4>>2]|0;B=Dd(A|0,B|0,-1828018395,-710438585)|0;E=Dd(B|0,C|0,f|0,E|0)|0;o=Dd(E|0,C|0,(H|b)^(m|j)^(l|p)|0,o|0)|0;o=Dd(o|0,C|0,(K^G)&M^K|0,(I^J)&D^I|0)|0;p=C;l=Gd(s|0,r|0,28)|0;j=C;m=Hd(s|0,r|0,36)|0;j=j|C;b=Gd(s|0,r|0,34)|0;H=C;E=Hd(s|0,r|0,30)|0;H=j^(H|C);j=Gd(s|0,r|0,39)|0;f=C;B=Hd(s|0,r|0,25)|0;f=Dd((y|v)&s|y&v|0,(x|u)&r|x&u|0,(l|m)^(b|E)^(j|B)|0,H^(f|C)|0)|0;H=C;L=Dd(F|0,L|0,o|0,p|0)|0;F=C;p=Dd(f|0,H|0,o|0,p|0)|0;o=C;H=Gd(L|0,F|0,14)|0;f=C;B=Hd(L|0,F|0,50)|0;f=f|C;j=Gd(L|0,F|0,18)|0;E=C;b=Hd(L|0,F|0,46)|0;E=f^(E|C);f=Gd(L|0,F|0,41)|0;m=C;l=Hd(L|0,F|0,23)|0;m=E^(m|C);E=g+240|0;A=c[E>>2]|0;E=c[E+4>>2]|0;I=Dd(K|0,I|0,-536640913,113926993)|0;E=Dd(I|0,C|0,A|0,E|0)|0;m=Dd(E|0,C|0,(H|B)^(j|b)^(f|l)|0,m|0)|0;m=Dd(m|0,C|0,(G^M)&L^G|0,(J^D)&F^J|0)|0;l=C;f=Gd(p|0,o|0,28)|0;b=C;j=Hd(p|0,o|0,36)|0;b=b|C;B=Gd(p|0,o|0,34)|0;H=C;E=Hd(p|0,o|0,30)|0;H=b^(H|C);b=Gd(p|0,o|0,39)|0;A=C;I=Hd(p|0,o|0,25)|0;A=Dd((v|s)&p|v&s|0,(u|r)&o|u&r|0,(f|j)^(B|E)^(b|I)|0,H^(A|C)|0)|0;H=C;x=Dd(y|0,x|0,m|0,l|0)|0;y=C;l=Dd(A|0,H|0,m|0,l|0)|0;m=C;H=Gd(x|0,y|0,14)|0;A=C;I=Hd(x|0,y|0,50)|0;A=A|C;b=Gd(x|0,y|0,18)|0;E=C;B=Hd(x|0,y|0,46)|0;E=A^(E|C);A=Gd(x|0,y|0,41)|0;j=C;f=Hd(x|0,y|0,23)|0;j=E^(j|C);E=g+248|0;K=c[E>>2]|0;E=c[E+4>>2]|0;J=Dd(G|0,J|0,168717936,338241895)|0;E=Dd(J|0,C|0,K|0,E|0)|0;j=Dd(E|0,C|0,(H|I)^(b|B)^(A|f)|0,j|0)|0;j=Dd(j|0,C|0,(M^L)&x^M|0,(D^F)&y^D|0)|0;f=C;A=Gd(l|0,m|0,28)|0;B=C;b=Hd(l|0,m|0,36)|0;B=B|C;I=Gd(l|0,m|0,34)|0;H=C;E=Hd(l|0,m|0,30)|0;H=B^(H|C);B=Gd(l|0,m|0,39)|0;K=C;J=Hd(l|0,m|0,25)|0;K=Dd((s|p)&l|s&p|0,(r|o)&m|r&o|0,(A|b)^(I|E)^(B|J)|0,H^(K|C)|0)|0;H=C;u=Dd(v|0,u|0,j|0,f|0)|0;v=C;f=Dd(K|0,H|0,j|0,f|0)|0;j=C;H=Gd(u|0,v|0,14)|0;K=C;J=Hd(u|0,v|0,50)|0;K=K|C;B=Gd(u|0,v|0,18)|0;E=C;I=Hd(u|0,v|0,46)|0;E=K^(E|C);K=Gd(u|0,v|0,41)|0;b=C;A=Hd(u|0,v|0,23)|0;b=E^(b|C);E=g+256|0;G=c[E>>2]|0;E=c[E+4>>2]|0;D=Dd(M|0,D|0,1188179964,666307205)|0;E=Dd(D|0,C|0,G|0,E|0)|0;b=Dd(E|0,C|0,(H|J)^(B|I)^(K|A)|0,b|0)|0;b=Dd(b|0,C|0,(L^x)&u^L|0,(F^y)&v^F|0)|0;A=C;K=Gd(f|0,j|0,28)|0;I=C;B=Hd(f|0,j|0,36)|0;I=I|C;J=Gd(f|0,j|0,34)|0;H=C;E=Hd(f|0,j|0,30)|0;H=I^(H|C);I=Gd(f|0,j|0,39)|0;G=C;D=Hd(f|0,j|0,25)|0;G=Dd((p|l)&f|p&l|0,(o|m)&j|o&m|0,(K|B)^(J|E)^(I|D)|0,H^(G|C)|0)|0;H=C;r=Dd(s|0,r|0,b|0,A|0)|0;s=C;A=Dd(G|0,H|0,b|0,A|0)|0;b=C;H=Gd(r|0,s|0,14)|0;G=C;D=Hd(r|0,s|0,50)|0;G=G|C;I=Gd(r|0,s|0,18)|0;E=C;J=Hd(r|0,s|0,46)|0;E=G^(E|C);G=Gd(r|0,s|0,41)|0;B=C;K=Hd(r|0,s|0,23)|0;B=E^(B|C);E=g+264|0;M=c[E>>2]|0;E=c[E+4>>2]|0;F=Dd(L|0,F|0,1546045734,773529912)|0;E=Dd(F|0,C|0,M|0,E|0)|0;B=Dd(E|0,C|0,(H|D)^(I|J)^(G|K)|0,B|0)|0;B=Dd(B|0,C|0,(x^u)&r^x|0,(y^v)&s^y|0)|0;K=C;G=Gd(A|0,b|0,28)|0;J=C;I=Hd(A|0,b|0,36)|0;J=J|C;D=Gd(A|0,b|0,34)|0;H=C;E=Hd(A|0,b|0,30)|0;H=J^(H|C);J=Gd(A|0,b|0,39)|0;M=C;F=Hd(A|0,b|0,25)|0;M=Dd((l|f)&A|l&f|0,(m|j)&b|m&j|0,(G|I)^(D|E)^(J|F)|0,H^(M|C)|0)|0;H=C;o=Dd(p|0,o|0,B|0,K|0)|0;p=C;K=Dd(M|0,H|0,B|0,K|0)|0;B=C;H=Gd(o|0,p|0,14)|0;M=C;F=Hd(o|0,p|0,50)|0;M=M|C;J=Gd(o|0,p|0,18)|0;E=C;D=Hd(o|0,p|0,46)|0;E=M^(E|C);M=Gd(o|0,p|0,41)|0;I=C;G=Hd(o|0,p|0,23)|0;I=E^(I|C);E=g+272|0;L=c[E>>2]|0;E=c[E+4>>2]|0;y=Dd(x|0,y|0,1522805485,1294757372)|0;E=Dd(y|0,C|0,L|0,E|0)|0;I=Dd(E|0,C|0,(H|F)^(J|D)^(M|G)|0,I|0)|0;I=Dd(I|0,C|0,(u^r)&o^u|0,(v^s)&p^v|0)|0;G=C;M=Gd(K|0,B|0,28)|0;D=C;J=Hd(K|0,B|0,36)|0;D=D|C;F=Gd(K|0,B|0,34)|0;H=C;E=Hd(K|0,B|0,30)|0;H=D^(H|C);D=Gd(K|0,B|0,39)|0;L=C;y=Hd(K|0,B|0,25)|0;L=Dd((f|A)&K|f&A|0,(j|b)&B|j&b|0,(M|J)^(F|E)^(D|y)|0,H^(L|C)|0)|0;H=C;m=Dd(l|0,m|0,I|0,G|0)|0;l=C;G=Dd(L|0,H|0,I|0,G|0)|0;I=C;H=Gd(m|0,l|0,14)|0;L=C;y=Hd(m|0,l|0,50)|0;L=L|C;D=Gd(m|0,l|0,18)|0;E=C;F=Hd(m|0,l|0,46)|0;E=L^(E|C);L=Gd(m|0,l|0,41)|0;J=C;M=Hd(m|0,l|0,23)|0;J=E^(J|C);E=g+280|0;x=c[E>>2]|0;E=c[E+4>>2]|0;v=Dd(u|0,v|0,-1651133473,1396182291)|0;E=Dd(v|0,C|0,x|0,E|0)|0;J=Dd(E|0,C|0,(H|y)^(D|F)^(L|M)|0,J|0)|0;J=Dd(J|0,C|0,(r^o)&m^r|0,(s^p)&l^s|0)|0;M=C;L=Gd(G|0,I|0,28)|0;F=C;D=Hd(G|0,I|0,36)|0;F=F|C;y=Gd(G|0,I|0,34)|0;H=C;E=Hd(G|0,I|0,30)|0;H=F^(H|C);F=Gd(G|0,I|0,39)|0;x=C;v=Hd(G|0,I|0,25)|0;x=Dd((A|K)&G|A&K|0,(b|B)&I|b&B|0,(L|D)^(y|E)^(F|v)|0,H^(x|C)|0)|0;H=C;j=Dd(f|0,j|0,J|0,M|0)|0;f=C;M=Dd(x|0,H|0,J|0,M|0)|0;J=C;H=Gd(j|0,f|0,14)|0;x=C;v=Hd(j|0,f|0,50)|0;x=x|C;F=Gd(j|0,f|0,18)|0;E=C;y=Hd(j|0,f|0,46)|0;E=x^(E|C);x=Gd(j|0,f|0,41)|0;D=C;L=Hd(j|0,f|0,23)|0;D=E^(D|C);E=g+288|0;u=c[E>>2]|0;E=c[E+4>>2]|0;s=Dd(r|0,s|0,-1951439906,1695183700)|0;E=Dd(s|0,C|0,u|0,E|0)|0;D=Dd(E|0,C|0,(H|v)^(F|y)^(x|L)|0,D|0)|0;D=Dd(D|0,C|0,(o^m)&j^o|0,(p^l)&f^p|0)|0;L=C;x=Gd(M|0,J|0,28)|0;y=C;F=Hd(M|0,J|0,36)|0;y=y|C;v=Gd(M|0,J|0,34)|0;H=C;E=Hd(M|0,J|0,30)|0;H=y^(H|C);y=Gd(M|0,J|0,39)|0;u=C;s=Hd(M|0,J|0,25)|0;u=Dd((K|G)&M|K&G|0,(B|I)&J|B&I|0,(x|F)^(v|E)^(y|s)|0,H^(u|C)|0)|0;H=C;b=Dd(A|0,b|0,D|0,L|0)|0;A=C;L=Dd(u|0,H|0,D|0,L|0)|0;D=C;H=Gd(b|0,A|0,14)|0;u=C;s=Hd(b|0,A|0,50)|0;u=u|C;y=Gd(b|0,A|0,18)|0;E=C;v=Hd(b|0,A|0,46)|0;E=u^(E|C);u=Gd(b|0,A|0,41)|0;F=C;x=Hd(b|0,A|0,23)|0;F=E^(F|C);E=g+296|0;r=c[E>>2]|0;E=c[E+4>>2]|0;p=Dd(o|0,p|0,1014477480,1986661051)|0;E=Dd(p|0,C|0,r|0,E|0)|0;F=Dd(E|0,C|0,(H|s)^(y|v)^(u|x)|0,F|0)|0;F=Dd(F|0,C|0,(m^j)&b^m|0,(l^f)&A^l|0)|0;x=C;u=Gd(L|0,D|0,28)|0;v=C;y=Hd(L|0,D|0,36)|0;v=v|C;s=Gd(L|0,D|0,34)|0;H=C;E=Hd(L|0,D|0,30)|0;H=v^(H|C);v=Gd(L|0,D|0,39)|0;r=C;p=Hd(L|0,D|0,25)|0;r=Dd((G|M)&L|G&M|0,(I|J)&D|I&J|0,(u|y)^(s|E)^(v|p)|0,H^(r|C)|0)|0;H=C;B=Dd(K|0,B|0,F|0,x|0)|0;K=C;x=Dd(r|0,H|0,F|0,x|0)|0;F=C;H=Gd(B|0,K|0,14)|0;r=C;p=Hd(B|0,K|0,50)|0;r=r|C;v=Gd(B|0,K|0,18)|0;E=C;s=Hd(B|0,K|0,46)|0;E=r^(E|C);r=Gd(B|0,K|0,41)|0;y=C;u=Hd(B|0,K|0,23)|0;y=E^(y|C);E=g+304|0;o=c[E>>2]|0;E=c[E+4>>2]|0;l=Dd(m|0,l|0,1206759142,-2117940946)|0;E=Dd(l|0,C|0,o|0,E|0)|0;y=Dd(E|0,C|0,(H|p)^(v|s)^(r|u)|0,y|0)|0;y=Dd(y|0,C|0,(j^b)&B^j|0,(f^A)&K^f|0)|0;u=C;r=Gd(x|0,F|0,28)|0;s=C;v=Hd(x|0,F|0,36)|0;s=s|C;p=Gd(x|0,F|0,34)|0;H=C;E=Hd(x|0,F|0,30)|0;H=s^(H|C);s=Gd(x|0,F|0,39)|0;o=C;l=Hd(x|0,F|0,25)|0;o=Dd((M|L)&x|M&L|0,(J|D)&F|J&D|0,(r|v)^(p|E)^(s|l)|0,H^(o|C)|0)|0;H=C;I=Dd(G|0,I|0,y|0,u|0)|0;G=C;u=Dd(o|0,H|0,y|0,u|0)|0;y=C;H=Gd(I|0,G|0,14)|0;o=C;l=Hd(I|0,G|0,50)|0;o=o|C;s=Gd(I|0,G|0,18)|0;E=C;p=Hd(I|0,G|0,46)|0;E=o^(E|C);o=Gd(I|0,G|0,41)|0;v=C;r=Hd(I|0,G|0,23)|0;v=E^(v|C);E=g+312|0;m=c[E>>2]|0;E=c[E+4>>2]|0;f=Dd(j|0,f|0,344077627,-1838011259)|0;E=Dd(f|0,C|0,m|0,E|0)|0;v=Dd(E|0,C|0,(H|l)^(s|p)^(o|r)|0,v|0)|0;v=Dd(v|0,C|0,(b^B)&I^b|0,(A^K)&G^A|0)|0;r=C;o=Gd(u|0,y|0,28)|0;p=C;s=Hd(u|0,y|0,36)|0;p=p|C;l=Gd(u|0,y|0,34)|0;H=C;E=Hd(u|0,y|0,30)|0;H=p^(H|C);p=Gd(u|0,y|0,39)|0;m=C;f=Hd(u|0,y|0,25)|0;m=Dd((L|x)&u|L&x|0,(D|F)&y|D&F|0,(o|s)^(l|E)^(p|f)|0,H^(m|C)|0)|0;H=C;J=Dd(M|0,J|0,v|0,r|0)|0;M=C;r=Dd(m|0,H|0,v|0,r|0)|0;v=C;H=Gd(J|0,M|0,14)|0;m=C;f=Hd(J|0,M|0,50)|0;m=m|C;p=Gd(J|0,M|0,18)|0;E=C;l=Hd(J|0,M|0,46)|0;E=m^(E|C);m=Gd(J|0,M|0,41)|0;s=C;o=Hd(J|0,M|0,23)|0;s=E^(s|C);E=g+320|0;j=c[E>>2]|0;E=c[E+4>>2]|0;A=Dd(b|0,A|0,1290863460,-1564481375)|0;E=Dd(A|0,C|0,j|0,E|0)|0;s=Dd(E|0,C|0,(H|f)^(p|l)^(m|o)|0,s|0)|0;s=Dd(s|0,C|0,(B^I)&J^B|0,(K^G)&M^K|0)|0;o=C;m=Gd(r|0,v|0,28)|0;l=C;p=Hd(r|0,v|0,36)|0;l=l|C;f=Gd(r|0,v|0,34)|0;H=C;E=Hd(r|0,v|0,30)|0;H=l^(H|C);l=Gd(r|0,v|0,39)|0;j=C;A=Hd(r|0,v|0,25)|0;j=Dd((x|u)&r|x&u|0,(F|y)&v|F&y|0,(m|p)^(f|E)^(l|A)|0,H^(j|C)|0)|0;H=C;D=Dd(L|0,D|0,s|0,o|0)|0;L=C;o=Dd(j|0,H|0,s|0,o|0)|0;s=C;H=Gd(D|0,L|0,14)|0;j=C;A=Hd(D|0,L|0,50)|0;j=j|C;l=Gd(D|0,L|0,18)|0;E=C;f=Hd(D|0,L|0,46)|0;E=j^(E|C);j=Gd(D|0,L|0,41)|0;p=C;m=Hd(D|0,L|0,23)|0;p=E^(p|C);E=g+328|0;b=c[E>>2]|0;E=c[E+4>>2]|0;K=Dd(B|0,K|0,-1136513023,-1474664885)|0;E=Dd(K|0,C|0,b|0,E|0)|0;p=Dd(E|0,C|0,(H|A)^(l|f)^(j|m)|0,p|0)|0;p=Dd(p|0,C|0,(I^J)&D^I|0,(G^M)&L^G|0)|0;m=C;j=Gd(o|0,s|0,28)|0;f=C;l=Hd(o|0,s|0,36)|0;f=f|C;A=Gd(o|0,s|0,34)|0;H=C;E=Hd(o|0,s|0,30)|0;H=f^(H|C);f=Gd(o|0,s|0,39)|0;b=C;K=Hd(o|0,s|0,25)|0;b=Dd((u|r)&o|u&r|0,(y|v)&s|y&v|0,(j|l)^(A|E)^(f|K)|0,H^(b|C)|0)|0;H=C;F=Dd(x|0,F|0,p|0,m|0)|0;x=C;m=Dd(b|0,H|0,p|0,m|0)|0;p=C;H=Gd(F|0,x|0,14)|0;b=C;K=Hd(F|0,x|0,50)|0;b=b|C;f=Gd(F|0,x|0,18)|0;E=C;A=Hd(F|0,x|0,46)|0;E=b^(E|C);b=Gd(F|0,x|0,41)|0;l=C;j=Hd(F|0,x|0,23)|0;l=E^(l|C);E=g+336|0;B=c[E>>2]|0;E=c[E+4>>2]|0;G=Dd(I|0,G|0,-789014639,-1035236496)|0;E=Dd(G|0,C|0,B|0,E|0)|0;l=Dd(E|0,C|0,(H|K)^(f|A)^(b|j)|0,l|0)|0;l=Dd(l|0,C|0,(J^D)&F^J|0,(M^L)&x^M|0)|0;j=C;b=Gd(m|0,p|0,28)|0;A=C;f=Hd(m|0,p|0,36)|0;A=A|C;K=Gd(m|0,p|0,34)|0;H=C;E=Hd(m|0,p|0,30)|0;H=A^(H|C);A=Gd(m|0,p|0,39)|0;B=C;G=Hd(m|0,p|0,25)|0;B=Dd((r|o)&m|r&o|0,(v|s)&p|v&s|0,(b|f)^(K|E)^(A|G)|0,H^(B|C)|0)|0;H=C;y=Dd(u|0,y|0,l|0,j|0)|0;u=C;j=Dd(B|0,H|0,l|0,j|0)|0;l=C;H=Gd(y|0,u|0,14)|0;B=C;G=Hd(y|0,u|0,50)|0;B=B|C;A=Gd(y|0,u|0,18)|0;E=C;K=Hd(y|0,u|0,46)|0;E=B^(E|C);B=Gd(y|0,u|0,41)|0;f=C;b=Hd(y|0,u|0,23)|0;f=E^(f|C);E=g+344|0;I=c[E>>2]|0;E=c[E+4>>2]|0;M=Dd(J|0,M|0,106217008,-949202525)|0;E=Dd(M|0,C|0,I|0,E|0)|0;f=Dd(E|0,C|0,(H|G)^(A|K)^(B|b)|0,f|0)|0;f=Dd(f|0,C|0,(D^F)&y^D|0,(L^x)&u^L|0)|0;b=C;B=Gd(j|0,l|0,28)|0;K=C;A=Hd(j|0,l|0,36)|0;K=K|C;G=Gd(j|0,l|0,34)|0;H=C;E=Hd(j|0,l|0,30)|0;H=K^(H|C);K=Gd(j|0,l|0,39)|0;I=C;M=Hd(j|0,l|0,25)|0;I=Dd((o|m)&j|o&m|0,(s|p)&l|s&p|0,(B|A)^(G|E)^(K|M)|0,H^(I|C)|0)|0;H=C;v=Dd(r|0,v|0,f|0,b|0)|0;r=C;b=Dd(I|0,H|0,f|0,b|0)|0;f=C;H=Gd(v|0,r|0,14)|0;I=C;M=Hd(v|0,r|0,50)|0;I=I|C;K=Gd(v|0,r|0,18)|0;E=C;G=Hd(v|0,r|0,46)|0;E=I^(E|C);I=Gd(v|0,r|0,41)|0;A=C;B=Hd(v|0,r|0,23)|0;A=E^(A|C);E=g+352|0;J=c[E>>2]|0;E=c[E+4>>2]|0;L=Dd(D|0,L|0,-688958952,-778901479)|0;E=Dd(L|0,C|0,J|0,E|0)|0;A=Dd(E|0,C|0,(H|M)^(K|G)^(I|B)|0,A|0)|0;A=Dd(A|0,C|0,(F^y)&v^F|0,(x^u)&r^x|0)|0;B=C;I=Gd(b|0,f|0,28)|0;G=C;K=Hd(b|0,f|0,36)|0;G=G|C;M=Gd(b|0,f|0,34)|0;H=C;E=Hd(b|0,f|0,30)|0;H=G^(H|C);G=Gd(b|0,f|0,39)|0;J=C;L=Hd(b|0,f|0,25)|0;J=Dd((m|j)&b|m&j|0,(p|l)&f|p&l|0,(I|K)^(M|E)^(G|L)|0,H^(J|C)|0)|0;H=C;s=Dd(o|0,s|0,A|0,B|0)|0;o=C;B=Dd(J|0,H|0,A|0,B|0)|0;A=C;H=Gd(s|0,o|0,14)|0;J=C;L=Hd(s|0,o|0,50)|0;J=J|C;G=Gd(s|0,o|0,18)|0;E=C;M=Hd(s|0,o|0,46)|0;E=J^(E|C);J=Gd(s|0,o|0,41)|0;K=C;I=Hd(s|0,o|0,23)|0;K=E^(K|C);E=g+360|0;D=c[E>>2]|0;E=c[E+4>>2]|0;x=Dd(F|0,x|0,1432725776,-694614492)|0;E=Dd(x|0,C|0,D|0,E|0)|0;K=Dd(E|0,C|0,(H|L)^(G|M)^(J|I)|0,K|0)|0;K=Dd(K|0,C|0,(y^v)&s^y|0,(u^r)&o^u|0)|0;I=C;J=Gd(B|0,A|0,28)|0;M=C;G=Hd(B|0,A|0,36)|0;M=M|C;L=Gd(B|0,A|0,34)|0;H=C;E=Hd(B|0,A|0,30)|0;H=M^(H|C);M=Gd(B|0,A|0,39)|0;D=C;x=Hd(B|0,A|0,25)|0;D=Dd((j|b)&B|j&b|0,(l|f)&A|l&f|0,(J|G)^(L|E)^(M|x)|0,H^(D|C)|0)|0;H=C;p=Dd(m|0,p|0,K|0,I|0)|0;m=C;I=Dd(D|0,H|0,K|0,I|0)|0;K=C;H=Gd(p|0,m|0,14)|0;D=C;x=Hd(p|0,m|0,50)|0;D=D|C;M=Gd(p|0,m|0,18)|0;E=C;L=Hd(p|0,m|0,46)|0;E=D^(E|C);D=Gd(p|0,m|0,41)|0;G=C;J=Hd(p|0,m|0,23)|0;G=E^(G|C);E=g+368|0;F=c[E>>2]|0;E=c[E+4>>2]|0;u=Dd(y|0,u|0,1467031594,-200395387)|0;E=Dd(u|0,C|0,F|0,E|0)|0;G=Dd(E|0,C|0,(H|x)^(M|L)^(D|J)|0,G|0)|0;G=Dd(G|0,C|0,(v^s)&p^v|0,(r^o)&m^r|0)|0;J=C;D=Gd(I|0,K|0,28)|0;L=C;M=Hd(I|0,K|0,36)|0;L=L|C;x=Gd(I|0,K|0,34)|0;H=C;E=Hd(I|0,K|0,30)|0;H=L^(H|C);L=Gd(I|0,K|0,39)|0;F=C;u=Hd(I|0,K|0,25)|0;F=Dd((b|B)&I|b&B|0,(f|A)&K|f&A|0,(D|M)^(x|E)^(L|u)|0,H^(F|C)|0)|0;H=C;l=Dd(j|0,l|0,G|0,J|0)|0;j=C;J=Dd(F|0,H|0,G|0,J|0)|0;G=C;H=Gd(l|0,j|0,14)|0;F=C;u=Hd(l|0,j|0,50)|0;F=F|C;L=Gd(l|0,j|0,18)|0;E=C;x=Hd(l|0,j|0,46)|0;E=F^(E|C);F=Gd(l|0,j|0,41)|0;M=C;D=Hd(l|0,j|0,23)|0;M=E^(M|C);E=g+376|0;y=c[E>>2]|0;E=c[E+4>>2]|0;r=Dd(v|0,r|0,851169720,275423344)|0;E=Dd(r|0,C|0,y|0,E|0)|0;M=Dd(E|0,C|0,(H|u)^(L|x)^(F|D)|0,M|0)|0;M=Dd(M|0,C|0,(s^p)&l^s|0,(o^m)&j^o|0)|0;D=C;F=Gd(J|0,G|0,28)|0;x=C;L=Hd(J|0,G|0,36)|0;x=x|C;u=Gd(J|0,G|0,34)|0;H=C;E=Hd(J|0,G|0,30)|0;H=x^(H|C);x=Gd(J|0,G|0,39)|0;y=C;r=Hd(J|0,G|0,25)|0;y=Dd((B|I)&J|B&I|0,(A|K)&G|A&K|0,(F|L)^(u|E)^(x|r)|0,H^(y|C)|0)|0;H=C;f=Dd(b|0,f|0,M|0,D|0)|0;b=C;D=Dd(y|0,H|0,M|0,D|0)|0;M=C;H=Gd(f|0,b|0,14)|0;y=C;r=Hd(f|0,b|0,50)|0;y=y|C;x=Gd(f|0,b|0,18)|0;E=C;u=Hd(f|0,b|0,46)|0;E=y^(E|C);y=Gd(f|0,b|0,41)|0;L=C;F=Hd(f|0,b|0,23)|0;L=E^(L|C);E=g+384|0;v=c[E>>2]|0;E=c[E+4>>2]|0;o=Dd(s|0,o|0,-1194143544,430227734)|0;E=Dd(o|0,C|0,v|0,E|0)|0;L=Dd(E|0,C|0,(H|r)^(x|u)^(y|F)|0,L|0)|0;L=Dd(L|0,C|0,(p^l)&f^p|0,(m^j)&b^m|0)|0;F=C;y=Gd(D|0,M|0,28)|0;u=C;x=Hd(D|0,M|0,36)|0;u=u|C;r=Gd(D|0,M|0,34)|0;H=C;E=Hd(D|0,M|0,30)|0;H=u^(H|C);u=Gd(D|0,M|0,39)|0;v=C;o=Hd(D|0,M|0,25)|0;v=Dd((I|J)&D|I&J|0,(K|G)&M|K&G|0,(y|x)^(r|E)^(u|o)|0,H^(v|C)|0)|0;H=C;A=Dd(B|0,A|0,L|0,F|0)|0;B=C;F=Dd(v|0,H|0,L|0,F|0)|0;L=C;H=Gd(A|0,B|0,14)|0;v=C;o=Hd(A|0,B|0,50)|0;v=v|C;u=Gd(A|0,B|0,18)|0;E=C;r=Hd(A|0,B|0,46)|0;E=v^(E|C);v=Gd(A|0,B|0,41)|0;x=C;y=Hd(A|0,B|0,23)|0;x=E^(x|C);E=g+392|0;s=c[E>>2]|0;E=c[E+4>>2]|0;m=Dd(p|0,m|0,1363258195,506948616)|0;E=Dd(m|0,C|0,s|0,E|0)|0;x=Dd(E|0,C|0,(H|o)^(u|r)^(v|y)|0,x|0)|0;x=Dd(x|0,C|0,(l^f)&A^l|0,(j^b)&B^j|0)|0;y=C;v=Gd(F|0,L|0,28)|0;r=C;u=Hd(F|0,L|0,36)|0;r=r|C;o=Gd(F|0,L|0,34)|0;H=C;E=Hd(F|0,L|0,30)|0;H=r^(H|C);r=Gd(F|0,L|0,39)|0;s=C;m=Hd(F|0,L|0,25)|0;s=Dd((J|D)&F|J&D|0,(G|M)&L|G&M|0,(v|u)^(o|E)^(r|m)|0,H^(s|C)|0)|0;H=C;K=Dd(I|0,K|0,x|0,y|0)|0;I=C;y=Dd(s|0,H|0,x|0,y|0)|0;x=C;H=Gd(K|0,I|0,14)|0;s=C;m=Hd(K|0,I|0,50)|0;s=s|C;r=Gd(K|0,I|0,18)|0;E=C;o=Hd(K|0,I|0,46)|0;E=s^(E|C);s=Gd(K|0,I|0,41)|0;u=C;v=Hd(K|0,I|0,23)|0;u=E^(u|C);E=g+400|0;p=c[E>>2]|0;E=c[E+4>>2]|0;j=Dd(l|0,j|0,-544281703,659060556)|0;E=Dd(j|0,C|0,p|0,E|0)|0;u=Dd(E|0,C|0,(H|m)^(r|o)^(s|v)|0,u|0)|0;u=Dd(u|0,C|0,(f^A)&K^f|0,(b^B)&I^b|0)|0;v=C;s=Gd(y|0,x|0,28)|0;o=C;r=Hd(y|0,x|0,36)|0;o=o|C;m=Gd(y|0,x|0,34)|0;H=C;E=Hd(y|0,x|0,30)|0;H=o^(H|C);o=Gd(y|0,x|0,39)|0;p=C;j=Hd(y|0,x|0,25)|0;p=Dd((D|F)&y|D&F|0,(M|L)&x|M&L|0,(s|r)^(m|E)^(o|j)|0,H^(p|C)|0)|0;H=C;G=Dd(J|0,G|0,u|0,v|0)|0;J=C;v=Dd(p|0,H|0,u|0,v|0)|0;u=C;H=Gd(G|0,J|0,14)|0;p=C;j=Hd(G|0,J|0,50)|0;p=p|C;o=Gd(G|0,J|0,18)|0;E=C;m=Hd(G|0,J|0,46)|0;E=p^(E|C);p=Gd(G|0,J|0,41)|0;r=C;s=Hd(G|0,J|0,23)|0;r=E^(r|C);E=g+408|0;l=c[E>>2]|0;E=c[E+4>>2]|0;b=Dd(f|0,b|0,-509917016,883997877)|0;E=Dd(b|0,C|0,l|0,E|0)|0;r=Dd(E|0,C|0,(H|j)^(o|m)^(p|s)|0,r|0)|0;r=Dd(r|0,C|0,(A^K)&G^A|0,(B^I)&J^B|0)|0;s=C;p=Gd(v|0,u|0,28)|0;m=C;o=Hd(v|0,u|0,36)|0;m=m|C;j=Gd(v|0,u|0,34)|0;H=C;E=Hd(v|0,u|0,30)|0;H=m^(H|C);m=Gd(v|0,u|0,39)|0;l=C;b=Hd(v|0,u|0,25)|0;l=Dd((F|y)&v|F&y|0,(L|x)&u|L&x|0,(p|o)^(j|E)^(m|b)|0,H^(l|C)|0)|0;H=C;M=Dd(D|0,M|0,r|0,s|0)|0;D=C;s=Dd(l|0,H|0,r|0,s|0)|0;r=C;H=Gd(M|0,D|0,14)|0;l=C;b=Hd(M|0,D|0,50)|0;l=l|C;m=Gd(M|0,D|0,18)|0;E=C;j=Hd(M|0,D|0,46)|0;E=l^(E|C);l=Gd(M|0,D|0,41)|0;o=C;p=Hd(M|0,D|0,23)|0;o=E^(o|C);E=g+416|0;f=c[E>>2]|0;E=c[E+4>>2]|0;B=Dd(A|0,B|0,-976659869,958139571)|0;E=Dd(B|0,C|0,f|0,E|0)|0;o=Dd(E|0,C|0,(H|b)^(m|j)^(l|p)|0,o|0)|0;o=Dd(o|0,C|0,(K^G)&M^K|0,(I^J)&D^I|0)|0;p=C;l=Gd(s|0,r|0,28)|0;j=C;m=Hd(s|0,r|0,36)|0;j=j|C;b=Gd(s|0,r|0,34)|0;H=C;E=Hd(s|0,r|0,30)|0;H=j^(H|C);j=Gd(s|0,r|0,39)|0;f=C;B=Hd(s|0,r|0,25)|0;f=Dd((y|v)&s|y&v|0,(x|u)&r|x&u|0,(l|m)^(b|E)^(j|B)|0,H^(f|C)|0)|0;H=C;L=Dd(F|0,L|0,o|0,p|0)|0;F=C;p=Dd(f|0,H|0,o|0,p|0)|0;o=C;H=Gd(L|0,F|0,14)|0;f=C;B=Hd(L|0,F|0,50)|0;f=f|C;j=Gd(L|0,F|0,18)|0;E=C;b=Hd(L|0,F|0,46)|0;E=f^(E|C);f=Gd(L|0,F|0,41)|0;m=C;l=Hd(L|0,F|0,23)|0;m=E^(m|C);E=g+424|0;A=c[E>>2]|0;E=c[E+4>>2]|0;I=Dd(K|0,I|0,-482243893,1322822218)|0;E=Dd(I|0,C|0,A|0,E|0)|0;m=Dd(E|0,C|0,(H|B)^(j|b)^(f|l)|0,m|0)|0;m=Dd(m|0,C|0,(G^M)&L^G|0,(J^D)&F^J|0)|0;l=C;f=Gd(p|0,o|0,28)|0;b=C;j=Hd(p|0,o|0,36)|0;b=b|C;B=Gd(p|0,o|0,34)|0;H=C;E=Hd(p|0,o|0,30)|0;H=b^(H|C);b=Gd(p|0,o|0,39)|0;A=C;I=Hd(p|0,o|0,25)|0;A=Dd((v|s)&p|v&s|0,(u|r)&o|u&r|0,(f|j)^(B|E)^(b|I)|0,H^(A|C)|0)|0;H=C;x=Dd(y|0,x|0,m|0,l|0)|0;y=C;l=Dd(A|0,H|0,m|0,l|0)|0;m=C;H=Gd(x|0,y|0,14)|0;A=C;I=Hd(x|0,y|0,50)|0;A=A|C;b=Gd(x|0,y|0,18)|0;E=C;B=Hd(x|0,y|0,46)|0;E=A^(E|C);A=Gd(x|0,y|0,41)|0;j=C;f=Hd(x|0,y|0,23)|0;j=E^(j|C);E=g+432|0;K=c[E>>2]|0;E=c[E+4>>2]|0;J=Dd(G|0,J|0,2003034995,1537002063)|0;E=Dd(J|0,C|0,K|0,E|0)|0;j=Dd(E|0,C|0,(H|I)^(b|B)^(A|f)|0,j|0)|0;j=Dd(j|0,C|0,(M^L)&x^M|0,(D^F)&y^D|0)|0;f=C;A=Gd(l|0,m|0,28)|0;B=C;b=Hd(l|0,m|0,36)|0;B=B|C;I=Gd(l|0,m|0,34)|0;H=C;E=Hd(l|0,m|0,30)|0;H=B^(H|C);B=Gd(l|0,m|0,39)|0;K=C;J=Hd(l|0,m|0,25)|0;K=Dd((s|p)&l|s&p|0,(r|o)&m|r&o|0,(A|b)^(I|E)^(B|J)|0,H^(K|C)|0)|0;H=C;u=Dd(v|0,u|0,j|0,f|0)|0;v=C;f=Dd(K|0,H|0,j|0,f|0)|0;j=C;H=Gd(u|0,v|0,14)|0;K=C;J=Hd(u|0,v|0,50)|0;K=K|C;B=Gd(u|0,v|0,18)|0;E=C;I=Hd(u|0,v|0,46)|0;E=K^(E|C);K=Gd(u|0,v|0,41)|0;b=C;A=Hd(u|0,v|0,23)|0;b=E^(b|C);E=g+440|0;G=c[E>>2]|0;E=c[E+4>>2]|0;D=Dd(M|0,D|0,-692930397,1747873779)|0;E=Dd(D|0,C|0,G|0,E|0)|0;b=Dd(E|0,C|0,(H|J)^(B|I)^(K|A)|0,b|0)|0;b=Dd(b|0,C|0,(L^x)&u^L|0,(F^y)&v^F|0)|0;A=C;K=Gd(f|0,j|0,28)|0;I=C;B=Hd(f|0,j|0,36)|0;I=I|C;J=Gd(f|0,j|0,34)|0;H=C;E=Hd(f|0,j|0,30)|0;H=I^(H|C);I=Gd(f|0,j|0,39)|0;G=C;D=Hd(f|0,j|0,25)|0;G=Dd((p|l)&f|p&l|0,(o|m)&j|o&m|0,(K|B)^(J|E)^(I|D)|0,H^(G|C)|0)|0;H=C;r=Dd(s|0,r|0,b|0,A|0)|0;s=C;A=Dd(G|0,H|0,b|0,A|0)|0;b=C;H=Gd(r|0,s|0,14)|0;G=C;D=Hd(r|0,s|0,50)|0;G=G|C;I=Gd(r|0,s|0,18)|0;E=C;J=Hd(r|0,s|0,46)|0;E=G^(E|C);G=Gd(r|0,s|0,41)|0;B=C;K=Hd(r|0,s|0,23)|0;B=E^(B|C);E=g+448|0;M=c[E>>2]|0;E=c[E+4>>2]|0;F=Dd(L|0,F|0,1575990012,1955562222)|0;E=Dd(F|0,C|0,M|0,E|0)|0;B=Dd(E|0,C|0,(H|D)^(I|J)^(G|K)|0,B|0)|0;B=Dd(B|0,C|0,(x^u)&r^x|0,(y^v)&s^y|0)|0;K=C;G=Gd(A|0,b|0,28)|0;J=C;I=Hd(A|0,b|0,36)|0;J=J|C;D=Gd(A|0,b|0,34)|0;H=C;E=Hd(A|0,b|0,30)|0;H=J^(H|C);J=Gd(A|0,b|0,39)|0;M=C;F=Hd(A|0,b|0,25)|0;M=Dd((l|f)&A|l&f|0,(m|j)&b|m&j|0,(G|I)^(D|E)^(J|F)|0,H^(M|C)|0)|0;H=C;o=Dd(p|0,o|0,B|0,K|0)|0;p=C;K=Dd(M|0,H|0,B|0,K|0)|0;B=C;H=Gd(o|0,p|0,14)|0;M=C;F=Hd(o|0,p|0,50)|0;M=M|C;J=Gd(o|0,p|0,18)|0;E=C;D=Hd(o|0,p|0,46)|0;E=M^(E|C);M=Gd(o|0,p|0,41)|0;I=C;G=Hd(o|0,p|0,23)|0;I=E^(I|C);E=g+456|0;L=c[E>>2]|0;E=c[E+4>>2]|0;y=Dd(x|0,y|0,1125592928,2024104815)|0;E=Dd(y|0,C|0,L|0,E|0)|0;I=Dd(E|0,C|0,(H|F)^(J|D)^(M|G)|0,I|0)|0;I=Dd(I|0,C|0,(u^r)&o^u|0,(v^s)&p^v|0)|0;G=C;M=Gd(K|0,B|0,28)|0;D=C;J=Hd(K|0,B|0,36)|0;D=D|C;F=Gd(K|0,B|0,34)|0;H=C;E=Hd(K|0,B|0,30)|0;H=D^(H|C);D=Gd(K|0,B|0,39)|0;L=C;y=Hd(K|0,B|0,25)|0;L=Dd((f|A)&K|f&A|0,(j|b)&B|j&b|0,(M|J)^(F|E)^(D|y)|0,H^(L|C)|0)|0;H=C;m=Dd(l|0,m|0,I|0,G|0)|0;l=C;G=Dd(L|0,H|0,I|0,G|0)|0;I=C;H=Gd(m|0,l|0,14)|0;L=C;y=Hd(m|0,l|0,50)|0;L=L|C;D=Gd(m|0,l|0,18)|0;E=C;F=Hd(m|0,l|0,46)|0;E=L^(E|C);L=Gd(m|0,l|0,41)|0;J=C;M=Hd(m|0,l|0,23)|0;J=E^(J|C);E=g+464|0;x=c[E>>2]|0;E=c[E+4>>2]|0;v=Dd(u|0,v|0,-1578062990,-2067236844)|0;E=Dd(v|0,C|0,x|0,E|0)|0;J=Dd(E|0,C|0,(H|y)^(D|F)^(L|M)|0,J|0)|0;J=Dd(J|0,C|0,(r^o)&m^r|0,(s^p)&l^s|0)|0;M=C;L=Gd(G|0,I|0,28)|0;F=C;D=Hd(G|0,I|0,36)|0;F=F|C;y=Gd(G|0,I|0,34)|0;H=C;E=Hd(G|0,I|0,30)|0;H=F^(H|C);F=Gd(G|0,I|0,39)|0;x=C;v=Hd(G|0,I|0,25)|0;x=Dd((A|K)&G|A&K|0,(b|B)&I|b&B|0,(L|D)^(y|E)^(F|v)|0,H^(x|C)|0)|0;H=C;j=Dd(f|0,j|0,J|0,M|0)|0;f=C;M=Dd(x|0,H|0,J|0,M|0)|0;J=C;H=Gd(j|0,f|0,14)|0;x=C;v=Hd(j|0,f|0,50)|0;x=x|C;F=Gd(j|0,f|0,18)|0;E=C;y=Hd(j|0,f|0,46)|0;E=x^(E|C);x=Gd(j|0,f|0,41)|0;D=C;L=Hd(j|0,f|0,23)|0;D=E^(D|C);E=g+472|0;u=c[E>>2]|0;E=c[E+4>>2]|0;s=Dd(r|0,s|0,442776044,-1933114872)|0;E=Dd(s|0,C|0,u|0,E|0)|0;D=Dd(E|0,C|0,(H|v)^(F|y)^(x|L)|0,D|0)|0;D=Dd(D|0,C|0,(o^m)&j^o|0,(p^l)&f^p|0)|0;L=C;x=Gd(M|0,J|0,28)|0;y=C;F=Hd(M|0,J|0,36)|0;y=y|C;v=Gd(M|0,J|0,34)|0;H=C;E=Hd(M|0,J|0,30)|0;H=y^(H|C);y=Gd(M|0,J|0,39)|0;u=C;s=Hd(M|0,J|0,25)|0;u=Dd((K|G)&M|K&G|0,(B|I)&J|B&I|0,(x|F)^(v|E)^(y|s)|0,H^(u|C)|0)|0;H=C;b=Dd(A|0,b|0,D|0,L|0)|0;A=C;L=Dd(u|0,H|0,D|0,L|0)|0;D=C;H=Gd(b|0,A|0,14)|0;u=C;s=Hd(b|0,A|0,50)|0;u=u|C;y=Gd(b|0,A|0,18)|0;E=C;v=Hd(b|0,A|0,46)|0;E=u^(E|C);u=Gd(b|0,A|0,41)|0;F=C;x=Hd(b|0,A|0,23)|0;F=E^(F|C);E=g+480|0;r=c[E>>2]|0;E=c[E+4>>2]|0;p=Dd(o|0,p|0,593698344,-1866530822)|0;E=Dd(p|0,C|0,r|0,E|0)|0;F=Dd(E|0,C|0,(H|s)^(y|v)^(u|x)|0,F|0)|0;F=Dd(F|0,C|0,(m^j)&b^m|0,(l^f)&A^l|0)|0;x=C;u=Gd(L|0,D|0,28)|0;v=C;y=Hd(L|0,D|0,36)|0;v=v|C;s=Gd(L|0,D|0,34)|0;H=C;E=Hd(L|0,D|0,30)|0;H=v^(H|C);v=Gd(L|0,D|0,39)|0;r=C;p=Hd(L|0,D|0,25)|0;r=Dd((G|M)&L|G&M|0,(I|J)&D|I&J|0,(u|y)^(s|E)^(v|p)|0,H^(r|C)|0)|0;H=C;B=Dd(K|0,B|0,F|0,x|0)|0;K=C;x=Dd(r|0,H|0,F|0,x|0)|0;F=C;H=Gd(B|0,K|0,14)|0;r=C;p=Hd(B|0,K|0,50)|0;r=r|C;v=Gd(B|0,K|0,18)|0;E=C;s=Hd(B|0,K|0,46)|0;E=r^(E|C);r=Gd(B|0,K|0,41)|0;y=C;u=Hd(B|0,K|0,23)|0;y=E^(y|C);E=g+488|0;o=c[E>>2]|0;E=c[E+4>>2]|0;l=Dd(m|0,l|0,-561857047,-1538233109)|0;E=Dd(l|0,C|0,o|0,E|0)|0;y=Dd(E|0,C|0,(H|p)^(v|s)^(r|u)|0,y|0)|0;y=Dd(y|0,C|0,(j^b)&B^j|0,(f^A)&K^f|0)|0;u=C;r=Gd(x|0,F|0,28)|0;s=C;v=Hd(x|0,F|0,36)|0;s=s|C;p=Gd(x|0,F|0,34)|0;H=C;E=Hd(x|0,F|0,30)|0;H=s^(H|C);s=Gd(x|0,F|0,39)|0;o=C;l=Hd(x|0,F|0,25)|0;o=Dd((M|L)&x|M&L|0,(J|D)&F|J&D|0,(r|v)^(p|E)^(s|l)|0,H^(o|C)|0)|0;H=C;I=Dd(G|0,I|0,y|0,u|0)|0;G=C;u=Dd(o|0,H|0,y|0,u|0)|0;y=C;H=Gd(I|0,G|0,14)|0;o=C;l=Hd(I|0,G|0,50)|0;o=o|C;s=Gd(I|0,G|0,18)|0;E=C;p=Hd(I|0,G|0,46)|0;E=o^(E|C);o=Gd(I|0,G|0,41)|0;v=C;r=Hd(I|0,G|0,23)|0;v=E^(v|C);E=g+496|0;m=c[E>>2]|0;E=c[E+4>>2]|0;f=Dd(j|0,f|0,-1295615723,-1090935817)|0;E=Dd(f|0,C|0,m|0,E|0)|0;v=Dd(E|0,C|0,(H|l)^(s|p)^(o|r)|0,v|0)|0;v=Dd(v|0,C|0,(b^B)&I^b|0,(A^K)&G^A|0)|0;r=C;o=Gd(u|0,y|0,28)|0;p=C;s=Hd(u|0,y|0,36)|0;p=p|C;l=Gd(u|0,y|0,34)|0;H=C;E=Hd(u|0,y|0,30)|0;H=p^(H|C);p=Gd(u|0,y|0,39)|0;m=C;f=Hd(u|0,y|0,25)|0;m=Dd((L|x)&u|L&x|0,(D|F)&y|D&F|0,(o|s)^(l|E)^(p|f)|0,H^(m|C)|0)|0;H=C;J=Dd(M|0,J|0,v|0,r|0)|0;M=C;r=Dd(m|0,H|0,v|0,r|0)|0;v=C;H=Gd(J|0,M|0,14)|0;m=C;f=Hd(J|0,M|0,50)|0;m=m|C;p=Gd(J|0,M|0,18)|0;E=C;l=Hd(J|0,M|0,46)|0;E=m^(E|C);m=Gd(J|0,M|0,41)|0;s=C;o=Hd(J|0,M|0,23)|0;s=E^(s|C);E=g+504|0;j=c[E>>2]|0;E=c[E+4>>2]|0;A=Dd(b|0,A|0,-479046869,-965641998)|0;E=Dd(A|0,C|0,j|0,E|0)|0;s=Dd(E|0,C|0,(H|f)^(p|l)^(m|o)|0,s|0)|0;s=Dd(s|0,C|0,(B^I)&J^B|0,(K^G)&M^K|0)|0;o=C;m=Gd(r|0,v|0,28)|0;l=C;p=Hd(r|0,v|0,36)|0;l=l|C;f=Gd(r|0,v|0,34)|0;H=C;E=Hd(r|0,v|0,30)|0;H=l^(H|C);l=Gd(r|0,v|0,39)|0;j=C;A=Hd(r|0,v|0,25)|0;j=Dd((x|u)&r|x&u|0,(F|y)&v|F&y|0,(m|p)^(f|E)^(l|A)|0,H^(j|C)|0)|0;H=C;D=Dd(L|0,D|0,s|0,o|0)|0;L=C;o=Dd(j|0,H|0,s|0,o|0)|0;s=C;H=Gd(D|0,L|0,14)|0;j=C;A=Hd(D|0,L|0,50)|0;j=j|C;l=Gd(D|0,L|0,18)|0;E=C;f=Hd(D|0,L|0,46)|0;E=j^(E|C);j=Gd(D|0,L|0,41)|0;p=C;m=Hd(D|0,L|0,23)|0;p=E^(p|C);E=g+512|0;b=c[E>>2]|0;E=c[E+4>>2]|0;K=Dd(B|0,K|0,-366583396,-903397682)|0;E=Dd(K|0,C|0,b|0,E|0)|0;p=Dd(E|0,C|0,(H|A)^(l|f)^(j|m)|0,p|0)|0;p=Dd(p|0,C|0,(I^J)&D^I|0,(G^M)&L^G|0)|0;m=C;j=Gd(o|0,s|0,28)|0;f=C;l=Hd(o|0,s|0,36)|0;f=f|C;A=Gd(o|0,s|0,34)|0;H=C;E=Hd(o|0,s|0,30)|0;H=f^(H|C);f=Gd(o|0,s|0,39)|0;b=C;K=Hd(o|0,s|0,25)|0;b=Dd((u|r)&o|u&r|0,(y|v)&s|y&v|0,(j|l)^(A|E)^(f|K)|0,H^(b|C)|0)|0;H=C;F=Dd(x|0,F|0,p|0,m|0)|0;x=C;m=Dd(b|0,H|0,p|0,m|0)|0;p=C;H=Gd(F|0,x|0,14)|0;b=C;K=Hd(F|0,x|0,50)|0;b=b|C;f=Gd(F|0,x|0,18)|0;E=C;A=Hd(F|0,x|0,46)|0;E=b^(E|C);b=Gd(F|0,x|0,41)|0;l=C;j=Hd(F|0,x|0,23)|0;l=E^(l|C);E=g+520|0;B=c[E>>2]|0;E=c[E+4>>2]|0;G=Dd(I|0,G|0,566280711,-779700025)|0;E=Dd(G|0,C|0,B|0,E|0)|0;l=Dd(E|0,C|0,(H|K)^(f|A)^(b|j)|0,l|0)|0;l=Dd(l|0,C|0,(J^D)&F^J|0,(M^L)&x^M|0)|0;j=C;b=Gd(m|0,p|0,28)|0;A=C;f=Hd(m|0,p|0,36)|0;A=A|C;K=Gd(m|0,p|0,34)|0;H=C;E=Hd(m|0,p|0,30)|0;H=A^(H|C);A=Gd(m|0,p|0,39)|0;B=C;G=Hd(m|0,p|0,25)|0;B=Dd((r|o)&m|r&o|0,(v|s)&p|v&s|0,(b|f)^(K|E)^(A|G)|0,H^(B|C)|0)|0;H=C;y=Dd(u|0,y|0,l|0,j|0)|0;u=C;j=Dd(B|0,H|0,l|0,j|0)|0;l=C;H=Gd(y|0,u|0,14)|0;B=C;G=Hd(y|0,u|0,50)|0;B=B|C;A=Gd(y|0,u|0,18)|0;E=C;K=Hd(y|0,u|0,46)|0;E=B^(E|C);B=Gd(y|0,u|0,41)|0;f=C;b=Hd(y|0,u|0,23)|0;f=E^(f|C);E=g+528|0;I=c[E>>2]|0;E=c[E+4>>2]|0;M=Dd(J|0,M|0,-840897762,-354779690)|0;E=Dd(M|0,C|0,I|0,E|0)|0;f=Dd(E|0,C|0,(H|G)^(A|K)^(B|b)|0,f|0)|0;f=Dd(f|0,C|0,(D^F)&y^D|0,(L^x)&u^L|0)|0;b=C;B=Gd(j|0,l|0,28)|0;K=C;A=Hd(j|0,l|0,36)|0;K=K|C;G=Gd(j|0,l|0,34)|0;H=C;E=Hd(j|0,l|0,30)|0;H=K^(H|C);K=Gd(j|0,l|0,39)|0;I=C;M=Hd(j|0,l|0,25)|0;I=Dd((o|m)&j|o&m|0,(s|p)&l|s&p|0,(B|A)^(G|E)^(K|M)|0,H^(I|C)|0)|0;H=C;v=Dd(r|0,v|0,f|0,b|0)|0;r=C;b=Dd(I|0,H|0,f|0,b|0)|0;f=C;H=Gd(v|0,r|0,14)|0;I=C;M=Hd(v|0,r|0,50)|0;I=I|C;K=Gd(v|0,r|0,18)|0;E=C;G=Hd(v|0,r|0,46)|0;E=I^(E|C);I=Gd(v|0,r|0,41)|0;A=C;B=Hd(v|0,r|0,23)|0;A=E^(A|C);E=g+536|0;J=c[E>>2]|0;E=c[E+4>>2]|0;L=Dd(D|0,L|0,-294727304,-176337025)|0;E=Dd(L|0,C|0,J|0,E|0)|0;A=Dd(E|0,C|0,(H|M)^(K|G)^(I|B)|0,A|0)|0;A=Dd(A|0,C|0,(F^y)&v^F|0,(x^u)&r^x|0)|0;B=C;I=Gd(b|0,f|0,28)|0;G=C;K=Hd(b|0,f|0,36)|0;G=G|C;M=Gd(b|0,f|0,34)|0;H=C;E=Hd(b|0,f|0,30)|0;H=G^(H|C);G=Gd(b|0,f|0,39)|0;J=C;L=Hd(b|0,f|0,25)|0;J=Dd((m|j)&b|m&j|0,(p|l)&f|p&l|0,(I|K)^(M|E)^(G|L)|0,H^(J|C)|0)|0;H=C;s=Dd(o|0,s|0,A|0,B|0)|0;o=C;B=Dd(J|0,H|0,A|0,B|0)|0;A=C;H=Gd(s|0,o|0,14)|0;J=C;L=Hd(s|0,o|0,50)|0;J=J|C;G=Gd(s|0,o|0,18)|0;E=C;M=Hd(s|0,o|0,46)|0;E=J^(E|C);J=Gd(s|0,o|0,41)|0;K=C;I=Hd(s|0,o|0,23)|0;K=E^(K|C);E=g+544|0;D=c[E>>2]|0;E=c[E+4>>2]|0;x=Dd(F|0,x|0,1914138554,116418474)|0;E=Dd(x|0,C|0,D|0,E|0)|0;K=Dd(E|0,C|0,(H|L)^(G|M)^(J|I)|0,K|0)|0;K=Dd(K|0,C|0,(y^v)&s^y|0,(u^r)&o^u|0)|0;I=C;J=Gd(B|0,A|0,28)|0;M=C;G=Hd(B|0,A|0,36)|0;M=M|C;L=Gd(B|0,A|0,34)|0;H=C;E=Hd(B|0,A|0,30)|0;H=M^(H|C);M=Gd(B|0,A|0,39)|0;D=C;x=Hd(B|0,A|0,25)|0;D=Dd((j|b)&B|j&b|0,(l|f)&A|l&f|0,(J|G)^(L|E)^(M|x)|0,H^(D|C)|0)|0;H=C;p=Dd(m|0,p|0,K|0,I|0)|0;m=C;I=Dd(D|0,H|0,K|0,I|0)|0;K=C;H=Gd(p|0,m|0,14)|0;D=C;x=Hd(p|0,m|0,50)|0;D=D|C;M=Gd(p|0,m|0,18)|0;E=C;L=Hd(p|0,m|0,46)|0;E=D^(E|C);D=Gd(p|0,m|0,41)|0;G=C;J=Hd(p|0,m|0,23)|0;G=E^(G|C);E=g+552|0;F=c[E>>2]|0;E=c[E+4>>2]|0;u=Dd(y|0,u|0,-1563912026,174292421)|0;E=Dd(u|0,C|0,F|0,E|0)|0;G=Dd(E|0,C|0,(H|x)^(M|L)^(D|J)|0,G|0)|0;G=Dd(G|0,C|0,(v^s)&p^v|0,(r^o)&m^r|0)|0;J=C;D=Gd(I|0,K|0,28)|0;L=C;M=Hd(I|0,K|0,36)|0;L=L|C;x=Gd(I|0,K|0,34)|0;H=C;E=Hd(I|0,K|0,30)|0;H=L^(H|C);L=Gd(I|0,K|0,39)|0;F=C;u=Hd(I|0,K|0,25)|0;F=Dd((b|B)&I|b&B|0,(f|A)&K|f&A|0,(D|M)^(x|E)^(L|u)|0,H^(F|C)|0)|0;H=C;l=Dd(j|0,l|0,G|0,J|0)|0;j=C;J=Dd(F|0,H|0,G|0,J|0)|0;G=C;H=Gd(l|0,j|0,14)|0;F=C;u=Hd(l|0,j|0,50)|0;F=F|C;L=Gd(l|0,j|0,18)|0;E=C;x=Hd(l|0,j|0,46)|0;E=F^(E|C);F=Gd(l|0,j|0,41)|0;M=C;D=Hd(l|0,j|0,23)|0;M=E^(M|C);E=g+560|0;y=c[E>>2]|0;E=c[E+4>>2]|0;r=Dd(v|0,r|0,-1090974290,289380356)|0;E=Dd(r|0,C|0,y|0,E|0)|0;M=Dd(E|0,C|0,(H|u)^(L|x)^(F|D)|0,M|0)|0;M=Dd(M|0,C|0,(s^p)&l^s|0,(o^m)&j^o|0)|0;D=C;F=Gd(J|0,G|0,28)|0;x=C;L=Hd(J|0,G|0,36)|0;x=x|C;u=Gd(J|0,G|0,34)|0;H=C;E=Hd(J|0,G|0,30)|0;H=x^(H|C);x=Gd(J|0,G|0,39)|0;y=C;r=Hd(J|0,G|0,25)|0;y=Dd((B|I)&J|B&I|0,(A|K)&G|A&K|0,(F|L)^(u|E)^(x|r)|0,H^(y|C)|0)|0;H=C;f=Dd(b|0,f|0,M|0,D|0)|0;b=C;D=Dd(y|0,H|0,M|0,D|0)|0;M=C;H=Gd(f|0,b|0,14)|0;y=C;r=Hd(f|0,b|0,50)|0;y=y|C;x=Gd(f|0,b|0,18)|0;E=C;u=Hd(f|0,b|0,46)|0;E=y^(E|C);y=Gd(f|0,b|0,41)|0;L=C;F=Hd(f|0,b|0,23)|0;L=E^(L|C);E=g+568|0;v=c[E>>2]|0;E=c[E+4>>2]|0;o=Dd(s|0,o|0,320620315,460393269)|0;E=Dd(o|0,C|0,v|0,E|0)|0;L=Dd(E|0,C|0,(H|r)^(x|u)^(y|F)|0,L|0)|0;L=Dd(L|0,C|0,(p^l)&f^p|0,(m^j)&b^m|0)|0;F=C;y=Gd(D|0,M|0,28)|0;u=C;x=Hd(D|0,M|0,36)|0;u=u|C;r=Gd(D|0,M|0,34)|0;H=C;E=Hd(D|0,M|0,30)|0;H=u^(H|C);u=Gd(D|0,M|0,39)|0;v=C;o=Hd(D|0,M|0,25)|0;v=Dd((I|J)&D|I&J|0,(K|G)&M|K&G|0,(y|x)^(r|E)^(u|o)|0,H^(v|C)|0)|0;H=C;A=Dd(B|0,A|0,L|0,F|0)|0;B=C;F=Dd(v|0,H|0,L|0,F|0)|0;L=C;H=Gd(A|0,B|0,14)|0;v=C;o=Hd(A|0,B|0,50)|0;v=v|C;u=Gd(A|0,B|0,18)|0;E=C;r=Hd(A|0,B|0,46)|0;E=v^(E|C);v=Gd(A|0,B|0,41)|0;x=C;y=Hd(A|0,B|0,23)|0;x=E^(x|C);E=g+576|0;s=c[E>>2]|0;E=c[E+4>>2]|0;m=Dd(p|0,m|0,587496836,685471733)|0;E=Dd(m|0,C|0,s|0,E|0)|0;x=Dd(E|0,C|0,(H|o)^(u|r)^(v|y)|0,x|0)|0;x=Dd(x|0,C|0,(l^f)&A^l|0,(j^b)&B^j|0)|0;y=C;v=Gd(F|0,L|0,28)|0;r=C;u=Hd(F|0,L|0,36)|0;r=r|C;o=Gd(F|0,L|0,34)|0;H=C;E=Hd(F|0,L|0,30)|0;H=r^(H|C);r=Gd(F|0,L|0,39)|0;s=C;m=Hd(F|0,L|0,25)|0;s=Dd((J|D)&F|J&D|0,(G|M)&L|G&M|0,(v|u)^(o|E)^(r|m)|0,H^(s|C)|0)|0;H=C;K=Dd(I|0,K|0,x|0,y|0)|0;I=C;y=Dd(s|0,H|0,x|0,y|0)|0;x=C;H=Gd(K|0,I|0,14)|0;s=C;m=Hd(K|0,I|0,50)|0;s=s|C;r=Gd(K|0,I|0,18)|0;E=C;o=Hd(K|0,I|0,46)|0;E=s^(E|C);s=Gd(K|0,I|0,41)|0;u=C;v=Hd(K|0,I|0,23)|0;u=E^(u|C);E=g+584|0;p=c[E>>2]|0;E=c[E+4>>2]|0;j=Dd(l|0,j|0,1086792851,852142971)|0;E=Dd(j|0,C|0,p|0,E|0)|0;u=Dd(E|0,C|0,(H|m)^(r|o)^(s|v)|0,u|0)|0;u=Dd(u|0,C|0,(f^A)&K^f|0,(b^B)&I^b|0)|0;v=C;s=Gd(y|0,x|0,28)|0;o=C;r=Hd(y|0,x|0,36)|0;o=o|C;m=Gd(y|0,x|0,34)|0;H=C;E=Hd(y|0,x|0,30)|0;H=o^(H|C);o=Gd(y|0,x|0,39)|0;p=C;j=Hd(y|0,x|0,25)|0;p=Dd((D|F)&y|D&F|0,(M|L)&x|M&L|0,(s|r)^(m|E)^(o|j)|0,H^(p|C)|0)|0;H=C;G=Dd(J|0,G|0,u|0,v|0)|0;J=C;v=Dd(p|0,H|0,u|0,v|0)|0;u=C;H=Gd(G|0,J|0,14)|0;p=C;j=Hd(G|0,J|0,50)|0;p=p|C;o=Gd(G|0,J|0,18)|0;E=C;m=Hd(G|0,J|0,46)|0;E=p^(E|C);p=Gd(G|0,J|0,41)|0;r=C;s=Hd(G|0,J|0,23)|0;r=E^(r|C);E=g+592|0;l=c[E>>2]|0;E=c[E+4>>2]|0;b=Dd(f|0,b|0,365543100,1017036298)|0;E=Dd(b|0,C|0,l|0,E|0)|0;r=Dd(E|0,C|0,(H|j)^(o|m)^(p|s)|0,r|0)|0;r=Dd(r|0,C|0,(A^K)&G^A|0,(B^I)&J^B|0)|0;s=C;p=Gd(v|0,u|0,28)|0;m=C;o=Hd(v|0,u|0,36)|0;m=m|C;j=Gd(v|0,u|0,34)|0;H=C;E=Hd(v|0,u|0,30)|0;H=m^(H|C);m=Gd(v|0,u|0,39)|0;l=C;b=Hd(v|0,u|0,25)|0;l=Dd((F|y)&v|F&y|0,(L|x)&u|L&x|0,(p|o)^(j|E)^(m|b)|0,H^(l|C)|0)|0;H=C;M=Dd(D|0,M|0,r|0,s|0)|0;D=C;s=Dd(l|0,H|0,r|0,s|0)|0;r=C;H=Gd(M|0,D|0,14)|0;l=C;b=Hd(M|0,D|0,50)|0;l=l|C;m=Gd(M|0,D|0,18)|0;E=C;j=Hd(M|0,D|0,46)|0;E=l^(E|C);l=Gd(M|0,D|0,41)|0;o=C;p=Hd(M|0,D|0,23)|0;o=E^(o|C);E=g+600|0;f=c[E>>2]|0;E=c[E+4>>2]|0;B=Dd(A|0,B|0,-1676669620,1126000580)|0;E=Dd(B|0,C|0,f|0,E|0)|0;o=Dd(E|0,C|0,(H|b)^(m|j)^(l|p)|0,o|0)|0;o=Dd(o|0,C|0,(K^G)&M^K|0,(I^J)&D^I|0)|0;p=C;l=Gd(s|0,r|0,28)|0;j=C;m=Hd(s|0,r|0,36)|0;j=j|C;b=Gd(s|0,r|0,34)|0;H=C;E=Hd(s|0,r|0,30)|0;H=j^(H|C);j=Gd(s|0,r|0,39)|0;f=C;B=Hd(s|0,r|0,25)|0;f=Dd((y|v)&s|y&v|0,(x|u)&r|x&u|0,(l|m)^(b|E)^(j|B)|0,H^(f|C)|0)|0;H=C;L=Dd(F|0,L|0,o|0,p|0)|0;F=C;p=Dd(f|0,H|0,o|0,p|0)|0;o=C;H=Gd(L|0,F|0,14)|0;f=C;B=Hd(L|0,F|0,50)|0;f=f|C;j=Gd(L|0,F|0,18)|0;E=C;b=Hd(L|0,F|0,46)|0;E=f^(E|C);f=Gd(L|0,F|0,41)|0;m=C;l=Hd(L|0,F|0,23)|0;m=E^(m|C);E=g+608|0;A=c[E>>2]|0;E=c[E+4>>2]|0;I=Dd(K|0,I|0,-885112138,1288033470)|0;E=Dd(I|0,C|0,A|0,E|0)|0;m=Dd(E|0,C|0,(H|B)^(j|b)^(f|l)|0,m|0)|0;m=Dd(m|0,C|0,(G^M)&L^G|0,(J^D)&F^J|0)|0;l=C;f=Gd(p|0,o|0,28)|0;b=C;j=Hd(p|0,o|0,36)|0;b=b|C;B=Gd(p|0,o|0,34)|0;H=C;E=Hd(p|0,o|0,30)|0;H=b^(H|C);b=Gd(p|0,o|0,39)|0;A=C;I=Hd(p|0,o|0,25)|0;A=Dd((v|s)&p|v&s|0,(u|r)&o|u&r|0,(f|j)^(B|E)^(b|I)|0,H^(A|C)|0)|0;H=C;x=Dd(y|0,x|0,m|0,l|0)|0;y=C;l=Dd(A|0,H|0,m|0,l|0)|0;m=C;H=Gd(x|0,y|0,14)|0;A=C;I=Hd(x|0,y|0,50)|0;A=A|C;b=Gd(x|0,y|0,18)|0;E=C;B=Hd(x|0,y|0,46)|0;E=A^(E|C);A=Gd(x|0,y|0,41)|0;j=C;f=Hd(x|0,y|0,23)|0;j=E^(j|C);E=g+616|0;K=c[E>>2]|0;E=c[E+4>>2]|0;J=Dd(G|0,J|0,-60457430,1501505948)|0;E=Dd(J|0,C|0,K|0,E|0)|0;j=Dd(E|0,C|0,(H|I)^(b|B)^(A|f)|0,j|0)|0;j=Dd(j|0,C|0,(M^L)&x^M|0,(D^F)&y^D|0)|0;f=C;A=Gd(l|0,m|0,28)|0;B=C;b=Hd(l|0,m|0,36)|0;B=B|C;I=Gd(l|0,m|0,34)|0;H=C;E=Hd(l|0,m|0,30)|0;H=B^(H|C);B=Gd(l|0,m|0,39)|0;K=C;J=Hd(l|0,m|0,25)|0;K=Dd((s|p)&l|s&p|0,(r|o)&m|r&o|0,(A|b)^(I|E)^(B|J)|0,H^(K|C)|0)|0;H=C;u=Dd(v|0,u|0,j|0,f|0)|0;v=C;f=Dd(K|0,H|0,j|0,f|0)|0;j=C;H=Gd(u|0,v|0,14)|0;K=C;J=Hd(u|0,v|0,50)|0;K=K|C;B=Gd(u|0,v|0,18)|0;E=C;I=Hd(u|0,v|0,46)|0;E=K^(E|C);K=Gd(u|0,v|0,41)|0;b=C;A=Hd(u|0,v|0,23)|0;b=E^(b|C);E=g+624|0;G=c[E>>2]|0;E=c[E+4>>2]|0;D=Dd(M|0,D|0,987167468,1607167915)|0;E=Dd(D|0,C|0,G|0,E|0)|0;b=Dd(E|0,C|0,(H|J)^(B|I)^(K|A)|0,b|0)|0;b=Dd(b|0,C|0,(L^x)&u^L|0,(F^y)&v^F|0)|0;A=C;K=Gd(f|0,j|0,28)|0;I=C;B=Hd(f|0,j|0,36)|0;I=I|C;J=Gd(f|0,j|0,34)|0;H=C;E=Hd(f|0,j|0,30)|0;H=I^(H|C);I=Gd(f|0,j|0,39)|0;G=C;D=Hd(f|0,j|0,25)|0;G=Dd((p|l)&f|p&l|0,(o|m)&j|o&m|0,(K|B)^(J|E)^(I|D)|0,H^(G|C)|0)|0;H=C;r=Dd(s|0,r|0,b|0,A|0)|0;s=C;A=Dd(G|0,H|0,b|0,A|0)|0;b=C;H=Gd(r|0,s|0,14)|0;G=C;D=Hd(r|0,s|0,50)|0;G=G|C;I=Gd(r|0,s|0,18)|0;E=C;J=Hd(r|0,s|0,46)|0;E=G^(E|C);G=Gd(r|0,s|0,41)|0;B=C;K=Hd(r|0,s|0,23)|0;B=E^(B|C);g=g+632|0;E=c[g>>2]|0;g=c[g+4>>2]|0;F=Dd(L|0,F|0,1246189591,1816402316)|0;g=Dd(F|0,C|0,E|0,g|0)|0;g=Dd(g|0,C|0,(H|D)^(I|J)^(G|K)|0,B|0)|0;g=Dd(g|0,C|0,(x^u)&r^x|0,(y^v)&s^y|0)|0;B=C;K=Gd(A|0,b|0,28)|0;G=C;J=Hd(A|0,b|0,36)|0;G=G|C;I=Gd(A|0,b|0,34)|0;D=C;H=Hd(A|0,b|0,30)|0;D=G^(D|C);G=Gd(A|0,b|0,39)|0;E=C;F=Hd(A|0,b|0,25)|0;E=Dd((l|f)&A|l&f|0,(m|j)&b|m&j|0,(K|J)^(I|H)^(G|F)|0,D^(E|C)|0)|0;D=C;o=Dd(p|0,o|0,g|0,B|0)|0;p=C;B=Dd(E|0,D|0,g|0,B|0)|0;g=a;B=Dd(c[g>>2]|0,c[g+4>>2]|0,B|0,C|0)|0;g=a;c[g>>2]=B;c[g+4>>2]=C;g=e;g=Dd(c[g>>2]|0,c[g+4>>2]|0,A|0,b|0)|0;a=e;c[a>>2]=g;c[a+4>>2]=C;a=k;j=Dd(c[a>>2]|0,c[a+4>>2]|0,f|0,j|0)|0;c[k>>2]=j;c[k+4>>2]=C;k=n;m=Dd(c[k>>2]|0,c[k+4>>2]|0,l|0,m|0)|0;c[n>>2]=m;c[n+4>>2]=C;n=q;p=Dd(c[n>>2]|0,c[n+4>>2]|0,o|0,p|0)|0;c[q>>2]=p;c[q+4>>2]=C;q=t;s=Dd(c[q>>2]|0,c[q+4>>2]|0,r|0,s|0)|0;c[t>>2]=s;c[t+4>>2]=C;t=w;v=Dd(c[t>>2]|0,c[t+4>>2]|0,u|0,v|0)|0;c[w>>2]=v;c[w+4>>2]=C;w=z;y=Dd(c[w>>2]|0,c[w+4>>2]|0,x|0,y|0)|0;c[z>>2]=y;c[z+4>>2]=C;i=h;return}function Ib(){return 144}function Jb(){return 16}function Kb(){return 32}function Lb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;f=i;g=i=i+63&-64;i=i+144|0;Ub(g,e);Tb(g,b,c,d);Rb(g,a);i=f;return 0}function Mb(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return Qb(a,b,c,d,e)|0}function Nb(a,b){a=a|0;b=b|0;Ub(a,b);return 0}function Ob(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Tb(a,b,c,d);return 0}function Pb(a,b){a=a|0;b=b|0;Rb(a,b);return 0}function Qb(b,c,d,e,f){b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0;h=i;g=i=i+63&-64;i=i+160|0;j=g;g=g+144|0;Ub(j,f);Tb(j,c,d,e);Rb(j,g);i=h;return ((((a[g+1>>0]^a[b+1>>0]|a[g>>0]^a[b>>0]|a[g+2>>0]^a[b+2>>0]|a[g+3>>0]^a[b+3>>0]|a[g+4>>0]^a[b+4>>0]|a[g+5>>0]^a[b+5>>0]|a[g+6>>0]^a[b+6>>0]|a[g+7>>0]^a[b+7>>0]|a[g+8>>0]^a[b+8>>0]|a[g+9>>0]^a[b+9>>0]|a[g+10>>0]^a[b+10>>0]|a[g+11>>0]^a[b+11>>0]|a[g+12>>0]^a[b+12>>0]|a[g+13>>0]^a[b+13>>0]|a[g+14>>0]^a[b+14>>0]|a[g+15>>0]^a[b+15>>0])&255)+511|0)>>>8&1)+-1|0}function Rb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;h=b+56|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if(!((g|0)==0&(h|0)==0)){e=b+64|0;a[e+g>>0]=1;f=Dd(g|0,h|0,1,0)|0;i=C;if(i>>>0<0|(i|0)==0&f>>>0<16){i=Cd(14,0,g|0,h|0)|0;Fd(b+(f+64)|0,0,i+1|0)|0}a[b+80>>0]=1;Sb(b,e,16,0)}i=c[b+24>>2]|0;p=(c[b+28>>2]|0)+(i>>>26)|0;e=p&67108863;n=(p>>>26)+(c[b+32>>2]|0)|0;m=n&67108863;f=(n>>>26)+(c[b+36>>2]|0)|0;h=((f>>>26)*5|0)+(c[b+20>>2]|0)|0;g=h&67108863;i=(h>>>26)+(i&67108863)|0;r=((g+5|0)>>>26)+i|0;q=r>>>26;o=(q+e|0)>>>26;k=(f|-67108864)+((o+m|0)>>>26)|0;l=(k>>>31)+-1|0;j=k>>31;i=r&67108863&l|j&i;e=q+p&67108863&l|j&e;m=o+n&67108863&l|j&m;g=Dd(h+5&67108863&l|j&g|i<<26|0,0,c[b+40>>2]|0,0)|0;h=C;i=Dd(i>>>6|e<<20|0,0,c[b+44>>2]|0,0)|0;h=Dd(i|0,C|0,h|0,0)|0;i=C;e=Dd(e>>>12|m<<14|0,0,c[b+48>>2]|0,0)|0;i=Dd(e|0,C|0,i|0,0)|0;e=C;f=Dd(m>>>18|(l&k|j&f)<<8|0,0,c[b+52>>2]|0,0)|0;e=Dd(f|0,C|0,e|0,0)|0;a[d>>0]=g;a[d+1>>0]=g>>>8;a[d+2>>0]=g>>>16;a[d+3>>0]=g>>>24;a[d+4>>0]=h;a[d+5>>0]=h>>>8;a[d+6>>0]=h>>>16;a[d+7>>0]=h>>>24;a[d+8>>0]=i;a[d+9>>0]=i>>>8;a[d+10>>0]=i>>>16;a[d+11>>0]=i>>>24;a[d+12>>0]=e;a[d+13>>0]=e>>>8;a[d+14>>0]=e>>>16;a[d+15>>0]=e>>>24;e=b+88|0;do{a[b>>0]=0;b=b+1|0}while((b|0)<(e|0));return}function Sb(b,e,f,g){b=b|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;s=(a[b+80>>0]|0)!=0?0:16777216;t=c[b+4>>2]|0;u=c[b+8>>2]|0;m=c[b+12>>2]|0;n=c[b+16>>2]|0;v=b+20|0;l=c[v>>2]|0;w=b+24|0;k=c[w>>2]|0;x=b+28|0;j=c[x>>2]|0;y=b+32|0;i=c[y>>2]|0;z=b+36|0;h=c[z>>2]|0;if(!(g>>>0>0|(g|0)==0&f>>>0>15)){q=l;r=k;s=j;t=i;u=h;c[v>>2]=q;c[w>>2]=r;c[x>>2]=s;c[y>>2]=t;c[z>>2]=u;return}o=n*5|0;p=m*5|0;q=u*5|0;r=t*5|0;b=c[b>>2]|0;while(1){J=d[e+3>>0]|0;B=(d[e+1>>0]<<8|d[e>>0]|d[e+2>>0]<<16|J<<24&50331648)+l|0;H=d[e+6>>0]|0;J=((d[e+4>>0]<<8|J|d[e+5>>0]<<16|H<<24)>>>2&67108863)+k|0;G=d[e+9>>0]|0;H=((d[e+7>>0]<<8|H|d[e+8>>0]<<16|G<<24)>>>4&67108863)+j|0;G=((d[e+10>>0]<<8|G|d[e+11>>0]<<16|d[e+12>>0]<<24)>>>6)+i|0;l=(d[e+13>>0]|s|d[e+14>>0]<<8|d[e+15>>0]<<16)+h|0;k=Od(B|0,0,b|0,0)|0;j=C;A=Od(J|0,0,o|0,0)|0;j=Dd(A|0,C|0,k|0,j|0)|0;k=C;A=Od(H|0,0,p|0,0)|0;A=Dd(j|0,k|0,A|0,C|0)|0;k=C;j=Od(G|0,0,q|0,0)|0;j=Dd(A|0,k|0,j|0,C|0)|0;k=C;A=Od(l|0,0,r|0,0)|0;A=Dd(j|0,k|0,A|0,C|0)|0;k=C;j=Od(B|0,0,t|0,0)|0;i=C;F=Od(J|0,0,b|0,0)|0;i=Dd(F|0,C|0,j|0,i|0)|0;j=C;F=Od(H|0,0,o|0,0)|0;F=Dd(i|0,j|0,F|0,C|0)|0;j=C;i=Od(G|0,0,p|0,0)|0;i=Dd(F|0,j|0,i|0,C|0)|0;j=C;F=Od(l|0,0,q|0,0)|0;F=Dd(i|0,j|0,F|0,C|0)|0;j=C;i=Od(B|0,0,u|0,0)|0;h=C;E=Od(J|0,0,t|0,0)|0;h=Dd(E|0,C|0,i|0,h|0)|0;i=C;E=Od(H|0,0,b|0,0)|0;E=Dd(h|0,i|0,E|0,C|0)|0;i=C;h=Od(G|0,0,o|0,0)|0;h=Dd(E|0,i|0,h|0,C|0)|0;i=C;E=Od(l|0,0,p|0,0)|0;E=Dd(h|0,i|0,E|0,C|0)|0;i=C;h=Od(B|0,0,m|0,0)|0;I=C;D=Od(J|0,0,u|0,0)|0;I=Dd(D|0,C|0,h|0,I|0)|0;h=C;D=Od(H|0,0,t|0,0)|0;D=Dd(I|0,h|0,D|0,C|0)|0;h=C;I=Od(G|0,0,b|0,0)|0;I=Dd(D|0,h|0,I|0,C|0)|0;h=C;D=Od(l|0,0,o|0,0)|0;D=Dd(I|0,h|0,D|0,C|0)|0;h=C;B=Od(B|0,0,n|0,0)|0;I=C;J=Od(J|0,0,m|0,0)|0;I=Dd(J|0,C|0,B|0,I|0)|0;B=C;H=Od(H|0,0,u|0,0)|0;H=Dd(I|0,B|0,H|0,C|0)|0;B=C;G=Od(G|0,0,t|0,0)|0;G=Dd(H|0,B|0,G|0,C|0)|0;B=C;l=Od(l|0,0,b|0,0)|0;l=Dd(G|0,B|0,l|0,C|0)|0;B=C;k=Gd(A|0,k|0,26)|0;k=Dd(F|0,j|0,k|0,0)|0;j=Gd(k|0,C|0,26)|0;j=Dd(E|0,i|0,j|0,0)|0;i=Gd(j|0,C|0,26)|0;j=j&67108863;i=Dd(D|0,h|0,i|0,0)|0;h=Gd(i|0,C|0,26)|0;i=i&67108863;h=Dd(l|0,B|0,h|0,0)|0;B=Gd(h|0,C|0,26)|0;h=h&67108863;B=B*5|0;l=B+A&67108863;k=((B+(A&67108863)|0)>>>26)+(k&67108863)|0;f=Dd(f|0,g|0,-16,-1)|0;g=C;if(!(g>>>0>0|(g|0)==0&f>>>0>15))break;else e=e+16|0}c[v>>2]=l;c[w>>2]=k;c[x>>2]=j;c[y>>2]=i;c[z>>2]=h;return}function Tb(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;n=b+56|0;g=n;h=c[g>>2]|0;g=c[g+4>>2]|0;do if(!((h|0)==0&(g|0)==0)){l=Cd(16,0,h|0,g|0)|0;m=C;k=m>>>0>f>>>0|(m|0)==(f|0)&l>>>0>e>>>0;l=k?e:l;m=k?f:m;if(!((l|0)==0&(m|0)==0)){j=b+64|0;k=0;i=0;do{o=a[d+k>>0]|0;g=Dd(h|0,g|0,k|0,i|0)|0;a[j+g>>0]=o;k=Dd(k|0,i|0,1,0)|0;i=C;g=n;h=c[g>>2]|0;g=c[g+4>>2]|0}while(i>>>0<m>>>0|(i|0)==(m|0)&k>>>0<l>>>0)}o=Dd(h|0,g|0,l|0,m|0)|0;k=C;j=n;c[j>>2]=o;c[j+4>>2]=k;if(k>>>0<0|(k|0)==0&o>>>0<16)return;else{e=Cd(e|0,f|0,l|0,m|0)|0;f=C;Sb(b,b+64|0,16,0);o=n;c[o>>2]=0;c[o+4>>2]=0;d=d+l|0;break}}while(0);if(f>>>0>0|(f|0)==0&e>>>0>15){i=e&-16;Sb(b,d,i,f);e=Cd(e|0,f|0,i|0,f|0)|0;d=d+i|0;i=C}else i=f;if((e|0)==0&(i|0)==0)return;f=b+64|0;g=0;h=0;do{b=a[d+g>>0]|0;o=n;o=Dd(c[o>>2]|0,c[o+4>>2]|0,g|0,h|0)|0;a[f+o>>0]=b;g=Dd(g|0,h|0,1,0)|0;h=C}while(h>>>0<i>>>0|(h|0)==(i|0)&g>>>0<e>>>0);b=n;b=Dd(c[b>>2]|0,c[b+4>>2]|0,e|0,i|0)|0;o=n;c[o>>2]=b;c[o+4>>2]=C;return}function Ub(b,e){b=b|0;e=e|0;var f=0,g=0;f=e+3|0;c[b>>2]=(d[e+1>>0]|0)<<8|(d[e>>0]|0)|(d[e+2>>0]|0)<<16|(d[f>>0]|0)<<24&50331648;g=e+6|0;c[b+4>>2]=((d[e+4>>0]|0)<<8|(d[f>>0]|0)|(d[e+5>>0]|0)<<16|(d[g>>0]|0)<<24)>>>2&67108611;f=e+9|0;c[b+8>>2]=((d[e+7>>0]|0)<<8|(d[g>>0]|0)|(d[e+8>>0]|0)<<16|(d[f>>0]|0)<<24)>>>4&67092735;c[b+12>>2]=((d[e+10>>0]|0)<<8|(d[f>>0]|0)|(d[e+11>>0]|0)<<16|(d[e+12>>0]|0)<<24)>>>6&66076671;c[b+16>>2]=(d[e+14>>0]|0)<<8|(d[e+13>>0]|0)|(d[e+15>>0]|0)<<16&983040;f=b+20|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[b+40>>2]=(d[e+17>>0]|0)<<8|(d[e+16>>0]|0)|(d[e+18>>0]|0)<<16|(d[e+19>>0]|0)<<24;c[b+44>>2]=(d[e+21>>0]|0)<<8|(d[e+20>>0]|0)|(d[e+22>>0]|0)<<16|(d[e+23>>0]|0)<<24;c[b+48>>2]=(d[e+25>>0]|0)<<8|(d[e+24>>0]|0)|(d[e+26>>0]|0)<<16|(d[e+27>>0]|0)<<24;c[b+52>>2]=(d[e+29>>0]|0)<<8|(d[e+28>>0]|0)|(d[e+30>>0]|0)<<16|(d[e+31>>0]|0)<<24;e=b+56|0;c[e>>2]=0;c[e+4>>2]=0;a[b+80>>0]=0;return}function Vb(b,e,f,g,h){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=i;t=i=i+63&-64;i=i+48|0;j=t+8|0;u=t+4|0;if((a[g>>0]|0)!=36){h=0;i=w;return h|0}if((a[g+1>>0]|0)!=55){h=0;i=w;return h|0}if((a[g+2>>0]|0)!=36){h=0;i=w;return h|0}o=a[g+3>>0]|0;n=o&255;a:do if(1){l=65;k=34881;do{if((a[k>>0]|0)==o<<24>>24)break a;k=k+1|0;l=l+-1|0;m=(l|0)!=0}while(m&(k&3|0)!=0);if(!m){h=0;i=w;return h|0}}else{l=65;k=34881}while(0);b:do if((a[k>>0]|0)!=o<<24>>24){m=_(n,16843009)|0;c:do if(l>>>0>3)while(1){s=c[k>>2]^m;if((s&-2139062144^-2139062144)&s+-16843009)break c;k=k+4|0;l=l+-4|0;if(l>>>0<=3){v=12;break}}else v=12;while(0);if((v|0)==12)if(!l){h=0;i=w;return h|0}while(1){if((a[k>>0]|0)==o<<24>>24)break b;l=l+-1|0;if(!l){j=0;break}else k=k+1|0}i=w;return j|0}while(0);if((k|0)==0|(l|0)==0){h=0;i=w;return h|0}r=Hd(1,0,k-34881|0)|0;s=C;k=Xb(u,g+4|0)|0;if(!k){h=0;i=w;return h|0}q=Xb(t,k)|0;if(!q){h=0;i=w;return h|0}o=q;p=o-g|0;n=(o&3|0)==0;d:do if(n){k=q;v=22}else{l=q;k=o;while(1){if(!(a[l>>0]|0))break d;l=l+1|0;k=l;if(!(k&3)){k=l;v=22;break}}}while(0);if((v|0)==22){while(1){l=c[k>>2]|0;if(!((l&-2139062144^-2139062144)&l+-16843009))k=k+4|0;else break}if((l&255)<<24>>24)do k=k+1|0;while((a[k>>0]|0)!=0)}l=k-o+1|0;while(1){k=l+-1|0;if(!l){v=32;break}m=q+k|0;if((a[m>>0]|0)==36){v=30;break}else l=k}if((v|0)==30)if(!m)v=32;else l=l+-1|0;if((v|0)==32){e:do if(n){k=q;v=35}else{k=q;l=o;while(1){if(!(a[k>>0]|0)){k=l;break e}k=k+1|0;l=k;if(!(l&3)){v=35;break}}}while(0);if((v|0)==35){while(1){l=c[k>>2]|0;if(!((l&-2139062144^-2139062144)&l+-16843009))k=k+4|0;else break}if((l&255)<<24>>24)do k=k+1|0;while((a[k>>0]|0)!=0)}l=k-o|0}k=l+p|0;p=k+45|0;if(p>>>0>102|p>>>0<l>>>0){h=0;i=w;return h|0}if(hc(b,e,f,q,l,r,s,c[u>>2]|0,c[t>>2]|0,j,32)|0){h=0;i=w;return h|0}Id(h|0,g|0,k|0)|0;s=h+k|0;r=s+1|0;a[s>>0]=36;s=r;r=h+102-r|0;k=0;f:while(1){if(k>>>0<32){p=0;q=k;k=0}else break;do{g=q;q=q+1|0;k=d[j+g>>0]<<p|k;p=p+8|0}while(q>>>0<32&p>>>0<24);if(!p)k=s;else{l=k;m=r;n=s;o=0;while(1){if(!m){v=50;break f}k=n+1|0;a[n>>0]=a[34881+(l&63)>>0]|0;o=o+6|0;if(o>>>0>=p>>>0)break;else{l=l>>>6;m=m+-1|0;n=k}}}g=(k|0)==0;r=(g?0:s-k|0)+r|0;if(g){v=50;break}else{s=k;k=q}}if((v|0)==50){k=j+32|0;do{a[j>>0]=0;j=j+1|0}while((j|0)<(k|0));h=0;i=w;return h|0}k=j+32|0;do{a[j>>0]=0;j=j+1|0}while((j|0)<(k|0));if(!((s|0)!=0&s>>>0<(h+102|0)>>>0)){h=0;i=w;return h|0}a[s>>0]=0;i=w;return h|0}function Wb(a,b,d,e,f,g,h,j,k,l){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;l=l|0;var m=0,n=0;m=i;n=i=i+63&-64;i=i+16|0;c[n+4>>2]=0;c[n>>2]=0;c[n+8>>2]=0;f=hc(n,a,b,d,e,f,g,h,j,k,l)|0;g=c[n>>2]|0;if(!g){i=m;return f|0}zd(g);i=m;return f|0}function Xb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=a[d>>0]|0;h=i&255;a:do if(1){e=65;f=34881;do{if((a[f>>0]|0)==i<<24>>24)break a;f=f+1|0;e=e+-1|0;g=(e|0)!=0}while(g&(f&3|0)!=0);if(!g){d=0;n=0;c[b>>2]=n;return d|0}}else{e=65;f=34881}while(0);b:do if((a[f>>0]|0)!=i<<24>>24){g=_(h,16843009)|0;c:do if(e>>>0>3)while(1){m=c[f>>2]^g;if((m&-2139062144^-2139062144)&m+-16843009)break c;f=f+4|0;e=e+-4|0;if(e>>>0<=3){n=9;break}}else n=9;while(0);if((n|0)==9)if(!e){d=0;n=0;c[b>>2]=n;return d|0}while(1){if((a[f>>0]|0)==i<<24>>24)break b;e=e+-1|0;if(!e){e=0;f=0;break}else f=f+1|0}c[b>>2]=f;return e|0}while(0);if((f|0)==0|(e|0)==0){d=0;n=0;c[b>>2]=n;return d|0}j=a[d+1>>0]|0;i=j&255;d:do if(1){e=65;g=34881;do{if((a[g>>0]|0)==j<<24>>24)break d;g=g+1|0;e=e+-1|0;h=(e|0)!=0}while(h&(g&3|0)!=0);if(!h){d=0;n=0;c[b>>2]=n;return d|0}}else{e=65;g=34881}while(0);e:do if((a[g>>0]|0)!=j<<24>>24){h=_(i,16843009)|0;f:do if(e>>>0>3)while(1){m=c[g>>2]^h;if((m&-2139062144^-2139062144)&m+-16843009)break f;g=g+4|0;e=e+-4|0;if(e>>>0<=3){n=22;break}}else n=22;while(0);if((n|0)==22)if(!e){d=0;n=0;c[b>>2]=n;return d|0}while(1){if((a[g>>0]|0)==j<<24>>24)break e;e=e+-1|0;if(!e){e=0;f=0;break}else g=g+1|0}c[b>>2]=f;return e|0}while(0);if((g|0)==0|(e|0)==0){d=0;n=0;c[b>>2]=n;return d|0}k=a[d+2>>0]|0;j=k&255;g:do if(1){e=65;h=34881;do{if((a[h>>0]|0)==k<<24>>24)break g;h=h+1|0;e=e+-1|0;i=(e|0)!=0}while(i&(h&3|0)!=0);if(!i){d=0;n=0;c[b>>2]=n;return d|0}}else{e=65;h=34881}while(0);h:do if((a[h>>0]|0)!=k<<24>>24){i=_(j,16843009)|0;i:do if(e>>>0>3)while(1){m=c[h>>2]^i;if((m&-2139062144^-2139062144)&m+-16843009)break i;h=h+4|0;e=e+-4|0;if(e>>>0<=3){n=36;break}}else n=36;while(0);if((n|0)==36)if(!e){d=0;n=0;c[b>>2]=n;return d|0}while(1){if((a[h>>0]|0)==k<<24>>24)break h;e=e+-1|0;if(!e){e=0;f=0;break}else h=h+1|0}c[b>>2]=f;return e|0}while(0);if((h|0)==0|(e|0)==0){d=0;n=0;c[b>>2]=n;return d|0}l=a[d+3>>0]|0;k=l&255;j:do if(1){e=65;i=34881;do{if((a[i>>0]|0)==l<<24>>24)break j;i=i+1|0;e=e+-1|0;j=(e|0)!=0}while(j&(i&3|0)!=0);if(!j){d=0;n=0;c[b>>2]=n;return d|0}}else{e=65;i=34881}while(0);k:do if((a[i>>0]|0)==l<<24>>24)m=i;else{j=_(k,16843009)|0;l:do if(e>>>0>3)while(1){m=c[i>>2]^j;if((m&-2139062144^-2139062144)&m+-16843009)break l;i=i+4|0;e=e+-4|0;if(e>>>0<=3){n=49;break}}else n=49;while(0);if((n|0)==49)if(!e){d=0;n=0;c[b>>2]=n;return d|0}while(1){if((a[i>>0]|0)==l<<24>>24){m=i;break k}e=e+-1|0;if(!e){e=0;f=0;break}else i=i+1|0}c[b>>2]=f;return e|0}while(0);if((m|0)==0|(e|0)==0){d=0;n=0;c[b>>2]=n;return d|0}l=a[d+4>>0]|0;k=l&255;m:do if(1){i=65;e=34881;do{if((a[e>>0]|0)==l<<24>>24)break m;e=e+1|0;i=i+-1|0;j=(i|0)!=0}while(j&(e&3|0)!=0);if(!j){d=0;n=0;c[b>>2]=n;return d|0}}else{i=65;e=34881}while(0);n:do if((a[e>>0]|0)!=l<<24>>24){j=_(k,16843009)|0;o:do if(i>>>0>3)while(1){k=c[e>>2]^j;if((k&-2139062144^-2139062144)&k+-16843009)break o;e=e+4|0;i=i+-4|0;if(i>>>0<=3){n=62;break}}else n=62;while(0);if((n|0)==62)if(!i){d=0;n=0;c[b>>2]=n;return d|0}while(1){if((a[e>>0]|0)==l<<24>>24)break n;i=i+-1|0;if(!i){e=0;f=0;break}else e=e+1|0}c[b>>2]=f;return e|0}while(0);if((e|0)==0|(i|0)==0){d=0;n=0;c[b>>2]=n;return d|0}d=d+5|0;n=e-34881<<24|(m-34881<<18|(h-34881<<12|(g-34881<<6|f-34881)));c[b>>2]=n;return d|0}function Yb(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;A=i;w=i=i+63&-64;i=i+560|0;r=w+488|0;z=w+456|0;v=w+208|0;x=w;y=w+416|0;w=w+424|0;n=v+32|0;if(d>>>0<=64){p=n;c[p>>2]=0;c[p+4>>2]=0;c[v>>2]=c[18];c[v+4>>2]=c[19];c[v+8>>2]=c[20];c[v+12>>2]=c[21];c[v+16>>2]=c[22];c[v+20>>2]=c[23];c[v+24>>2]=c[24];c[v+28>>2]=c[25];p=r;q=p+64|0;do{a[p>>0]=54;p=p+1|0}while((p|0)<(q|0));l=(d|0)==0;if(!l){j=d;k=n;a[r>>0]=a[b>>0]^54;if((j|0)==1)d=j;else{d=j;m=8}}else k=n}else{c[v>>2]=c[18];c[v+4>>2]=c[19];c[v+8>>2]=c[20];c[v+12>>2]=c[21];c[v+16>>2]=c[22];c[v+20>>2]=c[23];c[v+24>>2]=c[24];c[v+28>>2]=c[25];p=Hd(d|0,0,3)|0;l=n;c[l>>2]=p;c[l+4>>2]=C;l=v+40|0;p=l;m=b;q=p+64|0;do{a[p>>0]=a[m>>0]|0;p=p+1|0;m=m+1|0}while((p|0)<(q|0));Eb(v,l);j=b+64|0;k=Dd(d|0,0,-64,-1)|0;b=C;if(b>>>0>0|(b|0)==0&k>>>0>63){do{Eb(v,j);j=j+64|0;k=Dd(k|0,b|0,-64,-1)|0;b=C}while(b>>>0>0|(b|0)==0&k>>>0>63);b=k}else b=k;Id(l|0,j|0,b|0)|0;Db(v,z);p=n;c[p>>2]=0;c[p+4>>2]=0;c[v>>2]=c[18];c[v+4>>2]=c[19];c[v+8>>2]=c[20];c[v+12>>2]=c[21];c[v+16>>2]=c[22];c[v+20>>2]=c[23];c[v+24>>2]=c[24];c[v+28>>2]=c[25];p=r;q=p+64|0;do{a[p>>0]=54;p=p+1|0}while((p|0)<(q|0));a[r>>0]=a[z>>0]^54;d=32;b=z;k=n;l=0;m=8}if((m|0)==8){j=1;do{u=r+j|0;a[u>>0]=a[u>>0]^a[b+j>>0];j=j+1|0}while((j|0)!=(d|0))}o=k;c[o>>2]=512;c[o+4>>2]=0;o=v+40|0;p=o;m=r;q=p+64|0;do{a[p>>0]=a[m>>0]|0;p=p+1|0;m=m+1|0}while((p|0)<(q|0));Eb(v,o);n=v+104|0;m=v+136|0;p=m;c[p>>2]=0;c[p+4>>2]=0;c[n>>2]=c[18];c[n+4>>2]=c[19];c[n+8>>2]=c[20];c[n+12>>2]=c[21];c[n+16>>2]=c[22];c[n+20>>2]=c[23];c[n+24>>2]=c[24];c[n+28>>2]=c[25];p=r;q=p+64|0;do{a[p>>0]=92;p=p+1|0}while((p|0)<(q|0));if(!l?(a[r>>0]=a[b>>0]^92,(d|0)!=1):0){j=1;do{u=r+j|0;a[u>>0]=a[u>>0]^a[b+j>>0];j=j+1|0}while((j|0)!=(d|0))}j=m;c[j>>2]=512;c[j+4>>2]=0;j=v+144|0;p=j;m=r;q=p+64|0;do{a[p>>0]=a[m>>0]|0;p=p+1|0;m=m+1|0}while((p|0)<(q|0));Eb(n,j);do if(f){b=k;t=c[b>>2]|0;b=c[b+4>>2]|0;j=Gd(t|0,b|0,3)|0;j=j&63;u=Hd(f|0,0,3)|0;u=Dd(t|0,b|0,u|0,C|0)|0;b=k;c[b>>2]=u;c[b+4>>2]=C;b=64-j|0;j=v+40+j|0;if(b>>>0>f>>>0){Id(j|0,e|0,f|0)|0;break}Id(j|0,e|0,b|0)|0;Eb(v,o);j=e+b|0;k=Cd(f|0,0,b|0,0)|0;b=C;if(b>>>0>0|(b|0)==0&k>>>0>63){do{Eb(v,j);j=j+64|0;k=Dd(k|0,b|0,-64,-1)|0;b=C}while(b>>>0>0|(b|0)==0&k>>>0>63);b=k}else b=k;Id(o|0,j|0,b|0)|0}while(0);if(!h){i=A;return}l=y+3|0;d=y+2|0;n=y+1|0;o=x+32|0;r=x+104|0;e=x+136|0;f=x+144|0;s=x+40|0;t=0;u=0;do{u=u+1|0;a[l>>0]=u;a[d>>0]=u>>>8;a[n>>0]=u>>>16;a[y>>0]=u>>>24;Id(x|0,v|0,208)|0;q=o;b=c[q>>2]|0;q=c[q+4>>2]|0;j=Gd(b|0,q|0,3)|0;j=j&63;q=Dd(b|0,q|0,32,0)|0;b=o;c[b>>2]=q;c[b+4>>2]=C;b=64-j|0;j=x+40+j|0;if(b>>>0>4){q=c[y>>2]|0;a[j>>0]=q;a[j+1>>0]=q>>8;a[j+2>>0]=q>>16;a[j+3>>0]=q>>24}else{Id(j|0,y|0,b|0)|0;Eb(x,s);j=y+b|0;k=Cd(4,0,b|0,0)|0;b=C;if(b>>>0>0|(b|0)==0&k>>>0>63){do{Eb(x,j);j=j+64|0;k=Dd(k|0,b|0,-64,-1)|0;b=C}while(b>>>0>0|(b|0)==0&k>>>0>63);b=k}else b=k;Id(s|0,j|0,b|0)|0}Db(x,z);q=e;b=c[q>>2]|0;q=c[q+4>>2]|0;j=Gd(b|0,q|0,3)|0;j=j&63;q=Dd(b|0,q|0,256,0)|0;b=e;c[b>>2]=q;c[b+4>>2]=C;b=64-j|0;j=x+144+j|0;if(b>>>0>32){p=j;m=z;q=p+32|0;do{a[p>>0]=a[m>>0]|0;p=p+1|0;m=m+1|0}while((p|0)<(q|0))}else{Id(j|0,z|0,b|0)|0;Eb(r,f);j=z+b|0;k=Cd(32,0,b|0,0)|0;b=C;if(b>>>0>0|(b|0)==0&k>>>0>63){do{Eb(r,j);j=j+64|0;k=Dd(k|0,b|0,-64,-1)|0;b=C}while(b>>>0>0|(b|0)==0&k>>>0>63);b=k}else b=k;Id(f|0,j|0,b|0)|0}Db(r,w);q=h-t|0;Id(g+t|0,w|0,(q>>>0>32?32:q)|0)|0;t=u<<5}while(t>>>0<h>>>0);i=A;return}function Zb(){return 32}function _b(){return 102}function $b(){return 32984}function ac(){return 524288}function bc(){return 16777216}function cc(){return 33554432}function dc(){return 1073741824}function ec(a,b,d,e,f,g,h,j,k,l){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;l=l|0;var m=0,n=0,o=0,p=0;o=i;n=i=i+63&-64;i=i+16|0;Fd(a|0,0,b|0)|0;m=g|d;if(m>>>0>0|(m|0)==0&(f|b)>>>0>4294967295){if(!(c[7979]|0))d=31964;else d=c[(oa()|0)+60>>2]|0;c[d>>2]=27;n=-1;i=o;return n|0}g=k>>>0<0|(k|0)==0&j>>>0<32768;m=g?32768:j;k=g?0:k;a:do if(k>>>0<0|(k|0)==0&m>>>0<l>>>5>>>0){g=Gd(m|0,k|0,6)|0;j=C;k=1;while(1){m=Hd(1,0,k|0)|0;l=C;d=k+1|0;if(l>>>0>j>>>0|(l|0)==(j|0)&m>>>0>g>>>0){d=k;g=1;break a}if(d>>>0<63)k=d;else{g=1;break}}}else{g=l>>>11;j=1;while(1){l=Hd(1,0,j|0)|0;p=C;d=j+1|0;if(p>>>0>0|(p|0)==0&l>>>0>g>>>0){d=j;break}if(d>>>0<63)j=d;else break}g=Gd(m|0,k|0,2)|0;g=Gd(g|0,C|0,d|0)|0;p=C;m=p>>>0>0|(p|0)==0&g>>>0>1073741823;g=m?1073741823:g;g=g>>>3}while(0);d=Hd(1,0,d|0)|0;c[n+4>>2]=0;c[n>>2]=0;c[n+8>>2]=0;g=hc(n,e,f,h,32,d,C,8,g,a,b)|0;d=c[n>>2]|0;if(d)zd(d);p=g;i=o;return p|0}function fc(b,e,f,g,h,j,k){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=i;v=i=i+63&-64;i=i+112|0;t=v+72|0;u=v+12|0;l=b;m=l+102|0;do{a[l>>0]=0;l=l+1|0}while((l|0)<(m|0));if(g>>>0>0|(g|0)==0&f>>>0>4294967295){if(!(c[7979]|0))g=31964;else g=c[(oa()|0)+60>>2]|0;c[g>>2]=27;v=-1;i=w;return v|0}m=j>>>0<0|(j|0)==0&h>>>0<32768;n=m?32768:h;m=m?0:j;a:do if(m>>>0<0|(m|0)==0&n>>>0<k>>>5>>>0){h=Gd(n|0,m|0,6)|0;l=C;m=1;while(1){k=Hd(1,0,m|0)|0;n=C;g=m+1|0;if(n>>>0>l>>>0|(n|0)==(l|0)&k>>>0>h>>>0){g=m;h=1;break a}if(g>>>0<63)m=g;else{h=1;break}}}else{h=k>>>11;l=1;while(1){k=Hd(1,0,l|0)|0;j=C;g=l+1|0;if(j>>>0>0|(j|0)==0&k>>>0>h>>>0){g=l;break}if(g>>>0<63)l=g;else break}h=Gd(n|0,m|0,2)|0;h=Gd(h|0,C|0,g|0)|0;k=C;n=k>>>0>0|(k|0)==0&h>>>0>1073741823;h=n?1073741823:h;h=h>>>3}while(0);l=0;do{a[t+l>>0]=Ba(0)|0;l=l+1|0}while((l|0)!=32);b:do if((((((((g>>>0<=63?(k=Hd(h|0,0,3)|0,n=C,!(n>>>0>0|(n|0)==0&k>>>0>1073741823)):0)?(a[u>>0]=36,a[u+1>>0]=55,a[u+2>>0]=36,a[u+3>>0]=a[34881+g>>0]|0,a[u+4>>0]=54,k=u+5|0,o=u+9|0,a[k>>0]=46,a[k+1>>0]=46,a[k+2>>0]=46,a[k+3>>0]=46,(o|0)!=0):0)?(p=o,r=u+58|0,(r|0)!=(p|0)):0)?(q=r-p|0,a[o>>0]=a[34881+(h&63)>>0]|0,(q|0)!=1):0)?(a[u+10>>0]=a[34881+(h>>>6&63)>>0]|0,(q|0)!=2):0)?(a[u+11>>0]=a[34881+(h>>>12&63)>>0]|0,(q|0)!=3):0)?(a[u+12>>0]=a[34881+(h>>>18&63)>>0]|0,(q|0)!=4):0)?(s=u+14|0,a[u+13>>0]=a[34881+(h>>>24)>>0]|0,(s|0)!=0):0){p=s;o=r-s|0;g=0;while(1){if(g>>>0<32){n=0;k=g;g=0}else break;do{s=k;k=k+1|0;g=(d[t+s>>0]|0)<<n|g;n=n+8|0}while(k>>>0<32&n>>>0<24);if(!n)g=p;else{h=g;l=o;m=p;j=0;while(1){if(!l)break b;g=m+1|0;a[m>>0]=a[34881+(h&63)>>0]|0;j=j+6|0;if(j>>>0>=n>>>0)break;else{h=h>>>6;l=l+-1|0;m=g}}}s=(g|0)==0;o=(s?0:p-g|0)+o|0;if(s)break b;else{p=g;g=k}}if(p>>>0<(u+58|0)>>>0){a[p>>0]=0;l=v+4|0;c[l>>2]=0;c[v>>2]=0;m=v+8|0;c[m>>2]=0;g=(Vb(v,e,f,u,b)|0)==0;h=c[v>>2]|0;if(h)zd(h);c[l>>2]=0;c[v>>2]=0;c[m>>2]=0;if(!g){v=0;i=w;return v|0}if(!(c[7979]|0))g=31964;else g=c[(oa()|0)+60>>2]|0;c[g>>2]=22;v=-1;i=w;return v|0}}while(0);if(!(c[7979]|0))g=31964;else g=c[(oa()|0)+60>>2]|0;c[g>>2]=22;v=-1;i=w;return v|0}function gc(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0;m=i;l=i=i+63&-64;i=i+128|0;f=l+12|0;a:do if(b&3){g=102;h=b;do{if(!(a[h>>0]|0)){k=5;break a}h=h+1|0;g=g+-1|0;j=(g|0)!=0}while(j&(h&3|0)!=0);if(j)k=5;else g=0}else{g=102;h=b;k=5}while(0);b:do if((k|0)==5)if(a[h>>0]|0){c:do if(g>>>0>3)while(1){j=c[h>>2]|0;if((j&-2139062144^-2139062144)&j+-16843009)break;h=h+4|0;g=g+-4|0;if(g>>>0<=3){k=10;break c}}else k=10;while(0);if((k|0)==10)if(!g){g=0;break}while(1){if(!(a[h>>0]|0))break b;h=h+1|0;g=g+-1|0;if(!g){g=0;break}}}while(0);if((((g|0)!=0?h:0)|0)!=(b+101|0)){b=-1;i=m;return b|0}j=l+4|0;c[j>>2]=0;c[l>>2]=0;k=l+8|0;c[k>>2]=0;g=(Vb(l,d,e,b,f)|0)==0;h=c[l>>2]|0;if(h)zd(h);c[j>>2]=0;c[l>>2]=0;c[k>>2]=0;if(g){b=-1;i=m;return b|0}else{g=0;h=0}do{g=a[b+h>>0]^a[f+h>>0]|g;h=h+1|0}while((h|0)!=102);h=(((g&255)+511|0)>>>8&1)+-1|0;g=f+102|0;do{a[f>>0]=0;f=f+1|0}while((f|0)<(g|0));b=h;i=m;return b|0}function hc(b,e,f,g,h,i,j,k,l,m,n){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;j=j|0;k=k|0;l=l|0;m=m|0;n=n|0;var o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;J=Od(l|0,0,k|0,0)|0;I=C;if(I>>>0>0|(I|0)==0&J>>>0>1073741823){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=27;f=-1;return f|0}if(j>>>0>0|(j|0)==0&i>>>0>4294967295){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=27;f=-1;return f|0}G=Dd(i|0,j|0,-1,-1)|0;H=C;if(j>>>0<0|(j|0)==0&i>>>0<2|((G&i|0)!=0|(H&j|0)!=0)){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=22;f=-1;return f|0}if((k|0)==0|(l|0)==0){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=22;f=-1;return f|0}if(!(k>>>0>16777215?1:(33554431/(l>>>0)|0)>>>0<k>>>0)?!(0<j>>>0|(0==(j|0)?(33554431/(k>>>0)|0)>>>0<i>>>0:0)):0){I=k<<7;J=_(I,l)|0;y=Od(I|0,0,i|0,j|0)|0;o=y+J|0;if(o>>>0<y>>>0){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=12;f=-1;return f|0}F=k<<8|64;w=o+F|0;if(w>>>0<F>>>0){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=12;f=-1;return f|0}x=b+8|0;do if((c[x>>2]|0)>>>0<w>>>0){o=c[b>>2]|0;if(o)zd(o);v=b+4|0;c[v>>2]=0;c[b>>2]=0;c[x>>2]=0;do if(w>>>0<=4294967168){if(w>>>0>=4294967168){if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=12;q=12;o=0;break}t=w|8;o=yd(t+76|0)|0;if(o){s=o+-8|0;do if(o&63){r=o+63&-64;F=r+-8|0;q=s;r=(F-q|0)>>>0>15?F:r+56|0;q=r-q|0;o=o+-4|0;F=c[o>>2]|0;p=(F&-8)-q|0;if(!(F&3)){c[r>>2]=(c[s>>2]|0)+q;c[r+4>>2]=p;break}else{F=r+4|0;c[F>>2]=p|c[F>>2]&1|2;E=r+p+4|0;c[E>>2]=c[E>>2]|1;c[o>>2]=q|c[o>>2]&1|2;c[F>>2]=c[F>>2]|1;Ad(s,q);break}}else r=s;while(0);o=r+4|0;p=c[o>>2]|0;if((p&3|0)!=0?(u=p&-8,u>>>0>(t+16|0)>>>0):0){F=u-t|0;E=r+t|0;c[o>>2]=t|p&1|2;c[E+4>>2]=F|3;D=E+F+4|0;c[D>>2]=c[D>>2]|1;Ad(E,F)}q=0;o=r+8|0}else{q=12;o=0}}else{q=12;o=0}while(0);if(!(c[7979]|0))p=31964;else p=c[(oa()|0)+60>>2]|0;c[p>>2]=q;if(!q){c[b>>2]=o;c[v>>2]=o;c[x>>2]=(o|0)!=0?w:0;if(!o)o=-1;else break;return o|0}else{c[b>>2]=0;c[v>>2]=0;c[x>>2]=0;f=-1;return f|0}}else o=c[b+4>>2]|0;while(0);F=o+J|0;E=F+y|0;Yb(e,f,g,h,o,J);t=k<<5;u=E+(t<<2)|0;v=E+(k<<6<<2)|0;w=(t|0)==0;x=(i|0)==0&(j|0)==0;b=t&1073741792;y=(b|0)==0;h=I+-64|0;g=E+h|0;h=u+h|0;z=h+4|0;A=g+4|0;D=0;do{B=o+(_(I,D)|0)|0;if(!w){p=0;do{s=B+(p<<2)|0;c[E+(p<<2)>>2]=(d[s+1>>0]|0)<<8|(d[s>>0]|0)|(d[s+2>>0]|0)<<16|(d[s+3>>0]|0)<<24;p=p+1|0}while((p|0)!=(t|0))}a:do if(!x){if(y){p=0;q=0;do{ic(E,u,v,k);ic(u,E,v,k);p=Dd(p|0,q|0,2,0)|0;q=C}while(q>>>0<j>>>0|(q|0)==(j|0)&p>>>0<i>>>0)}else{r=0;s=0;do{p=Od(r|0,s|0,t|0,0)|0;p=F+(p<<2)|0;q=0;do{c[p+(q<<2)>>2]=c[E+(q<<2)>>2];q=q+1|0}while((q|0)!=(b|0));ic(E,u,v,k);p=Od(r|1|0,s|0,t|0,0)|0;p=F+(p<<2)|0;q=0;do{c[p+(q<<2)>>2]=c[u+(q<<2)>>2];q=q+1|0}while((q|0)!=(b|0));ic(u,E,v,k);r=Dd(r|0,s|0,2,0)|0;s=C}while(s>>>0<j>>>0|(s|0)==(j|0)&r>>>0<i>>>0)}if(y){p=0;q=0;while(1){ic(E,u,v,k);ic(u,E,v,k);p=Dd(p|0,q|0,2,0)|0;q=C;if(!(q>>>0<j>>>0|(q|0)==(j|0)&p>>>0<i>>>0))break a}}else{r=0;s=0}do{p=Od(c[g>>2]&G|0,c[A>>2]&H|0,t|0,0)|0;p=F+(p<<2)|0;q=0;do{K=E+(q<<2)|0;c[K>>2]=c[K>>2]^c[p+(q<<2)>>2];q=q+1|0}while((q|0)!=(b|0));ic(E,u,v,k);p=Od(c[h>>2]&G|0,c[z>>2]&H|0,t|0,0)|0;p=F+(p<<2)|0;q=0;do{K=u+(q<<2)|0;c[K>>2]=c[K>>2]^c[p+(q<<2)>>2];q=q+1|0}while((q|0)!=(b|0));ic(u,E,v,k);r=Dd(r|0,s|0,2,0)|0;s=C}while(s>>>0<j>>>0|(s|0)==(j|0)&r>>>0<i>>>0)}while(0);if(!w){p=0;do{K=B+(p<<2)|0;s=c[E+(p<<2)>>2]|0;a[K>>0]=s;a[K+1>>0]=s>>>8;a[K+2>>0]=s>>>16;a[K+3>>0]=s>>>24;p=p+1|0}while((p|0)!=(t|0))}D=D+1|0}while((D|0)!=(l|0));Yb(e,f,o,J,m,n);K=0;return K|0}if(!(c[7979]|0))o=31964;else o=c[(oa()|0)+60>>2]|0;c[o>>2]=12;K=-1;return K|0}function ic(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0;w=e<<1;m=a+((e<<5)+-16<<2)|0;o=c[m>>2]|0;c[d>>2]=o;q=c[m+4>>2]|0;L=d+4|0;c[L>>2]=q;t=c[m+8>>2]|0;x=d+8|0;c[x>>2]=t;u=c[m+12>>2]|0;y=d+12|0;c[y>>2]=u;s=c[m+16>>2]|0;z=d+16|0;c[z>>2]=s;r=c[m+20>>2]|0;A=d+20|0;c[A>>2]=r;p=c[m+24>>2]|0;B=d+24|0;c[B>>2]=p;n=c[m+28>>2]|0;C=d+28|0;c[C>>2]=n;l=c[m+32>>2]|0;D=d+32|0;c[D>>2]=l;j=c[m+36>>2]|0;E=d+36|0;c[E>>2]=j;h=c[m+40>>2]|0;F=d+40|0;c[F>>2]=h;f=c[m+44>>2]|0;G=d+44|0;c[G>>2]=f;g=c[m+48>>2]|0;H=d+48|0;c[H>>2]=g;i=c[m+52>>2]|0;I=d+52|0;c[I>>2]=i;k=c[m+56>>2]|0;J=d+56|0;c[J>>2]=k;m=c[m+60>>2]|0;K=d+60|0;c[K>>2]=m;if(!w)return;v=e<<4;e=0;while(1){M=e<<4;N=a+(M<<2)|0;c[d>>2]=o^c[N>>2];c[L>>2]=q^c[N+4>>2];c[x>>2]=t^c[N+8>>2];c[y>>2]=u^c[N+12>>2];c[z>>2]=s^c[N+16>>2];c[A>>2]=r^c[N+20>>2];c[B>>2]=p^c[N+24>>2];c[C>>2]=n^c[N+28>>2];c[D>>2]=l^c[N+32>>2];c[E>>2]=j^c[N+36>>2];c[F>>2]=h^c[N+40>>2];c[G>>2]=f^c[N+44>>2];c[H>>2]=g^c[N+48>>2];c[I>>2]=i^c[N+52>>2];c[J>>2]=k^c[N+56>>2];c[K>>2]=m^c[N+60>>2];jc(d);u=e<<3;t=b+(u<<2)|0;c[t>>2]=c[d>>2];c[t+4>>2]=c[L>>2];c[t+8>>2]=c[x>>2];c[t+12>>2]=c[y>>2];c[t+16>>2]=c[z>>2];c[t+20>>2]=c[A>>2];c[t+24>>2]=c[B>>2];c[t+28>>2]=c[C>>2];c[t+32>>2]=c[D>>2];c[t+36>>2]=c[E>>2];c[t+40>>2]=c[F>>2];c[t+44>>2]=c[G>>2];c[t+48>>2]=c[H>>2];c[t+52>>2]=c[I>>2];c[t+56>>2]=c[J>>2];c[t+60>>2]=c[K>>2];t=a+((M|16)<<2)|0;c[d>>2]=c[d>>2]^c[t>>2];c[L>>2]=c[L>>2]^c[t+4>>2];c[x>>2]=c[x>>2]^c[t+8>>2];c[y>>2]=c[y>>2]^c[t+12>>2];c[z>>2]=c[z>>2]^c[t+16>>2];c[A>>2]=c[A>>2]^c[t+20>>2];c[B>>2]=c[B>>2]^c[t+24>>2];c[C>>2]=c[C>>2]^c[t+28>>2];c[D>>2]=c[D>>2]^c[t+32>>2];c[E>>2]=c[E>>2]^c[t+36>>2];c[F>>2]=c[F>>2]^c[t+40>>2];c[G>>2]=c[G>>2]^c[t+44>>2];c[H>>2]=c[H>>2]^c[t+48>>2];c[I>>2]=c[I>>2]^c[t+52>>2];c[J>>2]=c[J>>2]^c[t+56>>2];c[K>>2]=c[K>>2]^c[t+60>>2];jc(d);u=b+(u+v<<2)|0;c[u>>2]=c[d>>2];c[u+4>>2]=c[L>>2];c[u+8>>2]=c[x>>2];c[u+12>>2]=c[y>>2];c[u+16>>2]=c[z>>2];c[u+20>>2]=c[A>>2];c[u+24>>2]=c[B>>2];c[u+28>>2]=c[C>>2];c[u+32>>2]=c[D>>2];c[u+36>>2]=c[E>>2];c[u+40>>2]=c[F>>2];c[u+44>>2]=c[G>>2];c[u+48>>2]=c[H>>2];c[u+52>>2]=c[I>>2];c[u+56>>2]=c[J>>2];c[u+60>>2]=c[K>>2];e=e+2|0;if(e>>>0>=w>>>0)break;f=c[G>>2]|0;g=c[H>>2]|0;i=c[I>>2]|0;k=c[J>>2]|0;m=c[K>>2]|0;o=c[d>>2]|0;q=c[L>>2]|0;t=c[x>>2]|0;u=c[y>>2]|0;s=c[z>>2]|0;r=c[A>>2]|0;p=c[B>>2]|0;n=c[C>>2]|0;l=c[D>>2]|0;j=c[E>>2]|0;h=c[F>>2]|0}return}function jc(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0;b=a+4|0;z=a+8|0;A=a+12|0;B=a+16|0;F=a+20|0;f=a+24|0;k=a+28|0;n=a+32|0;s=a+36|0;t=a+40|0;u=a+44|0;v=a+48|0;w=a+52|0;x=a+56|0;y=a+60|0;d=c[b>>2]|0;e=c[F>>2]|0;g=c[s>>2]|0;h=c[w>>2]|0;i=c[f>>2]|0;j=c[t>>2]|0;l=c[x>>2]|0;m=c[z>>2]|0;o=c[u>>2]|0;p=c[y>>2]|0;q=c[A>>2]|0;r=c[k>>2]|0;C=c[v>>2]|0;D=c[a>>2]|0;E=c[B>>2]|0;G=c[n>>2]|0;H=0;do{R=C+D|0;R=(R<<7|R>>>25)^E;O=R+D|0;O=(O<<9|O>>>23)^G;L=O+R|0;L=(L<<13|L>>>19)^C;U=L+O|0;U=(U<<18|U>>>14)^D;N=d+e|0;N=(N<<7|N>>>25)^g;K=N+e|0;K=(K<<9|K>>>23)^h;X=K+N|0;X=(X<<13|X>>>19)^d;Q=X+K|0;Q=(Q<<18|Q>>>14)^e;J=i+j|0;J=(J<<7|J>>>25)^l;W=J+j|0;W=(W<<9|W>>>23)^m;T=W+J|0;T=(T<<13|T>>>19)^i;M=T+W|0;M=(M<<18|M>>>14)^j;V=o+p|0;V=(V<<7|V>>>25)^q;S=V+p|0;S=(S<<9|S>>>23)^r;P=S+V|0;P=(P<<13|P>>>19)^o;I=P+S|0;I=(I<<18|I>>>14)^p;Y=V+U|0;d=(Y<<7|Y>>>25)^X;X=d+U|0;m=(X<<9|X>>>23)^W;W=m+d|0;q=(W<<13|W>>>19)^V;V=q+m|0;D=(V<<18|V>>>14)^U;U=R+Q|0;i=(U<<7|U>>>25)^T;T=i+Q|0;r=(T<<9|T>>>23)^S;S=r+i|0;E=(S<<13|S>>>19)^R;R=E+r|0;e=(R<<18|R>>>14)^Q;Q=N+M|0;o=(Q<<7|Q>>>25)^P;P=o+M|0;G=(P<<9|P>>>23)^O;O=G+o|0;g=(O<<13|O>>>19)^N;N=g+G|0;j=(N<<18|N>>>14)^M;M=J+I|0;C=(M<<7|M>>>25)^L;L=C+I|0;h=(L<<9|L>>>23)^K;K=h+C|0;l=(K<<13|K>>>19)^J;J=l+h|0;p=(J<<18|J>>>14)^I;H=H+2|0}while(H>>>0<8);c[a>>2]=(c[a>>2]|0)+D;c[b>>2]=(c[b>>2]|0)+d;c[z>>2]=(c[z>>2]|0)+m;c[A>>2]=(c[A>>2]|0)+q;c[B>>2]=(c[B>>2]|0)+E;c[F>>2]=(c[F>>2]|0)+e;c[f>>2]=(c[f>>2]|0)+i;c[k>>2]=(c[k>>2]|0)+r;c[n>>2]=(c[n>>2]|0)+G;c[s>>2]=(c[s>>2]|0)+g;c[t>>2]=(c[t>>2]|0)+j;c[u>>2]=(c[u>>2]|0)+o;c[v>>2]=(c[v>>2]|0)+C;c[w>>2]=(c[w>>2]|0)+h;c[x>>2]=(c[x>>2]|0)+l;c[y>>2]=(c[y>>2]|0)+p;return}function kc(){return 32}function lc(){return 32}function mc(a,b){a=a|0;b=b|0;md(a,b,33785);return 0}function nc(a,b,c){a=a|0;b=b|0;c=c|0;md(a,b,c);return 0}function oc(){return 32}function pc(){return 24}function qc(){return 16}function rc(b,c,d,e,f,g,h){b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;r=i;q=i=i+63&-64;i=i+240|0;p=q;o=q+176|0;q=q+144|0;nb(q,g,h,32988);h=b;j=d;if(b>>>0>=d>>>0?0<f>>>0|0==(f|0)&(h-j|0)>>>0<e>>>0:0)k=5;else if(d>>>0>=b>>>0?0<f>>>0|0==(f|0)&(j-h|0)>>>0<e>>>0:0)k=5;if((k|0)==5){Jd(b|0,d|0,e|0)|0;d=b}h=o;k=h+32|0;do{a[h>>0]=0;h=h+1|0}while((h|0)<(k|0));l=f>>>0>0|(f|0)==0&e>>>0>32;m=l?32:e;n=l?0:f;h=(m|0)==0&(n|0)==0;if(!h){k=f>>>0<0|(f|0)==0&e>>>0<32;k=Dd((k?e:32)|0,(k?f:0)|0,-1,0)|0;Id(o+32|0,d|0,k+1|0)|0}k=Dd(m|0,n|0,32,0)|0;j=g+16|0;nd(o,o,k,C,j,0,0,q);Ub(p,o);if(!h){g=f>>>0<0|(f|0)==0&e>>>0<32;g=Dd((g?e:32)|0,(g?f:0)|0,-1,0)|0;Id(b|0,o+32|0,g+1|0)|0}h=o;k=h+64|0;do{a[h>>0]=0;h=h+1|0}while((h|0)<(k|0));if(!l){Tb(p,b,e,f);Rb(p,c);i=r;return 0}o=Cd(e|0,f|0,m|0,n|0)|0;nd(b+m|0,d+m|0,o,C,j,1,0,q);Tb(p,b,e,f);Rb(p,c);i=r;return 0}function sc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(d>>>0>0|(d|0)==0&c>>>0>4294967279){e=-1;return e|0}rc(a+16|0,a,b,c,d,e,f)|0;e=0;return e|0}function tc(b,e,f,g,h,j,k){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;t=i;s=i=i+63&-64;i=i+208|0;m=s;o=s+144|0;n=s+112|0;r=s+48|0;s=s+16|0;nb(s,j,k,32988);q=j+16|0;k=n;j=s;l=k+32|0;do{a[k>>0]=a[j>>0]|0;k=k+1|0;j=j+1|0}while((k|0)<(l|0));l=q;j=l;l=l+4|0;l=d[l>>0]|d[l+1>>0]<<8|d[l+2>>0]<<16|d[l+3>>0]<<24;k=m;c[k>>2]=d[j>>0]|d[j+1>>0]<<8|d[j+2>>0]<<16|d[j+3>>0]<<24;c[k+4>>2]=l;k=m+8|0;c[k>>2]=0;c[k+4>>2]=0;ob(o,m,n,33817);k=0;do{a[r+k>>0]=a[o+k>>0]|0;k=k+1|0}while((k|0)!=32);if(Qb(f,e,g,h,r)|0){k=s;l=k+32|0;do{a[k>>0]=0;k=k+1|0}while((k|0)<(l|0));s=-1;i=t;return s|0}k=e;j=b;if(e>>>0>=b>>>0?0<h>>>0|0==(h|0)&(k-j|0)>>>0<g>>>0:0)p=9;else if(b>>>0>=e>>>0?0<h>>>0|0==(h|0)&(j-k|0)>>>0<g>>>0:0)p=9;if((p|0)==9){Jd(b|0,e|0,g|0)|0;e=b}k=h>>>0>0|(h|0)==0&g>>>0>32;j=k?32:g;l=k?0:h;if((j|0)==0&(l|0)==0)nd(r,r,32,0,q,0,0,s);else{f=r+32|0;p=h>>>0<0|(h|0)==0&g>>>0<32;p=Dd((p?g:32)|0,(p?h:0)|0,-1,0)|0;p=p+1|0;Id(f|0,e|0,p|0)|0;o=Dd(j|0,l|0,32,0)|0;nd(r,r,o,C,q,0,0,s);Id(b|0,f|0,p|0)|0}if(k){r=Cd(g|0,h|0,j|0,l|0)|0;nd(b+j|0,e+j|0,r,C,q,1,0,s)}k=s;l=k+32|0;do{a[k>>0]=0;k=k+1|0}while((k|0)<(l|0));s=0;i=t;return s|0}function uc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(d>>>0<0|(d|0)==0&c>>>0<16){e=-1;return e|0}d=Dd(c|0,d|0,-16,-1)|0;e=tc(a,b+16|0,b,d,C,e,f)|0;return e|0}function vc(){return 8}function wc(){return 16}function xc(b,c,e,f,g){b=b|0;c=c|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;h=d[g>>0]|0;o=Hd(d[g+1>>0]|0|0,0,8)|0;n=C;j=Hd(d[g+2>>0]|0|0,0,16)|0;n=n|C;k=Hd(d[g+3>>0]|0|0,0,24)|0;n=n|C|(d[g+4>>0]|0);r=Hd(d[g+5>>0]|0|0,0,40)|0;n=n|C;i=Hd(d[g+6>>0]|0|0,0,48)|0;n=n|C;l=Hd(d[g+7>>0]|0|0,0,56)|0;l=o|h|j|k|r|i|l;n=n|C;i=d[g+8>>0]|0;r=Hd(d[g+9>>0]|0|0,0,8)|0;k=C;j=Hd(d[g+10>>0]|0|0,0,16)|0;k=k|C;h=Hd(d[g+11>>0]|0|0,0,24)|0;k=k|C|(d[g+12>>0]|0);o=Hd(d[g+13>>0]|0|0,0,40)|0;k=k|C;p=Hd(d[g+14>>0]|0|0,0,48)|0;k=k|C;m=Hd(d[g+15>>0]|0|0,0,56)|0;m=r|i|j|h|o|p|m;k=k|C;p=e&7;o=c+e+(0-p)|0;e=Hd(e|0,f|0,56)|0;g=C;h=m^2037671283;j=k^1952801890;i=l^1852142177;f=n^1819895653;m=m^1852075885;k=k^1685025377;l=l^1886610805;n=n^1936682341;if((o|0)!=(c|0)){do{x=d[c>>0]|0;y=Hd(d[c+1>>0]|0|0,0,8)|0;r=C;w=Hd(d[c+2>>0]|0|0,0,16)|0;r=r|C;t=Hd(d[c+3>>0]|0|0,0,24)|0;r=r|C|(d[c+4>>0]|0);u=Hd(d[c+5>>0]|0|0,0,40)|0;r=r|C;v=Hd(d[c+6>>0]|0|0,0,48)|0;r=r|C;s=Hd(d[c+7>>0]|0|0,0,56)|0;s=y|x|w|t|u|v|s;r=r|C;v=s^h;u=r^j;n=Dd(l|0,n|0,m|0,k|0)|0;l=C;t=Hd(m|0,k|0,13)|0;h=C;m=Gd(m|0,k|0,51)|0;m=(t|m)^n;h=(h|C)^l;f=Dd(v|0,u|0,i|0,f|0)|0;i=C;t=Hd(v|0,u|0,16)|0;j=C;u=Gd(v|0,u|0,48)|0;u=(t|u)^f;j=(j|C)^i;n=Dd(u|0,j|0,l|0,n|0)|0;l=C;t=Hd(u|0,j|0,21)|0;k=C;j=Gd(u|0,j|0,43)|0;j=(t|j)^n;k=(k|C)^l;i=Dd(f|0,i|0,m|0,h|0)|0;f=C;t=Hd(m|0,h|0,17)|0;u=C;h=Gd(m|0,h|0,47)|0;h=i^(t|h);u=f^(u|C);l=Dd(n|0,l|0,h|0,u|0)|0;n=C;t=Hd(h|0,u|0,13)|0;m=C;u=Gd(h|0,u|0,51)|0;u=(t|u)^l;m=(m|C)^n;i=Dd(j|0,k|0,f|0,i|0)|0;f=C;t=Hd(j|0,k|0,16)|0;h=C;k=Gd(j|0,k|0,48)|0;k=(t|k)^i;h=(h|C)^f;l=Dd(k|0,h|0,n|0,l|0)|0;n=C;t=Hd(k|0,h|0,21)|0;j=C;h=Gd(k|0,h|0,43)|0;h=(t|h)^l;j=(j|C)^n;f=Dd(i|0,f|0,u|0,m|0)|0;i=C;t=Hd(u|0,m|0,17)|0;k=C;m=Gd(u|0,m|0,47)|0;m=(t|m)^f;k=(k|C)^i;l=l^s;n=n^r;c=c+8|0}while((c|0)!=(o|0));c=o}switch(p|0){case 7:{e=Hd(d[c+6>>0]|0|0,0,48)|0|e;g=C|g;q=5;break}case 6:{q=5;break}case 5:{q=6;break}case 4:{q=7;break}case 3:{q=8;break}case 2:{q=9;break}case 1:{q=10;break}default:{}}if((q|0)==5){y=Hd(d[c+5>>0]|0|0,0,40)|0;g=C|g;e=y|e;q=6}if((q|0)==6){g=d[c+4>>0]|0|g;q=7}if((q|0)==7){y=Hd(d[c+3>>0]|0|0,0,24)|0;e=y|e;g=C|g;q=8}if((q|0)==8){y=Hd(d[c+2>>0]|0|0,0,16)|0;e=y|e;g=C|g;q=9}if((q|0)==9){y=Hd(d[c+1>>0]|0|0,0,8)|0;e=y|e;g=C|g;q=10}if((q|0)==10)e=d[c>>0]|0|e;y=e^h;r=g^j;s=Dd(l|0,n|0,m|0,k|0)|0;q=C;w=Hd(m|0,k|0,13)|0;t=C;x=Gd(m|0,k|0,51)|0;x=(w|x)^s;t=(t|C)^q;w=Dd(y|0,r|0,i|0,f|0)|0;v=C;u=Hd(y|0,r|0,16)|0;p=C;r=Gd(y|0,r|0,48)|0;r=(u|r)^w;p=(p|C)^v;s=Dd(r|0,p|0,q|0,s|0)|0;q=C;u=Hd(r|0,p|0,21)|0;y=C;p=Gd(r|0,p|0,43)|0;p=(u|p)^s;y=(y|C)^q;v=Dd(w|0,v|0,x|0,t|0)|0;w=C;u=Hd(x|0,t|0,17)|0;r=C;t=Gd(x|0,t|0,47)|0;t=v^(u|t);r=w^(r|C);q=Dd(s|0,q|0,t|0,r|0)|0;s=C;u=Hd(t|0,r|0,13)|0;x=C;r=Gd(t|0,r|0,51)|0;r=(u|r)^q;x=(x|C)^s;v=Dd(p|0,y|0,w|0,v|0)|0;w=C;u=Hd(p|0,y|0,16)|0;t=C;y=Gd(p|0,y|0,48)|0;y=(u|y)^v;t=(t|C)^w;q=Dd(y|0,t|0,s|0,q|0)|0;s=C;u=Hd(y|0,t|0,21)|0;p=C;t=Gd(y|0,t|0,43)|0;t=(u|t)^q;p=(p|C)^s;w=Dd(v|0,w|0,r|0,x|0)|0;v=C;u=Hd(r|0,x|0,17)|0;y=C;x=Gd(r|0,x|0,47)|0;x=(u|x)^w;y=(y|C)^v;s=Dd(q^e|0,s^g|0,x|0,y|0)|0;q=C;u=Hd(x|0,y|0,13)|0;r=C;y=Gd(x|0,y|0,51)|0;y=s^(u|y);r=q^(r|C);w=Dd(t|0,p|0,v^255|0,w|0)|0;v=C;u=Hd(t|0,p|0,16)|0;x=C;p=Gd(t|0,p|0,48)|0;p=(u|p)^w;x=(x|C)^v;s=Dd(p|0,x|0,q|0,s|0)|0;q=C;u=Hd(p|0,x|0,21)|0;t=C;x=Gd(p|0,x|0,43)|0;x=(u|x)^s;t=(t|C)^q;v=Dd(w|0,v|0,y|0,r|0)|0;w=C;u=Hd(y|0,r|0,17)|0;p=C;r=Gd(y|0,r|0,47)|0;r=(u|r)^v;p=(p|C)^w;q=Dd(s|0,q|0,r|0,p|0)|0;s=C;u=Hd(r|0,p|0,13)|0;y=C;p=Gd(r|0,p|0,51)|0;p=(u|p)^q;y=(y|C)^s;v=Dd(x|0,t|0,w|0,v|0)|0;w=C;u=Hd(x|0,t|0,16)|0;r=C;t=Gd(x|0,t|0,48)|0;t=(u|t)^v;r=(r|C)^w;q=Dd(t|0,r|0,s|0,q|0)|0;s=C;u=Hd(t|0,r|0,21)|0;x=C;r=Gd(t|0,r|0,43)|0;r=(u|r)^q;x=(x|C)^s;w=Dd(v|0,w|0,p|0,y|0)|0;v=C;u=Hd(p|0,y|0,17)|0;t=C;y=Gd(p|0,y|0,47)|0;y=(u|y)^w;t=(t|C)^v;s=Dd(q|0,s|0,y|0,t|0)|0;q=C;u=Hd(y|0,t|0,13)|0;p=C;t=Gd(y|0,t|0,51)|0;t=(u|t)^s;p=(p|C)^q;w=Dd(r|0,x|0,v|0,w|0)|0;v=C;u=Hd(r|0,x|0,16)|0;y=C;x=Gd(r|0,x|0,48)|0;x=(u|x)^w;y=(y|C)^v;s=Dd(x|0,y|0,q|0,s|0)|0;q=C;u=Hd(x|0,y|0,21)|0;r=C;y=Gd(x|0,y|0,43)|0;y=(u|y)^s;r=(r|C)^q;v=Dd(w|0,v|0,t|0,p|0)|0;w=C;u=Hd(t|0,p|0,17)|0;x=C;p=Gd(t|0,p|0,47)|0;p=(u|p)^v;x=(x|C)^w;q=Dd(s|0,q|0,p|0,x|0)|0;s=C;u=Hd(p|0,x|0,13)|0;t=C;x=Gd(p|0,x|0,51)|0;q=(u|x)^q;s=(t|C)^s;v=Dd(y|0,r|0,w|0,v|0)|0;w=C;t=Hd(y|0,r|0,16)|0;x=C;r=Gd(y|0,r|0,48)|0;r=(t|r)^v;x=(x|C)^w;t=Hd(r|0,x|0,21)|0;y=C;x=Gd(r|0,x|0,43)|0;y=y|C;w=Dd(v|0,w|0,q|0,s|0)|0;v=C;r=Hd(q|0,s|0,17)|0;u=C;s=Gd(q|0,s|0,47)|0;x=(r|s)^w^v^(t|x);y=(u|C)^v^w^y;a[b>>0]=x;a[b+1>>0]=x>>>8;a[b+2>>0]=x>>>16;a[b+3>>0]=x>>>24;a[b+4>>0]=y;w=Gd(x|0,y|0,40)|0;a[b+5>>0]=w;w=Gd(x|0,y|0,48)|0;a[b+6>>0]=w;y=Gd(x|0,y|0,56)|0;a[b+7>>0]=y;return 0}function yc(){return 64}function zc(){return 32}function Ac(){return 32}function Bc(){return 64}function Cc(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;o=i;h=i=i+63&-64;i=i+496|0;k=h;j=h+448|0;l=h+408|0;m=h+368|0;h=h+208|0;g=k+64|0;n=k;p=8;q=n+64|0;do{c[n>>2]=c[p>>2];n=n+4|0;p=p+4|0}while((n|0)<(q|0));n=k+72|0;c[n>>2]=256;c[n+4>>2]=0;n=g;c[n>>2]=0;c[n+4>>2]=0;n=k+80|0;p=f;q=n+32|0;do{a[n>>0]=a[p>>0]|0;n=n+1|0;p=p+1|0}while((n|0)<(q|0));Gb(k,e);a[e>>0]=(d[e>>0]|0)&248;q=e+31|0;a[q>>0]=(d[q>>0]|0)&63|64;Rc(h,e);Ic(j,h+80|0);Jc(l,h,j);Jc(m,h+40|0,j);Lc(b,m);Lc(k,l);q=b+31|0;a[q>>0]=(d[q>>0]|0)^(d[k>>0]|0)<<7;Jd(e|0,f|0,32)|0;Jd(e+32|0,b|0,32)|0;i=o;return 0}function Dc(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;q=i;n=i=i+63&-64;i=i+528|0;m=n;l=n+448|0;o=n+408|0;p=n+368|0;k=n+208|0;n=n+488|0;f=0;do{a[n+f>>0]=Ba(0)|0;f=f+1|0}while((f|0)!=32);f=m+64|0;g=m;h=8;j=g+64|0;do{c[g>>2]=c[h>>2];g=g+4|0;h=h+4|0}while((g|0)<(j|0));g=m+72|0;c[g>>2]=256;c[g+4>>2]=0;g=f;c[g>>2]=0;c[g+4>>2]=0;g=m+80|0;h=n;j=g+32|0;do{a[g>>0]=a[h>>0]|0;g=g+1|0;h=h+1|0}while((g|0)<(j|0));Gb(m,e);a[e>>0]=(d[e>>0]|0)&248;g=e+31|0;a[g>>0]=(d[g>>0]|0)&63|64;Rc(k,e);Ic(l,k+80|0);Jc(o,k,l);Jc(p,k+40|0,l);Lc(b,p);Lc(m,o);g=b+31|0;a[g>>0]=(d[g>>0]|0)^(d[m>>0]|0)<<7;g=e;h=n;j=g+32|0;do{a[g>>0]=a[h>>0]|0;g=g+1|0;h=h+1|0}while((g|0)<(j|0));Jd(e+32|0,b|0,32)|0;i=q;return 0}function Ec(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0;h=i;j=i=i+63&-64;i=i+16|0;k=a+64|0;Jd(k|0,d|0,e|0)|0;Xc(a,j,k,e,f,g);g=j;d=(b|0)!=0;if((c[g>>2]|0)==64&(c[g+4>>2]|0)==0){if(!d){k=0;i=h;return k|0}j=Dd(e|0,f|0,64,0)|0;k=b;c[k>>2]=j;c[k+4>>2]=C;k=0;i=h;return k|0}else{if(d){k=b;c[k>>2]=0;c[k+4>>2]=0}k=Dd(e|0,f|0,64,0)|0;Fd(a|0,0,k|0)|0;k=-1;i=h;return k|0}return 0}function Fc(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;e=Dd(e|0,f|0,-64,-1)|0;f=C;do if(!(f>>>0>0|(f|0)==0&e>>>0>4294967231)){h=d+64|0;if(Vc(d,h,e,f,g)|0){Fd(a|0,0,e|0)|0;break}if(b){d=b;c[d>>2]=e;c[d+4>>2]=f}Jd(a|0,h|0,e|0)|0;d=0;return d|0}while(0);if(!b){d=-1;return d|0}d=b;c[d>>2]=0;c[d+4>>2]=0;d=-1;return d|0}function Gc(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;Xc(a,b,c,d,e,f);return 0}function Hc(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return Vc(a,b,c,d,e)|0}function Ic(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;g=i;c=i=i+63&-64;i=i+160|0;d=c+120|0;e=c+80|0;f=c+40|0;Kc(d,b);Kc(e,d);Kc(e,e);Jc(e,b,e);Jc(d,d,e);Kc(f,d);Jc(e,e,f);Kc(f,e);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Jc(e,f,e);Kc(f,e);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Jc(f,f,e);Kc(c,f);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Kc(c,c);Jc(f,c,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Kc(f,f);Jc(e,f,e);Kc(f,e);b=1;do{Kc(f,f);b=b+1|0}while((b|0)!=50);Jc(f,f,e);Kc(c,f);b=1;do{Kc(c,c);b=b+1|0}while((b|0)!=100);Jc(f,c,f);Kc(f,f);b=1;do{Kc(f,f);b=b+1|0}while((b|0)!=50);Jc(e,f,e);Kc(e,e);Kc(e,e);Kc(e,e);Kc(e,e);Kc(e,e);Jc(a,e,d);i=g;return}function Jc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0,Yb=0,Zb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0,kc=0,lc=0,mc=0,nc=0,oc=0,pc=0,qc=0,rc=0,sc=0,tc=0,uc=0,vc=0,wc=0,xc=0,yc=0,zc=0,Ac=0,Bc=0,Cc=0,Dc=0,Ec=0,Fc=0,Gc=0,Hc=0,Ic=0,Jc=0,Kc=0,Lc=0,Mc=0,Nc=0,Oc=0,Pc=0,Qc=0,Rc=0,Sc=0;l=c[b>>2]|0;s=c[b+4>>2]|0;j=c[b+8>>2]|0;Rb=c[b+12>>2]|0;e=c[b+16>>2]|0;za=c[b+20>>2]|0;ya=c[b+24>>2]|0;zb=c[b+28>>2]|0;h=c[b+32>>2]|0;ga=c[b+36>>2]|0;H=c[d>>2]|0;J=c[d+4>>2]|0;F=c[d+8>>2]|0;D=c[d+12>>2]|0;A=c[d+16>>2]|0;y=c[d+20>>2]|0;w=c[d+24>>2]|0;u=c[d+28>>2]|0;k=c[d+32>>2]|0;t=c[d+36>>2]|0;Oc=J*19|0;bc=F*19|0;rb=D*19|0;Ha=A*19|0;jc=y*19|0;Db=w*19|0;Ta=u*19|0;Sc=k*19|0;Qc=t*19|0;p=s<<1;f=Rb<<1;M=za<<1;i=zb<<1;d=ga<<1;o=((l|0)<0)<<31>>31;I=((H|0)<0)<<31>>31;Mc=Od(H|0,I|0,l|0,o|0)|0;Lc=C;K=((J|0)<0)<<31>>31;wc=Od(J|0,K|0,l|0,o|0)|0;vc=C;G=((F|0)<0)<<31>>31;ub=Od(F|0,G|0,l|0,o|0)|0;tb=C;E=((D|0)<0)<<31>>31;Ka=Od(D|0,E|0,l|0,o|0)|0;Ja=C;B=((A|0)<0)<<31>>31;mc=Od(A|0,B|0,l|0,o|0)|0;lc=C;z=((y|0)<0)<<31>>31;Gb=Od(y|0,z|0,l|0,o|0)|0;Fb=C;x=((w|0)<0)<<31>>31;Wa=Od(w|0,x|0,l|0,o|0)|0;Va=C;v=((u|0)<0)<<31>>31;ja=Od(u|0,v|0,l|0,o|0)|0;ia=C;Pc=((k|0)<0)<<31>>31;P=Od(k|0,Pc|0,l|0,o|0)|0;O=C;o=Od(t|0,((t|0)<0)<<31>>31|0,l|0,o|0)|0;l=C;t=((s|0)<0)<<31>>31;dc=Od(H|0,I|0,s|0,t|0)|0;ec=C;n=((p|0)<0)<<31>>31;yb=Od(J|0,K|0,p|0,n|0)|0;xb=C;Ma=Od(F|0,G|0,s|0,t|0)|0;La=C;oc=Od(D|0,E|0,p|0,n|0)|0;nc=C;Ib=Od(A|0,B|0,s|0,t|0)|0;Hb=C;Ya=Od(y|0,z|0,p|0,n|0)|0;Xa=C;la=Od(w|0,x|0,s|0,t|0)|0;ka=C;R=Od(u|0,v|0,p|0,n|0)|0;Q=C;t=Od(k|0,Pc|0,s|0,t|0)|0;s=C;Pc=((Qc|0)<0)<<31>>31;n=Od(Qc|0,Pc|0,p|0,n|0)|0;p=C;k=((j|0)<0)<<31>>31;wb=Od(H|0,I|0,j|0,k|0)|0;vb=C;Qa=Od(J|0,K|0,j|0,k|0)|0;Pa=C;qc=Od(F|0,G|0,j|0,k|0)|0;pc=C;Kb=Od(D|0,E|0,j|0,k|0)|0;Jb=C;_a=Od(A|0,B|0,j|0,k|0)|0;Za=C;na=Od(y|0,z|0,j|0,k|0)|0;ma=C;T=Od(w|0,x|0,j|0,k|0)|0;S=C;v=Od(u|0,v|0,j|0,k|0)|0;u=C;Rc=((Sc|0)<0)<<31>>31;yc=Od(Sc|0,Rc|0,j|0,k|0)|0;xc=C;k=Od(Qc|0,Pc|0,j|0,k|0)|0;j=C;Sb=((Rb|0)<0)<<31>>31;Oa=Od(H|0,I|0,Rb|0,Sb|0)|0;Na=C;fa=((f|0)<0)<<31>>31;uc=Od(J|0,K|0,f|0,fa|0)|0;tc=C;Mb=Od(F|0,G|0,Rb|0,Sb|0)|0;Lb=C;ab=Od(D|0,E|0,f|0,fa|0)|0;$a=C;pa=Od(A|0,B|0,Rb|0,Sb|0)|0;oa=C;V=Od(y|0,z|0,f|0,fa|0)|0;U=C;x=Od(w|0,x|0,Rb|0,Sb|0)|0;w=C;Ua=((Ta|0)<0)<<31>>31;Ac=Od(Ta|0,Ua|0,f|0,fa|0)|0;zc=C;Sb=Od(Sc|0,Rc|0,Rb|0,Sb|0)|0;Rb=C;fa=Od(Qc|0,Pc|0,f|0,fa|0)|0;f=C;N=((e|0)<0)<<31>>31;sc=Od(H|0,I|0,e|0,N|0)|0;rc=C;Qb=Od(J|0,K|0,e|0,N|0)|0;Pb=C;cb=Od(F|0,G|0,e|0,N|0)|0;bb=C;ra=Od(D|0,E|0,e|0,N|0)|0;qa=C;X=Od(A|0,B|0,e|0,N|0)|0;W=C;z=Od(y|0,z|0,e|0,N|0)|0;y=C;Eb=((Db|0)<0)<<31>>31;Cc=Od(Db|0,Eb|0,e|0,N|0)|0;Bc=C;Ub=Od(Ta|0,Ua|0,e|0,N|0)|0;Tb=C;ib=Od(Sc|0,Rc|0,e|0,N|0)|0;hb=C;N=Od(Qc|0,Pc|0,e|0,N|0)|0;e=C;Aa=((za|0)<0)<<31>>31;Ob=Od(H|0,I|0,za|0,Aa|0)|0;Nb=C;b=((M|0)<0)<<31>>31;gb=Od(J|0,K|0,M|0,b|0)|0;fb=C;ta=Od(F|0,G|0,za|0,Aa|0)|0;sa=C;Z=Od(D|0,E|0,M|0,b|0)|0;Y=C;B=Od(A|0,B|0,za|0,Aa|0)|0;A=C;kc=((jc|0)<0)<<31>>31;Ec=Od(jc|0,kc|0,M|0,b|0)|0;Dc=C;Wb=Od(Db|0,Eb|0,za|0,Aa|0)|0;Vb=C;kb=Od(Ta|0,Ua|0,M|0,b|0)|0;jb=C;Aa=Od(Sc|0,Rc|0,za|0,Aa|0)|0;za=C;b=Od(Qc|0,Pc|0,M|0,b|0)|0;M=C;g=((ya|0)<0)<<31>>31;eb=Od(H|0,I|0,ya|0,g|0)|0;db=C;xa=Od(J|0,K|0,ya|0,g|0)|0;wa=C;$=Od(F|0,G|0,ya|0,g|0)|0;_=C;E=Od(D|0,E|0,ya|0,g|0)|0;D=C;Ia=((Ha|0)<0)<<31>>31;Gc=Od(Ha|0,Ia|0,ya|0,g|0)|0;Fc=C;Yb=Od(jc|0,kc|0,ya|0,g|0)|0;Xb=C;mb=Od(Db|0,Eb|0,ya|0,g|0)|0;lb=C;Ca=Od(Ta|0,Ua|0,ya|0,g|0)|0;Ba=C;m=Od(Sc|0,Rc|0,ya|0,g|0)|0;r=C;g=Od(Qc|0,Pc|0,ya|0,g|0)|0;ya=C;Ab=((zb|0)<0)<<31>>31;va=Od(H|0,I|0,zb|0,Ab|0)|0;ua=C;ea=((i|0)<0)<<31>>31;da=Od(J|0,K|0,i|0,ea|0)|0;ca=C;G=Od(F|0,G|0,zb|0,Ab|0)|0;F=C;sb=((rb|0)<0)<<31>>31;Ic=Od(rb|0,sb|0,i|0,ea|0)|0;Hc=C;_b=Od(Ha|0,Ia|0,zb|0,Ab|0)|0;Zb=C;ob=Od(jc|0,kc|0,i|0,ea|0)|0;nb=C;Ea=Od(Db|0,Eb|0,zb|0,Ab|0)|0;Da=C;gc=Od(Ta|0,Ua|0,i|0,ea|0)|0;fc=C;Ab=Od(Sc|0,Rc|0,zb|0,Ab|0)|0;zb=C;ea=Od(Qc|0,Pc|0,i|0,ea|0)|0;i=C;L=((h|0)<0)<<31>>31;ba=Od(H|0,I|0,h|0,L|0)|0;aa=C;K=Od(J|0,K|0,h|0,L|0)|0;J=C;cc=((bc|0)<0)<<31>>31;Kc=Od(bc|0,cc|0,h|0,L|0)|0;Jc=C;ac=Od(rb|0,sb|0,h|0,L|0)|0;$b=C;qb=Od(Ha|0,Ia|0,h|0,L|0)|0;pb=C;Ga=Od(jc|0,kc|0,h|0,L|0)|0;Fa=C;ic=Od(Db|0,Eb|0,h|0,L|0)|0;hc=C;Cb=Od(Ta|0,Ua|0,h|0,L|0)|0;Bb=C;Sa=Od(Sc|0,Rc|0,h|0,L|0)|0;Ra=C;L=Od(Qc|0,Pc|0,h|0,L|0)|0;h=C;ha=((ga|0)<0)<<31>>31;I=Od(H|0,I|0,ga|0,ha|0)|0;H=C;q=((d|0)<0)<<31>>31;Oc=Od(Oc|0,((Oc|0)<0)<<31>>31|0,d|0,q|0)|0;Nc=C;cc=Od(bc|0,cc|0,ga|0,ha|0)|0;bc=C;sb=Od(rb|0,sb|0,d|0,q|0)|0;rb=C;Ia=Od(Ha|0,Ia|0,ga|0,ha|0)|0;Ha=C;kc=Od(jc|0,kc|0,d|0,q|0)|0;jc=C;Eb=Od(Db|0,Eb|0,ga|0,ha|0)|0;Db=C;Ua=Od(Ta|0,Ua|0,d|0,q|0)|0;Ta=C;ha=Od(Sc|0,Rc|0,ga|0,ha|0)|0;ga=C;q=Od(Qc|0,Pc|0,d|0,q|0)|0;d=C;Lc=Dd(Oc|0,Nc|0,Mc|0,Lc|0)|0;Jc=Dd(Lc|0,C|0,Kc|0,Jc|0)|0;Hc=Dd(Jc|0,C|0,Ic|0,Hc|0)|0;Fc=Dd(Hc|0,C|0,Gc|0,Fc|0)|0;Dc=Dd(Fc|0,C|0,Ec|0,Dc|0)|0;Bc=Dd(Dc|0,C|0,Cc|0,Bc|0)|0;zc=Dd(Bc|0,C|0,Ac|0,zc|0)|0;xc=Dd(zc|0,C|0,yc|0,xc|0)|0;p=Dd(xc|0,C|0,n|0,p|0)|0;n=C;ec=Dd(wc|0,vc|0,dc|0,ec|0)|0;dc=C;rc=Dd(uc|0,tc|0,sc|0,rc|0)|0;pc=Dd(rc|0,C|0,qc|0,pc|0)|0;nc=Dd(pc|0,C|0,oc|0,nc|0)|0;lc=Dd(nc|0,C|0,mc|0,lc|0)|0;jc=Dd(lc|0,C|0,kc|0,jc|0)|0;hc=Dd(jc|0,C|0,ic|0,hc|0)|0;fc=Dd(hc|0,C|0,gc|0,fc|0)|0;r=Dd(fc|0,C|0,m|0,r|0)|0;M=Dd(r|0,C|0,b|0,M|0)|0;b=C;r=Dd(p|0,n|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;m=C;bc=Dd(ec|0,dc|0,cc|0,bc|0)|0;$b=Dd(bc|0,C|0,ac|0,$b|0)|0;Zb=Dd($b|0,C|0,_b|0,Zb|0)|0;Xb=Dd(Zb|0,C|0,Yb|0,Xb|0)|0;Vb=Dd(Xb|0,C|0,Wb|0,Vb|0)|0;Tb=Dd(Vb|0,C|0,Ub|0,Tb|0)|0;Rb=Dd(Tb|0,C|0,Sb|0,Rb|0)|0;j=Dd(Rb|0,C|0,k|0,j|0)|0;j=Dd(j|0,C|0,r|0,m|0)|0;k=C;m=Hd(r|0,m|0,26)|0;m=Cd(p|0,n|0,m|0,C|0)|0;n=C;p=Dd(M|0,b|0,33554432,0)|0;p=Ed(p|0,C|0,26)|0;r=C;Nb=Dd(Qb|0,Pb|0,Ob|0,Nb|0)|0;Lb=Dd(Nb|0,C|0,Mb|0,Lb|0)|0;Jb=Dd(Lb|0,C|0,Kb|0,Jb|0)|0;Hb=Dd(Jb|0,C|0,Ib|0,Hb|0)|0;Fb=Dd(Hb|0,C|0,Gb|0,Fb|0)|0;Db=Dd(Fb|0,C|0,Eb|0,Db|0)|0;Bb=Dd(Db|0,C|0,Cb|0,Bb|0)|0;zb=Dd(Bb|0,C|0,Ab|0,zb|0)|0;ya=Dd(zb|0,C|0,g|0,ya|0)|0;ya=Dd(ya|0,C|0,p|0,r|0)|0;g=C;r=Hd(p|0,r|0,26)|0;r=Cd(M|0,b|0,r|0,C|0)|0;b=C;M=Dd(j|0,k|0,16777216,0)|0;M=Ed(M|0,C|0,25)|0;p=C;vb=Dd(yb|0,xb|0,wb|0,vb|0)|0;tb=Dd(vb|0,C|0,ub|0,tb|0)|0;rb=Dd(tb|0,C|0,sb|0,rb|0)|0;pb=Dd(rb|0,C|0,qb|0,pb|0)|0;nb=Dd(pb|0,C|0,ob|0,nb|0)|0;lb=Dd(nb|0,C|0,mb|0,lb|0)|0;jb=Dd(lb|0,C|0,kb|0,jb|0)|0;hb=Dd(jb|0,C|0,ib|0,hb|0)|0;f=Dd(hb|0,C|0,fa|0,f|0)|0;f=Dd(f|0,C|0,M|0,p|0)|0;fa=C;p=Hd(M|0,p|0,25)|0;p=Cd(j|0,k|0,p|0,C|0)|0;k=C;j=Dd(ya|0,g|0,16777216,0)|0;j=Ed(j|0,C|0,25)|0;M=C;db=Dd(gb|0,fb|0,eb|0,db|0)|0;bb=Dd(db|0,C|0,cb|0,bb|0)|0;$a=Dd(bb|0,C|0,ab|0,$a|0)|0;Za=Dd($a|0,C|0,_a|0,Za|0)|0;Xa=Dd(Za|0,C|0,Ya|0,Xa|0)|0;Va=Dd(Xa|0,C|0,Wa|0,Va|0)|0;Ta=Dd(Va|0,C|0,Ua|0,Ta|0)|0;Ra=Dd(Ta|0,C|0,Sa|0,Ra|0)|0;i=Dd(Ra|0,C|0,ea|0,i|0)|0;i=Dd(i|0,C|0,j|0,M|0)|0;ea=C;M=Hd(j|0,M|0,25)|0;M=Cd(ya|0,g|0,M|0,C|0)|0;g=C;ya=Dd(f|0,fa|0,33554432,0)|0;ya=Ed(ya|0,C|0,26)|0;j=C;Na=Dd(Qa|0,Pa|0,Oa|0,Na|0)|0;La=Dd(Na|0,C|0,Ma|0,La|0)|0;Ja=Dd(La|0,C|0,Ka|0,Ja|0)|0;Ha=Dd(Ja|0,C|0,Ia|0,Ha|0)|0;Fa=Dd(Ha|0,C|0,Ga|0,Fa|0)|0;Da=Dd(Fa|0,C|0,Ea|0,Da|0)|0;Ba=Dd(Da|0,C|0,Ca|0,Ba|0)|0;za=Dd(Ba|0,C|0,Aa|0,za|0)|0;e=Dd(za|0,C|0,N|0,e|0)|0;e=Dd(e|0,C|0,ya|0,j|0)|0;N=C;j=Hd(ya|0,j|0,26)|0;j=Cd(f|0,fa|0,j|0,C|0)|0;fa=Dd(i|0,ea|0,33554432,0)|0;fa=Ed(fa|0,C|0,26)|0;f=C;ua=Dd(xa|0,wa|0,va|0,ua|0)|0;sa=Dd(ua|0,C|0,ta|0,sa|0)|0;qa=Dd(sa|0,C|0,ra|0,qa|0)|0;oa=Dd(qa|0,C|0,pa|0,oa|0)|0;ma=Dd(oa|0,C|0,na|0,ma|0)|0;ka=Dd(ma|0,C|0,la|0,ka|0)|0;ia=Dd(ka|0,C|0,ja|0,ia|0)|0;ga=Dd(ia|0,C|0,ha|0,ga|0)|0;h=Dd(ga|0,C|0,L|0,h|0)|0;h=Dd(h|0,C|0,fa|0,f|0)|0;L=C;f=Hd(fa|0,f|0,26)|0;f=Cd(i|0,ea|0,f|0,C|0)|0;ea=Dd(e|0,N|0,16777216,0)|0;ea=Ed(ea|0,C|0,25)|0;i=C;b=Dd(ea|0,i|0,r|0,b|0)|0;r=C;i=Hd(ea|0,i|0,25)|0;i=Cd(e|0,N|0,i|0,C|0)|0;N=Dd(h|0,L|0,16777216,0)|0;N=Ed(N|0,C|0,25)|0;e=C;aa=Dd(da|0,ca|0,ba|0,aa|0)|0;_=Dd(aa|0,C|0,$|0,_|0)|0;Y=Dd(_|0,C|0,Z|0,Y|0)|0;W=Dd(Y|0,C|0,X|0,W|0)|0;U=Dd(W|0,C|0,V|0,U|0)|0;S=Dd(U|0,C|0,T|0,S|0)|0;Q=Dd(S|0,C|0,R|0,Q|0)|0;O=Dd(Q|0,C|0,P|0,O|0)|0;d=Dd(O|0,C|0,q|0,d|0)|0;d=Dd(d|0,C|0,N|0,e|0)|0;q=C;e=Hd(N|0,e|0,25)|0;e=Cd(h|0,L|0,e|0,C|0)|0;L=Dd(b|0,r|0,33554432,0)|0;L=Ed(L|0,C|0,26)|0;h=C;g=Dd(M|0,g|0,L|0,h|0)|0;h=Hd(L|0,h|0,26)|0;h=Cd(b|0,r|0,h|0,C|0)|0;r=Dd(d|0,q|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;b=C;H=Dd(K|0,J|0,I|0,H|0)|0;F=Dd(H|0,C|0,G|0,F|0)|0;D=Dd(F|0,C|0,E|0,D|0)|0;A=Dd(D|0,C|0,B|0,A|0)|0;y=Dd(A|0,C|0,z|0,y|0)|0;w=Dd(y|0,C|0,x|0,w|0)|0;u=Dd(w|0,C|0,v|0,u|0)|0;s=Dd(u|0,C|0,t|0,s|0)|0;l=Dd(s|0,C|0,o|0,l|0)|0;l=Dd(l|0,C|0,r|0,b|0)|0;o=C;b=Hd(r|0,b|0,26)|0;b=Cd(d|0,q|0,b|0,C|0)|0;q=Dd(l|0,o|0,16777216,0)|0;q=Ed(q|0,C|0,25)|0;d=C;r=Od(q|0,d|0,19,0)|0;n=Dd(r|0,C|0,m|0,n|0)|0;m=C;d=Hd(q|0,d|0,25)|0;d=Cd(l|0,o|0,d|0,C|0)|0;o=Dd(n|0,m|0,33554432,0)|0;o=Ed(o|0,C|0,26)|0;l=C;k=Dd(p|0,k|0,o|0,l|0)|0;l=Hd(o|0,l|0,26)|0;l=Cd(n|0,m|0,l|0,C|0)|0;c[a>>2]=l;c[a+4>>2]=k;c[a+8>>2]=j;c[a+12>>2]=i;c[a+16>>2]=h;c[a+20>>2]=g;c[a+24>>2]=f;c[a+28>>2]=e;c[a+32>>2]=b;c[a+36>>2]=d;return}function Kc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0;bb=c[b>>2]|0;ua=c[b+4>>2]|0;j=c[b+8>>2]|0;la=c[b+12>>2]|0;e=c[b+16>>2]|0;db=c[b+20>>2]|0;Y=c[b+24>>2]|0;La=c[b+28>>2]|0;h=c[b+32>>2]|0;b=c[b+36>>2]|0;l=bb<<1;p=ua<<1;Xa=j<<1;f=la<<1;na=e<<1;B=db<<1;m=Y<<1;i=La<<1;Ka=db*38|0;ra=Y*19|0;va=La*38|0;da=h*19|0;gb=b*38|0;cb=((bb|0)<0)<<31>>31;cb=Od(bb|0,cb|0,bb|0,cb|0)|0;bb=C;o=((l|0)<0)<<31>>31;ta=((ua|0)<0)<<31>>31;Ia=Od(l|0,o|0,ua|0,ta|0)|0;Ha=C;k=((j|0)<0)<<31>>31;Wa=Od(j|0,k|0,l|0,o|0)|0;Va=C;ma=((la|0)<0)<<31>>31;Ua=Od(la|0,ma|0,l|0,o|0)|0;Ta=C;D=((e|0)<0)<<31>>31;Oa=Od(e|0,D|0,l|0,o|0)|0;Na=C;eb=((db|0)<0)<<31>>31;ya=Od(db|0,eb|0,l|0,o|0)|0;xa=C;g=((Y|0)<0)<<31>>31;ga=Od(Y|0,g|0,l|0,o|0)|0;fa=C;Ma=((La|0)<0)<<31>>31;R=Od(La|0,Ma|0,l|0,o|0)|0;Q=C;A=((h|0)<0)<<31>>31;F=Od(h|0,A|0,l|0,o|0)|0;E=C;q=((b|0)<0)<<31>>31;o=Od(b|0,q|0,l|0,o|0)|0;l=C;n=((p|0)<0)<<31>>31;ta=Od(p|0,n|0,ua|0,ta|0)|0;ua=C;ba=Od(p|0,n|0,j|0,k|0)|0;ca=C;P=((f|0)<0)<<31>>31;Sa=Od(f|0,P|0,p|0,n|0)|0;Ra=C;Ca=Od(e|0,D|0,p|0,n|0)|0;Ba=C;d=((B|0)<0)<<31>>31;ia=Od(B|0,d|0,p|0,n|0)|0;ha=C;T=Od(Y|0,g|0,p|0,n|0)|0;S=C;O=((i|0)<0)<<31>>31;H=Od(i|0,O|0,p|0,n|0)|0;G=C;t=Od(h|0,A|0,p|0,n|0)|0;s=C;fb=((gb|0)<0)<<31>>31;n=Od(gb|0,fb|0,p|0,n|0)|0;p=C;Qa=Od(j|0,k|0,j|0,k|0)|0;Pa=C;Ya=((Xa|0)<0)<<31>>31;Aa=Od(Xa|0,Ya|0,la|0,ma|0)|0;za=C;ka=Od(e|0,D|0,Xa|0,Ya|0)|0;ja=C;X=Od(db|0,eb|0,Xa|0,Ya|0)|0;W=C;N=Od(Y|0,g|0,Xa|0,Ya|0)|0;M=C;v=Od(La|0,Ma|0,Xa|0,Ya|0)|0;u=C;ea=((da|0)<0)<<31>>31;Ya=Od(da|0,ea|0,Xa|0,Ya|0)|0;Xa=C;k=Od(gb|0,fb|0,j|0,k|0)|0;j=C;ma=Od(f|0,P|0,la|0,ma|0)|0;la=C;V=Od(f|0,P|0,e|0,D|0)|0;U=C;J=Od(B|0,d|0,f|0,P|0)|0;I=C;z=Od(Y|0,g|0,f|0,P|0)|0;y=C;wa=((va|0)<0)<<31>>31;_a=Od(va|0,wa|0,f|0,P|0)|0;Za=C;Ea=Od(da|0,ea|0,f|0,P|0)|0;Da=C;P=Od(gb|0,fb|0,f|0,P|0)|0;f=C;L=Od(e|0,D|0,e|0,D|0)|0;K=C;oa=((na|0)<0)<<31>>31;x=Od(na|0,oa|0,db|0,eb|0)|0;w=C;sa=((ra|0)<0)<<31>>31;ab=Od(ra|0,sa|0,na|0,oa|0)|0;$a=C;Ga=Od(va|0,wa|0,e|0,D|0)|0;Fa=C;oa=Od(da|0,ea|0,na|0,oa|0)|0;na=C;D=Od(gb|0,fb|0,e|0,D|0)|0;e=C;eb=Od(Ka|0,((Ka|0)<0)<<31>>31|0,db|0,eb|0)|0;db=C;Ka=Od(ra|0,sa|0,B|0,d|0)|0;Ja=C;qa=Od(va|0,wa|0,B|0,d|0)|0;pa=C;_=Od(da|0,ea|0,B|0,d|0)|0;Z=C;d=Od(gb|0,fb|0,B|0,d|0)|0;B=C;sa=Od(ra|0,sa|0,Y|0,g|0)|0;ra=C;aa=Od(va|0,wa|0,Y|0,g|0)|0;$=C;m=Od(da|0,ea|0,m|0,((m|0)<0)<<31>>31|0)|0;r=C;g=Od(gb|0,fb|0,Y|0,g|0)|0;Y=C;Ma=Od(va|0,wa|0,La|0,Ma|0)|0;La=C;wa=Od(da|0,ea|0,i|0,O|0)|0;va=C;O=Od(gb|0,fb|0,i|0,O|0)|0;i=C;ea=Od(da|0,ea|0,h|0,A|0)|0;da=C;A=Od(gb|0,fb|0,h|0,A|0)|0;h=C;q=Od(gb|0,fb|0,b|0,q|0)|0;b=C;bb=Dd(eb|0,db|0,cb|0,bb|0)|0;$a=Dd(bb|0,C|0,ab|0,$a|0)|0;Za=Dd($a|0,C|0,_a|0,Za|0)|0;Xa=Dd(Za|0,C|0,Ya|0,Xa|0)|0;p=Dd(Xa|0,C|0,n|0,p|0)|0;n=C;ua=Dd(Wa|0,Va|0,ta|0,ua|0)|0;ta=C;ca=Dd(Ua|0,Ta|0,ba|0,ca|0)|0;ba=C;Pa=Dd(Sa|0,Ra|0,Qa|0,Pa|0)|0;Na=Dd(Pa|0,C|0,Oa|0,Na|0)|0;La=Dd(Na|0,C|0,Ma|0,La|0)|0;r=Dd(La|0,C|0,m|0,r|0)|0;B=Dd(r|0,C|0,d|0,B|0)|0;d=C;r=Dd(p|0,n|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;m=C;Ha=Dd(Ka|0,Ja|0,Ia|0,Ha|0)|0;Fa=Dd(Ha|0,C|0,Ga|0,Fa|0)|0;Da=Dd(Fa|0,C|0,Ea|0,Da|0)|0;j=Dd(Da|0,C|0,k|0,j|0)|0;j=Dd(j|0,C|0,r|0,m|0)|0;k=C;m=Hd(r|0,m|0,26)|0;m=Cd(p|0,n|0,m|0,C|0)|0;n=C;p=Dd(B|0,d|0,33554432,0)|0;p=Ed(p|0,C|0,26)|0;r=C;za=Dd(Ca|0,Ba|0,Aa|0,za|0)|0;xa=Dd(za|0,C|0,ya|0,xa|0)|0;va=Dd(xa|0,C|0,wa|0,va|0)|0;Y=Dd(va|0,C|0,g|0,Y|0)|0;Y=Dd(Y|0,C|0,p|0,r|0)|0;g=C;r=Hd(p|0,r|0,26)|0;r=Cd(B|0,d|0,r|0,C|0)|0;d=C;B=Dd(j|0,k|0,16777216,0)|0;B=Ed(B|0,C|0,25)|0;p=C;ra=Dd(ua|0,ta|0,sa|0,ra|0)|0;pa=Dd(ra|0,C|0,qa|0,pa|0)|0;na=Dd(pa|0,C|0,oa|0,na|0)|0;f=Dd(na|0,C|0,P|0,f|0)|0;f=Dd(f|0,C|0,B|0,p|0)|0;P=C;p=Hd(B|0,p|0,25)|0;p=Cd(j|0,k|0,p|0,C|0)|0;k=C;j=Dd(Y|0,g|0,16777216,0)|0;j=Ed(j|0,C|0,25)|0;B=C;ja=Dd(ma|0,la|0,ka|0,ja|0)|0;ha=Dd(ja|0,C|0,ia|0,ha|0)|0;fa=Dd(ha|0,C|0,ga|0,fa|0)|0;da=Dd(fa|0,C|0,ea|0,da|0)|0;i=Dd(da|0,C|0,O|0,i|0)|0;i=Dd(i|0,C|0,j|0,B|0)|0;O=C;B=Hd(j|0,B|0,25)|0;B=Cd(Y|0,g|0,B|0,C|0)|0;g=C;Y=Dd(f|0,P|0,33554432,0)|0;Y=Ed(Y|0,C|0,26)|0;j=C;$=Dd(ca|0,ba|0,aa|0,$|0)|0;Z=Dd($|0,C|0,_|0,Z|0)|0;e=Dd(Z|0,C|0,D|0,e|0)|0;e=Dd(e|0,C|0,Y|0,j|0)|0;D=C;j=Hd(Y|0,j|0,26)|0;j=Cd(f|0,P|0,j|0,C|0)|0;P=Dd(i|0,O|0,33554432,0)|0;P=Ed(P|0,C|0,26)|0;f=C;U=Dd(X|0,W|0,V|0,U|0)|0;S=Dd(U|0,C|0,T|0,S|0)|0;Q=Dd(S|0,C|0,R|0,Q|0)|0;h=Dd(Q|0,C|0,A|0,h|0)|0;h=Dd(h|0,C|0,P|0,f|0)|0;A=C;f=Hd(P|0,f|0,26)|0;f=Cd(i|0,O|0,f|0,C|0)|0;O=Dd(e|0,D|0,16777216,0)|0;O=Ed(O|0,C|0,25)|0;i=C;d=Dd(O|0,i|0,r|0,d|0)|0;r=C;i=Hd(O|0,i|0,25)|0;i=Cd(e|0,D|0,i|0,C|0)|0;D=Dd(h|0,A|0,16777216,0)|0;D=Ed(D|0,C|0,25)|0;e=C;K=Dd(N|0,M|0,L|0,K|0)|0;I=Dd(K|0,C|0,J|0,I|0)|0;G=Dd(I|0,C|0,H|0,G|0)|0;E=Dd(G|0,C|0,F|0,E|0)|0;b=Dd(E|0,C|0,q|0,b|0)|0;b=Dd(b|0,C|0,D|0,e|0)|0;q=C;e=Hd(D|0,e|0,25)|0;e=Cd(h|0,A|0,e|0,C|0)|0;A=Dd(d|0,r|0,33554432,0)|0;A=Ed(A|0,C|0,26)|0;h=C;g=Dd(B|0,g|0,A|0,h|0)|0;h=Hd(A|0,h|0,26)|0;h=Cd(d|0,r|0,h|0,C|0)|0;r=Dd(b|0,q|0,33554432,0)|0;r=Ed(r|0,C|0,26)|0;d=C;w=Dd(z|0,y|0,x|0,w|0)|0;u=Dd(w|0,C|0,v|0,u|0)|0;s=Dd(u|0,C|0,t|0,s|0)|0;l=Dd(s|0,C|0,o|0,l|0)|0;l=Dd(l|0,C|0,r|0,d|0)|0;o=C;d=Hd(r|0,d|0,26)|0;d=Cd(b|0,q|0,d|0,C|0)|0;q=Dd(l|0,o|0,16777216,0)|0;q=Ed(q|0,C|0,25)|0;b=C;r=Od(q|0,b|0,19,0)|0;n=Dd(r|0,C|0,m|0,n|0)|0;m=C;b=Hd(q|0,b|0,25)|0;b=Cd(l|0,o|0,b|0,C|0)|0;o=Dd(n|0,m|0,33554432,0)|0;o=Ed(o|0,C|0,26)|0;l=C;k=Dd(p|0,k|0,o|0,l|0)|0;l=Hd(o|0,l|0,26)|0;l=Cd(n|0,m|0,l|0,C|0)|0;c[a>>2]=l;c[a+4>>2]=k;c[a+8>>2]=j;c[a+12>>2]=i;c[a+16>>2]=h;c[a+20>>2]=g;c[a+24>>2]=f;c[a+28>>2]=e;c[a+32>>2]=d;c[a+36>>2]=b;return}function Lc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=c[d>>2]|0;l=c[d+4>>2]|0;k=c[d+8>>2]|0;j=c[d+12>>2]|0;i=c[d+16>>2]|0;h=c[d+20>>2]|0;g=c[d+24>>2]|0;f=c[d+28>>2]|0;o=c[d+32>>2]|0;e=c[d+36>>2]|0;m=(((((((((((((e*19|0)+16777216>>25)+m>>26)+l>>25)+k>>26)+j>>25)+i>>26)+h>>25)+g>>26)+f>>25)+o>>26)+e>>25)*19|0)+m|0;n=m>>26;l=n+l|0;n=m-(n<<26)|0;m=l>>25;k=m+k|0;m=l-(m<<25)|0;l=k>>26;j=l+j|0;l=k-(l<<26)|0;k=j>>25;i=k+i|0;k=j-(k<<25)|0;j=i>>26;h=j+h|0;j=i-(j<<26)|0;i=h>>25;g=i+g|0;i=h-(i<<25)|0;h=g>>26;f=h+f|0;h=g-(h<<26)|0;g=f>>25;d=g+o|0;g=f-(g<<25)|0;f=d>>26;e=f+e|0;f=d-(f<<26)|0;d=e&33554431;a[b>>0]=n;a[b+1>>0]=n>>>8;a[b+2>>0]=n>>>16;a[b+3>>0]=m<<2|n>>>24;a[b+4>>0]=m>>>6;a[b+5>>0]=m>>>14;a[b+6>>0]=l<<3|m>>>22;a[b+7>>0]=l>>>5;a[b+8>>0]=l>>>13;a[b+9>>0]=k<<5|l>>>21;a[b+10>>0]=k>>>3;a[b+11>>0]=k>>>11;a[b+12>>0]=j<<6|k>>>19;a[b+13>>0]=j>>>2;a[b+14>>0]=j>>>10;a[b+15>>0]=j>>>18;a[b+16>>0]=i;a[b+17>>0]=i>>>8;a[b+18>>0]=i>>>16;a[b+19>>0]=h<<1|i>>>24;a[b+20>>0]=h>>>7;a[b+21>>0]=h>>>15;a[b+22>>0]=g<<3|h>>>23;a[b+23>>0]=g>>>5;a[b+24>>0]=g>>>13;a[b+25>>0]=f<<4|g>>>21;a[b+26>>0]=f>>>4;a[b+27>>0]=f>>>12;a[b+28>>0]=f>>>20|d<<6;a[b+29>>0]=e>>>2;a[b+30>>0]=e>>>10;a[b+31>>0]=d>>>18;return}function Mc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0;V=b+40|0;j=b+44|0;m=b+48|0;p=b+52|0;s=b+56|0;v=b+60|0;y=b+64|0;B=b+68|0;E=b+72|0;C=b+76|0;S=b+4|0;P=b+8|0;e=b+12|0;l=b+16|0;n=b+20|0;u=b+24|0;w=b+28|0;D=b+32|0;O=b+36|0;ga=(c[S>>2]|0)+(c[j>>2]|0)|0;fa=(c[P>>2]|0)+(c[m>>2]|0)|0;ea=(c[e>>2]|0)+(c[p>>2]|0)|0;da=(c[l>>2]|0)+(c[s>>2]|0)|0;ca=(c[n>>2]|0)+(c[v>>2]|0)|0;ba=(c[u>>2]|0)+(c[y>>2]|0)|0;aa=(c[w>>2]|0)+(c[B>>2]|0)|0;$=(c[D>>2]|0)+(c[E>>2]|0)|0;Y=(c[O>>2]|0)+(c[C>>2]|0)|0;c[a>>2]=(c[b>>2]|0)+(c[V>>2]|0);ha=a+4|0;c[ha>>2]=ga;ga=a+8|0;c[ga>>2]=fa;fa=a+12|0;c[fa>>2]=ea;ea=a+16|0;c[ea>>2]=da;da=a+20|0;c[da>>2]=ca;ca=a+24|0;c[ca>>2]=ba;ba=a+28|0;c[ba>>2]=aa;aa=a+32|0;c[aa>>2]=$;$=a+36|0;c[$>>2]=Y;Y=a+40|0;S=(c[j>>2]|0)-(c[S>>2]|0)|0;P=(c[m>>2]|0)-(c[P>>2]|0)|0;e=(c[p>>2]|0)-(c[e>>2]|0)|0;l=(c[s>>2]|0)-(c[l>>2]|0)|0;n=(c[v>>2]|0)-(c[n>>2]|0)|0;u=(c[y>>2]|0)-(c[u>>2]|0)|0;w=(c[B>>2]|0)-(c[w>>2]|0)|0;D=(c[E>>2]|0)-(c[D>>2]|0)|0;O=(c[C>>2]|0)-(c[O>>2]|0)|0;c[Y>>2]=(c[V>>2]|0)-(c[b>>2]|0);V=a+44|0;c[V>>2]=S;S=a+48|0;c[S>>2]=P;P=a+52|0;c[P>>2]=e;e=a+56|0;c[e>>2]=l;l=a+60|0;c[l>>2]=n;n=a+64|0;c[n>>2]=u;u=a+68|0;c[u>>2]=w;w=a+72|0;c[w>>2]=D;D=a+76|0;c[D>>2]=O;O=a+80|0;Jc(O,a,d);Jc(Y,Y,d+40|0);C=a+120|0;Jc(C,d+120|0,b+120|0);Jc(a,b+80|0,d+80|0);E=c[a>>2]<<1;B=c[ha>>2]<<1;y=c[ga>>2]<<1;v=c[fa>>2]<<1;s=c[ea>>2]<<1;p=c[da>>2]<<1;m=c[ca>>2]<<1;j=c[ba>>2]<<1;g=c[aa>>2]<<1;b=c[$>>2]<<1;Z=c[O>>2]|0;N=a+84|0;W=c[N>>2]|0;M=a+88|0;T=c[M>>2]|0;L=a+92|0;Q=c[L>>2]|0;K=a+96|0;f=c[K>>2]|0;J=a+100|0;h=c[J>>2]|0;I=a+104|0;o=c[I>>2]|0;H=a+108|0;q=c[H>>2]|0;G=a+112|0;x=c[G>>2]|0;F=a+116|0;z=c[F>>2]|0;_=c[Y>>2]|0;X=c[V>>2]|0;U=c[S>>2]|0;R=c[P>>2]|0;d=c[e>>2]|0;i=c[l>>2]|0;k=c[n>>2]|0;r=c[u>>2]|0;t=c[w>>2]|0;A=c[D>>2]|0;c[a>>2]=Z-_;c[ha>>2]=W-X;c[ga>>2]=T-U;c[fa>>2]=Q-R;c[ea>>2]=f-d;c[da>>2]=h-i;c[ca>>2]=o-k;c[ba>>2]=q-r;c[aa>>2]=x-t;c[$>>2]=z-A;c[Y>>2]=_+Z;c[V>>2]=X+W;c[S>>2]=U+T;c[P>>2]=R+Q;c[e>>2]=d+f;c[l>>2]=i+h;c[n>>2]=k+o;c[u>>2]=r+q;c[w>>2]=t+x;c[D>>2]=A+z;D=c[C>>2]|0;z=a+124|0;A=c[z>>2]|0;w=a+128|0;x=c[w>>2]|0;t=a+132|0;u=c[t>>2]|0;q=a+136|0;r=c[q>>2]|0;n=a+140|0;o=c[n>>2]|0;k=a+144|0;l=c[k>>2]|0;h=a+148|0;i=c[h>>2]|0;e=a+152|0;f=c[e>>2]|0;a=a+156|0;d=c[a>>2]|0;c[O>>2]=D+E;c[N>>2]=A+B;c[M>>2]=x+y;c[L>>2]=u+v;c[K>>2]=r+s;c[J>>2]=o+p;c[I>>2]=l+m;c[H>>2]=i+j;c[G>>2]=f+g;c[F>>2]=d+b;c[C>>2]=E-D;c[z>>2]=B-A;c[w>>2]=y-x;c[t>>2]=v-u;c[q>>2]=s-r;c[n>>2]=p-o;c[k>>2]=m-l;c[h>>2]=j-i;c[e>>2]=g-f;c[a>>2]=b-d;return}
function Ha(a){a=a|0;var b=0;b=i;i=i+a|0;i=i+15&-16;return b|0}function Ia(){return i|0}function Ja(a){a=a|0;i=a}function Ka(a,b){a=a|0;b=b|0;i=a;j=b}function La(a,b){a=a|0;b=b|0;if(!n){n=a;o=b}}function Ma(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0]}function Na(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0];a[k+4>>0]=a[b+4>>0];a[k+5>>0]=a[b+5>>0];a[k+6>>0]=a[b+6>>0];a[k+7>>0]=a[b+7>>0]}function Oa(a){a=a|0;C=a}function Pa(){return C|0}function Qa(){return 32}function Ra(){return 32}function Sa(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;Ua(a,b,c,d,e);return 0}function Ta(b,c,d,e,f){b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;h=i;i=i+32|0;g=h;Ua(g,c,d,e,f);d=Yc(b,g)|0;e=(g|0)==(b|0);c=0;f=0;do{c=a[b+f>>0]^a[g+f>>0]|c;f=f+1|0}while((f|0)!=32);i=h;return (e?-1:d)|(((c&255)+511|0)>>>8&1)+-1|0}function Ua(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;s=i;i=i+608|0;r=s+480|0;o=s+416|0;n=s;j=n+64|0;c[j>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;h=n;k=8;l=h+64|0;do{c[h>>2]=c[k>>2];h=h+4|0;k=k+4|0}while((h|0)<(l|0));h=r;l=h+128|0;do{a[h>>0]=54;h=h+1|0}while((h|0)<(l|0));a[r>>0]=a[g>>0]^54;h=1;do{q=r+h|0;a[q>>0]=a[q>>0]^a[g+h>>0];h=h+1|0}while((h|0)!=32);h=n+72|0;c[h>>2]=1024;c[h+4>>2]=0;c[j>>2]=0;c[j+4>>2]=0;j=n+80|0;h=j;k=r;l=h+128|0;do{a[h>>0]=a[k>>0]|0;h=h+1|0;k=k+1|0}while((h|0)<(l|0));Hb(n,j);j=a[g>>0]|0;q=n+208|0;m=n+272|0;c[m>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;h=q;k=8;l=h+64|0;do{c[h>>2]=c[k>>2];h=h+4|0;k=k+4|0}while((h|0)<(l|0));h=r;l=h+128|0;do{a[h>>0]=92;h=h+1|0}while((h|0)<(l|0));a[r>>0]=j^92;h=1;do{p=r+h|0;a[p>>0]=a[p>>0]^a[g+h>>0];h=h+1|0}while((h|0)!=32);j=n+280|0;p=j;c[p>>2]=1024;c[p+4>>2]=0;p=m;c[p>>2]=0;c[p+4>>2]=0;p=n+288|0;h=p;k=r;l=h+128|0;do{a[h>>0]=a[k>>0]|0;h=h+1|0;k=k+1|0}while((h|0)<(l|0));Hb(q,p);Fb(n,d,e,f);Gb(n,o);f=j;d=c[f>>2]|0;f=c[f+4>>2]|0;k=Gd(d|0,f|0,3)|0;k=k&127;h=Dd(d|0,f|0,512,0)|0;c[j>>2]=h;c[j+4>>2]=C;j=m;h=c[j>>2]|0;j=c[j+4>>2]|0;if(f>>>0>4294967295|(f|0)==-1&d>>>0>4294966783){h=Dd(h|0,j|0,1,0)|0;j=C;d=m;c[d>>2]=h;c[d+4>>2]=j}g=m;c[g>>2]=h;c[g+4>>2]=j;j=Cd(128,0,k|0,0)|0;g=C;h=n+288+k|0;if(g>>>0>0|(g|0)==0&j>>>0>64){k=o;l=h+64|0;do{a[h>>0]=a[k>>0]|0;h=h+1|0;k=k+1|0}while((h|0)<(l|0));Gb(q,r);h=b;k=r;l=h+32|0;do{a[h>>0]=a[k>>0]|0;h=h+1|0;k=k+1|0}while((h|0)<(l|0));i=s;return}Id(h|0,o|0,j|0)|0;Hb(q,p);h=o+j|0;j=Cd(64,0,j|0,g|0)|0;g=C;if(g>>>0>0|(g|0)==0&j>>>0>127)do{Hb(q,h);h=h+128|0;j=Dd(j|0,g|0,-128,-1)|0;g=C}while(g>>>0>0|(g|0)==0&j>>>0>127);Id(p|0,h|0,j|0)|0;Gb(q,r);h=b;k=r;l=h+32|0;do{a[h>>0]=a[k>>0]|0;h=h+1|0;k=k+1|0}while((h|0)<(l|0));i=s;return}function Va(){return 32}function Wa(){return 32}function Xa(){return 32}function Ya(){return 32}function Za(){return 24}function _a(){return 16}function $a(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;k=i;i=i+272|0;h=k;g=k+208|0;f=h+64|0;j=h;l=8;m=j+64|0;do{c[j>>2]=c[l>>2];j=j+4|0;l=l+4|0}while((j|0)<(m|0));j=h+72|0;c[j>>2]=256;c[j+4>>2]=0;j=f;c[j>>2]=0;c[j+4>>2]=0;j=h+80|0;l=e;m=j+32|0;do{a[j>>0]=a[l>>0]|0;j=j+1|0;l=l+1|0}while((j|0)<(m|0));Gb(h,g);j=d;l=g;m=j+32|0;do{a[j>>0]=a[l>>0]|0;j=j+1|0;l=l+1|0}while((j|0)<(m|0));md(b,d,33785);i=k;return 0}function ab(b,c){b=b|0;c=c|0;var d=0;d=0;do{a[c+d>>0]=Ba(0)|0;d=d+1|0}while((d|0)!=32);md(b,c,33785);return 0}function bb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=i;i=i+32|0;e=d;md(e,c,b);nb(a,32576,e,32592);i=d;return 0}function cb(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;rc(a,b,c,d,e,f,g)|0;return 0}function db(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0;j=i;i=i+64|0;l=j+32|0;k=j;md(l,h,g);nb(k,32576,l,32592);rc(a,b,c,d,e,f,k)|0;i=j;return 0}function eb(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(d>>>0>0|(d|0)==0&c>>>0>4294967279){e=-1;return e|0}rc(a+16|0,a,b,c,d,e,f)|0;e=0;return e|0}function fb(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0;k=i;i=i+64|0;j=k+32|0;h=k;if(d>>>0>0|(d|0)==0&c>>>0>4294967279){g=-1;i=k;return g|0}md(j,g,f);nb(h,32576,j,32592);rc(a+16|0,a,b,c,d,e,h)|0;g=0;i=k;return g|0}function gb(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;return tc(a,b,c,d,e,f,g)|0}function hb(a,b,c,d,e,f,g,h){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0;j=i;i=i+64|0;l=j+32|0;k=j;md(l,h,g);nb(k,32576,l,32592);h=tc(a,b,c,d,e,f,k)|0;i=j;return h|0}function ib(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(d>>>0<0|(d|0)==0&c>>>0<16){e=-1;return e|0}d=Dd(c|0,d|0,-16,-1)|0;e=tc(a,b+16|0,b,d,C,e,f)|0;return e|0}function jb(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0;k=i;i=i+64|0;j=k+32|0;h=k;if(d>>>0<0|(d|0)==0&c>>>0<16){g=-1;i=k;return g|0}c=Dd(c|0,d|0,-16,-1)|0;d=C;md(j,g,f);nb(h,32576,j,32592);g=tc(a,b+16|0,b,c,d,e,h)|0;i=k;return g|0}function kb(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;A=i;v=i=i+63&-64;i=i+480|0;y=v;w=v+448|0;x=v+424|0;j=v+392|0;v=v+360|0;h=0;do{a[v+h>>0]=Ba(0)|0;h=h+1|0}while((h|0)!=32);md(j,v,33785);h=b;o=j;p=h+32|0;do{a[h>>0]=a[o>>0]|0;h=h+1|0;o=o+1|0}while((h|0)<(p|0));Fd(y|0,0,357)|0;q=y;c[q>>2]=-222443248;c[q+4>>2]=1779033703;q=y+8|0;c[q>>2]=-2067093701;c[q+4>>2]=-1150833019;q=y+16|0;c[q>>2]=-23791573;c[q+4>>2]=1013904242;q=y+24|0;c[q>>2]=1595750129;c[q+4>>2]=-1521486534;q=y+32|0;c[q>>2]=-1377402159;c[q+4>>2]=1359893119;q=y+40|0;c[q>>2]=725511199;c[q+4>>2]=-1694144372;q=y+48|0;c[q>>2]=-79577749;c[q+4>>2]=528734635;q=y+56|0;c[q>>2]=327033209;c[q+4>>2]=1541459225;q=y+352|0;r=y+96|0;s=y+64|0;t=y+72|0;u=y+224|0;h=0;m=0;n=32;while(1){l=256-h|0;h=y+96+h|0;if(!(m>>>0>0|(m|0)==0&n>>>0>l>>>0)){z=5;break}Id(h|0,j|0,l|0)|0;c[q>>2]=(c[q>>2]|0)+l;p=s;h=c[p>>2]|0;p=c[p+4>>2]|0;k=Dd(h|0,p|0,128,0)|0;o=s;c[o>>2]=k;c[o+4>>2]=C;o=t;o=Dd((p>>>0>4294967295|(p|0)==-1&h>>>0>4294967167)&1|0,0,c[o>>2]|0,c[o+4>>2]|0)|0;h=t;c[h>>2]=o;c[h+4>>2]=C;Ab(y,r);h=r;o=u;p=h+128|0;do{c[h>>2]=c[o>>2];h=h+4|0;o=o+4|0}while((h|0)<(p|0));h=(c[q>>2]|0)+-128|0;c[q>>2]=h;k=Cd(n|0,m|0,l|0,0)|0;if((n|0)==(l|0)&(m|0)==0){n=g;l=0;m=32;break}else{j=j+l|0;m=C;n=k}}if((z|0)==5){Id(h|0,j|0,n|0)|0;h=Dd(c[q>>2]|0,0,n|0,m|0)|0;c[q>>2]=h;n=g;l=0;m=32}while(1){k=256-h|0;h=y+96+h|0;if(!(l>>>0>0|(l|0)==0&m>>>0>k>>>0)){z=8;break}Id(h|0,n|0,k|0)|0;c[q>>2]=(c[q>>2]|0)+k;p=s;h=c[p>>2]|0;p=c[p+4>>2]|0;j=Dd(h|0,p|0,128,0)|0;o=s;c[o>>2]=j;c[o+4>>2]=C;o=t;o=Dd((p>>>0>4294967295|(p|0)==-1&h>>>0>4294967167)&1|0,0,c[o>>2]|0,c[o+4>>2]|0)|0;h=t;c[h>>2]=o;c[h+4>>2]=C;Ab(y,r);h=r;o=u;p=h+128|0;do{c[h>>2]=c[o>>2];h=h+4|0;o=o+4|0}while((h|0)<(p|0));h=(c[q>>2]|0)+-128|0;c[q>>2]=h;j=Cd(m|0,l|0,k|0,0)|0;if((m|0)==(k|0)&(l|0)==0)break;else{n=n+k|0;l=C;m=j}}if((z|0)==8){Id(h|0,n|0,m|0)|0;z=Dd(c[q>>2]|0,0,m|0,l|0)|0;c[q>>2]=z}zb(y,x,24)|0;if(f>>>0>0|(f|0)==0&e>>>0>4294967279){z=-1;i=A;return z|0}md(y,v,g);nb(w,32576,y,32592);rc(b+48|0,b+32|0,d,e,f,x,w)|0;z=0;i=A;return z|0}function lb(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;y=i;v=i=i+63&-64;i=i+416|0;w=v;u=v+384|0;v=v+360|0;if(e>>>0<0|(e|0)==0&d>>>0<48){x=-1;i=y;return x|0}Fd(w|0,0,357)|0;p=w;c[p>>2]=-222443248;c[p+4>>2]=1779033703;p=w+8|0;c[p>>2]=-2067093701;c[p+4>>2]=-1150833019;p=w+16|0;c[p>>2]=-23791573;c[p+4>>2]=1013904242;p=w+24|0;c[p>>2]=1595750129;c[p+4>>2]=-1521486534;p=w+32|0;c[p>>2]=-1377402159;c[p+4>>2]=1359893119;p=w+40|0;c[p>>2]=725511199;c[p+4>>2]=-1694144372;p=w+48|0;c[p>>2]=-79577749;c[p+4>>2]=528734635;p=w+56|0;c[p>>2]=327033209;c[p+4>>2]=1541459225;p=w+352|0;q=w+96|0;r=w+64|0;s=w+72|0;t=w+224|0;k=b;h=0;m=0;n=32;while(1){l=256-h|0;h=w+96+h|0;if(!(m>>>0>0|(m|0)==0&n>>>0>l>>>0)){x=4;break}Id(h|0,k|0,l|0)|0;c[p>>2]=(c[p>>2]|0)+l;o=r;h=c[o>>2]|0;o=c[o+4>>2]|0;z=Dd(h|0,o|0,128,0)|0;j=r;c[j>>2]=z;c[j+4>>2]=C;j=s;j=Dd((o>>>0>4294967295|(o|0)==-1&h>>>0>4294967167)&1|0,0,c[j>>2]|0,c[j+4>>2]|0)|0;h=s;c[h>>2]=j;c[h+4>>2]=C;Ab(w,q);h=q;j=t;o=h+128|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(o|0));h=(c[p>>2]|0)+-128|0;c[p>>2]=h;j=Cd(n|0,m|0,l|0,0)|0;if((n|0)==(l|0)&(m|0)==0){l=0;m=32;break}else{k=k+l|0;m=C;n=j}}if((x|0)==4){Id(h|0,k|0,n|0)|0;h=Dd(c[p>>2]|0,0,n|0,m|0)|0;c[p>>2]=h;l=0;m=32}while(1){k=256-h|0;h=w+96+h|0;if(!(l>>>0>0|(l|0)==0&m>>>0>k>>>0)){x=7;break}Id(h|0,f|0,k|0)|0;c[p>>2]=(c[p>>2]|0)+k;o=r;h=c[o>>2]|0;o=c[o+4>>2]|0;z=Dd(h|0,o|0,128,0)|0;j=r;c[j>>2]=z;c[j+4>>2]=C;j=s;j=Dd((o>>>0>4294967295|(o|0)==-1&h>>>0>4294967167)&1|0,0,c[j>>2]|0,c[j+4>>2]|0)|0;h=s;c[h>>2]=j;c[h+4>>2]=C;Ab(w,q);h=q;j=t;o=h+128|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(o|0));h=(c[p>>2]|0)+-128|0;c[p>>2]=h;j=Cd(m|0,l|0,k|0,0)|0;if((m|0)==(k|0)&(l|0)==0)break;else{f=f+k|0;l=C;m=j}}if((x|0)==7){Id(h|0,f|0,m|0)|0;z=Dd(c[p>>2]|0,0,m|0,l|0)|0;c[p>>2]=z}zb(w,v,24)|0;if((d&-16|0)==32&(e|0)==0){z=-1;i=y;return z|0}x=Dd(d|0,e|0,-48,-1)|0;z=C;md(w,g,b);nb(u,32576,w,32592);z=tc(a,b+48|0,b+32|0,x,z,v,u)|0;i=y;return z|0}function mb(){return 48}function nb(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;k=20;l=(d[f+1>>0]|0)<<8|(d[f>>0]|0)|(d[f+2>>0]|0)<<16|(d[f+3>>0]|0)<<24;m=(d[e+1>>0]|0)<<8|(d[e>>0]|0)|(d[e+2>>0]|0)<<16|(d[e+3>>0]|0)<<24;n=(d[f+9>>0]|0)<<8|(d[f+8>>0]|0)|(d[f+10>>0]|0)<<16|(d[f+11>>0]|0)<<24;o=(d[e+17>>0]|0)<<8|(d[e+16>>0]|0)|(d[e+18>>0]|0)<<16|(d[e+19>>0]|0)<<24;p=(d[e+21>>0]|0)<<8|(d[e+20>>0]|0)|(d[e+22>>0]|0)<<16|(d[e+23>>0]|0)<<24;q=(d[e+25>>0]|0)<<8|(d[e+24>>0]|0)|(d[e+26>>0]|0)<<16|(d[e+27>>0]|0)<<24;r=(d[e+29>>0]|0)<<8|(d[e+28>>0]|0)|(d[e+30>>0]|0)<<16|(d[e+31>>0]|0)<<24;s=(d[f+13>>0]|0)<<8|(d[f+12>>0]|0)|(d[f+14>>0]|0)<<16|(d[f+15>>0]|0)<<24;t=(d[e+5>>0]|0)<<8|(d[e+4>>0]|0)|(d[e+6>>0]|0)<<16|(d[e+7>>0]|0)<<24;u=(d[e+9>>0]|0)<<8|(d[e+8>>0]|0)|(d[e+10>>0]|0)<<16|(d[e+11>>0]|0)<<24;j=(d[e+13>>0]|0)<<8|(d[e+12>>0]|0)|(d[e+14>>0]|0)<<16|(d[e+15>>0]|0)<<24;f=(d[f+5>>0]|0)<<8|(d[f+4>>0]|0)|(d[f+6>>0]|0)<<16|(d[f+7>>0]|0)<<24;g=(d[c+1>>0]|0)<<8|(d[c>>0]|0)|(d[c+2>>0]|0)<<16|(d[c+3>>0]|0)<<24;h=(d[c+5>>0]|0)<<8|(d[c+4>>0]|0)|(d[c+6>>0]|0)<<16|(d[c+7>>0]|0)<<24;i=(d[c+9>>0]|0)<<8|(d[c+8>>0]|0)|(d[c+10>>0]|0)<<16|(d[c+11>>0]|0)<<24;e=(d[c+13>>0]|0)<<8|(d[c+12>>0]|0)|(d[c+14>>0]|0)<<16|(d[c+15>>0]|0)<<24;while(1){D=p+l|0;D=(D>>>25|D<<7)^j;A=D+l|0;A=(A>>>23|A<<9)^i;x=A+D|0;x=(x>>>19|x<<13)^p;G=x+A|0;G=(G>>>14|G<<18)^l;z=f+m|0;z=e^(z>>>25|z<<7);w=z+f|0;w=q^(w>>>23|w<<9);J=w+z|0;J=(J>>>19|J<<13)^m;C=J+w|0;C=(C>>>14|C<<18)^f;v=n+g|0;v=r^(v>>>25|v<<7);I=v+n|0;I=(I>>>23|I<<9)^t;F=I+v|0;F=(F>>>19|F<<13)^g;y=F+I|0;y=(y>>>14|y<<18)^n;H=s+o|0;H=(H>>>25|H<<7)^u;E=H+s|0;E=(E>>>23|E<<9)^h;B=E+H|0;B=(B>>>19|B<<13)^o;c=B+E|0;c=(c>>>14|c<<18)^s;K=G+H|0;m=(K>>>25|K<<7)^J;J=m+G|0;t=(J>>>23|J<<9)^I;I=t+m|0;u=(I>>>19|I<<13)^H;H=u+t|0;l=(H>>>14|H<<18)^G;G=C+D|0;g=(G>>>25|G<<7)^F;F=g+C|0;h=(F>>>23|F<<9)^E;E=h+g|0;j=(E>>>19|E<<13)^D;D=j+h|0;f=(D>>>14|D<<18)^C;C=y+z|0;o=(C>>>25|C<<7)^B;B=o+y|0;i=(B>>>23|B<<9)^A;A=i+o|0;e=(A>>>19|A<<13)^z;z=e+i|0;n=(z>>>14|z<<18)^y;y=c+v|0;p=(y>>>25|y<<7)^x;x=p+c|0;q=(x>>>23|x<<9)^w;w=q+p|0;r=(w>>>19|w<<13)^v;v=r+q|0;s=(v>>>14|v<<18)^c;if((k|0)<=2)break;else k=k+-2|0}a[b>>0]=l;a[b+1>>0]=l>>>8;a[b+2>>0]=l>>>16;a[b+3>>0]=l>>>24;a[b+4>>0]=f;a[b+5>>0]=f>>>8;a[b+6>>0]=f>>>16;a[b+7>>0]=f>>>24;a[b+8>>0]=n;a[b+9>>0]=n>>>8;a[b+10>>0]=n>>>16;a[b+11>>0]=n>>>24;a[b+12>>0]=s;a[b+13>>0]=s>>>8;a[b+14>>0]=s>>>16;a[b+15>>0]=s>>>24;a[b+16>>0]=g;a[b+17>>0]=g>>>8;a[b+18>>0]=g>>>16;a[b+19>>0]=g>>>24;a[b+20>>0]=h;a[b+21>>0]=h>>>8;a[b+22>>0]=h>>>16;a[b+23>>0]=h>>>24;a[b+24>>0]=i;a[b+25>>0]=i>>>8;a[b+26>>0]=i>>>16;a[b+27>>0]=i>>>24;a[b+28>>0]=e;a[b+29>>0]=e>>>8;a[b+30>>0]=e>>>16;a[b+31>>0]=e>>>24;return}function ob(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0;F=(d[f+1>>0]|0)<<8|(d[f>>0]|0)|(d[f+2>>0]|0)<<16|(d[f+3>>0]|0)<<24;G=(d[e+1>>0]|0)<<8|(d[e>>0]|0)|(d[e+2>>0]|0)<<16|(d[e+3>>0]|0)<<24;H=(d[e+5>>0]|0)<<8|(d[e+4>>0]|0)|(d[e+6>>0]|0)<<16|(d[e+7>>0]|0)<<24;I=(d[e+9>>0]|0)<<8|(d[e+8>>0]|0)|(d[e+10>>0]|0)<<16|(d[e+11>>0]|0)<<24;J=(d[e+13>>0]|0)<<8|(d[e+12>>0]|0)|(d[e+14>>0]|0)<<16|(d[e+15>>0]|0)<<24;B=(d[f+5>>0]|0)<<8|(d[f+4>>0]|0)|(d[f+6>>0]|0)<<16|(d[f+7>>0]|0)<<24;C=(d[c+1>>0]|0)<<8|(d[c>>0]|0)|(d[c+2>>0]|0)<<16|(d[c+3>>0]|0)<<24;D=(d[c+5>>0]|0)<<8|(d[c+4>>0]|0)|(d[c+6>>0]|0)<<16|(d[c+7>>0]|0)<<24;E=(d[c+9>>0]|0)<<8|(d[c+8>>0]|0)|(d[c+10>>0]|0)<<16|(d[c+11>>0]|0)<<24;w=(d[c+13>>0]|0)<<8|(d[c+12>>0]|0)|(d[c+14>>0]|0)<<16|(d[c+15>>0]|0)<<24;x=(d[f+9>>0]|0)<<8|(d[f+8>>0]|0)|(d[f+10>>0]|0)<<16|(d[f+11>>0]|0)<<24;y=(d[e+17>>0]|0)<<8|(d[e+16>>0]|0)|(d[e+18>>0]|0)<<16|(d[e+19>>0]|0)<<24;z=(d[e+21>>0]|0)<<8|(d[e+20>>0]|0)|(d[e+22>>0]|0)<<16|(d[e+23>>0]|0)<<24;A=(d[e+25>>0]|0)<<8|(d[e+24>>0]|0)|(d[e+26>>0]|0)<<16|(d[e+27>>0]|0)<<24;v=(d[e+29>>0]|0)<<8|(d[e+28>>0]|0)|(d[e+30>>0]|0)<<16|(d[e+31>>0]|0)<<24;c=(d[f+13>>0]|0)<<8|(d[f+12>>0]|0)|(d[f+14>>0]|0)<<16|(d[f+15>>0]|0)<<24;e=20;f=F;g=G;h=x;i=y;j=z;k=A;l=v;m=c;n=H;o=I;p=J;q=B;r=C;s=D;t=E;u=w;while(1){T=f+j|0;T=(T>>>25|T<<7)^p;Q=T+f|0;Q=(Q>>>23|Q<<9)^t;N=Q+T|0;N=(N>>>19|N<<13)^j;W=N+Q|0;W=(W>>>14|W<<18)^f;P=g+q|0;P=(P>>>25|P<<7)^u;M=P+q|0;M=(M>>>23|M<<9)^k;Z=M+P|0;Z=(Z>>>19|Z<<13)^g;S=Z+M|0;S=(S>>>14|S<<18)^q;L=r+h|0;L=(L>>>25|L<<7)^l;Y=L+h|0;Y=(Y>>>23|Y<<9)^n;V=Y+L|0;V=(V>>>19|V<<13)^r;O=V+Y|0;O=(O>>>14|O<<18)^h;X=i+m|0;X=o^(X>>>25|X<<7);U=X+m|0;U=(U>>>23|U<<9)^s;R=U+X|0;R=(R>>>19|R<<13)^i;K=R+U|0;K=(K>>>14|K<<18)^m;_=W+X|0;g=(_>>>25|_<<7)^Z;Z=g+W|0;n=(Z>>>23|Z<<9)^Y;Y=n+g|0;o=(Y>>>19|Y<<13)^X;X=o+n|0;f=(X>>>14|X<<18)^W;W=S+T|0;r=(W>>>25|W<<7)^V;V=r+S|0;s=(V>>>23|V<<9)^U;U=s+r|0;p=(U>>>19|U<<13)^T;T=p+s|0;q=(T>>>14|T<<18)^S;S=O+P|0;i=(S>>>25|S<<7)^R;R=i+O|0;t=(R>>>23|R<<9)^Q;Q=t+i|0;u=(Q>>>19|Q<<13)^P;P=u+t|0;h=(P>>>14|P<<18)^O;O=K+L|0;j=(O>>>25|O<<7)^N;N=j+K|0;k=(N>>>23|N<<9)^M;M=k+j|0;l=(M>>>19|M<<13)^L;L=l+k|0;m=(L>>>14|L<<18)^K;if((e|0)<=2)break;else e=e+-2|0}L=f+F|0;M=g+G|0;N=n+H|0;O=o+I|0;P=p+J|0;Q=q+B|0;R=r+C|0;S=s+D|0;T=t+E|0;U=u+w|0;V=h+x|0;W=i+y|0;X=j+z|0;Y=k+A|0;Z=l+v|0;_=m+c|0;a[b>>0]=L;a[b+1>>0]=L>>>8;a[b+2>>0]=L>>>16;a[b+3>>0]=L>>>24;a[b+4>>0]=M;a[b+5>>0]=M>>>8;a[b+6>>0]=M>>>16;a[b+7>>0]=M>>>24;a[b+8>>0]=N;a[b+9>>0]=N>>>8;a[b+10>>0]=N>>>16;a[b+11>>0]=N>>>24;a[b+12>>0]=O;a[b+13>>0]=O>>>8;a[b+14>>0]=O>>>16;a[b+15>>0]=O>>>24;a[b+16>>0]=P;a[b+17>>0]=P>>>8;a[b+18>>0]=P>>>16;a[b+19>>0]=P>>>24;a[b+20>>0]=Q;a[b+21>>0]=Q>>>8;a[b+22>>0]=Q>>>16;a[b+23>>0]=Q>>>24;a[b+24>>0]=R;a[b+25>>0]=R>>>8;a[b+26>>0]=R>>>16;a[b+27>>0]=R>>>24;a[b+28>>0]=S;a[b+29>>0]=S>>>8;a[b+30>>0]=S>>>16;a[b+31>>0]=S>>>24;a[b+32>>0]=T;a[b+33>>0]=T>>>8;a[b+34>>0]=T>>>16;a[b+35>>0]=T>>>24;a[b+36>>0]=U;a[b+37>>0]=U>>>8;a[b+38>>0]=U>>>16;a[b+39>>0]=U>>>24;a[b+40>>0]=V;a[b+41>>0]=V>>>8;a[b+42>>0]=V>>>16;a[b+43>>0]=V>>>24;a[b+44>>0]=W;a[b+45>>0]=W>>>8;a[b+46>>0]=W>>>16;a[b+47>>0]=W>>>24;a[b+48>>0]=X;a[b+49>>0]=X>>>8;a[b+50>>0]=X>>>16;a[b+51>>0]=X>>>24;a[b+52>>0]=Y;a[b+53>>0]=Y>>>8;a[b+54>>0]=Y>>>16;a[b+55>>0]=Y>>>24;a[b+56>>0]=Z;a[b+57>>0]=Z>>>8;a[b+58>>0]=Z>>>16;a[b+59>>0]=Z>>>24;a[b+60>>0]=_;a[b+61>>0]=_>>>8;a[b+62>>0]=_>>>16;a[b+63>>0]=_>>>24;return}function pb(){return 16}function qb(){return 64}function rb(){return 32}function sb(){return 16}function tb(){return 64}function ub(){return 32}function vb(){return 384}function wb(b,e,f,g,h,j,k){b=b|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=i;t=i=i+63&-64;i=i+496|0;n=t+360|0;if((e+-1|0)>>>0>63|k>>>0>64){u=-1;i=v;return u|0}if(e>>>0>=256)za(32608,32628,18,32680);if(k>>>0>=256)za(32707,32628,19,32680);m=k&255;do if(!((b|0)==0|(f|0)==0&((g|0)!=0|(h|0)!=0)|((e&255)+-1&255)>63)?(l=m<<24>>24==0,!((m&255)>64|((j|0)!=0|l)^1)):0){if(l){Fd(t|0,0,357)|0;m=t;c[m>>2]=e&255^-222443256;c[m+4>>2]=1779033703;m=t+8|0;c[m>>2]=-2067093701;c[m+4>>2]=-1150833019;m=t+16|0;c[m>>2]=-23791573;c[m+4>>2]=1013904242;m=t+24|0;c[m>>2]=1595750129;c[m+4>>2]=-1521486534;m=t+32|0;c[m>>2]=-1377402159;c[m+4>>2]=1359893119;m=t+40|0;c[m>>2]=725511199;c[m+4>>2]=-1694144372;m=t+48|0;c[m>>2]=-79577749;c[m+4>>2]=528734635;m=t+56|0;c[m>>2]=327033209;c[m+4>>2]=1541459225;m=0}else{if((j|0)==0|(m+-1&255)>63){l=-1;break}l=k&255;Fd(t|0,0,357)|0;s=Hd(l|0,0,8)|0;o=t;c[o>>2]=(s|e&255)^-222443256;c[o+4>>2]=C^1779033703;o=t+8|0;c[o>>2]=-2067093701;c[o+4>>2]=-1150833019;o=t+16|0;c[o>>2]=-23791573;c[o+4>>2]=1013904242;o=t+24|0;c[o>>2]=1595750129;c[o+4>>2]=-1521486534;o=t+32|0;c[o>>2]=-1377402159;c[o+4>>2]=1359893119;o=t+40|0;c[o>>2]=725511199;c[o+4>>2]=-1694144372;o=t+48|0;c[o>>2]=-79577749;c[o+4>>2]=528734635;o=t+56|0;c[o>>2]=327033209;c[o+4>>2]=1541459225;Fd(n+l|0,0,(m<<24>>24<0?0:128-l|0)|0)|0;Id(n|0,j|0,l|0)|0;l=t+352|0;o=t+96|0;m=o+128|0;do{a[o>>0]=a[n>>0]|0;o=o+1|0;n=n+1|0}while((o|0)<(m|0));c[l>>2]=128;m=128}k=t+352|0;if(!((g|0)==0&(h|0)==0)){q=t+96|0;j=t+64|0;r=t+72|0;s=t+224|0;p=f;while(1){f=256-m|0;l=t+96+m|0;if(!(h>>>0>0|(h|0)==0&g>>>0>f>>>0)){u=16;break}Id(l|0,p|0,f|0)|0;c[k>>2]=(c[k>>2]|0)+f;m=j;o=c[m>>2]|0;m=c[m+4>>2]|0;l=Dd(o|0,m|0,128,0)|0;n=j;c[n>>2]=l;c[n+4>>2]=C;n=r;n=Dd((m>>>0>4294967295|(m|0)==-1&o>>>0>4294967167)&1|0,0,c[n>>2]|0,c[n+4>>2]|0)|0;o=r;c[o>>2]=n;c[o+4>>2]=C;Ab(t,q);o=q;n=s;m=o+128|0;do{c[o>>2]=c[n>>2];o=o+4|0;n=n+4|0}while((o|0)<(m|0));m=(c[k>>2]|0)+-128|0;c[k>>2]=m;l=Cd(g|0,h|0,f|0,0)|0;if((g|0)==(f|0)&(h|0)==0)break;else{p=p+f|0;h=C;g=l}}if((u|0)==16){Id(l|0,p|0,g|0)|0;m=Dd(c[k>>2]|0,0,g|0,h|0)|0;c[k>>2]=m}l=e&255;if(m>>>0>128){s=j;e=c[s>>2]|0;s=c[s+4>>2]|0;m=Dd(e|0,s|0,128,0)|0;n=j;c[n>>2]=m;c[n+4>>2]=C;n=t+72|0;m=n;m=Dd((s>>>0>4294967295|(s|0)==-1&e>>>0>4294967167)&1|0,0,c[m>>2]|0,c[m+4>>2]|0)|0;e=n;c[e>>2]=m;c[e+4>>2]=C;e=t+96|0;Ab(t,e);m=(c[k>>2]|0)+-128|0;c[k>>2]=m;Jd(e|0,t+224|0,m|0)|0;m=c[k>>2]|0}else u=19}else{j=t+64|0;l=e&255;u=19}if((u|0)==19)n=t+72|0;u=j;u=Dd(c[u>>2]|0,c[u+4>>2]|0,m|0,0)|0;s=C;r=j;c[r>>2]=u;c[r+4>>2]=s;r=n;e=r;r=r+4|0;r=Dd((s>>>0<0|(s|0)==0&u>>>0<m>>>0)&1|0,0,d[e>>0]|d[e+1>>0]<<8|d[e+2>>0]<<16|d[e+3>>0]<<24|0,d[r>>0]|d[r+1>>0]<<8|d[r+2>>0]<<16|d[r+3>>0]<<24|0)|0;e=C;u=n;s=u;a[s>>0]=r;a[s+1>>0]=r>>8;a[s+2>>0]=r>>16;a[s+3>>0]=r>>24;u=u+4|0;a[u>>0]=e;a[u+1>>0]=e>>8;a[u+2>>0]=e>>16;a[u+3>>0]=e>>24;if(a[t+356>>0]|0){u=t+88|0;c[u>>2]=-1;c[u+4>>2]=-1}u=t+80|0;c[u>>2]=-1;c[u+4>>2]=-1;Fd(t+96+m|0,0,256-m|0)|0;Ab(t,t+96|0);Id(b|0,t|0,l|0)|0;l=0}else l=-1;while(0);u=l;i=v;return u|0}function xb(b,c,d,e){b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;j=i;f=i=i+63&-64;i=i+128|0;if(d>>>0>64|(e+-1|0)>>>0>63){b=-1;i=j;return b|0}if(e>>>0>=256)za(32608,32628,53,32727);if(d>>>0>=256)za(32707,32628,54,32727);h=e&255;if((c|0)==0|(d|0)==0){if((h+-1&255)>63){b=-1;i=j;return b|0}Fd(b|0,0,357)|0;c=e&255^-222443256;e=b;d=e;a[d>>0]=c;a[d+1>>0]=c>>8;a[d+2>>0]=c>>16;a[d+3>>0]=c>>24;e=e+4|0;a[e>>0]=103;a[e+1>>0]=230;a[e+2>>0]=9;a[e+3>>0]=106;e=b+8|0;d=e;a[d>>0]=-2067093701;a[d+1>>0]=-2067093701>>8;a[d+2>>0]=-2067093701>>16;a[d+3>>0]=-2067093701>>24;e=e+4|0;a[e>>0]=-1150833019;a[e+1>>0]=-1150833019>>8;a[e+2>>0]=-1150833019>>16;a[e+3>>0]=-1150833019>>24;e=b+16|0;d=e;a[d>>0]=-23791573;a[d+1>>0]=-23791573>>8;a[d+2>>0]=-23791573>>16;a[d+3>>0]=-23791573>>24;e=e+4|0;a[e>>0]=114;a[e+1>>0]=243;a[e+2>>0]=110;a[e+3>>0]=60;e=b+24|0;d=e;a[d>>0]=241;a[d+1>>0]=54;a[d+2>>0]=29;a[d+3>>0]=95;e=e+4|0;a[e>>0]=-1521486534;a[e+1>>0]=-1521486534>>8;a[e+2>>0]=-1521486534>>16;a[e+3>>0]=-1521486534>>24;e=b+32|0;d=e;a[d>>0]=-1377402159;a[d+1>>0]=-1377402159>>8;a[d+2>>0]=-1377402159>>16;a[d+3>>0]=-1377402159>>24;e=e+4|0;a[e>>0]=127;a[e+1>>0]=82;a[e+2>>0]=14;a[e+3>>0]=81;e=b+40|0;d=e;a[d>>0]=31;a[d+1>>0]=108;a[d+2>>0]=62;a[d+3>>0]=43;e=e+4|0;a[e>>0]=-1694144372;a[e+1>>0]=-1694144372>>8;a[e+2>>0]=-1694144372>>16;a[e+3>>0]=-1694144372>>24;e=b+48|0;d=e;a[d>>0]=-79577749;a[d+1>>0]=-79577749>>8;a[d+2>>0]=-79577749>>16;a[d+3>>0]=-79577749>>24;e=e+4|0;a[e>>0]=171;a[e+1>>0]=217;a[e+2>>0]=131;a[e+3>>0]=31;b=b+56|0;e=b;a[e>>0]=121;a[e+1>>0]=33;a[e+2>>0]=126;a[e+3>>0]=19;b=b+4|0;a[b>>0]=25;a[b+1>>0]=205;a[b+2>>0]=224;a[b+3>>0]=91;b=0;i=j;return b|0}else{g=d&255;if((h+-1&255)>63|(g+-1&255)>63){b=-1;i=j;return b|0}h=d&255;Fd(b|0,0,357)|0;l=Hd(h|0,0,8)|0;l=(l|e&255)^-222443256;d=C^1779033703;e=b;k=e;a[k>>0]=l;a[k+1>>0]=l>>8;a[k+2>>0]=l>>16;a[k+3>>0]=l>>24;e=e+4|0;a[e>>0]=d;a[e+1>>0]=d>>8;a[e+2>>0]=d>>16;a[e+3>>0]=d>>24;e=b+8|0;d=e;a[d>>0]=-2067093701;a[d+1>>0]=-2067093701>>8;a[d+2>>0]=-2067093701>>16;a[d+3>>0]=-2067093701>>24;e=e+4|0;a[e>>0]=-1150833019;a[e+1>>0]=-1150833019>>8;a[e+2>>0]=-1150833019>>16;a[e+3>>0]=-1150833019>>24;e=b+16|0;d=e;a[d>>0]=-23791573;a[d+1>>0]=-23791573>>8;a[d+2>>0]=-23791573>>16;a[d+3>>0]=-23791573>>24;e=e+4|0;a[e>>0]=114;a[e+1>>0]=243;a[e+2>>0]=110;a[e+3>>0]=60;e=b+24|0;d=e;a[d>>0]=241;a[d+1>>0]=54;a[d+2>>0]=29;a[d+3>>0]=95;e=e+4|0;a[e>>0]=-1521486534;a[e+1>>0]=-1521486534>>8;a[e+2>>0]=-1521486534>>16;a[e+3>>0]=-1521486534>>24;e=b+32|0;d=e;a[d>>0]=-1377402159;a[d+1>>0]=-1377402159>>8;a[d+2>>0]=-1377402159>>16;a[d+3>>0]=-1377402159>>24;e=e+4|0;a[e>>0]=127;a[e+1>>0]=82;a[e+2>>0]=14;a[e+3>>0]=81;e=b+40|0;d=e;a[d>>0]=31;a[d+1>>0]=108;a[d+2>>0]=62;a[d+3>>0]=43;e=e+4|0;a[e>>0]=-1694144372;a[e+1>>0]=-1694144372>>8;a[e+2>>0]=-1694144372>>16;a[e+3>>0]=-1694144372>>24;e=b+48|0;d=e;a[d>>0]=-79577749;a[d+1>>0]=-79577749>>8;a[d+2>>0]=-79577749>>16;a[d+3>>0]=-79577749>>24;e=e+4|0;a[e>>0]=171;a[e+1>>0]=217;a[e+2>>0]=131;a[e+3>>0]=31;e=b+56|0;d=e;a[d>>0]=121;a[d+1>>0]=33;a[d+2>>0]=126;a[d+3>>0]=19;e=e+4|0;a[e>>0]=25;a[e+1>>0]=205;a[e+2>>0]=224;a[e+3>>0]=91;Fd(f+h|0,0,(g<<24>>24<0?0:128-h|0)|0)|0;Id(f|0,c|0,h|0)|0;c=b+352|0;h=b+96|0;g=h+128|0;do{a[h>>0]=a[f>>0]|0;h=h+1|0;f=f+1|0}while((h|0)<(g|0));a[c>>0]=128;a[c+1>>0]=0;a[c+2>>0]=0;a[c+3>>0]=0;l=0;i=j;return l|0}return 0}function yb(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;if((e|0)==0&(f|0)==0)return 0;k=b+352|0;l=b+96|0;m=b+64|0;n=b+72|0;o=b+224|0;g=d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24;j=e;while(1){i=256-g|0;e=b+96+g|0;if(!(f>>>0>0|(f|0)==0&j>>>0>i>>>0))break;Id(e|0,c|0,i|0)|0;h=(d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24)+i|0;a[k>>0]=h;a[k+1>>0]=h>>8;a[k+2>>0]=h>>16;a[k+3>>0]=h>>24;h=m;e=h;e=d[e>>0]|d[e+1>>0]<<8|d[e+2>>0]<<16|d[e+3>>0]<<24;h=h+4|0;h=d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24;s=Dd(e|0,h|0,128,0)|0;g=C;q=m;r=q;a[r>>0]=s;a[r+1>>0]=s>>8;a[r+2>>0]=s>>16;a[r+3>>0]=s>>24;q=q+4|0;a[q>>0]=g;a[q+1>>0]=g>>8;a[q+2>>0]=g>>16;a[q+3>>0]=g>>24;q=n;g=q;q=q+4|0;q=Dd((h>>>0>4294967295|(h|0)==-1&e>>>0>4294967167)&1|0,0,d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24|0,d[q>>0]|d[q+1>>0]<<8|d[q+2>>0]<<16|d[q+3>>0]<<24|0)|0;g=C;e=n;h=e;a[h>>0]=q;a[h+1>>0]=q>>8;a[h+2>>0]=q>>16;a[h+3>>0]=q>>24;e=e+4|0;a[e>>0]=g;a[e+1>>0]=g>>8;a[e+2>>0]=g>>16;a[e+3>>0]=g>>24;Ab(b,l);e=l;g=o;h=e+128|0;do{a[e>>0]=a[g>>0]|0;e=e+1|0;g=g+1|0}while((e|0)<(h|0));g=(d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24)+-128|0;a[k>>0]=g;a[k+1>>0]=g>>8;a[k+2>>0]=g>>16;a[k+3>>0]=g>>24;e=Cd(j|0,f|0,i|0,0)|0;if((j|0)==(i|0)&(f|0)==0){p=6;break}else{c=c+i|0;f=C;j=e}}if((p|0)==6)return 0;Id(e|0,c|0,j|0)|0;s=Dd(d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24|0,0,j|0,f|0)|0;a[k>>0]=s;a[k+1>>0]=s>>8;a[k+2>>0]=s>>16;a[k+3>>0]=s>>24;return 0}function zb(b,c,e){b=b|0;c=c|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;if(e>>>0>=256)za(32608,32628,106,32759);f=e&255;if(!(f<<24>>24)){b=-1;return b|0}if((f&255)>64){b=-1;return b|0}g=b+352|0;f=d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24;i=b+64|0;if(f>>>0>128){k=i;j=k;j=d[j>>0]|d[j+1>>0]<<8|d[j+2>>0]<<16|d[j+3>>0]<<24;k=k+4|0;k=d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24;m=Dd(j|0,k|0,128,0)|0;l=C;h=i;f=h;a[f>>0]=m;a[f+1>>0]=m>>8;a[f+2>>0]=m>>16;a[f+3>>0]=m>>24;h=h+4|0;a[h>>0]=l;a[h+1>>0]=l>>8;a[h+2>>0]=l>>16;a[h+3>>0]=l>>24;h=b+72|0;l=h;f=l;l=l+4|0;l=Dd((k>>>0>4294967295|(k|0)==-1&j>>>0>4294967167)&1|0,0,d[f>>0]|d[f+1>>0]<<8|d[f+2>>0]<<16|d[f+3>>0]<<24|0,d[l>>0]|d[l+1>>0]<<8|d[l+2>>0]<<16|d[l+3>>0]<<24|0)|0;f=C;j=h;k=j;a[k>>0]=l;a[k+1>>0]=l>>8;a[k+2>>0]=l>>16;a[k+3>>0]=l>>24;j=j+4|0;a[j>>0]=f;a[j+1>>0]=f>>8;a[j+2>>0]=f>>16;a[j+3>>0]=f>>24;j=b+96|0;Ab(b,j);f=(d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24)+-128|0;a[g>>0]=f;a[g+1>>0]=f>>8;a[g+2>>0]=f>>16;a[g+3>>0]=f>>24;Jd(j|0,b+224|0,f|0)|0;f=d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24}else h=b+72|0;m=i;k=m;m=m+4|0;m=Dd(d[k>>0]|d[k+1>>0]<<8|d[k+2>>0]<<16|d[k+3>>0]<<24|0,d[m>>0]|d[m+1>>0]<<8|d[m+2>>0]<<16|d[m+3>>0]<<24|0,f|0,0)|0;k=C;j=i;l=j;a[l>>0]=m;a[l+1>>0]=m>>8;a[l+2>>0]=m>>16;a[l+3>>0]=m>>24;j=j+4|0;a[j>>0]=k;a[j+1>>0]=k>>8;a[j+2>>0]=k>>16;a[j+3>>0]=k>>24;j=h;l=j;j=j+4|0;j=Dd((k>>>0<0|(k|0)==0&m>>>0<f>>>0)&1|0,0,d[l>>0]|d[l+1>>0]<<8|d[l+2>>0]<<16|d[l+3>>0]<<24|0,d[j>>0]|d[j+1>>0]<<8|d[j+2>>0]<<16|d[j+3>>0]<<24|0)|0;l=C;m=h;k=m;a[k>>0]=j;a[k+1>>0]=j>>8;a[k+2>>0]=j>>16;a[k+3>>0]=j>>24;m=m+4|0;a[m>>0]=l;a[m+1>>0]=l>>8;a[m+2>>0]=l>>16;a[m+3>>0]=l>>24;if(a[b+356>>0]|0){m=b+88|0;l=m;a[l>>0]=-1;a[l+1>>0]=-1>>8;a[l+2>>0]=-1>>16;a[l+3>>0]=-1>>24;m=m+4|0;a[m>>0]=-1;a[m+1>>0]=-1>>8;a[m+2>>0]=-1>>16;a[m+3>>0]=-1>>24}m=b+80|0;l=m;a[l>>0]=-1;a[l+1>>0]=-1>>8;a[l+2>>0]=-1>>16;a[l+3>>0]=-1>>24;m=m+4|0;a[m>>0]=-1;a[m+1>>0]=-1>>8;a[m+2>>0]=-1>>16;a[m+3>>0]=-1>>24;Fd(b+96+f|0,0,256-f|0)|0;Ab(b,b+96|0);Id(c|0,b|0,e&255|0)|0;m=0;return m|0}function Ab(b,c){b=b|0;c=c|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0;P=c;R=P;R=d[R>>0]|d[R+1>>0]<<8|d[R+2>>0]<<16|d[R+3>>0]<<24;P=P+4|0;P=d[P>>0]|d[P+1>>0]<<8|d[P+2>>0]<<16|d[P+3>>0]<<24;U=c+8|0;W=U;W=d[W>>0]|d[W+1>>0]<<8|d[W+2>>0]<<16|d[W+3>>0]<<24;U=U+4|0;U=d[U>>0]|d[U+1>>0]<<8|d[U+2>>0]<<16|d[U+3>>0]<<24;x=c+16|0;t=x;t=d[t>>0]|d[t+1>>0]<<8|d[t+2>>0]<<16|d[t+3>>0]<<24;x=x+4|0;x=d[x>>0]|d[x+1>>0]<<8|d[x+2>>0]<<16|d[x+3>>0]<<24;l=c+24|0;h=l;h=d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24;l=l+4|0;l=d[l>>0]|d[l+1>>0]<<8|d[l+2>>0]<<16|d[l+3>>0]<<24;$=c+32|0;p=$;p=d[p>>0]|d[p+1>>0]<<8|d[p+2>>0]<<16|d[p+3>>0]<<24;$=$+4|0;$=d[$>>0]|d[$+1>>0]<<8|d[$+2>>0]<<16|d[$+3>>0]<<24;F=c+40|0;H=F;H=d[H>>0]|d[H+1>>0]<<8|d[H+2>>0]<<16|d[H+3>>0]<<24;F=F+4|0;F=d[F>>0]|d[F+1>>0]<<8|d[F+2>>0]<<16|d[F+3>>0]<<24;u=c+48|0;s=u;s=d[s>>0]|d[s+1>>0]<<8|d[s+2>>0]<<16|d[s+3>>0]<<24;u=u+4|0;u=d[u>>0]|d[u+1>>0]<<8|d[u+2>>0]<<16|d[u+3>>0]<<24;r=c+56|0;n=r;n=d[n>>0]|d[n+1>>0]<<8|d[n+2>>0]<<16|d[n+3>>0]<<24;r=r+4|0;r=d[r>>0]|d[r+1>>0]<<8|d[r+2>>0]<<16|d[r+3>>0]<<24;i=c+64|0;g=i;g=d[g>>0]|d[g+1>>0]<<8|d[g+2>>0]<<16|d[g+3>>0]<<24;i=i+4|0;i=d[i>>0]|d[i+1>>0]<<8|d[i+2>>0]<<16|d[i+3>>0]<<24;Y=c+72|0;j=Y;j=d[j>>0]|d[j+1>>0]<<8|d[j+2>>0]<<16|d[j+3>>0]<<24;Y=Y+4|0;Y=d[Y>>0]|d[Y+1>>0]<<8|d[Y+2>>0]<<16|d[Y+3>>0]<<24;o=c+80|0;m=o;m=d[m>>0]|d[m+1>>0]<<8|d[m+2>>0]<<16|d[m+3>>0]<<24;o=o+4|0;o=d[o>>0]|d[o+1>>0]<<8|d[o+2>>0]<<16|d[o+3>>0]<<24;K=c+88|0;M=K;M=d[M>>0]|d[M+1>>0]<<8|d[M+2>>0]<<16|d[M+3>>0]<<24;K=K+4|0;K=d[K>>0]|d[K+1>>0]<<8|d[K+2>>0]<<16|d[K+3>>0]<<24;f=c+96|0;e=f;e=d[e>>0]|d[e+1>>0]<<8|d[e+2>>0]<<16|d[e+3>>0]<<24;f=f+4|0;f=d[f>>0]|d[f+1>>0]<<8|d[f+2>>0]<<16|d[f+3>>0]<<24;S=c+104|0;B=S;B=d[B>>0]|d[B+1>>0]<<8|d[B+2>>0]<<16|d[B+3>>0]<<24;S=S+4|0;S=d[S>>0]|d[S+1>>0]<<8|d[S+2>>0]<<16|d[S+3>>0]<<24;sa=c+112|0;ra=sa;ra=d[ra>>0]|d[ra+1>>0]<<8|d[ra+2>>0]<<16|d[ra+3>>0]<<24;sa=sa+4|0;sa=d[sa>>0]|d[sa+1>>0]<<8|d[sa+2>>0]<<16|d[sa+3>>0]<<24;A=c+120|0;y=A;y=d[y>>0]|d[y+1>>0]<<8|d[y+2>>0]<<16|d[y+3>>0]<<24;A=A+4|0;A=d[A>>0]|d[A+1>>0]<<8|d[A+2>>0]<<16|d[A+3>>0]<<24;ca=b;v=ca;ca=ca+4|0;N=b+8|0;oa=N;na=oa;na=d[na>>0]|d[na+1>>0]<<8|d[na+2>>0]<<16|d[na+3>>0]<<24;oa=oa+4|0;oa=d[oa>>0]|d[oa+1>>0]<<8|d[oa+2>>0]<<16|d[oa+3>>0]<<24;I=b+16|0;ka=I;ja=ka;ja=d[ja>>0]|d[ja+1>>0]<<8|d[ja+2>>0]<<16|d[ja+3>>0]<<24;ka=ka+4|0;ka=d[ka>>0]|d[ka+1>>0]<<8|d[ka+2>>0]<<16|d[ka+3>>0]<<24;D=b+24|0;ga=D;fa=ga;fa=d[fa>>0]|d[fa+1>>0]<<8|d[fa+2>>0]<<16|d[fa+3>>0]<<24;ga=ga+4|0;ga=d[ga>>0]|d[ga+1>>0]<<8|d[ga+2>>0]<<16|d[ga+3>>0]<<24;w=b+32|0;ma=w;la=ma;la=d[la>>0]|d[la+1>>0]<<8|d[la+2>>0]<<16|d[la+3>>0]<<24;ma=ma+4|0;ma=d[ma>>0]|d[ma+1>>0]<<8|d[ma+2>>0]<<16|d[ma+3>>0]<<24;q=b+40|0;ia=q;ha=ia;ha=d[ha>>0]|d[ha+1>>0]<<8|d[ha+2>>0]<<16|d[ha+3>>0]<<24;ia=ia+4|0;ia=d[ia>>0]|d[ia+1>>0]<<8|d[ia+2>>0]<<16|d[ia+3>>0]<<24;k=b+48|0;ua=k;ta=ua;ta=d[ta>>0]|d[ta+1>>0]<<8|d[ta+2>>0]<<16|d[ta+3>>0]<<24;ua=ua+4|0;ua=d[ua>>0]|d[ua+1>>0]<<8|d[ua+2>>0]<<16|d[ua+3>>0]<<24;c=b+56|0;qa=c;pa=qa;pa=d[pa>>0]|d[pa+1>>0]<<8|d[pa+2>>0]<<16|d[pa+3>>0]<<24;qa=qa+4|0;qa=d[qa>>0]|d[qa+1>>0]<<8|d[qa+2>>0]<<16|d[qa+3>>0]<<24;ba=b+64|0;aa=ba;ba=ba+4|0;aa=(d[aa>>0]|d[aa+1>>0]<<8|d[aa+2>>0]<<16|d[aa+3>>0]<<24)^-1377402159;ba=(d[ba>>0]|d[ba+1>>0]<<8|d[ba+2>>0]<<16|d[ba+3>>0]<<24)^1359893119;_=b+72|0;Z=_;_=_+4|0;Z=(d[Z>>0]|d[Z+1>>0]<<8|d[Z+2>>0]<<16|d[Z+3>>0]<<24)^725511199;_=(d[_>>0]|d[_+1>>0]<<8|d[_+2>>0]<<16|d[_+3>>0]<<24)^-1694144372;X=b+80|0;V=X;X=X+4|0;V=(d[V>>0]|d[V+1>>0]<<8|d[V+2>>0]<<16|d[V+3>>0]<<24)^-79577749;X=(d[X>>0]|d[X+1>>0]<<8|d[X+2>>0]<<16|d[X+3>>0]<<24)^528734635;ea=b+88|0;da=ea;ea=ea+4|0;da=(d[da>>0]|d[da+1>>0]<<8|d[da+2>>0]<<16|d[da+3>>0]<<24)^327033209;ea=(d[ea>>0]|d[ea+1>>0]<<8|d[ea+2>>0]<<16|d[ea+3>>0]<<24)^1541459225;ca=Dd(la|0,ma|0,d[v>>0]|d[v+1>>0]<<8|d[v+2>>0]<<16|d[v+3>>0]<<24|0,d[ca>>0]|d[ca+1>>0]<<8|d[ca+2>>0]<<16|d[ca+3>>0]<<24|0)|0;ca=Dd(ca|0,C|0,R|0,P|0)|0;v=C;aa=aa^ca;ba=ba^v;Q=Dd(ba|0,aa|0,-205731576,1779033703)|0;T=C;la=Q^la;ma=T^ma;O=Gd(la|0,ma|0,24)|0;L=C;ma=Hd(la|0,ma|0,40)|0;O=ma|O;L=C|L;v=Dd(W|0,U|0,ca|0,v|0)|0;v=Dd(v|0,C|0,O|0,L|0)|0;ca=C;ba=v^ba;aa=ca^aa;ma=Gd(ba|0,aa|0,16)|0;la=C;aa=Hd(ba|0,aa|0,48)|0;ma=aa|ma;la=C|la;T=Dd(ma|0,la|0,Q|0,T|0)|0;Q=C;O=T^O;L=Q^L;aa=Gd(O|0,L|0,63)|0;ba=C;L=Hd(O|0,L|0,1)|0;aa=L|aa;ba=C|ba;oa=Dd(ha|0,ia|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,t|0,x|0)|0;na=C;Z=Z^oa;_=_^na;L=Dd(_|0,Z|0,-2067093701,-1150833019)|0;O=C;ha=L^ha;ia=O^ia;J=Gd(ha|0,ia|0,24)|0;G=C;ia=Hd(ha|0,ia|0,40)|0;J=ia|J;G=C|G;na=Dd(h|0,l|0,oa|0,na|0)|0;na=Dd(na|0,C|0,J|0,G|0)|0;oa=C;_=na^_;Z=oa^Z;ia=Gd(_|0,Z|0,16)|0;ha=C;Z=Hd(_|0,Z|0,48)|0;ia=Z|ia;ha=C|ha;O=Dd(ia|0,ha|0,L|0,O|0)|0;L=C;J=O^J;G=L^G;Z=Gd(J|0,G|0,63)|0;_=C;G=Hd(J|0,G|0,1)|0;Z=G|Z;_=C|_;ka=Dd(ta|0,ua|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,p|0,$|0)|0;ja=C;V=V^ka;X=X^ja;G=Dd(X|0,V|0,-23791573,1013904242)|0;J=C;ta=G^ta;ua=J^ua;E=Gd(ta|0,ua|0,24)|0;z=C;ua=Hd(ta|0,ua|0,40)|0;E=ua|E;z=C|z;ja=Dd(H|0,F|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,E|0,z|0)|0;ka=C;X=ja^X;V=ka^V;ua=Gd(X|0,V|0,16)|0;ta=C;V=Hd(X|0,V|0,48)|0;ua=V|ua;ta=C|ta;J=Dd(ua|0,ta|0,G|0,J|0)|0;G=C;E=J^E;z=G^z;V=Gd(E|0,z|0,63)|0;X=C;z=Hd(E|0,z|0,1)|0;V=z|V;X=C|X;ga=Dd(pa|0,qa|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,s|0,u|0)|0;fa=C;da=da^ga;ea=ea^fa;z=Dd(ea|0,da|0,1595750129,-1521486534)|0;E=C;pa=z^pa;qa=E^qa;wa=Gd(pa|0,qa|0,24)|0;va=C;qa=Hd(pa|0,qa|0,40)|0;wa=qa|wa;va=C|va;fa=Dd(n|0,r|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ea=fa^ea;da=ga^da;qa=Gd(ea|0,da|0,16)|0;pa=C;da=Hd(ea|0,da|0,48)|0;qa=da|qa;pa=C|pa;E=Dd(qa|0,pa|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;da=Gd(wa|0,va|0,63)|0;ea=C;va=Hd(wa|0,va|0,1)|0;da=va|da;ea=C|ea;ca=Dd(Z|0,_|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,g|0,i|0)|0;v=C;qa=qa^ca;pa=pa^v;G=Dd(pa|0,qa|0,J|0,G|0)|0;J=C;Z=G^Z;_=J^_;va=Gd(Z|0,_|0,24)|0;wa=C;_=Hd(Z|0,_|0,40)|0;va=_|va;wa=C|wa;v=Dd(j|0,Y|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;pa=v^pa;qa=ca^qa;_=Gd(pa|0,qa|0,16)|0;Z=C;qa=Hd(pa|0,qa|0,48)|0;_=qa|_;Z=C|Z;J=Dd(_|0,Z|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;qa=Gd(va|0,wa|0,63)|0;pa=C;wa=Hd(va|0,wa|0,1)|0;qa=wa|qa;pa=C|pa;oa=Dd(V|0,X|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,m|0,o|0)|0;na=C;ma=ma^oa;la=la^na;z=Dd(la|0,ma|0,E|0,z|0)|0;E=C;V=z^V;X=E^X;wa=Gd(V|0,X|0,24)|0;va=C;X=Hd(V|0,X|0,40)|0;wa=X|wa;va=C|va;na=Dd(M|0,K|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;la=na^la;ma=oa^ma;X=Gd(la|0,ma|0,16)|0;V=C;ma=Hd(la|0,ma|0,48)|0;X=ma|X;V=C|V;E=Dd(X|0,V|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ma=Gd(wa|0,va|0,63)|0;la=C;va=Hd(wa|0,va|0,1)|0;ma=va|ma;la=C|la;ka=Dd(da|0,ea|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,e|0,f|0)|0;ja=C;ia=ia^ka;ha=ha^ja;Q=Dd(ha|0,ia|0,T|0,Q|0)|0;T=C;da=Q^da;ea=T^ea;va=Gd(da|0,ea|0,24)|0;wa=C;ea=Hd(da|0,ea|0,40)|0;va=ea|va;wa=C|wa;ja=Dd(B|0,S|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;ha=ja^ha;ia=ka^ia;ea=Gd(ha|0,ia|0,16)|0;da=C;ia=Hd(ha|0,ia|0,48)|0;ea=ia|ea;da=C|da;T=Dd(ea|0,da|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;ia=Gd(va|0,wa|0,63)|0;ha=C;wa=Hd(va|0,wa|0,1)|0;ia=wa|ia;ha=C|ha;ga=Dd(aa|0,ba|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,ra|0,sa|0)|0;fa=C;ua=ua^ga;ta=ta^fa;L=Dd(ta|0,ua|0,O|0,L|0)|0;O=C;aa=L^aa;ba=O^ba;wa=Gd(aa|0,ba|0,24)|0;va=C;ba=Hd(aa|0,ba|0,40)|0;wa=ba|wa;va=C|va;fa=Dd(y|0,A|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ta=fa^ta;ua=ga^ua;ba=Gd(ta|0,ua|0,16)|0;aa=C;ua=Hd(ta|0,ua|0,48)|0;ba=ua|ba;aa=C|aa;O=Dd(ba|0,aa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ua=Gd(wa|0,va|0,63)|0;ta=C;va=Hd(wa|0,va|0,1)|0;ua=va|ua;ta=C|ta;ca=Dd(ra|0,sa|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ua|0,ta|0)|0;v=C;X=ca^X;V=v^V;Q=Dd(V|0,X|0,T|0,Q|0)|0;T=C;ua=Q^ua;ta=T^ta;va=Gd(ua|0,ta|0,24)|0;wa=C;ta=Hd(ua|0,ta|0,40)|0;va=ta|va;wa=C|wa;v=Dd(m|0,o|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;V=v^V;X=ca^X;ta=Gd(V|0,X|0,16)|0;ua=C;X=Hd(V|0,X|0,48)|0;ta=X|ta;ua=C|ua;T=Dd(ta|0,ua|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;X=Gd(va|0,wa|0,63)|0;V=C;wa=Hd(va|0,wa|0,1)|0;X=wa|X;V=C|V;oa=Dd(qa|0,pa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,p|0,$|0)|0;na=C;ea=ea^oa;da=da^na;L=Dd(da|0,ea|0,O|0,L|0)|0;O=C;qa=L^qa;pa=O^pa;wa=Gd(qa|0,pa|0,24)|0;va=C;pa=Hd(qa|0,pa|0,40)|0;wa=pa|wa;va=C|va;na=Dd(g|0,i|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;da=na^da;ea=oa^ea;pa=Gd(da|0,ea|0,16)|0;qa=C;ea=Hd(da|0,ea|0,48)|0;pa=ea|pa;qa=C|qa;O=Dd(pa|0,qa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ea=Gd(wa|0,va|0,63)|0;da=C;va=Hd(wa|0,va|0,1)|0;ea=va|ea;da=C|da;ka=Dd(ma|0,la|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,j|0,Y|0)|0;ja=C;ba=ba^ka;aa=aa^ja;G=Dd(aa|0,ba|0,J|0,G|0)|0;J=C;ma=G^ma;la=J^la;va=Gd(ma|0,la|0,24)|0;wa=C;la=Hd(ma|0,la|0,40)|0;va=la|va;wa=C|wa;ja=Dd(y|0,A|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;aa=ja^aa;ba=ka^ba;la=Gd(aa|0,ba|0,16)|0;ma=C;ba=Hd(aa|0,ba|0,48)|0;la=ba|la;ma=C|ma;J=Dd(la|0,ma|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ba=Gd(va|0,wa|0,63)|0;aa=C;wa=Hd(va|0,wa|0,1)|0;ba=wa|ba;aa=C|aa;ga=Dd(ia|0,ha|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,B|0,S|0)|0;fa=C;_=_^ga;Z=Z^fa;z=Dd(Z|0,_|0,E|0,z|0)|0;E=C;ia=z^ia;ha=E^ha;wa=Gd(ia|0,ha|0,24)|0;va=C;ha=Hd(ia|0,ha|0,40)|0;wa=ha|wa;va=C|va;fa=Dd(s|0,u|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;Z=fa^Z;_=ga^_;ha=Gd(Z|0,_|0,16)|0;ia=C;_=Hd(Z|0,_|0,48)|0;ha=_|ha;ia=C|ia;E=Dd(ha|0,ia|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;_=Gd(wa|0,va|0,63)|0;Z=C;va=Hd(wa|0,va|0,1)|0;_=va|_;Z=C|Z;ca=Dd(ea|0,da|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,W|0,U|0)|0;v=C;ha=ha^ca;ia=ia^v;G=Dd(ia|0,ha|0,J|0,G|0)|0;J=C;ea=G^ea;da=J^da;va=Gd(ea|0,da|0,24)|0;wa=C;da=Hd(ea|0,da|0,40)|0;va=da|va;wa=C|wa;v=Dd(e|0,f|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ia=v^ia;ha=ca^ha;da=Gd(ia|0,ha|0,16)|0;ea=C;ha=Hd(ia|0,ha|0,48)|0;da=ha|da;ea=C|ea;J=Dd(da|0,ea|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ha=Gd(va|0,wa|0,63)|0;ia=C;wa=Hd(va|0,wa|0,1)|0;ha=wa|ha;ia=C|ia;oa=Dd(ba|0,aa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,R|0,P|0)|0;na=C;ta=ta^oa;ua=ua^na;z=Dd(ua|0,ta|0,E|0,z|0)|0;E=C;ba=z^ba;aa=E^aa;wa=Gd(ba|0,aa|0,24)|0;va=C;aa=Hd(ba|0,aa|0,40)|0;wa=aa|wa;va=C|va;na=Dd(t|0,x|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;ua=na^ua;ta=oa^ta;aa=Gd(ua|0,ta|0,16)|0;ba=C;ta=Hd(ua|0,ta|0,48)|0;aa=ta|aa;ba=C|ba;E=Dd(aa|0,ba|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ta=Gd(wa|0,va|0,63)|0;ua=C;va=Hd(wa|0,va|0,1)|0;ta=va|ta;ua=C|ua;ka=Dd(_|0,Z|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,M|0,K|0)|0;ja=C;pa=pa^ka;qa=qa^ja;Q=Dd(qa|0,pa|0,T|0,Q|0)|0;T=C;_=Q^_;Z=T^Z;va=Gd(_|0,Z|0,24)|0;wa=C;Z=Hd(_|0,Z|0,40)|0;va=Z|va;wa=C|wa;ja=Dd(n|0,r|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;qa=ja^qa;pa=ka^pa;Z=Gd(qa|0,pa|0,16)|0;_=C;pa=Hd(qa|0,pa|0,48)|0;Z=pa|Z;_=C|_;T=Dd(Z|0,_|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;pa=Gd(va|0,wa|0,63)|0;qa=C;wa=Hd(va|0,wa|0,1)|0;pa=wa|pa;qa=C|qa;ga=Dd(X|0,V|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,H|0,F|0)|0;fa=C;la=la^ga;ma=ma^fa;L=Dd(ma|0,la|0,O|0,L|0)|0;O=C;X=L^X;V=O^V;wa=Gd(X|0,V|0,24)|0;va=C;V=Hd(X|0,V|0,40)|0;wa=V|wa;va=C|va;fa=Dd(h|0,l|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ma=fa^ma;la=ga^la;V=Gd(ma|0,la|0,16)|0;X=C;la=Hd(ma|0,la|0,48)|0;V=la|V;X=C|X;O=Dd(V|0,X|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;la=Gd(wa|0,va|0,63)|0;ma=C;va=Hd(wa|0,va|0,1)|0;la=va|la;ma=C|ma;ca=Dd(M|0,K|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,la|0,ma|0)|0;v=C;aa=ca^aa;ba=v^ba;Q=Dd(ba|0,aa|0,T|0,Q|0)|0;T=C;la=Q^la;ma=T^ma;va=Gd(la|0,ma|0,24)|0;wa=C;ma=Hd(la|0,ma|0,40)|0;va=ma|va;wa=C|wa;v=Dd(g|0,i|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ba=v^ba;aa=ca^aa;ma=Gd(ba|0,aa|0,16)|0;la=C;aa=Hd(ba|0,aa|0,48)|0;ma=aa|ma;la=C|la;T=Dd(ma|0,la|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;aa=Gd(va|0,wa|0,63)|0;ba=C;wa=Hd(va|0,wa|0,1)|0;aa=wa|aa;ba=C|ba;oa=Dd(ha|0,ia|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,e|0,f|0)|0;na=C;Z=Z^oa;_=_^na;L=Dd(_|0,Z|0,O|0,L|0)|0;O=C;ha=L^ha;ia=O^ia;wa=Gd(ha|0,ia|0,24)|0;va=C;ia=Hd(ha|0,ia|0,40)|0;wa=ia|wa;va=C|va;na=Dd(R|0,P|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;_=na^_;Z=oa^Z;ia=Gd(_|0,Z|0,16)|0;ha=C;Z=Hd(_|0,Z|0,48)|0;ia=Z|ia;ha=C|ha;O=Dd(ia|0,ha|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;Z=Gd(wa|0,va|0,63)|0;_=C;va=Hd(wa|0,va|0,1)|0;Z=va|Z;_=C|_;ka=Dd(ta|0,ua|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,H|0,F|0)|0;ja=C;V=V^ka;X=X^ja;G=Dd(X|0,V|0,J|0,G|0)|0;J=C;ta=G^ta;ua=J^ua;va=Gd(ta|0,ua|0,24)|0;wa=C;ua=Hd(ta|0,ua|0,40)|0;va=ua|va;wa=C|wa;ja=Dd(t|0,x|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;X=ja^X;V=ka^V;ua=Gd(X|0,V|0,16)|0;ta=C;V=Hd(X|0,V|0,48)|0;ua=V|ua;ta=C|ta;J=Dd(ua|0,ta|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;V=Gd(va|0,wa|0,63)|0;X=C;wa=Hd(va|0,wa|0,1)|0;V=wa|V;X=C|X;ga=Dd(pa|0,qa|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,y|0,A|0)|0;fa=C;da=da^ga;ea=ea^fa;z=Dd(ea|0,da|0,E|0,z|0)|0;E=C;pa=z^pa;qa=E^qa;wa=Gd(pa|0,qa|0,24)|0;va=C;qa=Hd(pa|0,qa|0,40)|0;wa=qa|wa;va=C|va;fa=Dd(B|0,S|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ea=fa^ea;da=ga^da;qa=Gd(ea|0,da|0,16)|0;pa=C;da=Hd(ea|0,da|0,48)|0;qa=da|qa;pa=C|pa;E=Dd(qa|0,pa|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;da=Gd(wa|0,va|0,63)|0;ea=C;va=Hd(wa|0,va|0,1)|0;da=va|da;ea=C|ea;ca=Dd(Z|0,_|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,m|0,o|0)|0;v=C;qa=qa^ca;pa=pa^v;G=Dd(pa|0,qa|0,J|0,G|0)|0;J=C;Z=G^Z;_=J^_;va=Gd(Z|0,_|0,24)|0;wa=C;_=Hd(Z|0,_|0,40)|0;va=_|va;wa=C|wa;v=Dd(ra|0,sa|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;pa=v^pa;qa=ca^qa;_=Gd(pa|0,qa|0,16)|0;Z=C;qa=Hd(pa|0,qa|0,48)|0;_=qa|_;Z=C|Z;J=Dd(_|0,Z|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;qa=Gd(va|0,wa|0,63)|0;pa=C;wa=Hd(va|0,wa|0,1)|0;qa=wa|qa;pa=C|pa;oa=Dd(V|0,X|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,h|0,l|0)|0;na=C;ma=ma^oa;la=la^na;z=Dd(la|0,ma|0,E|0,z|0)|0;E=C;V=z^V;X=E^X;wa=Gd(V|0,X|0,24)|0;va=C;X=Hd(V|0,X|0,40)|0;wa=X|wa;va=C|va;na=Dd(s|0,u|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;la=na^la;ma=oa^ma;X=Gd(la|0,ma|0,16)|0;V=C;ma=Hd(la|0,ma|0,48)|0;X=ma|X;V=C|V;E=Dd(X|0,V|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ma=Gd(wa|0,va|0,63)|0;la=C;va=Hd(wa|0,va|0,1)|0;ma=va|ma;la=C|la;ka=Dd(da|0,ea|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,n|0,r|0)|0;ja=C;ia=ia^ka;ha=ha^ja;Q=Dd(ha|0,ia|0,T|0,Q|0)|0;T=C;da=Q^da;ea=T^ea;va=Gd(da|0,ea|0,24)|0;wa=C;ea=Hd(da|0,ea|0,40)|0;va=ea|va;wa=C|wa;ja=Dd(W|0,U|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;ha=ja^ha;ia=ka^ia;ea=Gd(ha|0,ia|0,16)|0;da=C;ia=Hd(ha|0,ia|0,48)|0;ea=ia|ea;da=C|da;T=Dd(ea|0,da|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;ia=Gd(va|0,wa|0,63)|0;ha=C;wa=Hd(va|0,wa|0,1)|0;ia=wa|ia;ha=C|ha;ga=Dd(aa|0,ba|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,j|0,Y|0)|0;fa=C;ua=ua^ga;ta=ta^fa;L=Dd(ta|0,ua|0,O|0,L|0)|0;O=C;aa=L^aa;ba=O^ba;wa=Gd(aa|0,ba|0,24)|0;va=C;ba=Hd(aa|0,ba|0,40)|0;wa=ba|wa;va=C|va;fa=Dd(p|0,$|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ta=fa^ta;ua=ga^ua;ba=Gd(ta|0,ua|0,16)|0;aa=C;ua=Hd(ta|0,ua|0,48)|0;ba=ua|ba;aa=C|aa;O=Dd(ba|0,aa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ua=Gd(wa|0,va|0,63)|0;ta=C;va=Hd(wa|0,va|0,1)|0;ua=va|ua;ta=C|ta;ca=Dd(n|0,r|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ua|0,ta|0)|0;v=C;X=ca^X;V=v^V;Q=Dd(V|0,X|0,T|0,Q|0)|0;T=C;ua=Q^ua;ta=T^ta;va=Gd(ua|0,ta|0,24)|0;wa=C;ta=Hd(ua|0,ta|0,40)|0;va=ta|va;wa=C|wa;v=Dd(j|0,Y|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;V=v^V;X=ca^X;ta=Gd(V|0,X|0,16)|0;ua=C;X=Hd(V|0,X|0,48)|0;ta=X|ta;ua=C|ua;T=Dd(ta|0,ua|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;X=Gd(va|0,wa|0,63)|0;V=C;wa=Hd(va|0,wa|0,1)|0;X=wa|X;V=C|V;oa=Dd(qa|0,pa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,h|0,l|0)|0;na=C;ea=ea^oa;da=da^na;L=Dd(da|0,ea|0,O|0,L|0)|0;O=C;qa=L^qa;pa=O^pa;wa=Gd(qa|0,pa|0,24)|0;va=C;pa=Hd(qa|0,pa|0,40)|0;wa=pa|wa;va=C|va;na=Dd(W|0,U|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;da=na^da;ea=oa^ea;pa=Gd(da|0,ea|0,16)|0;qa=C;ea=Hd(da|0,ea|0,48)|0;pa=ea|pa;qa=C|qa;O=Dd(pa|0,qa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ea=Gd(wa|0,va|0,63)|0;da=C;va=Hd(wa|0,va|0,1)|0;ea=va|ea;da=C|da;ka=Dd(ma|0,la|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,B|0,S|0)|0;ja=C;ba=ba^ka;aa=aa^ja;G=Dd(aa|0,ba|0,J|0,G|0)|0;J=C;ma=G^ma;la=J^la;va=Gd(ma|0,la|0,24)|0;wa=C;la=Hd(ma|0,la|0,40)|0;va=la|va;wa=C|wa;ja=Dd(e|0,f|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;aa=ja^aa;ba=ka^ba;la=Gd(aa|0,ba|0,16)|0;ma=C;ba=Hd(aa|0,ba|0,48)|0;la=ba|la;ma=C|ma;J=Dd(la|0,ma|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ba=Gd(va|0,wa|0,63)|0;aa=C;wa=Hd(va|0,wa|0,1)|0;ba=wa|ba;aa=C|aa;ga=Dd(ia|0,ha|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,M|0,K|0)|0;fa=C;_=_^ga;Z=Z^fa;z=Dd(Z|0,_|0,E|0,z|0)|0;E=C;ia=z^ia;ha=E^ha;wa=Gd(ia|0,ha|0,24)|0;va=C;ha=Hd(ia|0,ha|0,40)|0;wa=ha|wa;va=C|va;fa=Dd(ra|0,sa|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;Z=fa^Z;_=ga^_;ha=Gd(Z|0,_|0,16)|0;ia=C;_=Hd(Z|0,_|0,48)|0;ha=_|ha;ia=C|ia;E=Dd(ha|0,ia|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;_=Gd(wa|0,va|0,63)|0;Z=C;va=Hd(wa|0,va|0,1)|0;_=va|_;Z=C|Z;ca=Dd(ea|0,da|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,t|0,x|0)|0;v=C;ha=ha^ca;ia=ia^v;G=Dd(ia|0,ha|0,J|0,G|0)|0;J=C;ea=G^ea;da=J^da;va=Gd(ea|0,da|0,24)|0;wa=C;da=Hd(ea|0,da|0,40)|0;va=da|va;wa=C|wa;v=Dd(s|0,u|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ia=v^ia;ha=ca^ha;da=Gd(ia|0,ha|0,16)|0;ea=C;ha=Hd(ia|0,ha|0,48)|0;da=ha|da;ea=C|ea;J=Dd(da|0,ea|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ha=Gd(va|0,wa|0,63)|0;ia=C;wa=Hd(va|0,wa|0,1)|0;ha=wa|ha;ia=C|ia;oa=Dd(ba|0,aa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,H|0,F|0)|0;na=C;ta=ta^oa;ua=ua^na;z=Dd(ua|0,ta|0,E|0,z|0)|0;E=C;ba=z^ba;aa=E^aa;wa=Gd(ba|0,aa|0,24)|0;va=C;aa=Hd(ba|0,aa|0,40)|0;wa=aa|wa;va=C|va;na=Dd(m|0,o|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;ua=na^ua;ta=oa^ta;aa=Gd(ua|0,ta|0,16)|0;ba=C;ta=Hd(ua|0,ta|0,48)|0;aa=ta|aa;ba=C|ba;E=Dd(aa|0,ba|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ta=Gd(wa|0,va|0,63)|0;ua=C;va=Hd(wa|0,va|0,1)|0;ta=va|ta;ua=C|ua;ka=Dd(_|0,Z|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,p|0,$|0)|0;ja=C;pa=pa^ka;qa=qa^ja;Q=Dd(qa|0,pa|0,T|0,Q|0)|0;T=C;_=Q^_;Z=T^Z;va=Gd(_|0,Z|0,24)|0;wa=C;Z=Hd(_|0,Z|0,40)|0;va=Z|va;wa=C|wa;ja=Dd(R|0,P|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;qa=ja^qa;pa=ka^pa;Z=Gd(qa|0,pa|0,16)|0;_=C;pa=Hd(qa|0,pa|0,48)|0;Z=pa|Z;_=C|_;T=Dd(Z|0,_|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;pa=Gd(va|0,wa|0,63)|0;qa=C;wa=Hd(va|0,wa|0,1)|0;pa=wa|pa;qa=C|qa;ga=Dd(X|0,V|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,y|0,A|0)|0;fa=C;la=la^ga;ma=ma^fa;L=Dd(ma|0,la|0,O|0,L|0)|0;O=C;X=L^X;V=O^V;wa=Gd(X|0,V|0,24)|0;va=C;V=Hd(X|0,V|0,40)|0;wa=V|wa;va=C|va;fa=Dd(g|0,i|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ma=fa^ma;la=ga^la;V=Gd(ma|0,la|0,16)|0;X=C;la=Hd(ma|0,la|0,48)|0;V=la|V;X=C|X;O=Dd(V|0,X|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;la=Gd(wa|0,va|0,63)|0;ma=C;va=Hd(wa|0,va|0,1)|0;la=va|la;ma=C|ma;ca=Dd(j|0,Y|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,la|0,ma|0)|0;v=C;aa=ca^aa;ba=v^ba;Q=Dd(ba|0,aa|0,T|0,Q|0)|0;T=C;la=Q^la;ma=T^ma;va=Gd(la|0,ma|0,24)|0;wa=C;ma=Hd(la|0,ma|0,40)|0;va=ma|va;wa=C|wa;v=Dd(R|0,P|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ba=v^ba;aa=ca^aa;ma=Gd(ba|0,aa|0,16)|0;la=C;aa=Hd(ba|0,aa|0,48)|0;ma=aa|ma;la=C|la;T=Dd(ma|0,la|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;aa=Gd(va|0,wa|0,63)|0;ba=C;wa=Hd(va|0,wa|0,1)|0;aa=wa|aa;ba=C|ba;oa=Dd(ha|0,ia|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,H|0,F|0)|0;na=C;Z=Z^oa;_=_^na;L=Dd(_|0,Z|0,O|0,L|0)|0;O=C;ha=L^ha;ia=O^ia;wa=Gd(ha|0,ia|0,24)|0;va=C;ia=Hd(ha|0,ia|0,40)|0;wa=ia|wa;va=C|va;na=Dd(n|0,r|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;_=na^_;Z=oa^Z;ia=Gd(_|0,Z|0,16)|0;ha=C;Z=Hd(_|0,Z|0,48)|0;ia=Z|ia;ha=C|ha;O=Dd(ia|0,ha|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;Z=Gd(wa|0,va|0,63)|0;_=C;va=Hd(wa|0,va|0,1)|0;Z=va|Z;_=C|_;ka=Dd(ta|0,ua|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,t|0,x|0)|0;ja=C;V=V^ka;X=X^ja;G=Dd(X|0,V|0,J|0,G|0)|0;J=C;ta=G^ta;ua=J^ua;va=Gd(ta|0,ua|0,24)|0;wa=C;ua=Hd(ta|0,ua|0,40)|0;va=ua|va;wa=C|wa;ja=Dd(p|0,$|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;X=ja^X;V=ka^V;ua=Gd(X|0,V|0,16)|0;ta=C;V=Hd(X|0,V|0,48)|0;ua=V|ua;ta=C|ta;J=Dd(ua|0,ta|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;V=Gd(va|0,wa|0,63)|0;X=C;wa=Hd(va|0,wa|0,1)|0;V=wa|V;X=C|X;ga=Dd(pa|0,qa|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,m|0,o|0)|0;fa=C;da=da^ga;ea=ea^fa;z=Dd(ea|0,da|0,E|0,z|0)|0;E=C;pa=z^pa;qa=E^qa;wa=Gd(pa|0,qa|0,24)|0;va=C;qa=Hd(pa|0,qa|0,40)|0;wa=qa|wa;va=C|va;fa=Dd(y|0,A|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ea=fa^ea;da=ga^da;qa=Gd(ea|0,da|0,16)|0;pa=C;da=Hd(ea|0,da|0,48)|0;qa=da|qa;pa=C|pa;E=Dd(qa|0,pa|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;da=Gd(wa|0,va|0,63)|0;ea=C;va=Hd(wa|0,va|0,1)|0;da=va|da;ea=C|ea;ca=Dd(Z|0,_|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ra|0,sa|0)|0;v=C;qa=qa^ca;pa=pa^v;G=Dd(pa|0,qa|0,J|0,G|0)|0;J=C;Z=G^Z;_=J^_;va=Gd(Z|0,_|0,24)|0;wa=C;_=Hd(Z|0,_|0,40)|0;va=_|va;wa=C|wa;v=Dd(W|0,U|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;pa=v^pa;qa=ca^qa;_=Gd(pa|0,qa|0,16)|0;Z=C;qa=Hd(pa|0,qa|0,48)|0;_=qa|_;Z=C|Z;J=Dd(_|0,Z|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;qa=Gd(va|0,wa|0,63)|0;pa=C;wa=Hd(va|0,wa|0,1)|0;qa=wa|qa;pa=C|pa;oa=Dd(V|0,X|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,M|0,K|0)|0;na=C;ma=ma^oa;la=la^na;z=Dd(la|0,ma|0,E|0,z|0)|0;E=C;V=z^V;X=E^X;wa=Gd(V|0,X|0,24)|0;va=C;X=Hd(V|0,X|0,40)|0;wa=X|wa;va=C|va;na=Dd(e|0,f|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;la=na^la;ma=oa^ma;X=Gd(la|0,ma|0,16)|0;V=C;ma=Hd(la|0,ma|0,48)|0;X=ma|X;V=C|V;E=Dd(X|0,V|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ma=Gd(wa|0,va|0,63)|0;la=C;va=Hd(wa|0,va|0,1)|0;ma=va|ma;la=C|la;ka=Dd(da|0,ea|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,s|0,u|0)|0;ja=C;ia=ia^ka;ha=ha^ja;Q=Dd(ha|0,ia|0,T|0,Q|0)|0;T=C;da=Q^da;ea=T^ea;va=Gd(da|0,ea|0,24)|0;wa=C;ea=Hd(da|0,ea|0,40)|0;va=ea|va;wa=C|wa;ja=Dd(g|0,i|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;ha=ja^ha;ia=ka^ia;ea=Gd(ha|0,ia|0,16)|0;da=C;ia=Hd(ha|0,ia|0,48)|0;ea=ia|ea;da=C|da;T=Dd(ea|0,da|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;ia=Gd(va|0,wa|0,63)|0;ha=C;wa=Hd(va|0,wa|0,1)|0;ia=wa|ia;ha=C|ha;ga=Dd(aa|0,ba|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,h|0,l|0)|0;fa=C;ua=ua^ga;ta=ta^fa;L=Dd(ta|0,ua|0,O|0,L|0)|0;O=C;aa=L^aa;ba=O^ba;wa=Gd(aa|0,ba|0,24)|0;va=C;ba=Hd(aa|0,ba|0,40)|0;wa=ba|wa;va=C|va;fa=Dd(B|0,S|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ta=fa^ta;ua=ga^ua;ba=Gd(ta|0,ua|0,16)|0;aa=C;ua=Hd(ta|0,ua|0,48)|0;ba=ua|ba;aa=C|aa;O=Dd(ba|0,aa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ua=Gd(wa|0,va|0,63)|0;ta=C;va=Hd(wa|0,va|0,1)|0;ua=va|ua;ta=C|ta;ca=Dd(t|0,x|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ua|0,ta|0)|0;v=C;X=ca^X;V=v^V;Q=Dd(V|0,X|0,T|0,Q|0)|0;T=C;ua=Q^ua;ta=T^ta;va=Gd(ua|0,ta|0,24)|0;wa=C;ta=Hd(ua|0,ta|0,40)|0;va=ta|va;wa=C|wa;v=Dd(e|0,f|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;V=v^V;X=ca^X;ta=Gd(V|0,X|0,16)|0;ua=C;X=Hd(V|0,X|0,48)|0;ta=X|ta;ua=C|ua;T=Dd(ta|0,ua|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;X=Gd(va|0,wa|0,63)|0;V=C;wa=Hd(va|0,wa|0,1)|0;X=wa|X;V=C|V;oa=Dd(qa|0,pa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,s|0,u|0)|0;na=C;ea=ea^oa;da=da^na;L=Dd(da|0,ea|0,O|0,L|0)|0;O=C;qa=L^qa;pa=O^pa;wa=Gd(qa|0,pa|0,24)|0;va=C;pa=Hd(qa|0,pa|0,40)|0;wa=pa|wa;va=C|va;na=Dd(m|0,o|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;da=na^da;ea=oa^ea;pa=Gd(da|0,ea|0,16)|0;qa=C;ea=Hd(da|0,ea|0,48)|0;pa=ea|pa;qa=C|qa;O=Dd(pa|0,qa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ea=Gd(wa|0,va|0,63)|0;da=C;va=Hd(wa|0,va|0,1)|0;ea=va|ea;da=C|da;ka=Dd(ma|0,la|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,R|0,P|0)|0;ja=C;ba=ba^ka;aa=aa^ja;G=Dd(aa|0,ba|0,J|0,G|0)|0;J=C;ma=G^ma;la=J^la;va=Gd(ma|0,la|0,24)|0;wa=C;la=Hd(ma|0,la|0,40)|0;va=la|va;wa=C|wa;ja=Dd(M|0,K|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;aa=ja^aa;ba=ka^ba;la=Gd(aa|0,ba|0,16)|0;ma=C;ba=Hd(aa|0,ba|0,48)|0;la=ba|la;ma=C|ma;J=Dd(la|0,ma|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ba=Gd(va|0,wa|0,63)|0;aa=C;wa=Hd(va|0,wa|0,1)|0;ba=wa|ba;aa=C|aa;ga=Dd(ia|0,ha|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,g|0,i|0)|0;fa=C;_=_^ga;Z=Z^fa;z=Dd(Z|0,_|0,E|0,z|0)|0;E=C;ia=z^ia;ha=E^ha;wa=Gd(ia|0,ha|0,24)|0;va=C;ha=Hd(ia|0,ha|0,40)|0;wa=ha|wa;va=C|va;fa=Dd(h|0,l|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;Z=fa^Z;_=ga^_;ha=Gd(Z|0,_|0,16)|0;ia=C;_=Hd(Z|0,_|0,48)|0;ha=_|ha;ia=C|ia;E=Dd(ha|0,ia|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;_=Gd(wa|0,va|0,63)|0;Z=C;va=Hd(wa|0,va|0,1)|0;_=va|_;Z=C|Z;ca=Dd(ea|0,da|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,p|0,$|0)|0;v=C;ha=ha^ca;ia=ia^v;G=Dd(ia|0,ha|0,J|0,G|0)|0;J=C;ea=G^ea;da=J^da;va=Gd(ea|0,da|0,24)|0;wa=C;da=Hd(ea|0,da|0,40)|0;va=da|va;wa=C|wa;v=Dd(B|0,S|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ia=v^ia;ha=ca^ha;da=Gd(ia|0,ha|0,16)|0;ea=C;ha=Hd(ia|0,ha|0,48)|0;da=ha|da;ea=C|ea;J=Dd(da|0,ea|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ha=Gd(va|0,wa|0,63)|0;ia=C;wa=Hd(va|0,wa|0,1)|0;ha=wa|ha;ia=C|ia;oa=Dd(ba|0,aa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,n|0,r|0)|0;na=C;ta=ta^oa;ua=ua^na;z=Dd(ua|0,ta|0,E|0,z|0)|0;E=C;ba=z^ba;aa=E^aa;wa=Gd(ba|0,aa|0,24)|0;va=C;aa=Hd(ba|0,aa|0,40)|0;wa=aa|wa;va=C|va;na=Dd(H|0,F|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;ua=na^ua;ta=oa^ta;aa=Gd(ua|0,ta|0,16)|0;ba=C;ta=Hd(ua|0,ta|0,48)|0;aa=ta|aa;ba=C|ba;E=Dd(aa|0,ba|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ta=Gd(wa|0,va|0,63)|0;ua=C;va=Hd(wa|0,va|0,1)|0;ta=va|ta;ua=C|ua;ka=Dd(_|0,Z|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,y|0,A|0)|0;ja=C;pa=pa^ka;qa=qa^ja;Q=Dd(qa|0,pa|0,T|0,Q|0)|0;T=C;_=Q^_;Z=T^Z;va=Gd(_|0,Z|0,24)|0;wa=C;Z=Hd(_|0,Z|0,40)|0;va=Z|va;wa=C|wa;ja=Dd(ra|0,sa|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;qa=ja^qa;pa=ka^pa;Z=Gd(qa|0,pa|0,16)|0;_=C;pa=Hd(qa|0,pa|0,48)|0;Z=pa|Z;_=C|_;T=Dd(Z|0,_|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;pa=Gd(va|0,wa|0,63)|0;qa=C;wa=Hd(va|0,wa|0,1)|0;pa=wa|pa;qa=C|qa;ga=Dd(X|0,V|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,W|0,U|0)|0;fa=C;la=la^ga;ma=ma^fa;L=Dd(ma|0,la|0,O|0,L|0)|0;O=C;X=L^X;V=O^V;wa=Gd(X|0,V|0,24)|0;va=C;V=Hd(X|0,V|0,40)|0;wa=V|wa;va=C|va;fa=Dd(j|0,Y|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ma=fa^ma;la=ga^la;V=Gd(ma|0,la|0,16)|0;X=C;la=Hd(ma|0,la|0,48)|0;V=la|V;X=C|X;O=Dd(V|0,X|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;la=Gd(wa|0,va|0,63)|0;ma=C;va=Hd(wa|0,va|0,1)|0;la=va|la;ma=C|ma;ca=Dd(e|0,f|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,la|0,ma|0)|0;v=C;aa=ca^aa;ba=v^ba;Q=Dd(ba|0,aa|0,T|0,Q|0)|0;T=C;la=Q^la;ma=T^ma;va=Gd(la|0,ma|0,24)|0;wa=C;ma=Hd(la|0,ma|0,40)|0;va=ma|va;wa=C|wa;v=Dd(H|0,F|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ba=v^ba;aa=ca^aa;ma=Gd(ba|0,aa|0,16)|0;la=C;aa=Hd(ba|0,aa|0,48)|0;ma=aa|ma;la=C|la;T=Dd(ma|0,la|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;aa=Gd(va|0,wa|0,63)|0;ba=C;wa=Hd(va|0,wa|0,1)|0;aa=wa|aa;ba=C|ba;oa=Dd(ha|0,ia|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,W|0,U|0)|0;na=C;Z=Z^oa;_=_^na;L=Dd(_|0,Z|0,O|0,L|0)|0;O=C;ha=L^ha;ia=O^ia;wa=Gd(ha|0,ia|0,24)|0;va=C;ia=Hd(ha|0,ia|0,40)|0;wa=ia|wa;va=C|va;na=Dd(y|0,A|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;_=na^_;Z=oa^Z;ia=Gd(_|0,Z|0,16)|0;ha=C;Z=Hd(_|0,Z|0,48)|0;ia=Z|ia;ha=C|ha;O=Dd(ia|0,ha|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;Z=Gd(wa|0,va|0,63)|0;_=C;va=Hd(wa|0,va|0,1)|0;Z=va|Z;_=C|_;ka=Dd(ta|0,ua|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,ra|0,sa|0)|0;ja=C;V=V^ka;X=X^ja;G=Dd(X|0,V|0,J|0,G|0)|0;J=C;ta=G^ta;ua=J^ua;va=Gd(ta|0,ua|0,24)|0;wa=C;ua=Hd(ta|0,ua|0,40)|0;va=ua|va;wa=C|wa;ja=Dd(B|0,S|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;X=ja^X;V=ka^V;ua=Gd(X|0,V|0,16)|0;ta=C;V=Hd(X|0,V|0,48)|0;ua=V|ua;ta=C|ta;J=Dd(ua|0,ta|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;V=Gd(va|0,wa|0,63)|0;X=C;wa=Hd(va|0,wa|0,1)|0;V=wa|V;X=C|X;ga=Dd(pa|0,qa|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,p|0,$|0)|0;fa=C;da=da^ga;ea=ea^fa;z=Dd(ea|0,da|0,E|0,z|0)|0;E=C;pa=z^pa;qa=E^qa;wa=Gd(pa|0,qa|0,24)|0;va=C;qa=Hd(pa|0,qa|0,40)|0;wa=qa|wa;va=C|va;fa=Dd(m|0,o|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ea=fa^ea;da=ga^da;qa=Gd(ea|0,da|0,16)|0;pa=C;da=Hd(ea|0,da|0,48)|0;qa=da|qa;pa=C|pa;E=Dd(qa|0,pa|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;da=Gd(wa|0,va|0,63)|0;ea=C;va=Hd(wa|0,va|0,1)|0;da=va|da;ea=C|ea;ca=Dd(Z|0,_|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,R|0,P|0)|0;v=C;qa=qa^ca;pa=pa^v;G=Dd(pa|0,qa|0,J|0,G|0)|0;J=C;Z=G^Z;_=J^_;va=Gd(Z|0,_|0,24)|0;wa=C;_=Hd(Z|0,_|0,40)|0;va=_|va;wa=C|wa;v=Dd(n|0,r|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;pa=v^pa;qa=ca^qa;_=Gd(pa|0,qa|0,16)|0;Z=C;qa=Hd(pa|0,qa|0,48)|0;_=qa|_;Z=C|Z;J=Dd(_|0,Z|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;qa=Gd(va|0,wa|0,63)|0;pa=C;wa=Hd(va|0,wa|0,1)|0;qa=wa|qa;pa=C|pa;oa=Dd(V|0,X|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,s|0,u|0)|0;na=C;ma=ma^oa;la=la^na;z=Dd(la|0,ma|0,E|0,z|0)|0;E=C;V=z^V;X=E^X;wa=Gd(V|0,X|0,24)|0;va=C;X=Hd(V|0,X|0,40)|0;wa=X|wa;va=C|va;na=Dd(h|0,l|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;la=na^la;ma=oa^ma;X=Gd(la|0,ma|0,16)|0;V=C;ma=Hd(la|0,ma|0,48)|0;X=ma|X;V=C|V;E=Dd(X|0,V|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ma=Gd(wa|0,va|0,63)|0;la=C;va=Hd(wa|0,va|0,1)|0;ma=va|ma;la=C|la;ka=Dd(da|0,ea|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,j|0,Y|0)|0;ja=C;ia=ia^ka;ha=ha^ja;Q=Dd(ha|0,ia|0,T|0,Q|0)|0;T=C;da=Q^da;ea=T^ea;va=Gd(da|0,ea|0,24)|0;wa=C;ea=Hd(da|0,ea|0,40)|0;va=ea|va;wa=C|wa;ja=Dd(t|0,x|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;ha=ja^ha;ia=ka^ia;ea=Gd(ha|0,ia|0,16)|0;da=C;ia=Hd(ha|0,ia|0,48)|0;ea=ia|ea;da=C|da;T=Dd(ea|0,da|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;ia=Gd(va|0,wa|0,63)|0;ha=C;wa=Hd(va|0,wa|0,1)|0;ia=wa|ia;ha=C|ha;ga=Dd(aa|0,ba|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,g|0,i|0)|0;fa=C;ua=ua^ga;ta=ta^fa;L=Dd(ta|0,ua|0,O|0,L|0)|0;O=C;aa=L^aa;ba=O^ba;wa=Gd(aa|0,ba|0,24)|0;va=C;ba=Hd(aa|0,ba|0,40)|0;wa=ba|wa;va=C|va;fa=Dd(M|0,K|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ta=fa^ta;ua=ga^ua;ba=Gd(ta|0,ua|0,16)|0;aa=C;ua=Hd(ta|0,ua|0,48)|0;ba=ua|ba;aa=C|aa;O=Dd(ba|0,aa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ua=Gd(wa|0,va|0,63)|0;ta=C;va=Hd(wa|0,va|0,1)|0;ua=va|ua;ta=C|ta;ca=Dd(B|0,S|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ua|0,ta|0)|0;v=C;X=ca^X;V=v^V;Q=Dd(V|0,X|0,T|0,Q|0)|0;T=C;ua=Q^ua;ta=T^ta;va=Gd(ua|0,ta|0,24)|0;wa=C;ta=Hd(ua|0,ta|0,40)|0;va=ta|va;wa=C|wa;v=Dd(M|0,K|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;V=v^V;X=ca^X;ta=Gd(V|0,X|0,16)|0;ua=C;X=Hd(V|0,X|0,48)|0;ta=X|ta;ua=C|ua;T=Dd(ta|0,ua|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;X=Gd(va|0,wa|0,63)|0;V=C;wa=Hd(va|0,wa|0,1)|0;X=wa|X;V=C|V;oa=Dd(qa|0,pa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,n|0,r|0)|0;na=C;ea=ea^oa;da=da^na;L=Dd(da|0,ea|0,O|0,L|0)|0;O=C;qa=L^qa;pa=O^pa;wa=Gd(qa|0,pa|0,24)|0;va=C;pa=Hd(qa|0,pa|0,40)|0;wa=pa|wa;va=C|va;na=Dd(ra|0,sa|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;da=na^da;ea=oa^ea;pa=Gd(da|0,ea|0,16)|0;qa=C;ea=Hd(da|0,ea|0,48)|0;pa=ea|pa;qa=C|qa;O=Dd(pa|0,qa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ea=Gd(wa|0,va|0,63)|0;da=C;va=Hd(wa|0,va|0,1)|0;ea=va|ea;da=C|da;ka=Dd(ma|0,la|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,e|0,f|0)|0;ja=C;ba=ba^ka;aa=aa^ja;G=Dd(aa|0,ba|0,J|0,G|0)|0;J=C;ma=G^ma;la=J^la;va=Gd(ma|0,la|0,24)|0;wa=C;la=Hd(ma|0,la|0,40)|0;va=la|va;wa=C|wa;ja=Dd(W|0,U|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;aa=ja^aa;ba=ka^ba;la=Gd(aa|0,ba|0,16)|0;ma=C;ba=Hd(aa|0,ba|0,48)|0;la=ba|la;ma=C|ma;J=Dd(la|0,ma|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ba=Gd(va|0,wa|0,63)|0;aa=C;wa=Hd(va|0,wa|0,1)|0;ba=wa|ba;aa=C|aa;ga=Dd(ia|0,ha|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,h|0,l|0)|0;fa=C;_=_^ga;Z=Z^fa;z=Dd(Z|0,_|0,E|0,z|0)|0;E=C;ia=z^ia;ha=E^ha;wa=Gd(ia|0,ha|0,24)|0;va=C;ha=Hd(ia|0,ha|0,40)|0;wa=ha|wa;va=C|va;fa=Dd(j|0,Y|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;Z=fa^Z;_=ga^_;ha=Gd(Z|0,_|0,16)|0;ia=C;_=Hd(Z|0,_|0,48)|0;ha=_|ha;ia=C|ia;E=Dd(ha|0,ia|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;_=Gd(wa|0,va|0,63)|0;Z=C;va=Hd(wa|0,va|0,1)|0;_=va|_;Z=C|Z;ca=Dd(ea|0,da|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,H|0,F|0)|0;v=C;ha=ha^ca;ia=ia^v;G=Dd(ia|0,ha|0,J|0,G|0)|0;J=C;ea=G^ea;da=J^da;va=Gd(ea|0,da|0,24)|0;wa=C;da=Hd(ea|0,da|0,40)|0;va=da|va;wa=C|wa;v=Dd(R|0,P|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ia=v^ia;ha=ca^ha;da=Gd(ia|0,ha|0,16)|0;ea=C;ha=Hd(ia|0,ha|0,48)|0;da=ha|da;ea=C|ea;J=Dd(da|0,ea|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ha=Gd(va|0,wa|0,63)|0;ia=C;wa=Hd(va|0,wa|0,1)|0;ha=wa|ha;ia=C|ia;oa=Dd(ba|0,aa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,y|0,A|0)|0;na=C;ta=ta^oa;ua=ua^na;z=Dd(ua|0,ta|0,E|0,z|0)|0;E=C;ba=z^ba;aa=E^aa;wa=Gd(ba|0,aa|0,24)|0;va=C;aa=Hd(ba|0,aa|0,40)|0;wa=aa|wa;va=C|va;na=Dd(p|0,$|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;ua=na^ua;ta=oa^ta;aa=Gd(ua|0,ta|0,16)|0;ba=C;ta=Hd(ua|0,ta|0,48)|0;aa=ta|aa;ba=C|ba;E=Dd(aa|0,ba|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ta=Gd(wa|0,va|0,63)|0;ua=C;va=Hd(wa|0,va|0,1)|0;ta=va|ta;ua=C|ua;ka=Dd(_|0,Z|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,g|0,i|0)|0;ja=C;pa=pa^ka;qa=qa^ja;Q=Dd(qa|0,pa|0,T|0,Q|0)|0;T=C;_=Q^_;Z=T^Z;va=Gd(_|0,Z|0,24)|0;wa=C;Z=Hd(_|0,Z|0,40)|0;va=Z|va;wa=C|wa;ja=Dd(s|0,u|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;qa=ja^qa;pa=ka^pa;Z=Gd(qa|0,pa|0,16)|0;_=C;pa=Hd(qa|0,pa|0,48)|0;Z=pa|Z;_=C|_;T=Dd(Z|0,_|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;pa=Gd(va|0,wa|0,63)|0;qa=C;wa=Hd(va|0,wa|0,1)|0;pa=wa|pa;qa=C|qa;ga=Dd(X|0,V|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,t|0,x|0)|0;fa=C;la=la^ga;ma=ma^fa;L=Dd(ma|0,la|0,O|0,L|0)|0;O=C;X=L^X;V=O^V;wa=Gd(X|0,V|0,24)|0;va=C;V=Hd(X|0,V|0,40)|0;wa=V|wa;va=C|va;fa=Dd(m|0,o|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ma=fa^ma;la=ga^la;V=Gd(ma|0,la|0,16)|0;X=C;la=Hd(ma|0,la|0,48)|0;V=la|V;X=C|X;O=Dd(V|0,X|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;la=Gd(wa|0,va|0,63)|0;ma=C;va=Hd(wa|0,va|0,1)|0;la=va|la;ma=C|ma;ca=Dd(s|0,u|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,la|0,ma|0)|0;v=C;aa=ca^aa;ba=v^ba;Q=Dd(ba|0,aa|0,T|0,Q|0)|0;T=C;la=Q^la;ma=T^ma;va=Gd(la|0,ma|0,24)|0;wa=C;ma=Hd(la|0,ma|0,40)|0;va=ma|va;wa=C|wa;v=Dd(y|0,A|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ba=v^ba;aa=ca^aa;ma=Gd(ba|0,aa|0,16)|0;la=C;aa=Hd(ba|0,aa|0,48)|0;ma=aa|ma;la=C|la;T=Dd(ma|0,la|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;aa=Gd(va|0,wa|0,63)|0;ba=C;wa=Hd(va|0,wa|0,1)|0;aa=wa|aa;ba=C|ba;oa=Dd(ha|0,ia|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,ra|0,sa|0)|0;na=C;Z=Z^oa;_=_^na;L=Dd(_|0,Z|0,O|0,L|0)|0;O=C;ha=L^ha;ia=O^ia;wa=Gd(ha|0,ia|0,24)|0;va=C;ia=Hd(ha|0,ia|0,40)|0;wa=ia|wa;va=C|va;na=Dd(j|0,Y|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;_=na^_;Z=oa^Z;ia=Gd(_|0,Z|0,16)|0;ha=C;Z=Hd(_|0,Z|0,48)|0;ia=Z|ia;ha=C|ha;O=Dd(ia|0,ha|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;Z=Gd(wa|0,va|0,63)|0;_=C;va=Hd(wa|0,va|0,1)|0;Z=va|Z;_=C|_;ka=Dd(ta|0,ua|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,M|0,K|0)|0;ja=C;V=V^ka;X=X^ja;G=Dd(X|0,V|0,J|0,G|0)|0;J=C;ta=G^ta;ua=J^ua;va=Gd(ta|0,ua|0,24)|0;wa=C;ua=Hd(ta|0,ua|0,40)|0;va=ua|va;wa=C|wa;ja=Dd(h|0,l|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;X=ja^X;V=ka^V;ua=Gd(X|0,V|0,16)|0;ta=C;V=Hd(X|0,V|0,48)|0;ua=V|ua;ta=C|ta;J=Dd(ua|0,ta|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;V=Gd(va|0,wa|0,63)|0;X=C;wa=Hd(va|0,wa|0,1)|0;V=wa|V;X=C|X;ga=Dd(pa|0,qa|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,R|0,P|0)|0;fa=C;da=da^ga;ea=ea^fa;z=Dd(ea|0,da|0,E|0,z|0)|0;E=C;pa=z^pa;qa=E^qa;wa=Gd(pa|0,qa|0,24)|0;va=C;qa=Hd(pa|0,qa|0,40)|0;wa=qa|wa;va=C|va;fa=Dd(g|0,i|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ea=fa^ea;da=ga^da;qa=Gd(ea|0,da|0,16)|0;pa=C;da=Hd(ea|0,da|0,48)|0;qa=da|qa;pa=C|pa;E=Dd(qa|0,pa|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;da=Gd(wa|0,va|0,63)|0;ea=C;va=Hd(wa|0,va|0,1)|0;da=va|da;ea=C|ea;ca=Dd(Z|0,_|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,e|0,f|0)|0;v=C;qa=qa^ca;pa=pa^v;G=Dd(pa|0,qa|0,J|0,G|0)|0;J=C;Z=G^Z;_=J^_;va=Gd(Z|0,_|0,24)|0;wa=C;_=Hd(Z|0,_|0,40)|0;va=_|va;wa=C|wa;v=Dd(t|0,x|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;pa=v^pa;qa=ca^qa;_=Gd(pa|0,qa|0,16)|0;Z=C;qa=Hd(pa|0,qa|0,48)|0;_=qa|_;Z=C|Z;J=Dd(_|0,Z|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;qa=Gd(va|0,wa|0,63)|0;pa=C;wa=Hd(va|0,wa|0,1)|0;qa=wa|qa;pa=C|pa;oa=Dd(V|0,X|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,B|0,S|0)|0;na=C;ma=ma^oa;la=la^na;z=Dd(la|0,ma|0,E|0,z|0)|0;E=C;V=z^V;X=E^X;wa=Gd(V|0,X|0,24)|0;va=C;X=Hd(V|0,X|0,40)|0;wa=X|wa;va=C|va;na=Dd(n|0,r|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;la=na^la;ma=oa^ma;X=Gd(la|0,ma|0,16)|0;V=C;ma=Hd(la|0,ma|0,48)|0;X=ma|X;V=C|V;E=Dd(X|0,V|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ma=Gd(wa|0,va|0,63)|0;la=C;va=Hd(wa|0,va|0,1)|0;ma=va|ma;la=C|la;ka=Dd(da|0,ea|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,W|0,U|0)|0;ja=C;ia=ia^ka;ha=ha^ja;Q=Dd(ha|0,ia|0,T|0,Q|0)|0;T=C;da=Q^da;ea=T^ea;va=Gd(da|0,ea|0,24)|0;wa=C;ea=Hd(da|0,ea|0,40)|0;va=ea|va;wa=C|wa;ja=Dd(p|0,$|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;ha=ja^ha;ia=ka^ia;ea=Gd(ha|0,ia|0,16)|0;da=C;ia=Hd(ha|0,ia|0,48)|0;ea=ia|ea;da=C|da;T=Dd(ea|0,da|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;ia=Gd(va|0,wa|0,63)|0;ha=C;wa=Hd(va|0,wa|0,1)|0;ia=wa|ia;ha=C|ha;ga=Dd(aa|0,ba|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,m|0,o|0)|0;fa=C;ua=ua^ga;ta=ta^fa;L=Dd(ta|0,ua|0,O|0,L|0)|0;O=C;aa=L^aa;ba=O^ba;wa=Gd(aa|0,ba|0,24)|0;va=C;ba=Hd(aa|0,ba|0,40)|0;wa=ba|wa;va=C|va;fa=Dd(H|0,F|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ta=fa^ta;ua=ga^ua;ba=Gd(ta|0,ua|0,16)|0;aa=C;ua=Hd(ta|0,ua|0,48)|0;ba=ua|ba;aa=C|aa;O=Dd(ba|0,aa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ua=Gd(wa|0,va|0,63)|0;ta=C;va=Hd(wa|0,va|0,1)|0;ua=va|ua;ta=C|ta;ca=Dd(m|0,o|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ua|0,ta|0)|0;v=C;X=ca^X;V=v^V;Q=Dd(V|0,X|0,T|0,Q|0)|0;T=C;ua=Q^ua;ta=T^ta;va=Gd(ua|0,ta|0,24)|0;wa=C;ta=Hd(ua|0,ta|0,40)|0;va=ta|va;wa=C|wa;v=Dd(t|0,x|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;V=v^V;X=ca^X;ta=Gd(V|0,X|0,16)|0;ua=C;X=Hd(V|0,X|0,48)|0;ta=X|ta;ua=C|ua;T=Dd(ta|0,ua|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;X=Gd(va|0,wa|0,63)|0;V=C;wa=Hd(va|0,wa|0,1)|0;X=wa|X;V=C|V;oa=Dd(qa|0,pa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,g|0,i|0)|0;na=C;ea=ea^oa;da=da^na;L=Dd(da|0,ea|0,O|0,L|0)|0;O=C;qa=L^qa;pa=O^pa;wa=Gd(qa|0,pa|0,24)|0;va=C;pa=Hd(qa|0,pa|0,40)|0;wa=pa|wa;va=C|va;na=Dd(p|0,$|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;da=na^da;ea=oa^ea;pa=Gd(da|0,ea|0,16)|0;qa=C;ea=Hd(da|0,ea|0,48)|0;pa=ea|pa;qa=C|qa;O=Dd(pa|0,qa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ea=Gd(wa|0,va|0,63)|0;da=C;va=Hd(wa|0,va|0,1)|0;ea=va|ea;da=C|da;ka=Dd(ma|0,la|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,n|0,r|0)|0;ja=C;ba=ba^ka;aa=aa^ja;G=Dd(aa|0,ba|0,J|0,G|0)|0;J=C;ma=G^ma;la=J^la;va=Gd(ma|0,la|0,24)|0;wa=C;la=Hd(ma|0,la|0,40)|0;va=la|va;wa=C|wa;ja=Dd(s|0,u|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;aa=ja^aa;ba=ka^ba;la=Gd(aa|0,ba|0,16)|0;ma=C;ba=Hd(aa|0,ba|0,48)|0;la=ba|la;ma=C|ma;J=Dd(la|0,ma|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ba=Gd(va|0,wa|0,63)|0;aa=C;wa=Hd(va|0,wa|0,1)|0;ba=wa|ba;aa=C|aa;ga=Dd(ia|0,ha|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,W|0,U|0)|0;fa=C;_=_^ga;Z=Z^fa;z=Dd(Z|0,_|0,E|0,z|0)|0;E=C;ia=z^ia;ha=E^ha;wa=Gd(ia|0,ha|0,24)|0;va=C;ha=Hd(ia|0,ha|0,40)|0;wa=ha|wa;va=C|va;fa=Dd(H|0,F|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;Z=fa^Z;_=ga^_;ha=Gd(Z|0,_|0,16)|0;ia=C;_=Hd(Z|0,_|0,48)|0;ha=_|ha;ia=C|ia;E=Dd(ha|0,ia|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;_=Gd(wa|0,va|0,63)|0;Z=C;va=Hd(wa|0,va|0,1)|0;_=va|_;Z=C|Z;ca=Dd(ea|0,da|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,y|0,A|0)|0;v=C;ha=ha^ca;ia=ia^v;G=Dd(ia|0,ha|0,J|0,G|0)|0;J=C;ea=G^ea;da=J^da;va=Gd(ea|0,da|0,24)|0;wa=C;da=Hd(ea|0,da|0,40)|0;va=da|va;wa=C|wa;v=Dd(M|0,K|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ia=v^ia;ha=ca^ha;da=Gd(ia|0,ha|0,16)|0;ea=C;ha=Hd(ia|0,ha|0,48)|0;da=ha|da;ea=C|ea;J=Dd(da|0,ea|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;ha=Gd(va|0,wa|0,63)|0;ia=C;wa=Hd(va|0,wa|0,1)|0;ha=wa|ha;ia=C|ia;oa=Dd(ba|0,aa|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,j|0,Y|0)|0;na=C;ta=ta^oa;ua=ua^na;z=Dd(ua|0,ta|0,E|0,z|0)|0;E=C;ba=z^ba;aa=E^aa;wa=Gd(ba|0,aa|0,24)|0;va=C;aa=Hd(ba|0,aa|0,40)|0;wa=aa|wa;va=C|va;na=Dd(ra|0,sa|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;ua=na^ua;ta=oa^ta;aa=Gd(ua|0,ta|0,16)|0;ba=C;ta=Hd(ua|0,ta|0,48)|0;aa=ta|aa;ba=C|ba;E=Dd(aa|0,ba|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ta=Gd(wa|0,va|0,63)|0;ua=C;va=Hd(wa|0,va|0,1)|0;ta=va|ta;ua=C|ua;ka=Dd(_|0,Z|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,h|0,l|0)|0;ja=C;pa=pa^ka;qa=qa^ja;Q=Dd(qa|0,pa|0,T|0,Q|0)|0;T=C;_=Q^_;Z=T^Z;va=Gd(_|0,Z|0,24)|0;wa=C;Z=Hd(_|0,Z|0,40)|0;va=Z|va;wa=C|wa;ja=Dd(e|0,f|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;qa=ja^qa;pa=ka^pa;Z=Gd(qa|0,pa|0,16)|0;_=C;pa=Hd(qa|0,pa|0,48)|0;Z=pa|Z;_=C|_;T=Dd(Z|0,_|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;pa=Gd(va|0,wa|0,63)|0;qa=C;wa=Hd(va|0,wa|0,1)|0;pa=wa|pa;qa=C|qa;ga=Dd(X|0,V|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,B|0,S|0)|0;fa=C;la=la^ga;ma=ma^fa;L=Dd(ma|0,la|0,O|0,L|0)|0;O=C;X=L^X;V=O^V;wa=Gd(X|0,V|0,24)|0;va=C;V=Hd(X|0,V|0,40)|0;wa=V|wa;va=C|va;fa=Dd(R|0,P|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ma=fa^ma;la=ga^la;V=Gd(ma|0,la|0,16)|0;X=C;la=Hd(ma|0,la|0,48)|0;V=la|V;X=C|X;O=Dd(V|0,X|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;la=Gd(wa|0,va|0,63)|0;ma=C;va=Hd(wa|0,va|0,1)|0;la=va|la;ma=C|ma;ca=Dd(R|0,P|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,la|0,ma|0)|0;v=C;aa=ca^aa;ba=v^ba;Q=Dd(ba|0,aa|0,T|0,Q|0)|0;T=C;la=Q^la;ma=T^ma;va=Gd(la|0,ma|0,24)|0;wa=C;ma=Hd(la|0,ma|0,40)|0;va=ma|va;wa=C|wa;v=Dd(W|0,U|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;ba=v^ba;aa=ca^aa;ma=Gd(ba|0,aa|0,16)|0;la=C;aa=Hd(ba|0,aa|0,48)|0;ma=aa|ma;la=C|la;T=Dd(ma|0,la|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;aa=Gd(va|0,wa|0,63)|0;ba=C;wa=Hd(va|0,wa|0,1)|0;aa=wa|aa;ba=C|ba;oa=Dd(ha|0,ia|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,t|0,x|0)|0;na=C;Z=Z^oa;_=_^na;L=Dd(_|0,Z|0,O|0,L|0)|0;O=C;ha=L^ha;ia=O^ia;wa=Gd(ha|0,ia|0,24)|0;va=C;ia=Hd(ha|0,ia|0,40)|0;wa=ia|wa;va=C|va;na=Dd(h|0,l|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;_=na^_;Z=oa^Z;ia=Gd(_|0,Z|0,16)|0;ha=C;Z=Hd(_|0,Z|0,48)|0;ia=Z|ia;ha=C|ha;O=Dd(ia|0,ha|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;Z=Gd(wa|0,va|0,63)|0;_=C;va=Hd(wa|0,va|0,1)|0;Z=va|Z;_=C|_;ka=Dd(ta|0,ua|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,p|0,$|0)|0;ja=C;V=V^ka;X=X^ja;G=Dd(X|0,V|0,J|0,G|0)|0;J=C;ta=G^ta;ua=J^ua;va=Gd(ta|0,ua|0,24)|0;wa=C;ua=Hd(ta|0,ua|0,40)|0;va=ua|va;wa=C|wa;ja=Dd(H|0,F|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;X=ja^X;V=ka^V;ua=Gd(X|0,V|0,16)|0;ta=C;V=Hd(X|0,V|0,48)|0;ua=V|ua;ta=C|ta;J=Dd(ua|0,ta|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;V=Gd(va|0,wa|0,63)|0;X=C;wa=Hd(va|0,wa|0,1)|0;V=wa|V;X=C|X;ga=Dd(pa|0,qa|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,s|0,u|0)|0;fa=C;da=da^ga;ea=ea^fa;z=Dd(ea|0,da|0,E|0,z|0)|0;E=C;pa=z^pa;qa=E^qa;wa=Gd(pa|0,qa|0,24)|0;va=C;qa=Hd(pa|0,qa|0,40)|0;wa=qa|wa;va=C|va;fa=Dd(n|0,r|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ea=fa^ea;da=ga^da;qa=Gd(ea|0,da|0,16)|0;pa=C;da=Hd(ea|0,da|0,48)|0;qa=da|qa;pa=C|pa;E=Dd(qa|0,pa|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;da=Gd(wa|0,va|0,63)|0;ea=C;va=Hd(wa|0,va|0,1)|0;da=va|da;ea=C|ea;ca=Dd(Z|0,_|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,g|0,i|0)|0;v=C;qa=qa^ca;pa=pa^v;G=Dd(pa|0,qa|0,J|0,G|0)|0;J=C;Z=G^Z;_=J^_;va=Gd(Z|0,_|0,24)|0;wa=C;_=Hd(Z|0,_|0,40)|0;va=_|va;wa=C|wa;v=Dd(j|0,Y|0,ca|0,v|0)|0;v=Dd(v|0,C|0,va|0,wa|0)|0;ca=C;pa=v^pa;qa=ca^qa;_=Gd(pa|0,qa|0,16)|0;Z=C;qa=Hd(pa|0,qa|0,48)|0;_=qa|_;Z=C|Z;J=Dd(_|0,Z|0,G|0,J|0)|0;G=C;va=J^va;wa=G^wa;qa=Gd(va|0,wa|0,63)|0;pa=C;wa=Hd(va|0,wa|0,1)|0;qa=wa|qa;pa=C|pa;oa=Dd(V|0,X|0,na|0,oa|0)|0;oa=Dd(oa|0,C|0,m|0,o|0)|0;na=C;ma=ma^oa;la=la^na;z=Dd(la|0,ma|0,E|0,z|0)|0;E=C;V=z^V;X=E^X;wa=Gd(V|0,X|0,24)|0;va=C;X=Hd(V|0,X|0,40)|0;wa=X|wa;va=C|va;na=Dd(M|0,K|0,oa|0,na|0)|0;na=Dd(na|0,C|0,wa|0,va|0)|0;oa=C;la=na^la;ma=oa^ma;X=Gd(la|0,ma|0,16)|0;V=C;ma=Hd(la|0,ma|0,48)|0;X=ma|X;V=C|V;E=Dd(X|0,V|0,z|0,E|0)|0;z=C;wa=E^wa;va=z^va;ma=Gd(wa|0,va|0,63)|0;la=C;va=Hd(wa|0,va|0,1)|0;ma=va|ma;la=C|la;ka=Dd(da|0,ea|0,ja|0,ka|0)|0;ka=Dd(ka|0,C|0,e|0,f|0)|0;ja=C;ia=ia^ka;ha=ha^ja;Q=Dd(ha|0,ia|0,T|0,Q|0)|0;T=C;da=Q^da;ea=T^ea;va=Gd(da|0,ea|0,24)|0;wa=C;ea=Hd(da|0,ea|0,40)|0;va=ea|va;wa=C|wa;ja=Dd(B|0,S|0,ka|0,ja|0)|0;ja=Dd(ja|0,C|0,va|0,wa|0)|0;ka=C;ha=ja^ha;ia=ka^ia;ea=Gd(ha|0,ia|0,16)|0;da=C;ia=Hd(ha|0,ia|0,48)|0;ea=ia|ea;da=C|da;T=Dd(ea|0,da|0,Q|0,T|0)|0;Q=C;va=T^va;wa=Q^wa;ia=Gd(va|0,wa|0,63)|0;ha=C;wa=Hd(va|0,wa|0,1)|0;ia=wa|ia;ha=C|ha;ga=Dd(aa|0,ba|0,fa|0,ga|0)|0;ga=Dd(ga|0,C|0,ra|0,sa|0)|0;fa=C;ua=ua^ga;ta=ta^fa;L=Dd(ta|0,ua|0,O|0,L|0)|0;O=C;aa=L^aa;ba=O^ba;wa=Gd(aa|0,ba|0,24)|0;va=C;ba=Hd(aa|0,ba|0,40)|0;wa=ba|wa;va=C|va;fa=Dd(y|0,A|0,ga|0,fa|0)|0;fa=Dd(fa|0,C|0,wa|0,va|0)|0;ga=C;ta=fa^ta;ua=ga^ua;ba=Gd(ta|0,ua|0,16)|0;aa=C;ua=Hd(ta|0,ua|0,48)|0;ba=ua|ba;aa=C|aa;O=Dd(ba|0,aa|0,L|0,O|0)|0;L=C;wa=O^wa;va=L^va;ua=Gd(wa|0,va|0,63)|0;ta=C;va=Hd(wa|0,va|0,1)|0;ua=va|ua;ta=C|ta;ca=Dd(ra|0,sa|0,v|0,ca|0)|0;ca=Dd(ca|0,C|0,ua|0,ta|0)|0;v=C;X=ca^X;V=v^V;Q=Dd(V|0,X|0,T|0,Q|0)|0;T=C;ua=Q^ua;ta=T^ta;sa=Gd(ua|0,ta|0,24)|0;ra=C;ta=Hd(ua|0,ta|0,40)|0;sa=ta|sa;ra=C|ra;v=Dd(m|0,o|0,ca|0,v|0)|0;v=Dd(v|0,C|0,sa|0,ra|0)|0;ca=C;V=v^V;X=ca^X;o=Gd(V|0,X|0,16)|0;m=C;X=Hd(V|0,X|0,48)|0;o=X|o;m=C|m;T=Dd(o|0,m|0,Q|0,T|0)|0;Q=C;sa=T^sa;ra=Q^ra;X=Gd(sa|0,ra|0,63)|0;V=C;ra=Hd(sa|0,ra|0,1)|0;X=ra|X;V=C|V;oa=Dd(qa|0,pa|0,na|0,oa|0)|0;$=Dd(oa|0,C|0,p|0,$|0)|0;p=C;ea=ea^$;da=da^p;L=Dd(da|0,ea|0,O|0,L|0)|0;O=C;qa=L^qa;pa=O^pa;oa=Gd(qa|0,pa|0,24)|0;na=C;pa=Hd(qa|0,pa|0,40)|0;oa=pa|oa;na=C|na;p=Dd(g|0,i|0,$|0,p|0)|0;p=Dd(p|0,C|0,oa|0,na|0)|0;$=C;da=p^da;ea=$^ea;i=Gd(da|0,ea|0,16)|0;g=C;ea=Hd(da|0,ea|0,48)|0;i=ea|i;g=C|g;O=Dd(i|0,g|0,L|0,O|0)|0;L=C;oa=O^oa;na=L^na;ea=Gd(oa|0,na|0,63)|0;da=C;na=Hd(oa|0,na|0,1)|0;ea=na|ea;da=C|da;ka=Dd(ma|0,la|0,ja|0,ka|0)|0;Y=Dd(ka|0,C|0,j|0,Y|0)|0;j=C;ba=ba^Y;aa=aa^j;G=Dd(aa|0,ba|0,J|0,G|0)|0;J=C;ma=G^ma;la=J^la;ka=Gd(ma|0,la|0,24)|0;ja=C;la=Hd(ma|0,la|0,40)|0;ka=la|ka;ja=C|ja;j=Dd(y|0,A|0,Y|0,j|0)|0;j=Dd(j|0,C|0,ka|0,ja|0)|0;Y=C;aa=j^aa;ba=Y^ba;A=Gd(aa|0,ba|0,16)|0;y=C;ba=Hd(aa|0,ba|0,48)|0;A=ba|A;y=C|y;J=Dd(A|0,y|0,G|0,J|0)|0;G=C;ka=J^ka;ja=G^ja;ba=Gd(ka|0,ja|0,63)|0;aa=C;ja=Hd(ka|0,ja|0,1)|0;ba=ja|ba;aa=C|aa;ga=Dd(ia|0,ha|0,fa|0,ga|0)|0;S=Dd(ga|0,C|0,B|0,S|0)|0;B=C;_=_^S;Z=Z^B;z=Dd(Z|0,_|0,E|0,z|0)|0;E=C;ia=z^ia;ha=E^ha;ga=Gd(ia|0,ha|0,24)|0;fa=C;ha=Hd(ia|0,ha|0,40)|0;ga=ha|ga;fa=C|fa;B=Dd(s|0,u|0,S|0,B|0)|0;B=Dd(B|0,C|0,ga|0,fa|0)|0;S=C;Z=B^Z;_=S^_;u=Gd(Z|0,_|0,16)|0;s=C;_=Hd(Z|0,_|0,48)|0;u=_|u;s=C|s;E=Dd(u|0,s|0,z|0,E|0)|0;z=C;ga=E^ga;fa=z^fa;_=Gd(ga|0,fa|0,63)|0;Z=C;fa=Hd(ga|0,fa|0,1)|0;_=fa|_;Z=C|Z;ca=Dd(ea|0,da|0,v|0,ca|0)|0;U=Dd(ca|0,C|0,W|0,U|0)|0;W=C;u=u^U;s=s^W;G=Dd(s|0,u|0,J|0,G|0)|0;J=C;ea=G^ea;da=J^da;ca=Gd(ea|0,da|0,24)|0;v=C;da=Hd(ea|0,da|0,40)|0;ca=da|ca;v=C|v;W=Dd(e|0,f|0,U|0,W|0)|0;W=Dd(W|0,C|0,ca|0,v|0)|0;U=C;s=W^s;u=U^u;f=Gd(s|0,u|0,16)|0;e=C;u=Hd(s|0,u|0,48)|0;f=u|f;e=C|e;J=Dd(f|0,e|0,G|0,J|0)|0;G=C;ca=J^ca;v=G^v;u=Gd(ca|0,v|0,63)|0;s=C;v=Hd(ca|0,v|0,1)|0;s=C|s;$=Dd(ba|0,aa|0,p|0,$|0)|0;P=Dd($|0,C|0,R|0,P|0)|0;R=C;o=o^P;m=m^R;z=Dd(m|0,o|0,E|0,z|0)|0;E=C;ba=z^ba;aa=E^aa;$=Gd(ba|0,aa|0,24)|0;p=C;aa=Hd(ba|0,aa|0,40)|0;$=aa|$;p=C|p;R=Dd(t|0,x|0,P|0,R|0)|0;R=Dd(R|0,C|0,$|0,p|0)|0;P=C;m=R^m;o=P^o;x=Gd(m|0,o|0,16)|0;t=C;o=Hd(m|0,o|0,48)|0;x=o|x;t=C|t;E=Dd(x|0,t|0,z|0,E|0)|0;z=C;$=E^$;p=z^p;o=Gd($|0,p|0,63)|0;m=C;p=Hd($|0,p|0,1)|0;m=C|m;Y=Dd(_|0,Z|0,j|0,Y|0)|0;K=Dd(Y|0,C|0,M|0,K|0)|0;M=C;i=i^K;g=g^M;Q=Dd(g|0,i|0,T|0,Q|0)|0;T=C;_=Q^_;Z=T^Z;Y=Gd(_|0,Z|0,24)|0;j=C;Z=Hd(_|0,Z|0,40)|0;Y=Z|Y;j=C|j;M=Dd(n|0,r|0,K|0,M|0)|0;M=Dd(M|0,C|0,Y|0,j|0)|0;K=C;g=M^g;i=K^i;r=Gd(g|0,i|0,16)|0;n=C;i=Hd(g|0,i|0,48)|0;r=i|r;n=C|n;T=Dd(r|0,n|0,Q|0,T|0)|0;Q=C;Y=T^Y;j=Q^j;i=Gd(Y|0,j|0,63)|0;g=C;j=Hd(Y|0,j|0,1)|0;g=C|g;S=Dd(X|0,V|0,B|0,S|0)|0;F=Dd(S|0,C|0,H|0,F|0)|0;H=C;A=A^F;y=y^H;L=Dd(y|0,A|0,O|0,L|0)|0;O=C;X=L^X;V=O^V;S=Gd(X|0,V|0,24)|0;B=C;V=Hd(X|0,V|0,40)|0;S=V|S;B=C|B;H=Dd(h|0,l|0,F|0,H|0)|0;H=Dd(H|0,C|0,S|0,B|0)|0;F=C;y=H^y;A=F^A;l=Gd(y|0,A|0,16)|0;h=C;A=Hd(y|0,A|0,48)|0;l=A|l;h=C|h;O=Dd(l|0,h|0,L|0,O|0)|0;L=C;S=O^S;B=L^B;A=Gd(S|0,B|0,63)|0;y=C;B=Hd(S|0,B|0,1)|0;S=b;V=S;S=S+4|0;T=W^(d[V>>0]|d[V+1>>0]<<8|d[V+2>>0]<<16|d[V+3>>0]<<24)^T;Q=U^(d[S>>0]|d[S+1>>0]<<8|d[S+2>>0]<<16|d[S+3>>0]<<24)^Q;S=b;a[S>>0]=T;a[S+1>>0]=T>>8;a[S+2>>0]=T>>16;a[S+3>>0]=T>>24;b=b+4|0;a[b>>0]=Q;a[b+1>>0]=Q>>8;a[b+2>>0]=Q>>16;a[b+3>>0]=Q>>24;b=N;Q=b;b=b+4|0;O=R^(d[Q>>0]|d[Q+1>>0]<<8|d[Q+2>>0]<<16|d[Q+3>>0]<<24)^O;L=P^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^L;b=N;N=b;a[N>>0]=O;a[N+1>>0]=O>>8;a[N+2>>0]=O>>16;a[N+3>>0]=O>>24;b=b+4|0;a[b>>0]=L;a[b+1>>0]=L>>8;a[b+2>>0]=L>>16;a[b+3>>0]=L>>24;b=I;L=b;b=b+4|0;J=M^(d[L>>0]|d[L+1>>0]<<8|d[L+2>>0]<<16|d[L+3>>0]<<24)^J;G=K^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^G;b=I;I=b;a[I>>0]=J;a[I+1>>0]=J>>8;a[I+2>>0]=J>>16;a[I+3>>0]=J>>24;b=b+4|0;a[b>>0]=G;a[b+1>>0]=G>>8;a[b+2>>0]=G>>16;a[b+3>>0]=G>>24;b=D;G=b;b=b+4|0;E=H^(d[G>>0]|d[G+1>>0]<<8|d[G+2>>0]<<16|d[G+3>>0]<<24)^E;z=F^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^z;b=D;D=b;a[D>>0]=E;a[D+1>>0]=E>>8;a[D+2>>0]=E>>16;a[D+3>>0]=E>>24;b=b+4|0;a[b>>0]=z;a[b+1>>0]=z>>8;a[b+2>>0]=z>>16;a[b+3>>0]=z>>24;b=w;z=b;b=b+4|0;x=(B|A)^(d[z>>0]|d[z+1>>0]<<8|d[z+2>>0]<<16|d[z+3>>0]<<24)^x;t=(C|y)^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^t;b=w;w=b;a[w>>0]=x;a[w+1>>0]=x>>8;a[w+2>>0]=x>>16;a[w+3>>0]=x>>24;b=b+4|0;a[b>>0]=t;a[b+1>>0]=t>>8;a[b+2>>0]=t>>16;a[b+3>>0]=t>>24;b=q;t=b;b=b+4|0;r=(v|u)^(d[t>>0]|d[t+1>>0]<<8|d[t+2>>0]<<16|d[t+3>>0]<<24)^r;n=s^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^n;b=q;q=b;a[q>>0]=r;a[q+1>>0]=r>>8;a[q+2>>0]=r>>16;a[q+3>>0]=r>>24;b=b+4|0;a[b>>0]=n;a[b+1>>0]=n>>8;a[b+2>>0]=n>>16;a[b+3>>0]=n>>24;b=k;n=b;b=b+4|0;l=(p|o)^(d[n>>0]|d[n+1>>0]<<8|d[n+2>>0]<<16|d[n+3>>0]<<24)^l;h=m^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^h;b=k;k=b;a[k>>0]=l;a[k+1>>0]=l>>8;a[k+2>>0]=l>>16;a[k+3>>0]=l>>24;b=b+4|0;a[b>>0]=h;a[b+1>>0]=h>>8;a[b+2>>0]=h>>16;a[b+3>>0]=h>>24;b=c;h=b;b=b+4|0;f=(j|i)^(d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24)^f;b=g^(d[b>>0]|d[b+1>>0]<<8|d[b+2>>0]<<16|d[b+3>>0]<<24)^e;e=c;a[e>>0]=f;a[e+1>>0]=f>>8;a[e+2>>0]=f>>16;a[e+3>>0]=f>>24;c=c+4|0;a[c>>0]=b;a[c+1>>0]=b>>8;a[c+2>>0]=b>>16;a[c+3>>0]=b>>24;return}function Bb(){return 64}function Cb(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0;n=i;m=i=i+63&-64;i=i+208|0;g=m+64|0;h=m;j=8;k=h+64|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));h=Hd(e|0,f|0,3)|0;j=C;k=Gd(e|0,f|0,61)|0;l=m+72|0;c[l>>2]=h;c[l+4>>2]=j;l=g;c[l>>2]=k;c[l+4>>2]=C;l=m+80|0;if(f>>>0<0|(f|0)==0&e>>>0<128){Id(l|0,d|0,e|0)|0;Gb(m,b);i=n;return 0}h=l;j=d;k=h+128|0;do{a[h>>0]=a[j>>0]|0;h=h+1|0;j=j+1|0}while((h|0)<(k|0));Hb(m,l);g=d+128|0;d=Dd(e|0,f|0,-128,-1)|0;h=C;if(h>>>0>0|(h|0)==0&d>>>0>127)do{Hb(m,g);g=g+128|0;d=Dd(d|0,h|0,-128,-1)|0;h=C}while(h>>>0>0|(h|0)==0&d>>>0>127);Id(l|0,g|0,d|0)|0;Gb(m,b);i=n;return 0}function Db(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;n=i;m=i=i+63&-64;i=i+16|0;l=b+32|0;e=l;f=c[e>>2]|0;e=c[e+4>>2]|0;a[m+7>>0]=f;g=Gd(f|0,e|0,8)|0;a[m+6>>0]=g;g=Gd(f|0,e|0,16)|0;a[m+5>>0]=g;g=Gd(f|0,e|0,24)|0;a[m+4>>0]=g;a[m+3>>0]=e;g=Gd(f|0,e|0,40)|0;a[m+2>>0]=g;g=Gd(f|0,e|0,48)|0;a[m+1>>0]=g;g=Gd(f|0,e|0,56)|0;a[m>>0]=g;g=Gd(f|0,e|0,3)|0;g=g&63;k=g>>>0<56?56:120;j=k-g|0;do if((k|0)!=(g|0)){h=Hd(j|0,0,3)|0;f=Dd(h|0,C|0,f|0,e|0)|0;e=C;h=l;c[h>>2]=f;c[h+4>>2]=e;h=64-g|0;g=b+40+g|0;if(j>>>0<h>>>0){Id(g|0,32792,j|0)|0;break}Id(g|0,32792,h|0)|0;k=b+40|0;Eb(b,k);e=32792+h|0;g=Cd(j|0,0,h|0,0)|0;f=C;if(f>>>0>0|(f|0)==0&g>>>0>63){do{Eb(b,e);e=e+64|0;g=Dd(g|0,f|0,-64,-1)|0;f=C}while(f>>>0>0|(f|0)==0&g>>>0>63);f=g}else f=g;Id(k|0,e|0,f|0)|0;e=l;f=c[e>>2]|0;e=c[e+4>>2]|0}while(0);k=Gd(f|0,e|0,3)|0;k=k&63;e=Dd(f|0,e|0,64,0)|0;f=l;c[f>>2]=e;c[f+4>>2]=C;f=64-k|0;e=b+40+k|0;if(f>>>0>8){k=c[m>>2]|0;m=c[m+4>>2]|0;l=e;a[l>>0]=k;a[l+1>>0]=k>>8;a[l+2>>0]=k>>16;a[l+3>>0]=k>>24;e=e+4|0;a[e>>0]=m;a[e+1>>0]=m>>8;a[e+2>>0]=m>>16;a[e+3>>0]=m>>24;e=b}else{Id(e|0,m|0,f|0)|0;h=b+40|0;Eb(b,h);e=m+f|0;g=Cd(8,0,f|0,0)|0;f=C;if(f>>>0>0|(f|0)==0&g>>>0>63){do{Eb(b,e);e=e+64|0;g=Dd(g|0,f|0,-64,-1)|0;f=C}while(f>>>0>0|(f|0)==0&g>>>0>63);f=g}else f=g;Id(h|0,e|0,f|0)|0;e=b}e=c[e>>2]|0;a[d+3>>0]=e;a[d+2>>0]=e>>>8;a[d+1>>0]=e>>>16;a[d>>0]=e>>>24;e=c[b+4>>2]|0;a[d+7>>0]=e;a[d+6>>0]=e>>>8;a[d+5>>0]=e>>>16;a[d+4>>0]=e>>>24;e=c[b+8>>2]|0;a[d+11>>0]=e;a[d+10>>0]=e>>>8;a[d+9>>0]=e>>>16;a[d+8>>0]=e>>>24;e=c[b+12>>2]|0;a[d+15>>0]=e;a[d+14>>0]=e>>>8;a[d+13>>0]=e>>>16;a[d+12>>0]=e>>>24;e=c[b+16>>2]|0;a[d+19>>0]=e;a[d+18>>0]=e>>>8;a[d+17>>0]=e>>>16;a[d+16>>0]=e>>>24;e=c[b+20>>2]|0;a[d+23>>0]=e;a[d+22>>0]=e>>>8;a[d+21>>0]=e>>>16;a[d+20>>0]=e>>>24;e=c[b+24>>2]|0;a[d+27>>0]=e;a[d+26>>0]=e>>>8;a[d+25>>0]=e>>>16;a[d+24>>0]=e>>>24;e=c[b+28>>2]|0;a[d+31>>0]=e;a[d+30>>0]=e>>>8;a[d+29>>0]=e>>>16;a[d+28>>0]=e>>>24;e=b+104|0;do{a[b>>0]=0;b=b+1|0}while((b|0)<(e|0));i=n;return}function Eb(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;g=i;f=i=i+63&-64;i=i+256|0;e=0;do{h=b+(e<<2)|0;c[f+(e<<2)>>2]=(d[h+2>>0]|0)<<8|(d[h+3>>0]|0)|(d[h+1>>0]|0)<<16|(d[h>>0]|0)<<24;e=e+1|0}while((e|0)!=16);b=c[f>>2]|0;e=16;do{h=c[f+(e+-2<<2)>>2]|0;j=b;b=c[f+(e+-15<<2)>>2]|0;c[f+(e<<2)>>2]=j+(c[f+(e+-7<<2)>>2]|0)+((h>>>19|h<<13)^h>>>10^(h>>>17|h<<15))+((b>>>18|b<<14)^b>>>3^(b>>>7|b<<25));e=e+1|0}while((e|0)!=64);u=c[a>>2]|0;s=a+4|0;t=c[s>>2]|0;q=a+8|0;r=c[q>>2]|0;o=a+12|0;m=a+16|0;n=c[m>>2]|0;k=a+20|0;l=c[k>>2]|0;e=a+24|0;b=c[e>>2]|0;j=a+28|0;h=(c[j>>2]|0)+1116352408+(c[f>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=(c[o>>2]|0)+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+1899447441+(c[f+4>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+-1245643825+(c[f+8>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+-373957723+(c[f+12>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+961987163+(c[f+16>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+1508970993+(c[f+20>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+-1841331548+(c[f+24>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+-1424204075+(c[f+28>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+-670586216+(c[f+32>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+310598401+(c[f+36>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+607225278+(c[f+40>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+1426881987+(c[f+44>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+1925078388+(c[f+48>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+-2132889090+(c[f+52>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+-1680079193+(c[f+56>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+-1046744716+(c[f+60>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+-459576895+(c[f+64>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+-272742522+(c[f+68>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+264347078+(c[f+72>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+604807628+(c[f+76>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+770255983+(c[f+80>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+1249150122+(c[f+84>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+1555081692+(c[f+88>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+1996064986+(c[f+92>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+-1740746414+(c[f+96>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+-1473132947+(c[f+100>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+-1341970488+(c[f+104>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+-1084653625+(c[f+108>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+-958395405+(c[f+112>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+-710438585+(c[f+116>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+113926993+(c[f+120>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+338241895+(c[f+124>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+666307205+(c[f+128>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+773529912+(c[f+132>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+1294757372+(c[f+136>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+1396182291+(c[f+140>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+1695183700+(c[f+144>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+1986661051+(c[f+148>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+-2117940946+(c[f+152>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+-1838011259+(c[f+156>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+-1564481375+(c[f+160>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+-1474664885+(c[f+164>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+-1035236496+(c[f+168>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+-949202525+(c[f+172>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+-778901479+(c[f+176>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+-694614492+(c[f+180>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+-200395387+(c[f+184>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+275423344+(c[f+188>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+430227734+(c[f+192>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+506948616+(c[f+196>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+659060556+(c[f+200>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+883997877+(c[f+204>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+958139571+(c[f+208>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+1322822218+(c[f+212>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+1537002063+(c[f+216>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;u=u+1747873779+(c[f+220>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;n=n+u|0;u=((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+u|0;h=h+1955562222+(c[f+224>>2]|0)+((n>>>6|n<<26)^(n>>>11|n<<21)^(n>>>25|n<<7))+((b^l)&n^b)|0;p=p+h|0;h=((r|t)&u|r&t)+((u>>>2|u<<30)^(u>>>13|u<<19)^(u>>>22|u<<10))+h|0;b=b+2024104815+(c[f+228>>2]|0)+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+((l^n)&p^l)|0;r=r+b|0;b=((t|u)&h|t&u)+((h>>>2|h<<30)^(h>>>13|h<<19)^(h>>>22|h<<10))+b|0;l=l+-2067236844+(c[f+232>>2]|0)+((r>>>6|r<<26)^(r>>>11|r<<21)^(r>>>25|r<<7))+((n^p)&r^n)|0;t=t+l|0;l=((u|h)&b|u&h)+((b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10))+l|0;n=n+-1933114872+(c[f+236>>2]|0)+((t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7))+((p^r)&t^p)|0;u=u+n|0;n=((h|b)&l|h&b)+((l>>>2|l<<30)^(l>>>13|l<<19)^(l>>>22|l<<10))+n|0;p=p+-1866530822+(c[f+240>>2]|0)+((u>>>6|u<<26)^(u>>>11|u<<21)^(u>>>25|u<<7))+((r^t)&u^r)|0;h=h+p|0;p=((b|l)&n|b&l)+((n>>>2|n<<30)^(n>>>13|n<<19)^(n>>>22|n<<10))+p|0;r=r+-1538233109+(c[f+244>>2]|0)+((h>>>6|h<<26)^(h>>>11|h<<21)^(h>>>25|h<<7))+((t^u)&h^t)|0;b=b+r|0;r=((l|n)&p|l&n)+((p>>>2|p<<30)^(p>>>13|p<<19)^(p>>>22|p<<10))+r|0;t=t+-1090935817+(c[f+248>>2]|0)+((b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7))+((u^h)&b^u)|0;l=l+t|0;t=((n|p)&r|n&p)+((r>>>2|r<<30)^(r>>>13|r<<19)^(r>>>22|r<<10))+t|0;f=u+-965641998+(c[f+252>>2]|0)+((l>>>6|l<<26)^(l>>>11|l<<21)^(l>>>25|l<<7))+((h^b)&l^h)|0;c[a>>2]=(c[a>>2]|0)+(((p|r)&t|p&r)+((t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10))+f);c[s>>2]=(c[s>>2]|0)+t;c[q>>2]=(c[q>>2]|0)+r;c[o>>2]=(c[o>>2]|0)+p;c[m>>2]=(c[m>>2]|0)+(n+f);c[k>>2]=(c[k>>2]|0)+l;c[e>>2]=(c[e>>2]|0)+b;c[j>>2]=(c[j>>2]|0)+h;i=g;return}function Fb(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;j=a+72|0;m=j;o=c[m>>2]|0;m=c[m+4>>2]|0;k=Gd(o|0,m|0,3)|0;k=k&127;l=Hd(d|0,e|0,3)|0;n=C;h=Gd(d|0,e|0,61)|0;i=C;m=Dd(o|0,m|0,l|0,n|0)|0;o=C;c[j>>2]=m;c[j+4>>2]=o;j=a+64|0;g=j;f=c[g>>2]|0;g=c[g+4>>2]|0;if(o>>>0<n>>>0|(o|0)==(n|0)&m>>>0<l>>>0){f=Dd(f|0,g|0,1,0)|0;g=C;o=j;c[o>>2]=f;c[o+4>>2]=g}h=Dd(f|0,g|0,h|0,i|0)|0;g=j;c[g>>2]=h;c[g+4>>2]=C;g=Cd(128,0,k|0,0)|0;h=C;f=a+80+k|0;if(h>>>0>e>>>0|(h|0)==(e|0)&g>>>0>d>>>0){Id(f|0,b|0,d|0)|0;return}Id(f|0,b|0,g|0)|0;i=a+80|0;Hb(a,i);f=b+g|0;g=Cd(d|0,e|0,g|0,h|0)|0;h=C;if(h>>>0>0|(h|0)==0&g>>>0>127)do{Hb(a,f);f=f+128|0;g=Dd(g|0,h|0,-128,-1)|0;h=C}while(h>>>0>0|(h|0)==0&g>>>0>127);Id(i|0,f|0,g|0)|0;return}function Gb(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;s=i;e=i=i+63&-64;i=i+16|0;r=b+64|0;f=r;g=c[f>>2]|0;f=c[f+4>>2]|0;a[e+7>>0]=g;q=Gd(g|0,f|0,8)|0;a[e+6>>0]=q;q=Gd(g|0,f|0,16)|0;a[e+5>>0]=q;q=Gd(g|0,f|0,24)|0;a[e+4>>0]=q;a[e+3>>0]=f;q=Gd(g|0,f|0,40)|0;a[e+2>>0]=q;q=Gd(g|0,f|0,48)|0;a[e+1>>0]=q;q=Gd(g|0,f|0,56)|0;a[e>>0]=q;q=b+72|0;j=q;h=c[j>>2]|0;j=c[j+4>>2]|0;a[e+15>>0]=h;n=Gd(h|0,j|0,8)|0;a[e+14>>0]=n;n=Gd(h|0,j|0,16)|0;a[e+13>>0]=n;n=Gd(h|0,j|0,24)|0;a[e+12>>0]=n;a[e+11>>0]=j;n=Gd(h|0,j|0,40)|0;a[e+10>>0]=n;n=Gd(h|0,j|0,48)|0;a[e+9>>0]=n;n=Gd(h|0,j|0,56)|0;a[e+8>>0]=n;n=Gd(h|0,j|0,3)|0;n=n&127;o=0<0|0==0&n>>>0<112;o=Cd((o?112:240)|0,(o?0:0)|0,n|0,0)|0;p=C;m=Hd(o|0,p|0,3)|0;t=C;k=Gd(o|0,p|0,61)|0;l=C;j=Dd(m|0,t|0,h|0,j|0)|0;h=C;u=q;c[u>>2]=j;c[u+4>>2]=h;if(h>>>0<t>>>0|(h|0)==(t|0)&j>>>0<m>>>0){g=Dd(g|0,f|0,1,0)|0;f=C;u=r;c[u>>2]=g;c[u+4>>2]=f}g=Dd(g|0,f|0,k|0,l|0)|0;f=C;l=r;c[l>>2]=g;c[l+4>>2]=f;l=Cd(128,0,n|0,0)|0;m=C;k=b+80+n|0;if(p>>>0<m>>>0|(p|0)==(m|0)&o>>>0<l>>>0)Id(k|0,32856,o|0)|0;else{Id(k|0,32856,l|0)|0;j=b+80|0;Hb(b,j);f=32856+l|0;g=Cd(o|0,p|0,l|0,m|0)|0;h=C;if(h>>>0>0|(h|0)==0&g>>>0>127)do{Hb(b,f);f=f+128|0;g=Dd(g|0,h|0,-128,-1)|0;h=C}while(h>>>0>0|(h|0)==0&g>>>0>127);Id(j|0,f|0,g|0)|0;h=q;f=r;j=c[h>>2]|0;h=c[h+4>>2]|0;g=c[f>>2]|0;f=c[f+4>>2]|0}k=Gd(j|0,h|0,3)|0;k=k&127;t=Dd(j|0,h|0,128,0)|0;u=q;c[u>>2]=t;c[u+4>>2]=C;if(h>>>0>4294967295|(h|0)==-1&j>>>0>4294967167){g=Dd(g|0,f|0,1,0)|0;f=C;u=r;c[u>>2]=g;c[u+4>>2]=f}h=r;c[h>>2]=g;c[h+4>>2]=f;g=Cd(128,0,k|0,0)|0;h=C;f=b+80+k|0;if(h>>>0>0|(h|0)==0&g>>>0>16){g=f;f=g+16|0;do{a[g>>0]=a[e>>0]|0;g=g+1|0;e=e+1|0}while((g|0)<(f|0))}else{Id(f|0,e|0,g|0)|0;j=b+80|0;Hb(b,j);e=e+g|0;f=Cd(16,0,g|0,h|0)|0;g=C;if(g>>>0>0|(g|0)==0&f>>>0>127)do{Hb(b,e);e=e+128|0;f=Dd(f|0,g|0,-128,-1)|0;g=C}while(g>>>0>0|(g|0)==0&f>>>0>127);Id(j|0,e|0,f|0)|0}e=0;do{u=d+(e<<3)|0;t=b+(e<<3)|0;r=c[t>>2]|0;t=c[t+4>>2]|0;a[u+7>>0]=r;q=Gd(r|0,t|0,8)|0;a[u+6>>0]=q;q=Gd(r|0,t|0,16)|0;a[u+5>>0]=q;q=Gd(r|0,t|0,24)|0;a[u+4>>0]=q;a[u+3>>0]=t;q=Gd(r|0,t|0,40)|0;a[u+2>>0]=q;q=Gd(r|0,t|0,48)|0;a[u+1>>0]=q;t=Gd(r|0,t|0,56)|0;a[u>>0]=t;e=e+1|0}while((e|0)!=8);Fd(b|0,0,208)|0;i=s;return}
function yd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;do if(a>>>0<245){o=a>>>0<11?16:a+11&-8;a=o>>>3;j=c[8020]|0;b=j>>>a;if(b&3){b=(b&1^1)+a|0;d=32120+(b<<1<<2)|0;e=d+8|0;f=c[e>>2]|0;g=f+8|0;h=c[g>>2]|0;do if((d|0)!=(h|0)){if(h>>>0<(c[8024]|0)>>>0)ra();a=h+12|0;if((c[a>>2]|0)==(f|0)){c[a>>2]=d;c[e>>2]=h;break}else ra()}else c[8020]=j&~(1<<b);while(0);G=b<<3;c[f+4>>2]=G|3;G=f+G+4|0;c[G>>2]=c[G>>2]|1;G=g;return G|0}h=c[8022]|0;if(o>>>0>h>>>0){if(b){d=2<<a;d=b<<a&(d|0-d);d=(d&0-d)+-1|0;i=d>>>12&16;d=d>>>i;f=d>>>5&8;d=d>>>f;g=d>>>2&4;d=d>>>g;e=d>>>1&2;d=d>>>e;b=d>>>1&1;b=(f|i|g|e|b)+(d>>>b)|0;d=32120+(b<<1<<2)|0;e=d+8|0;g=c[e>>2]|0;i=g+8|0;f=c[i>>2]|0;do if((d|0)!=(f|0)){if(f>>>0<(c[8024]|0)>>>0)ra();a=f+12|0;if((c[a>>2]|0)==(g|0)){c[a>>2]=d;c[e>>2]=f;k=c[8022]|0;break}else ra()}else{c[8020]=j&~(1<<b);k=h}while(0);h=(b<<3)-o|0;c[g+4>>2]=o|3;e=g+o|0;c[e+4>>2]=h|1;c[e+h>>2]=h;if(k){f=c[8025]|0;b=k>>>3;d=32120+(b<<1<<2)|0;a=c[8020]|0;b=1<<b;if(a&b){a=d+8|0;b=c[a>>2]|0;if(b>>>0<(c[8024]|0)>>>0)ra();else{l=a;m=b}}else{c[8020]=a|b;l=d+8|0;m=d}c[l>>2]=f;c[m+12>>2]=f;c[f+8>>2]=m;c[f+12>>2]=d}c[8022]=h;c[8025]=e;G=i;return G|0}a=c[8021]|0;if(a){i=(a&0-a)+-1|0;F=i>>>12&16;i=i>>>F;E=i>>>5&8;i=i>>>E;G=i>>>2&4;i=i>>>G;b=i>>>1&2;i=i>>>b;j=i>>>1&1;j=c[32384+((E|F|G|b|j)+(i>>>j)<<2)>>2]|0;i=(c[j+4>>2]&-8)-o|0;b=j;while(1){a=c[b+16>>2]|0;if(!a){a=c[b+20>>2]|0;if(!a)break}b=(c[a+4>>2]&-8)-o|0;G=b>>>0<i>>>0;i=G?b:i;b=a;j=G?a:j}f=c[8024]|0;if(j>>>0<f>>>0)ra();h=j+o|0;if(j>>>0>=h>>>0)ra();g=c[j+24>>2]|0;d=c[j+12>>2]|0;do if((d|0)==(j|0)){b=j+20|0;a=c[b>>2]|0;if(!a){b=j+16|0;a=c[b>>2]|0;if(!a){n=0;break}}while(1){d=a+20|0;e=c[d>>2]|0;if(e){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}if(b>>>0<f>>>0)ra();else{c[b>>2]=0;n=a;break}}else{e=c[j+8>>2]|0;if(e>>>0<f>>>0)ra();a=e+12|0;if((c[a>>2]|0)!=(j|0))ra();b=d+8|0;if((c[b>>2]|0)==(j|0)){c[a>>2]=d;c[b>>2]=e;n=d;break}else ra()}while(0);do if(g){a=c[j+28>>2]|0;b=32384+(a<<2)|0;if((j|0)==(c[b>>2]|0)){c[b>>2]=n;if(!n){c[8021]=c[8021]&~(1<<a);break}}else{if(g>>>0<(c[8024]|0)>>>0)ra();a=g+16|0;if((c[a>>2]|0)==(j|0))c[a>>2]=n;else c[g+20>>2]=n;if(!n)break}b=c[8024]|0;if(n>>>0<b>>>0)ra();c[n+24>>2]=g;a=c[j+16>>2]|0;do if(a)if(a>>>0<b>>>0)ra();else{c[n+16>>2]=a;c[a+24>>2]=n;break}while(0);a=c[j+20>>2]|0;if(a)if(a>>>0<(c[8024]|0)>>>0)ra();else{c[n+20>>2]=a;c[a+24>>2]=n;break}}while(0);if(i>>>0<16){G=i+o|0;c[j+4>>2]=G|3;G=j+G+4|0;c[G>>2]=c[G>>2]|1}else{c[j+4>>2]=o|3;c[h+4>>2]=i|1;c[h+i>>2]=i;a=c[8022]|0;if(a){e=c[8025]|0;b=a>>>3;d=32120+(b<<1<<2)|0;a=c[8020]|0;b=1<<b;if(a&b){a=d+8|0;b=c[a>>2]|0;if(b>>>0<(c[8024]|0)>>>0)ra();else{p=a;q=b}}else{c[8020]=a|b;p=d+8|0;q=d}c[p>>2]=e;c[q+12>>2]=e;c[e+8>>2]=q;c[e+12>>2]=d}c[8022]=i;c[8025]=h}G=j+8|0;return G|0}}}else if(a>>>0<=4294967231){a=a+11|0;o=a&-8;k=c[8021]|0;if(k){d=0-o|0;a=a>>>8;if(a)if(o>>>0>16777215)j=31;else{q=(a+1048320|0)>>>16&8;z=a<<q;p=(z+520192|0)>>>16&4;z=z<<p;j=(z+245760|0)>>>16&2;j=14-(p|q|j)+(z<<j>>>15)|0;j=o>>>(j+7|0)&1|j<<1}else j=0;b=c[32384+(j<<2)>>2]|0;a:do if(!b){a=0;b=0;z=86}else{f=d;a=0;h=o<<((j|0)==31?0:25-(j>>>1)|0);i=b;b=0;while(1){e=c[i+4>>2]&-8;d=e-o|0;if(d>>>0<f>>>0)if((e|0)==(o|0)){a=i;b=i;z=90;break a}else b=i;else d=f;e=c[i+20>>2]|0;i=c[i+16+(h>>>31<<2)>>2]|0;a=(e|0)==0|(e|0)==(i|0)?a:e;e=(i|0)==0;if(e){z=86;break}else{f=d;h=h<<(e&1^1)}}}while(0);if((z|0)==86){if((a|0)==0&(b|0)==0){a=2<<j;a=k&(a|0-a);if(!a)break;q=(a&0-a)+-1|0;m=q>>>12&16;q=q>>>m;l=q>>>5&8;q=q>>>l;n=q>>>2&4;q=q>>>n;p=q>>>1&2;q=q>>>p;a=q>>>1&1;a=c[32384+((l|m|n|p|a)+(q>>>a)<<2)>>2]|0}if(!a){i=d;j=b}else z=90}if((z|0)==90)while(1){z=0;q=(c[a+4>>2]&-8)-o|0;e=q>>>0<d>>>0;d=e?q:d;b=e?a:b;e=c[a+16>>2]|0;if(e){a=e;z=90;continue}a=c[a+20>>2]|0;if(!a){i=d;j=b;break}else z=90}if((j|0)!=0?i>>>0<((c[8022]|0)-o|0)>>>0:0){f=c[8024]|0;if(j>>>0<f>>>0)ra();h=j+o|0;if(j>>>0>=h>>>0)ra();g=c[j+24>>2]|0;d=c[j+12>>2]|0;do if((d|0)==(j|0)){b=j+20|0;a=c[b>>2]|0;if(!a){b=j+16|0;a=c[b>>2]|0;if(!a){s=0;break}}while(1){d=a+20|0;e=c[d>>2]|0;if(e){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}if(b>>>0<f>>>0)ra();else{c[b>>2]=0;s=a;break}}else{e=c[j+8>>2]|0;if(e>>>0<f>>>0)ra();a=e+12|0;if((c[a>>2]|0)!=(j|0))ra();b=d+8|0;if((c[b>>2]|0)==(j|0)){c[a>>2]=d;c[b>>2]=e;s=d;break}else ra()}while(0);do if(g){a=c[j+28>>2]|0;b=32384+(a<<2)|0;if((j|0)==(c[b>>2]|0)){c[b>>2]=s;if(!s){c[8021]=c[8021]&~(1<<a);break}}else{if(g>>>0<(c[8024]|0)>>>0)ra();a=g+16|0;if((c[a>>2]|0)==(j|0))c[a>>2]=s;else c[g+20>>2]=s;if(!s)break}b=c[8024]|0;if(s>>>0<b>>>0)ra();c[s+24>>2]=g;a=c[j+16>>2]|0;do if(a)if(a>>>0<b>>>0)ra();else{c[s+16>>2]=a;c[a+24>>2]=s;break}while(0);a=c[j+20>>2]|0;if(a)if(a>>>0<(c[8024]|0)>>>0)ra();else{c[s+20>>2]=a;c[a+24>>2]=s;break}}while(0);do if(i>>>0>=16){c[j+4>>2]=o|3;c[h+4>>2]=i|1;c[h+i>>2]=i;a=i>>>3;if(i>>>0<256){d=32120+(a<<1<<2)|0;b=c[8020]|0;a=1<<a;if(b&a){a=d+8|0;b=c[a>>2]|0;if(b>>>0<(c[8024]|0)>>>0)ra();else{t=a;v=b}}else{c[8020]=b|a;t=d+8|0;v=d}c[t>>2]=h;c[v+12>>2]=h;c[h+8>>2]=v;c[h+12>>2]=d;break}a=i>>>8;if(a)if(i>>>0>16777215)d=31;else{F=(a+1048320|0)>>>16&8;G=a<<F;E=(G+520192|0)>>>16&4;G=G<<E;d=(G+245760|0)>>>16&2;d=14-(E|F|d)+(G<<d>>>15)|0;d=i>>>(d+7|0)&1|d<<1}else d=0;e=32384+(d<<2)|0;c[h+28>>2]=d;a=h+16|0;c[a+4>>2]=0;c[a>>2]=0;a=c[8021]|0;b=1<<d;if(!(a&b)){c[8021]=a|b;c[e>>2]=h;c[h+24>>2]=e;c[h+12>>2]=h;c[h+8>>2]=h;break}d=i<<((d|0)==31?0:25-(d>>>1)|0);e=c[e>>2]|0;while(1){if((c[e+4>>2]&-8|0)==(i|0)){z=148;break}b=e+16+(d>>>31<<2)|0;a=c[b>>2]|0;if(!a){z=145;break}else{d=d<<1;e=a}}if((z|0)==145)if(b>>>0<(c[8024]|0)>>>0)ra();else{c[b>>2]=h;c[h+24>>2]=e;c[h+12>>2]=h;c[h+8>>2]=h;break}else if((z|0)==148){a=e+8|0;b=c[a>>2]|0;G=c[8024]|0;if(b>>>0>=G>>>0&e>>>0>=G>>>0){c[b+12>>2]=h;c[a>>2]=h;c[h+8>>2]=b;c[h+12>>2]=e;c[h+24>>2]=0;break}else ra()}}else{G=i+o|0;c[j+4>>2]=G|3;G=j+G+4|0;c[G>>2]=c[G>>2]|1}while(0);G=j+8|0;return G|0}}}else o=-1;while(0);d=c[8022]|0;if(d>>>0>=o>>>0){a=d-o|0;b=c[8025]|0;if(a>>>0>15){G=b+o|0;c[8025]=G;c[8022]=a;c[G+4>>2]=a|1;c[G+a>>2]=a;c[b+4>>2]=o|3}else{c[8022]=0;c[8025]=0;c[b+4>>2]=d|3;G=b+d+4|0;c[G>>2]=c[G>>2]|1}G=b+8|0;return G|0}a=c[8023]|0;if(a>>>0>o>>>0){E=a-o|0;c[8023]=E;G=c[8026]|0;F=G+o|0;c[8026]=F;c[F+4>>2]=E|1;c[G+4>>2]=o|3;G=G+8|0;return G|0}do if(!(c[8138]|0)){a=na(30)|0;if(!(a+-1&a)){c[8140]=a;c[8139]=a;c[8141]=-1;c[8142]=-1;c[8143]=0;c[8131]=0;c[8138]=(ta(0)|0)&-16^1431655768;break}else ra()}while(0);h=o+48|0;e=c[8140]|0;i=o+47|0;d=e+i|0;e=0-e|0;j=d&e;if(j>>>0<=o>>>0){G=0;return G|0}a=c[8130]|0;if((a|0)!=0?(t=c[8128]|0,v=t+j|0,v>>>0<=t>>>0|v>>>0>a>>>0):0){G=0;return G|0}b:do if(!(c[8131]&4)){b=c[8026]|0;c:do if(b){f=32528;while(1){a=c[f>>2]|0;if(a>>>0<=b>>>0?(r=f+4|0,(a+(c[r>>2]|0)|0)>>>0>b>>>0):0)break;a=c[f+8>>2]|0;if(!a){z=173;break c}else f=a}a=d-(c[8023]|0)&e;if(a>>>0<2147483647){b=sa(a|0)|0;if((b|0)==((c[f>>2]|0)+(c[r>>2]|0)|0)){if((b|0)!=(-1|0)){h=b;g=a;z=193;break b}}else z=183}}else z=173;while(0);do if((z|0)==173?(u=sa(0)|0,(u|0)!=(-1|0)):0){a=u;b=c[8139]|0;d=b+-1|0;if(!(d&a))a=j;else a=j-a+(d+a&0-b)|0;b=c[8128]|0;d=b+a|0;if(a>>>0>o>>>0&a>>>0<2147483647){v=c[8130]|0;if((v|0)!=0?d>>>0<=b>>>0|d>>>0>v>>>0:0)break;b=sa(a|0)|0;if((b|0)==(u|0)){h=u;g=a;z=193;break b}else z=183}}while(0);d:do if((z|0)==183){d=0-a|0;do if(h>>>0>a>>>0&(a>>>0<2147483647&(b|0)!=(-1|0))?(w=c[8140]|0,w=i-a+w&0-w,w>>>0<2147483647):0)if((sa(w|0)|0)==(-1|0)){sa(d|0)|0;break d}else{a=w+a|0;break}while(0);if((b|0)!=(-1|0)){h=b;g=a;z=193;break b}}while(0);c[8131]=c[8131]|4;z=190}else z=190;while(0);if((((z|0)==190?j>>>0<2147483647:0)?(x=sa(j|0)|0,y=sa(0)|0,x>>>0<y>>>0&((x|0)!=(-1|0)&(y|0)!=(-1|0))):0)?(g=y-x|0,g>>>0>(o+40|0)>>>0):0){h=x;z=193}if((z|0)==193){a=(c[8128]|0)+g|0;c[8128]=a;if(a>>>0>(c[8129]|0)>>>0)c[8129]=a;k=c[8026]|0;do if(k){f=32528;while(1){a=c[f>>2]|0;b=f+4|0;d=c[b>>2]|0;if((h|0)==(a+d|0)){z=203;break}e=c[f+8>>2]|0;if(!e)break;else f=e}if(((z|0)==203?(c[f+12>>2]&8|0)==0:0)?k>>>0<h>>>0&k>>>0>=a>>>0:0){c[b>>2]=d+g;G=k+8|0;G=(G&7|0)==0?0:0-G&7;F=k+G|0;G=g-G+(c[8023]|0)|0;c[8026]=F;c[8023]=G;c[F+4>>2]=G|1;c[F+G+4>>2]=40;c[8027]=c[8142];break}a=c[8024]|0;if(h>>>0<a>>>0){c[8024]=h;i=h}else i=a;b=h+g|0;a=32528;while(1){if((c[a>>2]|0)==(b|0)){z=211;break}a=c[a+8>>2]|0;if(!a){b=32528;break}}if((z|0)==211)if(!(c[a+12>>2]&8)){c[a>>2]=h;m=a+4|0;c[m>>2]=(c[m>>2]|0)+g;m=h+8|0;m=h+((m&7|0)==0?0:0-m&7)|0;a=b+8|0;a=b+((a&7|0)==0?0:0-a&7)|0;l=m+o|0;j=a-m-o|0;c[m+4>>2]=o|3;do if((a|0)!=(k|0)){if((a|0)==(c[8025]|0)){G=(c[8022]|0)+j|0;c[8022]=G;c[8025]=l;c[l+4>>2]=G|1;c[l+G>>2]=G;break}b=c[a+4>>2]|0;if((b&3|0)==1){h=b&-8;f=b>>>3;e:do if(b>>>0>=256){g=c[a+24>>2]|0;e=c[a+12>>2]|0;do if((e|0)==(a|0)){e=a+16|0;d=e+4|0;b=c[d>>2]|0;if(!b){b=c[e>>2]|0;if(!b){E=0;break}else d=e}while(1){e=b+20|0;f=c[e>>2]|0;if(f){b=f;d=e;continue}e=b+16|0;f=c[e>>2]|0;if(!f)break;else{b=f;d=e}}if(d>>>0<i>>>0)ra();else{c[d>>2]=0;E=b;break}}else{f=c[a+8>>2]|0;if(f>>>0<i>>>0)ra();b=f+12|0;if((c[b>>2]|0)!=(a|0))ra();d=e+8|0;if((c[d>>2]|0)==(a|0)){c[b>>2]=e;c[d>>2]=f;E=e;break}else ra()}while(0);if(!g)break;b=c[a+28>>2]|0;d=32384+(b<<2)|0;do if((a|0)!=(c[d>>2]|0)){if(g>>>0<(c[8024]|0)>>>0)ra();b=g+16|0;if((c[b>>2]|0)==(a|0))c[b>>2]=E;else c[g+20>>2]=E;if(!E)break e}else{c[d>>2]=E;if(E)break;c[8021]=c[8021]&~(1<<b);break e}while(0);e=c[8024]|0;if(E>>>0<e>>>0)ra();c[E+24>>2]=g;b=a+16|0;d=c[b>>2]|0;do if(d)if(d>>>0<e>>>0)ra();else{c[E+16>>2]=d;c[d+24>>2]=E;break}while(0);b=c[b+4>>2]|0;if(!b)break;if(b>>>0<(c[8024]|0)>>>0)ra();else{c[E+20>>2]=b;c[b+24>>2]=E;break}}else{d=c[a+8>>2]|0;e=c[a+12>>2]|0;b=32120+(f<<1<<2)|0;do if((d|0)!=(b|0)){if(d>>>0<i>>>0)ra();if((c[d+12>>2]|0)==(a|0))break;ra()}while(0);if((e|0)==(d|0)){c[8020]=c[8020]&~(1<<f);break}do if((e|0)==(b|0))B=e+8|0;else{if(e>>>0<i>>>0)ra();b=e+8|0;if((c[b>>2]|0)==(a|0)){B=b;break}ra()}while(0);c[d+12>>2]=e;c[B>>2]=d}while(0);a=a+h|0;f=h+j|0}else f=j;a=a+4|0;c[a>>2]=c[a>>2]&-2;c[l+4>>2]=f|1;c[l+f>>2]=f;a=f>>>3;if(f>>>0<256){d=32120+(a<<1<<2)|0;b=c[8020]|0;a=1<<a;do if(!(b&a)){c[8020]=b|a;F=d+8|0;G=d}else{a=d+8|0;b=c[a>>2]|0;if(b>>>0>=(c[8024]|0)>>>0){F=a;G=b;break}ra()}while(0);c[F>>2]=l;c[G+12>>2]=l;c[l+8>>2]=G;c[l+12>>2]=d;break}a=f>>>8;do if(!a)d=0;else{if(f>>>0>16777215){d=31;break}F=(a+1048320|0)>>>16&8;G=a<<F;E=(G+520192|0)>>>16&4;G=G<<E;d=(G+245760|0)>>>16&2;d=14-(E|F|d)+(G<<d>>>15)|0;d=f>>>(d+7|0)&1|d<<1}while(0);e=32384+(d<<2)|0;c[l+28>>2]=d;a=l+16|0;c[a+4>>2]=0;c[a>>2]=0;a=c[8021]|0;b=1<<d;if(!(a&b)){c[8021]=a|b;c[e>>2]=l;c[l+24>>2]=e;c[l+12>>2]=l;c[l+8>>2]=l;break}d=f<<((d|0)==31?0:25-(d>>>1)|0);e=c[e>>2]|0;while(1){if((c[e+4>>2]&-8|0)==(f|0)){z=281;break}b=e+16+(d>>>31<<2)|0;a=c[b>>2]|0;if(!a){z=278;break}else{d=d<<1;e=a}}if((z|0)==278)if(b>>>0<(c[8024]|0)>>>0)ra();else{c[b>>2]=l;c[l+24>>2]=e;c[l+12>>2]=l;c[l+8>>2]=l;break}else if((z|0)==281){a=e+8|0;b=c[a>>2]|0;G=c[8024]|0;if(b>>>0>=G>>>0&e>>>0>=G>>>0){c[b+12>>2]=l;c[a>>2]=l;c[l+8>>2]=b;c[l+12>>2]=e;c[l+24>>2]=0;break}else ra()}}else{G=(c[8023]|0)+j|0;c[8023]=G;c[8026]=l;c[l+4>>2]=G|1}while(0);G=m+8|0;return G|0}else b=32528;while(1){a=c[b>>2]|0;if(a>>>0<=k>>>0?(A=a+(c[b+4>>2]|0)|0,A>>>0>k>>>0):0)break;b=c[b+8>>2]|0}f=A+-47|0;b=f+8|0;b=f+((b&7|0)==0?0:0-b&7)|0;f=k+16|0;b=b>>>0<f>>>0?k:b;a=b+8|0;d=h+8|0;d=(d&7|0)==0?0:0-d&7;G=h+d|0;d=g+-40-d|0;c[8026]=G;c[8023]=d;c[G+4>>2]=d|1;c[G+d+4>>2]=40;c[8027]=c[8142];d=b+4|0;c[d>>2]=27;c[a>>2]=c[8132];c[a+4>>2]=c[8133];c[a+8>>2]=c[8134];c[a+12>>2]=c[8135];c[8132]=h;c[8133]=g;c[8135]=0;c[8134]=a;a=b+24|0;do{a=a+4|0;c[a>>2]=7}while((a+4|0)>>>0<A>>>0);if((b|0)!=(k|0)){g=b-k|0;c[d>>2]=c[d>>2]&-2;c[k+4>>2]=g|1;c[b>>2]=g;a=g>>>3;if(g>>>0<256){d=32120+(a<<1<<2)|0;b=c[8020]|0;a=1<<a;if(b&a){a=d+8|0;b=c[a>>2]|0;if(b>>>0<(c[8024]|0)>>>0)ra();else{C=a;D=b}}else{c[8020]=b|a;C=d+8|0;D=d}c[C>>2]=k;c[D+12>>2]=k;c[k+8>>2]=D;c[k+12>>2]=d;break}a=g>>>8;if(a)if(g>>>0>16777215)d=31;else{F=(a+1048320|0)>>>16&8;G=a<<F;E=(G+520192|0)>>>16&4;G=G<<E;d=(G+245760|0)>>>16&2;d=14-(E|F|d)+(G<<d>>>15)|0;d=g>>>(d+7|0)&1|d<<1}else d=0;e=32384+(d<<2)|0;c[k+28>>2]=d;c[k+20>>2]=0;c[f>>2]=0;a=c[8021]|0;b=1<<d;if(!(a&b)){c[8021]=a|b;c[e>>2]=k;c[k+24>>2]=e;c[k+12>>2]=k;c[k+8>>2]=k;break}d=g<<((d|0)==31?0:25-(d>>>1)|0);e=c[e>>2]|0;while(1){if((c[e+4>>2]&-8|0)==(g|0)){z=307;break}b=e+16+(d>>>31<<2)|0;a=c[b>>2]|0;if(!a){z=304;break}else{d=d<<1;e=a}}if((z|0)==304)if(b>>>0<(c[8024]|0)>>>0)ra();else{c[b>>2]=k;c[k+24>>2]=e;c[k+12>>2]=k;c[k+8>>2]=k;break}else if((z|0)==307){a=e+8|0;b=c[a>>2]|0;G=c[8024]|0;if(b>>>0>=G>>>0&e>>>0>=G>>>0){c[b+12>>2]=k;c[a>>2]=k;c[k+8>>2]=b;c[k+12>>2]=e;c[k+24>>2]=0;break}else ra()}}}else{G=c[8024]|0;if((G|0)==0|h>>>0<G>>>0)c[8024]=h;c[8132]=h;c[8133]=g;c[8135]=0;c[8029]=c[8138];c[8028]=-1;a=0;do{G=32120+(a<<1<<2)|0;c[G+12>>2]=G;c[G+8>>2]=G;a=a+1|0}while((a|0)!=32);G=h+8|0;G=(G&7|0)==0?0:0-G&7;F=h+G|0;G=g+-40-G|0;c[8026]=F;c[8023]=G;c[F+4>>2]=G|1;c[F+G+4>>2]=40;c[8027]=c[8142]}while(0);a=c[8023]|0;if(a>>>0>o>>>0){E=a-o|0;c[8023]=E;G=c[8026]|0;F=G+o|0;c[8026]=F;c[F+4>>2]=E|1;c[G+4>>2]=o|3;G=G+8|0;return G|0}}if(!(c[7979]|0))a=31964;else a=c[(oa()|0)+60>>2]|0;c[a>>2]=12;G=0;return G|0}function zd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;if(!a)return;d=a+-8|0;h=c[8024]|0;if(d>>>0<h>>>0)ra();a=c[a+-4>>2]|0;b=a&3;if((b|0)==1)ra();e=a&-8;m=d+e|0;do if(!(a&1)){a=c[d>>2]|0;if(!b)return;k=d+(0-a)|0;j=a+e|0;if(k>>>0<h>>>0)ra();if((k|0)==(c[8025]|0)){a=m+4|0;b=c[a>>2]|0;if((b&3|0)!=3){q=k;f=j;break}c[8022]=j;c[a>>2]=b&-2;c[k+4>>2]=j|1;c[k+j>>2]=j;return}e=a>>>3;if(a>>>0<256){b=c[k+8>>2]|0;d=c[k+12>>2]|0;a=32120+(e<<1<<2)|0;if((b|0)!=(a|0)){if(b>>>0<h>>>0)ra();if((c[b+12>>2]|0)!=(k|0))ra()}if((d|0)==(b|0)){c[8020]=c[8020]&~(1<<e);q=k;f=j;break}if((d|0)!=(a|0)){if(d>>>0<h>>>0)ra();a=d+8|0;if((c[a>>2]|0)==(k|0))g=a;else ra()}else g=d+8|0;c[b+12>>2]=d;c[g>>2]=b;q=k;f=j;break}g=c[k+24>>2]|0;d=c[k+12>>2]|0;do if((d|0)==(k|0)){d=k+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){i=0;break}else b=d}while(1){d=a+20|0;e=c[d>>2]|0;if(e){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}if(b>>>0<h>>>0)ra();else{c[b>>2]=0;i=a;break}}else{e=c[k+8>>2]|0;if(e>>>0<h>>>0)ra();a=e+12|0;if((c[a>>2]|0)!=(k|0))ra();b=d+8|0;if((c[b>>2]|0)==(k|0)){c[a>>2]=d;c[b>>2]=e;i=d;break}else ra()}while(0);if(g){a=c[k+28>>2]|0;b=32384+(a<<2)|0;if((k|0)==(c[b>>2]|0)){c[b>>2]=i;if(!i){c[8021]=c[8021]&~(1<<a);q=k;f=j;break}}else{if(g>>>0<(c[8024]|0)>>>0)ra();a=g+16|0;if((c[a>>2]|0)==(k|0))c[a>>2]=i;else c[g+20>>2]=i;if(!i){q=k;f=j;break}}d=c[8024]|0;if(i>>>0<d>>>0)ra();c[i+24>>2]=g;a=k+16|0;b=c[a>>2]|0;do if(b)if(b>>>0<d>>>0)ra();else{c[i+16>>2]=b;c[b+24>>2]=i;break}while(0);a=c[a+4>>2]|0;if(a)if(a>>>0<(c[8024]|0)>>>0)ra();else{c[i+20>>2]=a;c[a+24>>2]=i;q=k;f=j;break}else{q=k;f=j}}else{q=k;f=j}}else{q=d;f=e}while(0);if(q>>>0>=m>>>0)ra();a=m+4|0;b=c[a>>2]|0;if(!(b&1))ra();if(!(b&2)){if((m|0)==(c[8026]|0)){p=(c[8023]|0)+f|0;c[8023]=p;c[8026]=q;c[q+4>>2]=p|1;if((q|0)!=(c[8025]|0))return;c[8025]=0;c[8022]=0;return}if((m|0)==(c[8025]|0)){p=(c[8022]|0)+f|0;c[8022]=p;c[8025]=q;c[q+4>>2]=p|1;c[q+p>>2]=p;return}f=(b&-8)+f|0;e=b>>>3;do if(b>>>0>=256){g=c[m+24>>2]|0;a=c[m+12>>2]|0;do if((a|0)==(m|0)){d=m+16|0;b=d+4|0;a=c[b>>2]|0;if(!a){a=c[d>>2]|0;if(!a){n=0;break}else b=d}while(1){d=a+20|0;e=c[d>>2]|0;if(e){a=e;b=d;continue}d=a+16|0;e=c[d>>2]|0;if(!e)break;else{a=e;b=d}}if(b>>>0<(c[8024]|0)>>>0)ra();else{c[b>>2]=0;n=a;break}}else{b=c[m+8>>2]|0;if(b>>>0<(c[8024]|0)>>>0)ra();d=b+12|0;if((c[d>>2]|0)!=(m|0))ra();e=a+8|0;if((c[e>>2]|0)==(m|0)){c[d>>2]=a;c[e>>2]=b;n=a;break}else ra()}while(0);if(g){a=c[m+28>>2]|0;b=32384+(a<<2)|0;if((m|0)==(c[b>>2]|0)){c[b>>2]=n;if(!n){c[8021]=c[8021]&~(1<<a);break}}else{if(g>>>0<(c[8024]|0)>>>0)ra();a=g+16|0;if((c[a>>2]|0)==(m|0))c[a>>2]=n;else c[g+20>>2]=n;if(!n)break}d=c[8024]|0;if(n>>>0<d>>>0)ra();c[n+24>>2]=g;a=m+16|0;b=c[a>>2]|0;do if(b)if(b>>>0<d>>>0)ra();else{c[n+16>>2]=b;c[b+24>>2]=n;break}while(0);a=c[a+4>>2]|0;if(a)if(a>>>0<(c[8024]|0)>>>0)ra();else{c[n+20>>2]=a;c[a+24>>2]=n;break}}}else{b=c[m+8>>2]|0;d=c[m+12>>2]|0;a=32120+(e<<1<<2)|0;if((b|0)!=(a|0)){if(b>>>0<(c[8024]|0)>>>0)ra();if((c[b+12>>2]|0)!=(m|0))ra()}if((d|0)==(b|0)){c[8020]=c[8020]&~(1<<e);break}if((d|0)!=(a|0)){if(d>>>0<(c[8024]|0)>>>0)ra();a=d+8|0;if((c[a>>2]|0)==(m|0))l=a;else ra()}else l=d+8|0;c[b+12>>2]=d;c[l>>2]=b}while(0);c[q+4>>2]=f|1;c[q+f>>2]=f;if((q|0)==(c[8025]|0)){c[8022]=f;return}}else{c[a>>2]=b&-2;c[q+4>>2]=f|1;c[q+f>>2]=f}a=f>>>3;if(f>>>0<256){d=32120+(a<<1<<2)|0;b=c[8020]|0;a=1<<a;if(b&a){a=d+8|0;b=c[a>>2]|0;if(b>>>0<(c[8024]|0)>>>0)ra();else{o=a;p=b}}else{c[8020]=b|a;o=d+8|0;p=d}c[o>>2]=q;c[p+12>>2]=q;c[q+8>>2]=p;c[q+12>>2]=d;return}a=f>>>8;if(a)if(f>>>0>16777215)d=31;else{o=(a+1048320|0)>>>16&8;p=a<<o;n=(p+520192|0)>>>16&4;p=p<<n;d=(p+245760|0)>>>16&2;d=14-(n|o|d)+(p<<d>>>15)|0;d=f>>>(d+7|0)&1|d<<1}else d=0;e=32384+(d<<2)|0;c[q+28>>2]=d;c[q+20>>2]=0;c[q+16>>2]=0;a=c[8021]|0;b=1<<d;do if(a&b){d=f<<((d|0)==31?0:25-(d>>>1)|0);e=c[e>>2]|0;while(1){if((c[e+4>>2]&-8|0)==(f|0)){a=130;break}b=e+16+(d>>>31<<2)|0;a=c[b>>2]|0;if(!a){a=127;break}else{d=d<<1;e=a}}if((a|0)==127)if(b>>>0<(c[8024]|0)>>>0)ra();else{c[b>>2]=q;c[q+24>>2]=e;c[q+12>>2]=q;c[q+8>>2]=q;break}else if((a|0)==130){a=e+8|0;b=c[a>>2]|0;p=c[8024]|0;if(b>>>0>=p>>>0&e>>>0>=p>>>0){c[b+12>>2]=q;c[a>>2]=q;c[q+8>>2]=b;c[q+12>>2]=e;c[q+24>>2]=0;break}else ra()}}else{c[8021]=a|b;c[e>>2]=q;c[q+24>>2]=e;c[q+12>>2]=q;c[q+8>>2]=q}while(0);q=(c[8028]|0)+-1|0;c[8028]=q;if(!q)a=32536;else return;while(1){a=c[a>>2]|0;if(!a)break;else a=a+8|0}c[8028]=-1;return}function Ad(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;o=a+b|0;d=c[a+4>>2]|0;do if(!(d&1)){g=c[a>>2]|0;if(!(d&3))return;l=a+(0-g)|0;k=g+b|0;i=c[8024]|0;if(l>>>0<i>>>0)ra();if((l|0)==(c[8025]|0)){a=o+4|0;d=c[a>>2]|0;if((d&3|0)!=3){r=l;f=k;break}c[8022]=k;c[a>>2]=d&-2;c[l+4>>2]=k|1;c[l+k>>2]=k;return}e=g>>>3;if(g>>>0<256){a=c[l+8>>2]|0;b=c[l+12>>2]|0;d=32120+(e<<1<<2)|0;if((a|0)!=(d|0)){if(a>>>0<i>>>0)ra();if((c[a+12>>2]|0)!=(l|0))ra()}if((b|0)==(a|0)){c[8020]=c[8020]&~(1<<e);r=l;f=k;break}if((b|0)!=(d|0)){if(b>>>0<i>>>0)ra();d=b+8|0;if((c[d>>2]|0)==(l|0))h=d;else ra()}else h=b+8|0;c[a+12>>2]=b;c[h>>2]=a;r=l;f=k;break}g=c[l+24>>2]|0;b=c[l+12>>2]|0;do if((b|0)==(l|0)){b=l+16|0;a=b+4|0;d=c[a>>2]|0;if(!d){d=c[b>>2]|0;if(!d){j=0;break}else a=b}while(1){b=d+20|0;e=c[b>>2]|0;if(e){d=e;a=b;continue}b=d+16|0;e=c[b>>2]|0;if(!e)break;else{d=e;a=b}}if(a>>>0<i>>>0)ra();else{c[a>>2]=0;j=d;break}}else{e=c[l+8>>2]|0;if(e>>>0<i>>>0)ra();d=e+12|0;if((c[d>>2]|0)!=(l|0))ra();a=b+8|0;if((c[a>>2]|0)==(l|0)){c[d>>2]=b;c[a>>2]=e;j=b;break}else ra()}while(0);if(g){d=c[l+28>>2]|0;a=32384+(d<<2)|0;if((l|0)==(c[a>>2]|0)){c[a>>2]=j;if(!j){c[8021]=c[8021]&~(1<<d);r=l;f=k;break}}else{if(g>>>0<(c[8024]|0)>>>0)ra();d=g+16|0;if((c[d>>2]|0)==(l|0))c[d>>2]=j;else c[g+20>>2]=j;if(!j){r=l;f=k;break}}b=c[8024]|0;if(j>>>0<b>>>0)ra();c[j+24>>2]=g;d=l+16|0;a=c[d>>2]|0;do if(a)if(a>>>0<b>>>0)ra();else{c[j+16>>2]=a;c[a+24>>2]=j;break}while(0);d=c[d+4>>2]|0;if(d)if(d>>>0<(c[8024]|0)>>>0)ra();else{c[j+20>>2]=d;c[d+24>>2]=j;r=l;f=k;break}else{r=l;f=k}}else{r=l;f=k}}else{r=a;f=b}while(0);h=c[8024]|0;if(o>>>0<h>>>0)ra();d=o+4|0;a=c[d>>2]|0;if(!(a&2)){if((o|0)==(c[8026]|0)){q=(c[8023]|0)+f|0;c[8023]=q;c[8026]=r;c[r+4>>2]=q|1;if((r|0)!=(c[8025]|0))return;c[8025]=0;c[8022]=0;return}if((o|0)==(c[8025]|0)){q=(c[8022]|0)+f|0;c[8022]=q;c[8025]=r;c[r+4>>2]=q|1;c[r+q>>2]=q;return}f=(a&-8)+f|0;e=a>>>3;do if(a>>>0>=256){g=c[o+24>>2]|0;b=c[o+12>>2]|0;do if((b|0)==(o|0)){b=o+16|0;a=b+4|0;d=c[a>>2]|0;if(!d){d=c[b>>2]|0;if(!d){n=0;break}else a=b}while(1){b=d+20|0;e=c[b>>2]|0;if(e){d=e;a=b;continue}b=d+16|0;e=c[b>>2]|0;if(!e)break;else{d=e;a=b}}if(a>>>0<h>>>0)ra();else{c[a>>2]=0;n=d;break}}else{e=c[o+8>>2]|0;if(e>>>0<h>>>0)ra();d=e+12|0;if((c[d>>2]|0)!=(o|0))ra();a=b+8|0;if((c[a>>2]|0)==(o|0)){c[d>>2]=b;c[a>>2]=e;n=b;break}else ra()}while(0);if(g){d=c[o+28>>2]|0;a=32384+(d<<2)|0;if((o|0)==(c[a>>2]|0)){c[a>>2]=n;if(!n){c[8021]=c[8021]&~(1<<d);break}}else{if(g>>>0<(c[8024]|0)>>>0)ra();d=g+16|0;if((c[d>>2]|0)==(o|0))c[d>>2]=n;else c[g+20>>2]=n;if(!n)break}b=c[8024]|0;if(n>>>0<b>>>0)ra();c[n+24>>2]=g;d=o+16|0;a=c[d>>2]|0;do if(a)if(a>>>0<b>>>0)ra();else{c[n+16>>2]=a;c[a+24>>2]=n;break}while(0);d=c[d+4>>2]|0;if(d)if(d>>>0<(c[8024]|0)>>>0)ra();else{c[n+20>>2]=d;c[d+24>>2]=n;break}}}else{a=c[o+8>>2]|0;b=c[o+12>>2]|0;d=32120+(e<<1<<2)|0;if((a|0)!=(d|0)){if(a>>>0<h>>>0)ra();if((c[a+12>>2]|0)!=(o|0))ra()}if((b|0)==(a|0)){c[8020]=c[8020]&~(1<<e);break}if((b|0)!=(d|0)){if(b>>>0<h>>>0)ra();d=b+8|0;if((c[d>>2]|0)==(o|0))m=d;else ra()}else m=b+8|0;c[a+12>>2]=b;c[m>>2]=a}while(0);c[r+4>>2]=f|1;c[r+f>>2]=f;if((r|0)==(c[8025]|0)){c[8022]=f;return}}else{c[d>>2]=a&-2;c[r+4>>2]=f|1;c[r+f>>2]=f}d=f>>>3;if(f>>>0<256){b=32120+(d<<1<<2)|0;a=c[8020]|0;d=1<<d;if(a&d){d=b+8|0;a=c[d>>2]|0;if(a>>>0<(c[8024]|0)>>>0)ra();else{p=d;q=a}}else{c[8020]=a|d;p=b+8|0;q=b}c[p>>2]=r;c[q+12>>2]=r;c[r+8>>2]=q;c[r+12>>2]=b;return}d=f>>>8;if(d)if(f>>>0>16777215)b=31;else{p=(d+1048320|0)>>>16&8;q=d<<p;o=(q+520192|0)>>>16&4;q=q<<o;b=(q+245760|0)>>>16&2;b=14-(o|p|b)+(q<<b>>>15)|0;b=f>>>(b+7|0)&1|b<<1}else b=0;e=32384+(b<<2)|0;c[r+28>>2]=b;c[r+20>>2]=0;c[r+16>>2]=0;d=c[8021]|0;a=1<<b;if(!(d&a)){c[8021]=d|a;c[e>>2]=r;c[r+24>>2]=e;c[r+12>>2]=r;c[r+8>>2]=r;return}b=f<<((b|0)==31?0:25-(b>>>1)|0);e=c[e>>2]|0;while(1){if((c[e+4>>2]&-8|0)==(f|0)){d=127;break}a=e+16+(b>>>31<<2)|0;d=c[a>>2]|0;if(!d){d=124;break}else{b=b<<1;e=d}}if((d|0)==124){if(a>>>0<(c[8024]|0)>>>0)ra();c[a>>2]=r;c[r+24>>2]=e;c[r+12>>2]=r;c[r+8>>2]=r;return}else if((d|0)==127){d=e+8|0;a=c[d>>2]|0;q=c[8024]|0;if(!(a>>>0>=q>>>0&e>>>0>=q>>>0))ra();c[a+12>>2]=r;c[d>>2]=r;c[r+8>>2]=a;c[r+12>>2]=e;c[r+24>>2]=0;return}}function Bd(){}function Cd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (C=d,a-c>>>0|0)|0}function Dd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (C=b+d+(c>>>0<a>>>0|0)>>>0,c|0)|0}function Ed(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){C=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}C=(b|0)<0?-1:0;return b>>c-32|0}function Fd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=b+e|0;if((e|0)>=20){d=d&255;h=b&3;i=d|d<<8|d<<16|d<<24;g=f&~3;if(h){h=b+4-h|0;while((b|0)<(h|0)){a[b>>0]=d;b=b+1|0}}while((b|0)<(g|0)){c[b>>2]=i;b=b+4|0}}while((b|0)<(f|0)){a[b>>0]=d;b=b+1|0}return b-e|0}function Gd(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){C=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}C=0;return b>>>c-32|0}function Hd(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){C=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}C=a<<c-32;return 0}function Id(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((e|0)>=4096)return va(b|0,d|0,e|0)|0;f=b|0;if((b&3)==(d&3)){while(b&3){if(!e)return f|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function Jd(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;if((c|0)<(b|0)&(b|0)<(c+d|0)){e=b;c=c+d|0;b=b+d|0;while((d|0)>0){b=b-1|0;c=c-1|0;d=d-1|0;a[b>>0]=a[c>>0]|0}b=e}else Id(b,c,d)|0;return b|0}function Kd(b){b=b|0;var c=0;c=a[m+(b&255)>>0]|0;if((c|0)<8)return c|0;c=a[m+(b>>8&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[m+(b>>16&255)>>0]|0;if((c|0)<8)return c+16|0;return (a[m+(b>>>24)>>0]|0)+24|0}function Ld(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=_(e,f)|0;d=a>>>16;a=(c>>>16)+(_(e,d)|0)|0;e=b>>>16;b=_(e,f)|0;return (C=(a>>>16)+(_(e,d)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|c&65535|0)|0}function Md(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=b>>31|((b|0)<0?-1:0)<<1;i=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;f=d>>31|((d|0)<0?-1:0)<<1;e=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;h=Cd(j^a,i^b,j,i)|0;g=C;a=f^j;b=e^i;return Cd((Rd(h,g,Cd(f^c,e^d,f,e)|0,C,0)|0)^a,C^b,a,b)|0}function Nd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0;f=i;i=i+16|0;j=f|0;h=b>>31|((b|0)<0?-1:0)<<1;g=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;l=e>>31|((e|0)<0?-1:0)<<1;k=((e|0)<0?-1:0)>>31|((e|0)<0?-1:0)<<1;a=Cd(h^a,g^b,h,g)|0;b=C;Rd(a,b,Cd(l^d,k^e,l,k)|0,C,j)|0;e=Cd(c[j>>2]^h,c[j+4>>2]^g,h,g)|0;d=C;i=f;return (C=d,e)|0}function Od(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=Ld(e,f)|0;a=C;return (C=(_(b,f)|0)+(_(d,e)|0)+a|a&0,c|0|0)|0}function Pd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Rd(a,b,c,d,0)|0}function Qd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;g=i;i=i+16|0;f=g|0;Rd(a,b,d,e,f)|0;i=g;return (C=c[f+4>>2]|0,c[f>>2]|0)|0}function Rd(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;l=a;j=b;k=j;h=d;n=e;i=n;if(!k){g=(f|0)!=0;if(!i){if(g){c[f>>2]=(l>>>0)%(h>>>0);c[f+4>>2]=0}n=0;f=(l>>>0)/(h>>>0)>>>0;return (C=n,f)|0}else{if(!g){n=0;f=0;return (C=n,f)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;n=0;f=0;return (C=n,f)|0}}g=(i|0)==0;do if(h){if(!g){g=(aa(i|0)|0)-(aa(k|0)|0)|0;if(g>>>0<=31){m=g+1|0;i=31-g|0;b=g-31>>31;h=m;a=l>>>(m>>>0)&b|k<<i;b=k>>>(m>>>0)&b;g=0;i=l<<i;break}if(!f){n=0;f=0;return (C=n,f)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;n=0;f=0;return (C=n,f)|0}g=h-1|0;if(g&h){i=(aa(h|0)|0)+33-(aa(k|0)|0)|0;p=64-i|0;m=32-i|0;j=m>>31;o=i-32|0;b=o>>31;h=i;a=m-1>>31&k>>>(o>>>0)|(k<<m|l>>>(i>>>0))&b;b=b&k>>>(i>>>0);g=l<<p&j;i=(k<<p|l>>>(o>>>0))&j|l<<m&i-33>>31;break}if(f){c[f>>2]=g&l;c[f+4>>2]=0}if((h|0)==1){o=j|b&0;p=a|0|0;return (C=o,p)|0}else{p=Kd(h|0)|0;o=k>>>(p>>>0)|0;p=k<<32-p|l>>>(p>>>0)|0;return (C=o,p)|0}}else{if(g){if(f){c[f>>2]=(k>>>0)%(h>>>0);c[f+4>>2]=0}o=0;p=(k>>>0)/(h>>>0)>>>0;return (C=o,p)|0}if(!l){if(f){c[f>>2]=0;c[f+4>>2]=(k>>>0)%(i>>>0)}o=0;p=(k>>>0)/(i>>>0)>>>0;return (C=o,p)|0}g=i-1|0;if(!(g&i)){if(f){c[f>>2]=a|0;c[f+4>>2]=g&k|b&0}o=0;p=k>>>((Kd(i|0)|0)>>>0);return (C=o,p)|0}g=(aa(i|0)|0)-(aa(k|0)|0)|0;if(g>>>0<=30){b=g+1|0;i=31-g|0;h=b;a=k<<i|l>>>(b>>>0);b=k>>>(b>>>0);g=0;i=l<<i;break}if(!f){o=0;p=0;return (C=o,p)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;o=0;p=0;return (C=o,p)|0}while(0);if(!h){k=i;j=0;i=0}else{m=d|0|0;l=n|e&0;k=Dd(m|0,l|0,-1,-1)|0;d=C;j=i;i=0;do{e=j;j=g>>>31|j<<1;g=i|g<<1;e=a<<1|e>>>31|0;n=a>>>31|b<<1|0;Cd(k,d,e,n)|0;p=C;o=p>>31|((p|0)<0?-1:0)<<1;i=o&1;a=Cd(e,n,o&m,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&l)|0;b=C;h=h-1|0}while((h|0)!=0);k=j;j=0}h=0;if(f){c[f>>2]=a;c[f+4>>2]=b}o=(g|0)>>>31|(k|h)<<1|(h<<1|g>>>31)&0|j;p=(g<<1|0>>>31)&-2|i;return (C=o,p)|0}function Sd(a){a=a|0;return Da[a&31]()|0}function Td(){return ea(0)|0}function Ud(){return ea(1)|0}function Vd(){return ea(2)|0}function Wd(){return ea(3)|0}function Xd(){return ea(4)|0}function Yd(){return ea(5)|0}function Zd(){return ea(6)|0}function _d(){return ea(7)|0}function $d(a,b){a=a|0;b=b|0;return Ea[a&31](b|0)|0}function ae(a){a=a|0;return ga(0,a|0)|0}function be(a){a=a|0;return ga(1,a|0)|0}function ce(a){a=a|0;return ga(2,a|0)|0}function de(a){a=a|0;return ga(3,a|0)|0}function ee(a){a=a|0;return ga(4,a|0)|0}function fe(a){a=a|0;return ga(5,a|0)|0}function ge(a){a=a|0;return ga(6,a|0)|0}function he(a){a=a|0;return ga(7,a|0)|0}function ie(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Fa[a&31](b|0,c|0,d|0)|0}function je(a,b,c){a=a|0;b=b|0;c=c|0;return ia(0,a|0,b|0,c|0)|0}function ke(a,b,c){a=a|0;b=b|0;c=c|0;return ia(1,a|0,b|0,c|0)|0}function le(a,b,c){a=a|0;b=b|0;c=c|0;return ia(2,a|0,b|0,c|0)|0}function me(a,b,c){a=a|0;b=b|0;c=c|0;return ia(3,a|0,b|0,c|0)|0}function ne(a,b,c){a=a|0;b=b|0;c=c|0;return ia(4,a|0,b|0,c|0)|0}function oe(a,b,c){a=a|0;b=b|0;c=c|0;return ia(5,a|0,b|0,c|0)|0}function pe(a,b,c){a=a|0;b=b|0;c=c|0;return ia(6,a|0,b|0,c|0)|0}function qe(a,b,c){a=a|0;b=b|0;c=c|0;return ia(7,a|0,b|0,c|0)|0}function re(a,b){a=a|0;b=b|0;Ga[a&31](b|0)}function se(a){a=a|0;ka(0,a|0)}function te(a){a=a|0;ka(1,a|0)}function ue(a){a=a|0;ka(2,a|0)}function ve(a){a=a|0;ka(3,a|0)}function we(a){a=a|0;ka(4,a|0)}function xe(a){a=a|0;ka(5,a|0)}function ye(a){a=a|0;ka(6,a|0)}function ze(a){a=a|0;ka(7,a|0)}function Ae(){ba(0);return 0}function Be(a){a=a|0;ba(1);return 0}function Ce(a,b,c){a=a|0;b=b|0;c=c|0;ba(2);return 0}function De(a){a=a|0;ba(3)}

// EMSCRIPTEN_END_FUNCS
var Da=[Ae,Ae,Td,Ae,Ud,Ae,Vd,Ae,Wd,Ae,Xd,Ae,Yd,Ae,Zd,Ae,_d,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae,Ae];var Ea=[Be,Be,ae,Be,be,Be,ce,Be,de,Be,ee,Be,fe,Be,ge,Be,he,Be,pd,Be,Be,Be,Be,Be,Be,Be,Be,Be,Be,Be,Be,Be];var Fa=[Ce,Ce,je,Ce,ke,Ce,le,Ce,me,Ce,ne,Ce,oe,Ce,pe,Ce,qe,Ce,sd,qd,rd,Ce,Ce,Ce,Ce,Ce,Ce,Ce,Ce,Ce,Ce,Ce];var Ga=[De,De,se,De,te,De,ue,De,ve,De,we,De,xe,De,ye,De,ze,De,wd,De,De,De,De,De,De,De,De,De,De,De,De,De];return{_sodium_library_version_minor:jd,_crypto_onetimeauth_bytes:Jb,_sodium_version_string:hd,_sodium_hex2bin:gd,_crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive:dc,_bitshift64Lshr:Gd,_crypto_pwhash_scryptsalsa208sha256:ec,_crypto_box_noncebytes:Za,_crypto_box_beforenm:bb,_crypto_scalarmult_base:mc,_crypto_auth_bytes:Qa,_crypto_sign_open:Fc,_memcpy:Id,_crypto_box_seed_keypair:$a,_crypto_pwhash_scryptsalsa208sha256_memlimit_interactive:bc,_crypto_box_open_easy_afternm:ib,_crypto_sign_ed25519_sk_to_curve25519:Uc,_sodium_memzero:ed,_crypto_box_seal:kb,_free:zd,_crypto_shorthash:xc,_crypto_auth_keybytes:Ra,_crypto_pwhash_scryptsalsa208sha256_saltbytes:Zb,_crypto_sign_seedbytes:zc,_crypto_box_detached_afternm:cb,_crypto_auth:Sa,_randombytes_random:_c,_crypto_sign_keypair:Dc,_crypto_shorthash_keybytes:wc,_crypto_generichash_statebytes:vb,_crypto_pwhash_scryptsalsa208sha256_str_verify:gc,_crypto_generichash_init:xb,_crypto_generichash_keybytes_max:tb,_crypto_sign_ed25519_pk_to_curve25519:Tc,_crypto_box_beforenmbytes:Ya,_crypto_generichash:wb,_sodium_library_version_major:id,_randombytes_stir:$c,_randombytes_close:cd,_crypto_onetimeauth_keybytes:Kb,_crypto_onetimeauth:Lb,_crypto_shorthash_bytes:vc,_crypto_box_secretkeybytes:Xa,_crypto_onetimeauth_update:Ob,_crypto_pwhash_scryptsalsa208sha256_ll:Wb,_crypto_box_detached:db,_randombytes_buf:bd,_crypto_pwhash_scryptsalsa208sha256_str:fc,_bitshift64Ashr:Ed,_crypto_box_open_detached:hb,_crypto_scalarmult_bytes:kc,_crypto_auth_verify:Ta,_crypto_box_seal_open:lb,_crypto_secretbox_detached:rc,_crypto_secretbox_easy:sc,_crypto_pwhash_scryptsalsa208sha256_strbytes:_b,_memset:Fd,_crypto_box_open_detached_afternm:gb,_crypto_box_sealbytes:mb,_i64Subtract:Cd,_crypto_pwhash_scryptsalsa208sha256_strprefix:$b,_crypto_box_seedbytes:Va,_crypto_hash:Cb,_crypto_box_easy_afternm:eb,_crypto_box_macbytes:_a,_crypto_box_publickeybytes:Wa,_sodium_bin2hex:fd,_crypto_sign_secretkeybytes:Bc,_crypto_scalarmult_scalarbytes:lc,_crypto_onetimeauth_statebytes:Ib,_crypto_generichash_keybytes_min:sb,_malloc:yd,_memmove:Jd,_crypto_sign:Ec,_crypto_secretbox_noncebytes:pc,_randombytes_set_implementation:Zc,_crypto_box_keypair:ab,_crypto_generichash_keybytes:ub,_crypto_generichash_bytes_min:pb,_sodium_init:dd,_crypto_secretbox_macbytes:qc,_crypto_secretbox_keybytes:oc,_bitshift64Shl:Hd,_crypto_hash_bytes:Bb,_fflush:td,_crypto_generichash_bytes:rb,_crypto_generichash_bytes_max:qb,_crypto_secretbox_open_detached:tc,_crypto_sign_verify_detached:Hc,_crypto_onetimeauth_verify:Mb,_crypto_box_open_easy:jb,_crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive:cc,_crypto_sign_publickeybytes:Ac,_i64Add:Dd,_crypto_sign_bytes:yc,_crypto_generichash_update:yb,_crypto_scalarmult:nc,_crypto_sign_detached:Gc,_crypto_box_easy:fb,___errno_location:od,_crypto_onetimeauth_final:Pb,_crypto_secretbox_open_easy:uc,_crypto_generichash_final:zb,_randombytes_uniform:ad,_crypto_sign_seed_keypair:Cc,_crypto_pwhash_scryptsalsa208sha256_opslimit_interactive:ac,_crypto_onetimeauth_init:Nb,runPostSets:Bd,stackAlloc:Ha,stackSave:Ia,stackRestore:Ja,establishStackSpace:Ka,setThrew:La,setTempRet0:Oa,getTempRet0:Pa,dynCall_i:Sd,dynCall_ii:$d,dynCall_iiii:ie,dynCall_vi:re}})


// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg,Module.asmLibraryArg,buffer);var _sodium_library_version_minor=Module["_sodium_library_version_minor"]=asm["_sodium_library_version_minor"];var _crypto_onetimeauth_bytes=Module["_crypto_onetimeauth_bytes"]=asm["_crypto_onetimeauth_bytes"];var _crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive=Module["_crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive"]=asm["_crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive"];var _bitshift64Lshr=Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];var _crypto_pwhash_scryptsalsa208sha256=Module["_crypto_pwhash_scryptsalsa208sha256"]=asm["_crypto_pwhash_scryptsalsa208sha256"];var _crypto_box_noncebytes=Module["_crypto_box_noncebytes"]=asm["_crypto_box_noncebytes"];var _crypto_box_beforenm=Module["_crypto_box_beforenm"]=asm["_crypto_box_beforenm"];var _crypto_scalarmult_base=Module["_crypto_scalarmult_base"]=asm["_crypto_scalarmult_base"];var _crypto_auth_bytes=Module["_crypto_auth_bytes"]=asm["_crypto_auth_bytes"];var _crypto_sign_open=Module["_crypto_sign_open"]=asm["_crypto_sign_open"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _crypto_box_seed_keypair=Module["_crypto_box_seed_keypair"]=asm["_crypto_box_seed_keypair"];var _crypto_pwhash_scryptsalsa208sha256_memlimit_interactive=Module["_crypto_pwhash_scryptsalsa208sha256_memlimit_interactive"]=asm["_crypto_pwhash_scryptsalsa208sha256_memlimit_interactive"];var _crypto_box_open_easy_afternm=Module["_crypto_box_open_easy_afternm"]=asm["_crypto_box_open_easy_afternm"];var _crypto_sign_ed25519_sk_to_curve25519=Module["_crypto_sign_ed25519_sk_to_curve25519"]=asm["_crypto_sign_ed25519_sk_to_curve25519"];var _sodium_memzero=Module["_sodium_memzero"]=asm["_sodium_memzero"];var _crypto_box_seal=Module["_crypto_box_seal"]=asm["_crypto_box_seal"];var _free=Module["_free"]=asm["_free"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var _crypto_shorthash=Module["_crypto_shorthash"]=asm["_crypto_shorthash"];var _crypto_auth_keybytes=Module["_crypto_auth_keybytes"]=asm["_crypto_auth_keybytes"];var _crypto_pwhash_scryptsalsa208sha256_saltbytes=Module["_crypto_pwhash_scryptsalsa208sha256_saltbytes"]=asm["_crypto_pwhash_scryptsalsa208sha256_saltbytes"];var _crypto_sign_seedbytes=Module["_crypto_sign_seedbytes"]=asm["_crypto_sign_seedbytes"];var _crypto_box_detached_afternm=Module["_crypto_box_detached_afternm"]=asm["_crypto_box_detached_afternm"];var _crypto_auth=Module["_crypto_auth"]=asm["_crypto_auth"];var _randombytes_random=Module["_randombytes_random"]=asm["_randombytes_random"];var _crypto_sign_keypair=Module["_crypto_sign_keypair"]=asm["_crypto_sign_keypair"];var _crypto_generichash_keybytes_min=Module["_crypto_generichash_keybytes_min"]=asm["_crypto_generichash_keybytes_min"];var _crypto_generichash_statebytes=Module["_crypto_generichash_statebytes"]=asm["_crypto_generichash_statebytes"];var _crypto_pwhash_scryptsalsa208sha256_str_verify=Module["_crypto_pwhash_scryptsalsa208sha256_str_verify"]=asm["_crypto_pwhash_scryptsalsa208sha256_str_verify"];var _sodium_version_string=Module["_sodium_version_string"]=asm["_sodium_version_string"];var _crypto_generichash_keybytes_max=Module["_crypto_generichash_keybytes_max"]=asm["_crypto_generichash_keybytes_max"];var _crypto_sign_ed25519_pk_to_curve25519=Module["_crypto_sign_ed25519_pk_to_curve25519"]=asm["_crypto_sign_ed25519_pk_to_curve25519"];var _crypto_sign_publickeybytes=Module["_crypto_sign_publickeybytes"]=asm["_crypto_sign_publickeybytes"];var _crypto_box_beforenmbytes=Module["_crypto_box_beforenmbytes"]=asm["_crypto_box_beforenmbytes"];var _crypto_generichash=Module["_crypto_generichash"]=asm["_crypto_generichash"];var _sodium_library_version_major=Module["_sodium_library_version_major"]=asm["_sodium_library_version_major"];var _randombytes_stir=Module["_randombytes_stir"]=asm["_randombytes_stir"];var _crypto_shorthash_keybytes=Module["_crypto_shorthash_keybytes"]=asm["_crypto_shorthash_keybytes"];var _randombytes_close=Module["_randombytes_close"]=asm["_randombytes_close"];var _crypto_onetimeauth_keybytes=Module["_crypto_onetimeauth_keybytes"]=asm["_crypto_onetimeauth_keybytes"];var _crypto_onetimeauth=Module["_crypto_onetimeauth"]=asm["_crypto_onetimeauth"];var _crypto_shorthash_bytes=Module["_crypto_shorthash_bytes"]=asm["_crypto_shorthash_bytes"];var _crypto_box_secretkeybytes=Module["_crypto_box_secretkeybytes"]=asm["_crypto_box_secretkeybytes"];var _crypto_onetimeauth_update=Module["_crypto_onetimeauth_update"]=asm["_crypto_onetimeauth_update"];var _crypto_pwhash_scryptsalsa208sha256_ll=Module["_crypto_pwhash_scryptsalsa208sha256_ll"]=asm["_crypto_pwhash_scryptsalsa208sha256_ll"];var _crypto_box_detached=Module["_crypto_box_detached"]=asm["_crypto_box_detached"];var _randombytes_buf=Module["_randombytes_buf"]=asm["_randombytes_buf"];var _crypto_pwhash_scryptsalsa208sha256_strbytes=Module["_crypto_pwhash_scryptsalsa208sha256_strbytes"]=asm["_crypto_pwhash_scryptsalsa208sha256_strbytes"];var _bitshift64Ashr=Module["_bitshift64Ashr"]=asm["_bitshift64Ashr"];var _crypto_box_open_detached=Module["_crypto_box_open_detached"]=asm["_crypto_box_open_detached"];var _crypto_scalarmult_bytes=Module["_crypto_scalarmult_bytes"]=asm["_crypto_scalarmult_bytes"];var _crypto_auth_verify=Module["_crypto_auth_verify"]=asm["_crypto_auth_verify"];var _crypto_sign_detached=Module["_crypto_sign_detached"]=asm["_crypto_sign_detached"];var _crypto_secretbox_detached=Module["_crypto_secretbox_detached"]=asm["_crypto_secretbox_detached"];var _crypto_secretbox_easy=Module["_crypto_secretbox_easy"]=asm["_crypto_secretbox_easy"];var _crypto_pwhash_scryptsalsa208sha256_str=Module["_crypto_pwhash_scryptsalsa208sha256_str"]=asm["_crypto_pwhash_scryptsalsa208sha256_str"];var _memset=Module["_memset"]=asm["_memset"];var _crypto_box_open_detached_afternm=Module["_crypto_box_open_detached_afternm"]=asm["_crypto_box_open_detached_afternm"];var _crypto_box_sealbytes=Module["_crypto_box_sealbytes"]=asm["_crypto_box_sealbytes"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _crypto_pwhash_scryptsalsa208sha256_strprefix=Module["_crypto_pwhash_scryptsalsa208sha256_strprefix"]=asm["_crypto_pwhash_scryptsalsa208sha256_strprefix"];var _crypto_box_seedbytes=Module["_crypto_box_seedbytes"]=asm["_crypto_box_seedbytes"];var _crypto_hash=Module["_crypto_hash"]=asm["_crypto_hash"];var _crypto_box_easy_afternm=Module["_crypto_box_easy_afternm"]=asm["_crypto_box_easy_afternm"];var _crypto_box_macbytes=Module["_crypto_box_macbytes"]=asm["_crypto_box_macbytes"];var _crypto_box_publickeybytes=Module["_crypto_box_publickeybytes"]=asm["_crypto_box_publickeybytes"];var _sodium_bin2hex=Module["_sodium_bin2hex"]=asm["_sodium_bin2hex"];var _crypto_sign_secretkeybytes=Module["_crypto_sign_secretkeybytes"]=asm["_crypto_sign_secretkeybytes"];var _crypto_scalarmult_scalarbytes=Module["_crypto_scalarmult_scalarbytes"]=asm["_crypto_scalarmult_scalarbytes"];var _crypto_onetimeauth_statebytes=Module["_crypto_onetimeauth_statebytes"]=asm["_crypto_onetimeauth_statebytes"];var _crypto_generichash_bytes_min=Module["_crypto_generichash_bytes_min"]=asm["_crypto_generichash_bytes_min"];var _malloc=Module["_malloc"]=asm["_malloc"];var _crypto_secretbox_open_easy=Module["_crypto_secretbox_open_easy"]=asm["_crypto_secretbox_open_easy"];var _crypto_sign=Module["_crypto_sign"]=asm["_crypto_sign"];var _crypto_secretbox_noncebytes=Module["_crypto_secretbox_noncebytes"]=asm["_crypto_secretbox_noncebytes"];var _randombytes_set_implementation=Module["_randombytes_set_implementation"]=asm["_randombytes_set_implementation"];var _crypto_box_keypair=Module["_crypto_box_keypair"]=asm["_crypto_box_keypair"];var _crypto_generichash_keybytes=Module["_crypto_generichash_keybytes"]=asm["_crypto_generichash_keybytes"];var _sodium_hex2bin=Module["_sodium_hex2bin"]=asm["_sodium_hex2bin"];var _sodium_init=Module["_sodium_init"]=asm["_sodium_init"];var _crypto_secretbox_macbytes=Module["_crypto_secretbox_macbytes"]=asm["_crypto_secretbox_macbytes"];var _crypto_secretbox_keybytes=Module["_crypto_secretbox_keybytes"]=asm["_crypto_secretbox_keybytes"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _crypto_hash_bytes=Module["_crypto_hash_bytes"]=asm["_crypto_hash_bytes"];var _fflush=Module["_fflush"]=asm["_fflush"];var _crypto_generichash_bytes=Module["_crypto_generichash_bytes"]=asm["_crypto_generichash_bytes"];var _crypto_generichash_bytes_max=Module["_crypto_generichash_bytes_max"]=asm["_crypto_generichash_bytes_max"];var _crypto_secretbox_open_detached=Module["_crypto_secretbox_open_detached"]=asm["_crypto_secretbox_open_detached"];var _crypto_sign_verify_detached=Module["_crypto_sign_verify_detached"]=asm["_crypto_sign_verify_detached"];var _crypto_onetimeauth_verify=Module["_crypto_onetimeauth_verify"]=asm["_crypto_onetimeauth_verify"];var _crypto_box_open_easy=Module["_crypto_box_open_easy"]=asm["_crypto_box_open_easy"];var _crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive=Module["_crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive"]=asm["_crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive"];var _crypto_generichash_init=Module["_crypto_generichash_init"]=asm["_crypto_generichash_init"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _crypto_sign_bytes=Module["_crypto_sign_bytes"]=asm["_crypto_sign_bytes"];var _crypto_generichash_update=Module["_crypto_generichash_update"]=asm["_crypto_generichash_update"];var _crypto_scalarmult=Module["_crypto_scalarmult"]=asm["_crypto_scalarmult"];var _crypto_box_seal_open=Module["_crypto_box_seal_open"]=asm["_crypto_box_seal_open"];var _crypto_box_easy=Module["_crypto_box_easy"]=asm["_crypto_box_easy"];var ___errno_location=Module["___errno_location"]=asm["___errno_location"];var _crypto_onetimeauth_final=Module["_crypto_onetimeauth_final"]=asm["_crypto_onetimeauth_final"];var _memmove=Module["_memmove"]=asm["_memmove"];var _crypto_generichash_final=Module["_crypto_generichash_final"]=asm["_crypto_generichash_final"];var _randombytes_uniform=Module["_randombytes_uniform"]=asm["_randombytes_uniform"];var _crypto_sign_seed_keypair=Module["_crypto_sign_seed_keypair"]=asm["_crypto_sign_seed_keypair"];var _crypto_pwhash_scryptsalsa208sha256_opslimit_interactive=Module["_crypto_pwhash_scryptsalsa208sha256_opslimit_interactive"]=asm["_crypto_pwhash_scryptsalsa208sha256_opslimit_interactive"];var _crypto_onetimeauth_init=Module["_crypto_onetimeauth_init"]=asm["_crypto_onetimeauth_init"];var dynCall_i=Module["dynCall_i"]=asm["dynCall_i"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];Runtime.stackAlloc=asm["stackAlloc"];Runtime.stackSave=asm["stackSave"];Runtime.stackRestore=asm["stackRestore"];Runtime.establishStackSpace=asm["establishStackSpace"];Runtime.setTempRet0=asm["setTempRet0"];Runtime.getTempRet0=asm["getTempRet0"];function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};Module["callMain"]=Module.callMain=function callMain(args){assert(runDependencies==0,"cannot call main when async dependencies remain! (listen on __ATMAIN__)");assert(__ATPRERUN__.length==0,"cannot call main when preRun functions remain to be called");args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++){argv.push(0)}}var argv=[allocate(intArrayFromString(Module["thisProgram"]),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);try{var ret=Module["_main"](argc,argv,0);exit(ret,true)}catch(e){if(e instanceof ExitStatus){return}else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{if(e&&typeof e==="object"&&e.stack)Module.printErr("exception thrown: "+[e,e.stack]);throw e}}finally{calledMain=true}};function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(Module["_main"]&&shouldRunNow)Module["callMain"](args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=Module.run=run;function exit(status,implicit){if(implicit&&Module["noExitRuntime"]){return}if(Module["noExitRuntime"]){}else{ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();if(Module["onExit"])Module["onExit"](status)}if(ENVIRONMENT_IS_NODE){process["stdout"]["once"]("drain",(function(){process["exit"](status)}));console.log(" ");setTimeout((function(){process["exit"](status)}),500)}else if(ENVIRONMENT_IS_SHELL&&typeof quit==="function"){quit(status)}throw new ExitStatus(status)}Module["exit"]=Module.exit=exit;var abortDecorators=[];function abort(what){if(what!==undefined){Module.print(what);Module.printErr(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";var output="abort("+what+") at "+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach((function(decorator){output=decorator(output,what)}))}throw output}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"]){shouldRunNow=false}run()




    return Module;
});

},
"EDJAH/R7NidIhBhI+SqQVti/ffEubSpQD++eiim866s=":
function (require, module, exports, __dirname, __filename) {
var ltgt = require('ltgt')

//compare two array items
function isArrayLike (a) {
  return Array.isArray(a) || Buffer.isBuffer(a)
}

function isPrimitive (a) {
  return 'string' === typeof a || 'number' === typeof a
}

function has(o, k) {
  return Object.hasOwnProperty.call(o, k)
}

function compare (a, b) {

  if(isArrayLike(a) && isArrayLike(b)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var c = compare(a[i], b[i])
      if(c) return c
    }
    return a.length - b.length
  }
  if(isPrimitive(a) && isPrimitive(b))
    return a < b ? -1 : a > b ? 1 : 0

  throw new Error('items not comparable:'
    + JSON.stringify(a) + ' ' + JSON.stringify(b))
}

//this assumes that the prefix is of the form:
// [Array, string]

function prefix (a, b) {
  if(a.length > b.length) return false
  var l = a.length - 1
  var lastA = a[l]
  var lastB = b[l]

  if(typeof lastA !== typeof lastB)
    return false

  if('string' == typeof lastA
    && 0 != lastB.indexOf(lastA))
      return false
  
  //handle cas where there is no key prefix
  //(a hook on an entire sublevel)
  if(a.length == 1 && isArrayLike(lastA)) l ++
  
  while(l--) {
    if(compare(a[l], b[l])) return false
  }
  return true
}

exports = module.exports = function (range, key, _compare) {
  _compare = _compare || compare
  //handle prefix specially,
  //check that everything up to the last item is equal
  //then check the last item starts with
  if(isArrayLike(range)) return prefix(range, key)

//  return ltgt.contains(range, key, compare)

  if(range.lt  && _compare(key, range.lt) >= 0) return false
  if(range.lte && _compare(key, range.lte) > 0) return false
  if(range.gt  && _compare(key, range.gt) <= 0) return false
  if(range.gte && _compare(key, range.gte) < 0) return false

  return true
}

function addPrefix(prefix, range) {
  var r = {}
  if(has(range, 'lt')) r.lt = [prefix, range.lt]
  if(has(range, 'gt')) r.gt = [prefix, range.gt]
  if(has(range, 'lte')) r.lte = [prefix, range.lte]
  if(has(range, 'gte')) r.gte = [prefix, range.gte]
  if(has(range, 'start')) {
    if(range.reverse)  r.lte = [prefix, range.start]
    else               r.gte = [prefix, range.start]
  }
  if(has(range, 'end')) {
    if(range.reverse)  r.gte = [prefix, range.end]
    else               r.lte = [prefix, range.end]
  }
  if(has(range, 'min')) r.gte = [prefix, range.min]
  if(has(range, 'max')) r.lte = [prefix, range.max]
  r.reverse = !!range.reverse

  //if there where no ranges, then then just use a prefix.
  if(!r.gte &&!r.lte) return [prefix]

  return r
}

exports.compare = compare
exports.prefix = prefix
exports.addPrefix = addPrefix

},
"EHrxS/FWHzi1hI96G0cZaw3H1JjiFalRujwe4JtRmdk=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015-2016 Titus Wormer
 * @license MIT
 * @module remark:utilities
 * @version 3.2.2
 * @fileoverview Collection of tiny helpers useful for
 *   both parsing and compiling markdown.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var collapseWhiteSpace = require('collapse-white-space');

/*
 * Expressions.
 */

var EXPRESSION_LINE_BREAKS = /\r\n|\r/g;
var EXPRESSION_SYMBOL_FOR_NEW_LINE = /\u2424/g;
var EXPRESSION_BOM = /^\ufeff/;

/**
 * Throw an exception with in its `message` `value`
 * and `name`.
 *
 * @param {*} value - Invalid value.
 * @param {string} name - Setting name.
 */
function raise(value, name) {
    throw new Error(
        'Invalid value `' + value + '` ' +
        'for setting `' + name + '`'
    );
}

/**
 * Validate a value to be boolean. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * a boolean.
 *
 * @example
 *   validateBoolean({foo: null}, 'foo', true) // true
 *   validateBoolean({foo: false}, 'foo', true) // false
 *   validateBoolean({foo: 'bar'}, 'foo', true) // Throws
 *
 * @throws {Error} - When a setting is neither omitted nor
 *   a boolean.
 * @param {Object} context - Settings.
 * @param {string} name - Setting name.
 * @param {boolean} def - Default value.
 */
function validateBoolean(context, name, def) {
    var value = context[name];

    if (value === null || value === undefined) {
        value = def;
    }

    if (typeof value !== 'boolean') {
        raise(value, 'options.' + name);
    }

    context[name] = value;
}

/**
 * Validate a value to be boolean. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * a boolean.
 *
 * @example
 *   validateNumber({foo: null}, 'foo', 1) // 1
 *   validateNumber({foo: 2}, 'foo', 1) // 2
 *   validateNumber({foo: 'bar'}, 'foo', 1) // Throws
 *
 * @throws {Error} - When a setting is neither omitted nor
 *   a number.
 * @param {Object} context - Settings.
 * @param {string} name - Setting name.
 * @param {number} def - Default value.
 */
function validateNumber(context, name, def) {
    var value = context[name];

    if (value === null || value === undefined) {
        value = def;
    }

    if (typeof value !== 'number' || value !== value) {
        raise(value, 'options.' + name);
    }

    context[name] = value;
}

/**
 * Validate a value to be in `map`. Defaults to `def`.
 * Raises an exception with `context[name]` when not
 * not in `map`.
 *
 * @example
 *   var map = {bar: true, baz: true};
 *   validateString({foo: null}, 'foo', 'bar', map) // 'bar'
 *   validateString({foo: 'baz'}, 'foo', 'bar', map) // 'baz'
 *   validateString({foo: true}, 'foo', 'bar', map) // Throws
 *
 * @throws {Error} - When a setting is neither omitted nor
 *   in `map`.
 * @param {Object} context - Settings.
 * @param {string} name - Setting name.
 * @param {string} def - Default value.
 * @param {Object} map - Enum.
 */
function validateString(context, name, def, map) {
    var value = context[name];

    if (value === null || value === undefined) {
        value = def;
    }

    if (!(value in map)) {
        raise(value, 'options.' + name);
    }

    context[name] = value;
}

/**
 * Clean a string in preperation of parsing.
 *
 * @example
 *   clean('\ufefffoo'); // 'foo'
 *   clean('foo\r\nbar'); // 'foo\nbar'
 *   clean('foo\u2424bar'); // 'foo\nbar'
 *
 * @param {string} value - Content to clean.
 * @return {string} - Cleaned content.
 */
function clean(value) {
    return String(value)
        .replace(EXPRESSION_BOM, '')
        .replace(EXPRESSION_LINE_BREAKS, '\n')
        .replace(EXPRESSION_SYMBOL_FOR_NEW_LINE, '\n');
}

/**
 * Normalize an identifier.  Collapses multiple white space
 * characters into a single space, and removes casing.
 *
 * @example
 *   normalizeIdentifier('FOO\t bar'); // 'foo bar'
 *
 * @param {string} value - Content to normalize.
 * @return {string} - Normalized content.
 */
function normalizeIdentifier(value) {
    return collapseWhiteSpace(value).toLowerCase();
}

/**
 * Construct a state `toggler`: a function which inverses
 * `property` in context based on its current value.
 * The by `toggler` returned function restores that value.
 *
 * @example
 *   var context = {};
 *   var key = 'foo';
 *   var val = true;
 *   context[key] = val;
 *   context.enter = stateToggler(key, val);
 *   context[key]; // true
 *   var exit = context.enter();
 *   context[key]; // false
 *   var nested = context.enter();
 *   context[key]; // false
 *   nested();
 *   context[key]; // false
 *   exit();
 *   context[key]; // true
 *
 * @param {string} key - Property to toggle.
 * @param {boolean} state - It's default state.
 * @return {function(): function()} - Enter.
 */
function stateToggler(key, state) {
    /**
     * Construct a toggler for the bound `key`.
     *
     * @return {Function} - Exit state.
     */
    function enter() {
        var self = this;
        var current = self[key];

        self[key] = !state;

        /**
         * State canceler, cancels the state, if allowed.
         */
        function exit() {
            self[key] = current;
        }

        return exit;
    }

    return enter;
}

/*
 * Define nodes of a type which can be merged.
 */

var MERGEABLE_NODES = {};

/**
 * Check whether a node is mergeable with adjacent nodes.
 *
 * @param {Object} node - Node to check.
 * @return {boolean} - Whether `node` is mergable.
 */
function mergeable(node) {
    var start;
    var end;

    if (node.type !== 'text' || !node.position) {
        return true;
    }

    start = node.position.start;
    end = node.position.end;

    /*
     * Only merge nodes which occupy the same size as their
     * `value`.
     */

    return start.line !== end.line ||
        end.column - start.column === node.value.length;
}

/**
 * Merge two text nodes: `node` into `prev`.
 *
 * @param {Object} prev - Preceding sibling.
 * @param {Object} node - Following sibling.
 * @return {Object} - `prev`.
 */
MERGEABLE_NODES.text = function (prev, node) {
    prev.value += node.value;

    return prev;
};

/**
 * Merge two blockquotes: `node` into `prev`, unless in
 * CommonMark mode.
 *
 * @param {Object} prev - Preceding sibling.
 * @param {Object} node - Following sibling.
 * @return {Object} - `prev`, or `node` in CommonMark mode.
 */
MERGEABLE_NODES.blockquote = function (prev, node) {
    if (this.options.commonmark) {
        return node;
    }

    prev.children = prev.children.concat(node.children);

    return prev;
};

/*
 * Expose `validate`.
 */

exports.validate = {
    'boolean': validateBoolean,
    'string': validateString,
    'number': validateNumber
};

/*
 * Expose.
 */

exports.normalizeIdentifier = normalizeIdentifier;
exports.clean = clean;
exports.raise = raise;
exports.stateToggler = stateToggler;
exports.mergeable = mergeable;
exports.MERGEABLE_NODES = MERGEABLE_NODES;

},
"EQUOWX7Pu1S73njemTStK3KnASkdpJLaqk1t4SZNbwk=":
function (require, module, exports, __dirname, __filename) {
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},
"EY8v1o/+TvrcfwIMsMmLnhgGYs06G+gtDTeCSTgybV8=":
function (require, module, exports, __dirname, __filename) {
var isArray = Array.isArray
var merge   = require('map-merge')

function isObject (o) {
  return o && 'object' === typeof o
}

function isString (s) {
  return 'string' === typeof s
}

var clone = exports.clone = function clone (obj, mapper) {
  function map(v, k) {
    return isObject(v) ? clone(v, mapper) : mapper(v, k)
  }
  if(isArray(obj))
    return obj.map(map)
  else if(isObject(obj)) {
    var o = {}
    for(var k in obj)
      o[k] = map(obj[k], k)
    return o
  }
  else
    return map(obj)
}

exports.parseAddress = function (e) {
  if(isString(e)) {
    var parts = e.split(':')
    var e = {
      host: parts[0],
      port: +parts[1],
      key: fromId(parts[2])
    }
    return e
  }
  return e
}

var fromId = exports.fromId = function (id) {
  return new Buffer(id.substring(0, id.indexOf('.')), 'base64')
}

exports.toId = function (pub) {
  return Buffer.isBuffer(pub) ? pub.toString('base64')+'.ed25519' : pub
}

exports.merge = {
  permissions: function (perms, _perms, name) {
    return merge(perms,
      clone(_perms, function (v) {
        return name ? name + '.' + v : v
      })
    )

  },
  manifest: function (manf, _manf, name) {
    if(name) {
      var o = {}; o[name] = _manf; _manf = o
    }
    return merge(manf, _manf)
  }
}

exports.hookOptionalCB = function (syncFn) {
  // syncFn is a function that's expected to return its result or throw an error
  // we're going to hook it so you can optionally pass a callback
  syncFn.hook(function(fn, args) {
    // if a function is given as the last argument, treat it as a callback
    var cb = args[args.length - 1]
    if (typeof cb == 'function') {
      var res
      args.pop() // remove cb from the arguments
      try { res = fn.apply(this, args) }
      catch (e) { return cb(e) }
      cb(null, res)
    } else {
      // no cb provided, regular usage
      return fn.apply(this, args)
    }
  })
}

},
"Ec94syWZ8ZehXUFpWXfxPzgEuSAFW53cQ5rrsxA9vDg=":
function (require, module, exports, __dirname, __filename) {

exports.source = require('./source')
exports.through = require('./through')
exports.sink = require('./sink')
exports.duplex = require('./duplex')

},
"Ed2Ny21B1gRjdGc84PA+uArK4XS0W3BuIKN0puLCqUI=":
function (require, module, exports, __dirname, __filename) {
var _require = require //fool browserify
module.exports = _require('chloridedown/build/Release/sodium')

},
"F0Hy3421FqiV544O5jyAgknHiyPqSjrY/NNPV6lKdfA=":
function (require, module, exports, __dirname, __filename) {
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},
"FKVMw71gi1LIQLOsVV1rBVCqZv6A5NcsfiKOZf4E0MA=":
function (require, module, exports, __dirname, __filename) {
var noop = function () {}

function abortAll(ary, abort, cb) {
  var n = ary.length
  if(!n) return cb(abort)
  ary.forEach(function (f) {
    if(f) f(abort, next)
    else next()
  })

  function next() {
    if(--n) return
    cb(abort)
  }
  if(!n) next()
}

module.exports = function (streams) {
  return function (abort, cb) {
    ;(function next () {
      if(abort)
        abortAll(streams, abort, cb)
      else if(!streams.length)
        cb(true)
      else if(!streams[0])
        streams.shift(), next()
      else
        streams[0](null, function (err, data) {
          if(err) {
            streams.shift() //drop the first, has already ended.
            if(err === true) next()
            else             abortAll(streams, err, cb)
          }
          else
            cb(null, data)
        })
    })()
  }
}





},
"FTRTxNhKPC8TWJw3BVp9r/YdSEddzOVU9+7a0V/Hs+U=":
function (require, module, exports, __dirname, __filename) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},
"Fju9JulzJl7g9KUH8Ulfa7fcoCCWfPTWbDwcISRFMGE=":
function (require, module, exports, __dirname, __filename) {
var pfs  = require('pull-fs')
var pull = require('pull-stream')
var path = require('path')
var glob =

module.exports = function (x) {

  var rest = path.normalize(x).split('/')
  var stream

  var pipe = []

  if(rest[0] == '...') {
    pipe.push(pfs.ancestors())
    rest.shift()
  } else if(rest[0] === '~' || rest[0] === '') {
    pipe.push(pull.values([rest.shift() ? process.env.HOME : '/']))
  } else {
    pipe.push(pull.values(['.']))
  }

  //this should be tidied up.
  //need a more betterer glob parser
  //that handles escapes...
  rest.forEach(function (e) {
    if('**' === e) {
      pipe.push(pfs.starStar())
    } else if(/[*?{}]/.test(e)) {
      //literal
      e = e
        .split('.').join('\\.')
        .split('?').join('.')
        .split(/({.*?})/).map(function (e, i) {
        if(i % 2)
          return e.replace('{', '(?:')
                  .replace('}', ')')
                  .split(',').join('|')
        return e
      }).join('')

      var x = new RegExp('^'+e.split('*').join('.*')+'$')
      pipe.push(pfs.star(x))
    } else if(e === '')
      //will only happen in the last position
      //if you do */
      pipe.push(pfs.isDirectory())
    else
      pipe.push(pull(pfs.resolve(e), pfs.exists()))
  })

  return pull.apply(null, pipe)
}

if(!module.parent) {
  if(!process.argv[2])
    throw new Error("expect glob: '**/*.js'")
  s = module.exports(process.argv[2])

  if(/-f|--first/.test(process.argv[3]))
    s = pull(s, pull.take(1))

  pull(s, pull.drain(console.log))
}


},
"GcTFTVnj+D5rDts8W8YkGHe4g560hWY5VxEZRbgK/Zw=":
function (require, module, exports, __dirname, __filename) {

function getStack(err) {
  return err.stack.substring(err.name.length + 3 + err.message.length)
    .split('\n')
}

function removePrefix (a, b) {
  return a.filter(function (e) {
    return !~b.indexOf(e)
  })
}

var explain = module.exports = function (err, message) {
  var _err = new Error(message)
  var stack = removePrefix(getStack(_err).slice(1), getStack(err)).join('\n')

  _err.stack =
    _err.name + ': ' + _err.message + '\n' +
    stack + '\n  ' + err.stack

  return _err
}


},
"H6y6JY7lDTTrkj/x3BGLUvRIaMNKZCwbHk04Z/3ebtY=":
function (require, module, exports, __dirname, __filename) {

exports.parse = exports.decode = decode
exports.stringify = exports.encode = encode

exports.safe = safe
exports.unsafe = unsafe

var eol = process.platform === "win32" ? "\r\n" : "\n"

function encode (obj, opt) {
  var children = []
    , out = ""

  if (typeof opt === "string") {
    opt = {
      section: opt,
      whitespace: false
    }
  } else {
    opt = opt || {}
    opt.whitespace = opt.whitespace === true
  }

  var separator = opt.whitespace ? " = " : "="

  Object.keys(obj).forEach(function (k, _, __) {
    var val = obj[k]
    if (val && Array.isArray(val)) {
        val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n"
        })
    }
    else if (val && typeof val === "object") {
      children.push(k)
    } else {
      out += safe(k) + separator + safe(val) + eol
    }
  })

  if (opt.section && out.length) {
    out = "[" + safe(opt.section) + "]" + eol + out
  }

  children.forEach(function (k, _, __) {
    var nk = dotSplit(k).join('\\.')
    var section = (opt.section ? opt.section + "." : "") + nk
    var child = encode(obj[k], {
      section: section,
      whitespace: opt.whitespace
    })
    if (out.length && child.length) {
      out += eol
    }
    out += child
  })

  return out
}

function dotSplit (str) {
  return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
         .replace(/\\\./g, '\u0001')
         .split(/\./).map(function (part) {
           return part.replace(/\1/g, '\\.')
                  .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
        })
}

function decode (str) {
  var out = {}
    , p = out
    , section = null
    , state = "START"
           // section     |key = value
    , re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
    , lines = str.split(/[\r\n]+/g)
    , section = null

  lines.forEach(function (line, _, __) {
    if (!line || line.match(/^\s*[;#]/)) return
    var match = line.match(re)
    if (!match) return
    if (match[1] !== undefined) {
      section = unsafe(match[1])
      p = out[section] = out[section] || {}
      return
    }
    var key = unsafe(match[2])
      , value = match[3] ? unsafe((match[4] || "")) : true
    switch (value) {
      case 'true':
      case 'false':
      case 'null': value = JSON.parse(value)
    }

    // Convert keys with '[]' suffix to an array
    if (key.length > 2 && key.slice(-2) === "[]") {
        key = key.substring(0, key.length - 2)
        if (!p[key]) {
          p[key] = []
        }
        else if (!Array.isArray(p[key])) {
          p[key] = [p[key]]
        }
    }

    // safeguard against resetting a previously defined
    // array by accidentally forgetting the brackets
    if (Array.isArray(p[key])) {
      p[key].push(value)
    }
    else {
      p[key] = value
    }
  })

  // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
  // use a filter to return the keys that have to be deleted.
  Object.keys(out).filter(function (k, _, __) {
    if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) return false
    // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion
    var parts = dotSplit(k)
      , p = out
      , l = parts.pop()
      , nl = l.replace(/\\\./g, '.')
    parts.forEach(function (part, _, __) {
      if (!p[part] || typeof p[part] !== "object") p[part] = {}
      p = p[part]
    })
    if (p === out && nl === l) return false
    p[nl] = out[k]
    return true
  }).forEach(function (del, _, __) {
    delete out[del]
  })

  return out
}

function isQuoted (val) {
  return (val.charAt(0) === "\"" && val.slice(-1) === "\"")
         || (val.charAt(0) === "'" && val.slice(-1) === "'")
}

function safe (val) {
  return ( typeof val !== "string"
         || val.match(/[=\r\n]/)
         || val.match(/^\[/)
         || (val.length > 1
             && isQuoted(val))
         || val !== val.trim() )
         ? JSON.stringify(val)
         : val.replace(/;/g, '\\;').replace(/#/g, "\\#")
}

function unsafe (val, doUnesc) {
  val = (val || "").trim()
  if (isQuoted(val)) {
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'") {
      val = val.substr(1, val.length - 2);
    }
    try { val = JSON.parse(val) } catch (_) {}
  } else {
    // walk the val to find the first not-escaped ; character
    var esc = false
    var unesc = "";
    for (var i = 0, l = val.length; i < l; i++) {
      var c = val.charAt(i)
      if (esc) {
        if ("\\;#".indexOf(c) !== -1)
          unesc += c
        else
          unesc += "\\" + c
        esc = false
      } else if (";#".indexOf(c) !== -1) {
        break
      } else if (c === "\\") {
        esc = true
      } else {
        unesc += c
      }
    }
    if (esc)
      unesc += "\\"
    return unesc
  }
  return val
}

},
"HfzSWv797N1jtOQ2zUPDxBqxGbPp2ud3U4nN1sk8o2o=":
function (require, module, exports, __dirname, __filename) {
var u      = require('pull-core')
var sources = require('./sources')
var sinks = require('./sinks')

var prop   = u.prop
var id     = u.id
var tester = u.tester

var map = exports.map =
function (read, map) {
  map = prop(map) || id
  return function (abort, cb) {
    read(abort, function (end, data) {
      try {
      data = !end ? map(data) : null
      } catch (err) {
        return read(err, function () {
          return cb(err)
        })
      }
      cb(end, data)
    })
  }
}

var asyncMap = exports.asyncMap =
function (read, map) {
  if(!map) return read
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    read(null, function (end, data) {
      if(end) return cb(end, data)
      map(data, cb)
    })
  }
}

var paraMap = exports.paraMap =
function (read, map, width) {
  if(!map) return read
  var ended = false, queue = [], _cb

  function drain () {
    if(!_cb) return
    var cb = _cb
    _cb = null
    if(queue.length)
      return cb(null, queue.shift())
    else if(ended && !n)
      return cb(ended)
    _cb = cb
  }

  function pull () {
    read(null, function (end, data) {
      if(end) {
        ended = end
        return drain()
      }
      n++
      map(data, function (err, data) {
        n--

        queue.push(data)
        drain()
      })

      if(n < width && !ended)
        pull()
    })
  }

  var n = 0
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    //continue to read while there are less than 3 maps in flight
    _cb = cb
    if(queue.length || ended)
      pull(), drain()
    else pull()
  }
  return highWaterMark(asyncMap(read, map), width)
}

var filter = exports.filter =
function (read, test) {
  //regexp
  test = tester(test)
  return function next (end, cb) {
    var sync, loop = true
    while(loop) {
      loop = false
      sync = true
      read(end, function (end, data) {
        if(!end && !test(data))
          return sync ? loop = true : next(end, cb)
        cb(end, data)
      })
      sync = false
    }
  }
}

var filterNot = exports.filterNot =
function (read, test) {
  test = tester(test)
  return filter(read, function (e) {
    return !test(e)
  })
}

var through = exports.through =
function (read, op, onEnd) {
  var a = false
  function once (abort) {
    if(a || !onEnd) return
    a = true
    onEnd(abort === true ? null : abort)
  }

  return function (end, cb) {
    if(end) once(end)
    return read(end, function (end, data) {
      if(!end) op && op(data)
      else once(end)
      cb(end, data)
    })
  }
}

var take = exports.take =
function (read, test, opts) {
  opts = opts || {}
  var last = opts.last || false // whether the first item for which !test(item) should still pass
  var ended = false
  if('number' === typeof test) {
    last = true
    var n = test; test = function () {
      return --n
    }
  }

  function terminate (cb) {
    read(true, function (err) {
      last = false; cb(err || true)
    })
  }

  return function (end, cb) {
    if(ended)            last ? terminate(cb) : cb(ended)
    else if(ended = end) read(ended, cb)
    else
      read(null, function (end, data) {
        if(ended = ended || end) {
          //last ? terminate(cb) :
          cb(ended)
        }
        else if(!test(data)) {
          ended = true
          last ? cb(null, data) : terminate(cb)
        }
        else
          cb(null, data)
      })
  }
}

var unique = exports.unique = function (read, field, invert) {
  field = prop(field) || id
  var seen = {}
  return filter(read, function (data) {
    var key = field(data)
    if(seen[key]) return !!invert //false, by default
    else seen[key] = true
    return !invert //true by default
  })
}

var nonUnique = exports.nonUnique = function (read, field) {
  return unique(read, field, true)
}

var group = exports.group =
function (read, size) {
  var ended; size = size || 5
  var queue = []

  return function (end, cb) {
    //this means that the upstream is sending an error.
    if(end) return read(ended = end, cb)
    //this means that we read an end before.
    if(ended) return cb(ended)

    read(null, function next(end, data) {
      if(ended = ended || end) {
        if(!queue.length)
          return cb(ended)

        var _queue = queue; queue = []
        return cb(null, _queue)
      }
      queue.push(data)
      if(queue.length < size)
        return read(null, next)

      var _queue = queue; queue = []
      cb(null, _queue)
    })
  }
}

var flatten = exports.flatten = function (read) {
  var _read
  return function (abort, cb) {
    if (abort) {
      _read ? _read(abort, function(err) {
        read(err || abort, cb)
      }) : read(abort, cb)
    }
    else if(_read) nextChunk()
    else nextStream()

    function nextChunk () {
      _read(null, function (err, data) {
        if (err === true) nextStream()
        else if (err) {
          read(true, function(abortErr) {
            // TODO: what do we do with the abortErr?
            cb(err)
          })
        }
        else cb(null, data)
      })
    }
    function nextStream () {
      read(null, function (end, stream) {
        if(end)
          return cb(end)
        if(Array.isArray(stream) || stream && 'object' === typeof stream)
          stream = sources.values(stream)
        else if('function' != typeof stream)
          throw new Error('expected stream of streams')
        _read = stream
        nextChunk()
      })
    }
  }
}

var prepend =
exports.prepend =
function (read, head) {

  return function (abort, cb) {
    if(head !== null) {
      if(abort)
        return read(abort, cb)
      var _head = head
      head = null
      cb(null, _head)
    } else {
      read(abort, cb)
    }
  }

}

//var drainIf = exports.drainIf = function (op, done) {
//  sinks.drain(
//}

var _reduce = exports._reduce = function (read, reduce, initial) {
  return function (close, cb) {
    if(close) return read(close, cb)
    if(ended) return cb(ended)

    sinks.drain(function (item) {
      initial = reduce(initial, item)
    }, function (err, data) {
      ended = err || true
      if(!err) cb(null, initial)
      else     cb(ended)
    })
    (read)
  }
}

var nextTick = process.nextTick

var highWaterMark = exports.highWaterMark =
function (read, highWaterMark) {
  var buffer = [], waiting = [], ended, ending, reading = false
  highWaterMark = highWaterMark || 10

  function readAhead () {
    while(waiting.length && (buffer.length || ended))
      waiting.shift()(ended, ended ? null : buffer.shift())

    if (!buffer.length && ending) ended = ending;
  }

  function next () {
    if(ended || ending || reading || buffer.length >= highWaterMark)
      return
    reading = true
    return read(ended || ending, function (end, data) {
      reading = false
      ending = ending || end
      if(data != null) buffer.push(data)

      next(); readAhead()
    })
  }

  process.nextTick(next)

  return function (end, cb) {
    ended = ended || end
    waiting.push(cb)

    next(); readAhead()
  }
}

var flatMap = exports.flatMap =
function (read, mapper) {
  mapper = mapper || id
  var queue = [], ended

  return function (abort, cb) {
    if(queue.length) return cb(null, queue.shift())
    else if(ended)   return cb(ended)

    read(abort, function next (end, data) {
      if(end) ended = end
      else {
        var add = mapper(data)
        while(add && add.length)
          queue.push(add.shift())
      }

      if(queue.length) cb(null, queue.shift())
      else if(ended)   cb(ended)
      else             read(null, next)
    })
  }
}


},
"Hk6T3FVpUObSr+tQzzuU3LOQ2HC4cqsuS+qI19rk5aI=":
function (require, module, exports, __dirname, __filename) {
var all = module.exports.all = [
  {
    errno: -2,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: -1,
    code: 'UNKNOWN',
    description: 'unknown error'
  },
  {
    errno: 0,
    code: 'OK',
    description: 'success'
  },
  {
    errno: 1,
    code: 'EOF',
    description: 'end of file'
  },
  {
    errno: 2,
    code: 'EADDRINFO',
    description: 'getaddrinfo error'
  },
  {
    errno: 3,
    code: 'EACCES',
    description: 'permission denied'
  },
  {
    errno: 4,
    code: 'EAGAIN',
    description: 'resource temporarily unavailable'
  },
  {
    errno: 5,
    code: 'EADDRINUSE',
    description: 'address already in use'
  },
  {
    errno: 6,
    code: 'EADDRNOTAVAIL',
    description: 'address not available'
  },
  {
    errno: 7,
    code: 'EAFNOSUPPORT',
    description: 'address family not supported'
  },
  {
    errno: 8,
    code: 'EALREADY',
    description: 'connection already in progress'
  },
  {
    errno: 9,
    code: 'EBADF',
    description: 'bad file descriptor'
  },
  {
    errno: 10,
    code: 'EBUSY',
    description: 'resource busy or locked'
  },
  {
    errno: 11,
    code: 'ECONNABORTED',
    description: 'software caused connection abort'
  },
  {
    errno: 12,
    code: 'ECONNREFUSED',
    description: 'connection refused'
  },
  {
    errno: 13,
    code: 'ECONNRESET',
    description: 'connection reset by peer'
  },
  {
    errno: 14,
    code: 'EDESTADDRREQ',
    description: 'destination address required'
  },
  {
    errno: 15,
    code: 'EFAULT',
    description: 'bad address in system call argument'
  },
  {
    errno: 16,
    code: 'EHOSTUNREACH',
    description: 'host is unreachable'
  },
  {
    errno: 17,
    code: 'EINTR',
    description: 'interrupted system call'
  },
  {
    errno: 18,
    code: 'EINVAL',
    description: 'invalid argument'
  },
  {
    errno: 19,
    code: 'EISCONN',
    description: 'socket is already connected'
  },
  {
    errno: 20,
    code: 'EMFILE',
    description: 'too many open files'
  },
  {
    errno: 21,
    code: 'EMSGSIZE',
    description: 'message too long'
  },
  {
    errno: 22,
    code: 'ENETDOWN',
    description: 'network is down'
  },
  {
    errno: 23,
    code: 'ENETUNREACH',
    description: 'network is unreachable'
  },
  {
    errno: 24,
    code: 'ENFILE',
    description: 'file table overflow'
  },
  {
    errno: 25,
    code: 'ENOBUFS',
    description: 'no buffer space available'
  },
  {
    errno: 26,
    code: 'ENOMEM',
    description: 'not enough memory'
  },
  {
    errno: 27,
    code: 'ENOTDIR',
    description: 'not a directory'
  },
  {
    errno: 28,
    code: 'EISDIR',
    description: 'illegal operation on a directory'
  },
  {
    errno: 29,
    code: 'ENONET',
    description: 'machine is not on the network'
  },
  {
    errno: 31,
    code: 'ENOTCONN',
    description: 'socket is not connected'
  },
  {
    errno: 32,
    code: 'ENOTSOCK',
    description: 'socket operation on non-socket'
  },
  {
    errno: 33,
    code: 'ENOTSUP',
    description: 'operation not supported on socket'
  },
  {
    errno: 34,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: 35,
    code: 'ENOSYS',
    description: 'function not implemented'
  },
  {
    errno: 36,
    code: 'EPIPE',
    description: 'broken pipe'
  },
  {
    errno: 37,
    code: 'EPROTO',
    description: 'protocol error'
  },
  {
    errno: 38,
    code: 'EPROTONOSUPPORT',
    description: 'protocol not supported'
  },
  {
    errno: 39,
    code: 'EPROTOTYPE',
    description: 'protocol wrong type for socket'
  },
  {
    errno: 40,
    code: 'ETIMEDOUT',
    description: 'connection timed out'
  },
  {
    errno: 41,
    code: 'ECHARSET',
    description: 'invalid Unicode character'
  },
  {
    errno: 42,
    code: 'EAIFAMNOSUPPORT',
    description: 'address family for hostname not supported'
  },
  {
    errno: 44,
    code: 'EAISERVICE',
    description: 'servname not supported for ai_socktype'
  },
  {
    errno: 45,
    code: 'EAISOCKTYPE',
    description: 'ai_socktype not supported'
  },
  {
    errno: 46,
    code: 'ESHUTDOWN',
    description: 'cannot send after transport endpoint shutdown'
  },
  {
    errno: 47,
    code: 'EEXIST',
    description: 'file already exists'
  },
  {
    errno: 48,
    code: 'ESRCH',
    description: 'no such process'
  },
  {
    errno: 49,
    code: 'ENAMETOOLONG',
    description: 'name too long'
  },
  {
    errno: 50,
    code: 'EPERM',
    description: 'operation not permitted'
  },
  {
    errno: 51,
    code: 'ELOOP',
    description: 'too many symbolic links encountered'
  },
  {
    errno: 52,
    code: 'EXDEV',
    description: 'cross-device link not permitted'
  },
  {
    errno: 53,
    code: 'ENOTEMPTY',
    description: 'directory not empty'
  },
  {
    errno: 54,
    code: 'ENOSPC',
    description: 'no space left on device'
  },
  {
    errno: 55,
    code: 'EIO',
    description: 'i/o error'
  },
  {
    errno: 56,
    code: 'EROFS',
    description: 'read-only file system'
  },
  {
    errno: 57,
    code: 'ENODEV',
    description: 'no such device'
  },
  {
    errno: 58,
    code: 'ESPIPE',
    description: 'invalid seek'
  },
  {
    errno: 59,
    code: 'ECANCELED',
    description: 'operation canceled'
  }
]

module.exports.errno = {}
module.exports.code = {}

all.forEach(function (error) {
  module.exports.errno[error.errno] = error
  module.exports.code[error.code] = error
})

module.exports.custom = require('./custom')(module.exports)
module.exports.create = module.exports.custom.createError

},
"HloXk/tRBEo+dy1TA9XKdvW6VuulkPBrdTlMnOCRxaw=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var pull      = require('pull-stream')
var pl        = require('pull-level')
var paramap   = require('pull-paramap')
var timestamp = require('monotonic-timestamp')
var defer     = require('pull-defer')
var ltgt      = require('ltgt')
var deepEqual = require('deep-equal')
var cat       = require('pull-cat')
var cont      = require('cont')

var util = require('./util')
var createDiskIndex = require('./indexes/disk')

var LO = null
var HI = undefined

function addTo(aryTo, aryFrom) {
  aryFrom.forEach(function (e) { aryTo.push(e) })
}

var isArray = Array.isArray

function find (ary, test) {
  for(var i = 0; i < ary.length; i++)
    if(test(ary[i], i, ary)) return ary[i]
}

module.exports = function (_db) {

  var db = _db.sublevel ? _db : require('level-sublevel/bytewise')(_db)
  var logDb = db.sublevel('log')

  // ************************************
  // Log / Scan
  //
  //index everything into logDb.

  db.pre(function (op, add) {
    add({
      prefix: logDb, type: 'put',
      key: timestamp(), value: op.key,
    })
  })

  //output EVERYTHING currently in the database.
  //in the same order as it was added.
  db.scan = function (opts) {
    return pull(
      pl.read(logDb),
      //filter by unique is a hack. would rather make sure
      //that things where not added twice...
      //TODO: enable/disable? this with an option if records
      //can never be updated.
      pull.unique('value'),
      paramap(function (data, cb) {
        db.get(data.value, function (err, value) {
          cb(null, {key: data.value, value: value, ts: data.key})
        })
      })
    )
  }

  // ************************************
  // Drain / Pause

  db.inflight = 0
  db.landed = 0

  var waiting = []
  db.pre(function () {
    db.inflight ++
  })

  db.post(function (op) {
    db.landed ++
    if(waiting.length && db.landed === db.landed)
      while(waiting.length) waiting.shift()()
  })

  db.drain = cont(function (cb) {
    if(landed === inflight) cb()
    else waiting.shift(cb)
  })

  // ************************************
  // Index Creation
  //
  // for a set of paths into the database,
  // create indexes for those values.

  db.indexes = []

  db.getIndex = function (path) {
    util.assertDepth(path, 'getIndex')
    return util.find(db.indexes, function (index) {
      return deepEqual(index.path, path)
    })
  }

  db.createIndex = cont(function (path, cb) {

    //TODO: persist memory indexes
    if(db.getIndex(path)) return cb()

    return db.createIndexes([path], cb)
  })

  db.createIndexes = cont(function (paths, cb) {
    if(!cb) throw new Error('mynosql.createIndexes: must provide callback')

    var batch = [], maxTs = 0

    var indexes = paths.map(function (path) {
      return createDiskIndex(db, path)
    })

    pull(
      db.scan(),
      pull.drain(function (data) {
        maxTs = Math.max(data.ts, maxTs)

        indexes.forEach(function (index) {
          index.pre(data).forEach(function (op) { batch.push(op) })
        })
      },
      function (err) {
        paths.forEach(function (index) {
          batch.push({
            key: index, value: maxTs,
            prefix: db.sublevel('meta'), type: 'put'
          })
        })
        db.sublevel('idx').batch(batch, function (err) {
          if(err) return cb(err)
          indexes.forEach(function (index) {
            if(!db.getIndex(index.path))
              db.indexes.push(index)
          })
          cb()
        })
      })
    )
  })

  // ************************************
  // Querying!
  //

  //preinsert, add to persitent indexes

  db.pre(function (data, add) {
    db.indexes.forEach(function (index) {
      if(index.pre) index.pre(data).forEach(add)
    })
  })

  //postinsert, add to memory indexes

  db.post(function (data) {
    db.indexes.forEach(function (index) {
      if(index.post) index.post(data)
    })
  })



  var init = util.createInit(function (cb) {
    pull(
      pl.read(db.sublevel('meta')),
      pull.drain(function (op) {
        db.indexes.push(createDiskIndex(db, op.key))
      }, cb)
    )
  })

  var strategies = [
    require('./query/compound-index'),
    require('./query/intersection'),
    require('./query/filtered-index'),
    require('./query/scan')
  ]

  //read out of the index and lookup original,
  //with optional filtering...

  db.readIndex = function (opts, filter) {
    var index = db.getIndex(opts.path || opts.index)

    if(!index) throw new Error('no index for:' + JSON.stringify(opts.path || opts.index))

    return pull(
      index.read(opts),
      paramap(function (key, cb) {
        db.get(key, function (err, value) {
          cb(null, {key: key, value: value})
        })
      }),
      filter ? pull.filter(function (data) {
        return filter(data.value)
      }) : null
    )
  }

  db.plan = cont(function (query, opts, cb) {
    if(!isArray(query)) query = [query]
    init(function () {
      cb(null, strategies.map(function (strategy) {
        return strategy(db, query, opts)
      }).filter(Boolean))
    })
  })

  db.query = function (query, opts) {
    if(!isArray(query)) {
      opts = query
      query = opts.query
    }
    var stream = defer.source()
    db.plan(query, opts, function (err, plans) {
      stream.resolve(plans.filter(Boolean).shift().exec())
    })

    if(!opts || !opts.live) return stream

    var filter = util.createFilter(query)

    return cat([
      stream,
      opts.sync ? pull.values([{sync: true}]) : null,
      pull(pl.live(db), pull.filter(function (data) {
        return filter(data.value)
      }))
    ])
  }

  db.wipeIndexes = cont(function (cb) {
    var batch = db.indexes.map(function (index) {
      if(index.pre) //a persisted index
        return {key: index.path, type: 'del'}
    }).filter(Boolean)

    db.sublevel('meta').batch(batch, function (err) {
      db.indexes = [] //todo, delete indexes from disk!
      cb()
    })
  })

  return db
}


},
"I2taVnO+Xnbts77NgNtcH7gMPIYTPZPQVatsmTMyoV4=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module remark:html:compilers
 * @fileoverview AST transformer for HTML.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var visit = require('unist-util-visit');

/*
 * Constants.
 */

var FIRST_WORD = /^[^\ \t]+(?=[\ \t]|$)/;

/**
 * Helper to get/set `htmlAttributes`.
 *
 * @param {Node} node - Node to get data from.
 * @return {Object} - Attributes.
 */
function getAttributes(node) {
    var data = node.data || (node.data = {});
    return data.htmlAttributes || (data.htmlAttributes = {});
}

/**
 * Augment a code node.
 *
 * @param {Node} node - Code node.
 */
function code(node) {
    var lang = node.lang && node.lang.match(FIRST_WORD);
    var attrs;

    if (!lang) {
        return;
    }

    attrs = getAttributes(node);
    attrs.class = (attrs.class ? attrs.class + ' ' : '') + 'language-' + lang;
}

/*
 * Map of node-type handlers.
 */

var handlers = {};

handlers.code = code;

/**
 * Transform `ast`.
 *
 * @param {Node} ast - Tree.
 */
function transformer(ast) {
    visit(ast, function (node) {
        if (node.type in handlers) {
            handlers[node.type](node);
        }
    });
}

/*
 * Expose.
 */

module.exports = transformer;

},
"Ivy4eD14ohiB5WII4inwQwBjGoTms6fLdvA0Zm53s78=":
function (require, module, exports, __dirname, __filename) {
module.exports = function (stream) {
  var read, started = false, id = Math.random()

  function consume (_read) {
    if(!_read) throw new Error('must be passed a readable')
    read = _read
    if(started) stream(read)
  }

  consume.resolve =
  consume.ready =
  consume.start = function (_stream) {
    started = true; stream = _stream || stream
    if(read) stream(read)
    return consume
  }

  return consume
}

},
"JNYvwEQ/ohHKdqRUNcAb7KGtW5zqZ1RgE83gvseqnbs=":
function (require, module, exports, __dirname, __filename) {
var minimist = require('minimist')
var toPull   = require('stream-to-pull-stream')
var pull     = require('pull-stream')
var wrap     = require('word-wrap')

var usageErrors = [
  'UsageError',
  'BadParamError',
  'BadArgError',
  'TypeError'
]

var isBuffer = Buffer.isBuffer
function isObject (o) {
  return o && 'object' === typeof o && !Buffer.isBuffer(o)
}
function isString (s) {
  return 'string' === typeof s
}
function isUsageError (err) {
  return usageErrors.indexOf(err.name) >= 0
}

function maybeStringify () {
  return pull.map(function (b) {
    if(isBuffer(b)) return b
    return JSON.stringify(b, null, 2) + '\n\n'
  })
}

function get(obj, path) {
  path.forEach(function (k) {
    obj = obj ? obj[k] : null
  })
  return obj
}

function usage (cmd, manifest, rpc) {
  var usageType = get(manifest, ['usage'])
  var usageCmd  = get(rpc, ['usage'])
  if (!usageType || !usageCmd || (usageType != 'sync' && usageType != 'async'))
    next(null, 'Invalid command')
  else
    usageCmd(Array.isArray(cmd) ? cmd.join('.') : cmd, next)

  function next (err, str) {
    if (err)
      str = ''+(err.message || err)
    console.error(str.split('\n').map(function (v) { return wrap(v, { width: process.stdout.columns-5, indent: '' }) }).join('\n'))
    process.exit(1)
  }
}

function onerror (err, cmd, manifest, rpc) {
  console.error(err.name + ': ' + err.message)
  if (isUsageError(err))
    usage(cmd, rpc, manifest)
  else
    return process.exit(1)
}

module.exports = function (argv, manifest, rpc) {
  // parse out `cmd`, `args`, and `isStdin`
  var parsedArgv = minimist(argv)
  var cmd = parsedArgv._[0], args = parsedArgv._.slice(1)
  var isStdin = ('.' === args[0] || '--' === args[0])

  delete parsedArgv._
  if (Object.keys(parsedArgv).length)
    args.push(parsedArgv)

  // route to the command
  if (!cmd)
    return usage(false, manifest, rpc)
  if (parsedArgv.h || parsedArgv.help)
    return usage(cmd, manifest, rpc)
  cmd = cmd.split('.')
  var cmdType = get(manifest, cmd)
  if (!cmdType) {
    console.error('Command not found: '+cmd.join('.'))
    return usage(false, manifest, rpc)
  }

  // handle stdin-mode
  if(!process.stdin.isTTY && isStdin) {
    pull(
      toPull.source(process.stdin),
      pull.collect(function (err, ary) {
        var str = Buffer.concat(ary).toString('utf8')
        var data = JSON.parse(str)
        next([data])
      })
    )
  }
  else
    next(args)

  function next (args) {

    if ('async' === cmdType || cmdType === 'sync') {
      get(rpc, cmd).apply(null, args.concat([function (err, res) {
        if (err)
          return onerror(err, cmd, rpc, manifest)
        if (typeof res != 'undefined')
          console.log(JSON.stringify(res, null, 2))
        process.exit()
      }]))
    }
    else if ('source' === cmdType)
      pull(
        get(rpc, cmd).apply(null, args),
        maybeStringify(),
        toPull.sink(process.stdout, function (err) {
          if (err) 
            return onerror(err, cmd, rpc, manifest)
          process.exit()
        })
      )
    else if ('sink' === cmdType)
      pull(
        toPull.source(process.stdin),
        get(rpc, cmd).apply(null, args.concat([function (err, res) {
          if (err) 
            return onerror(err, cmd, rpc, manifest)
          if (typeof res != 'undefined')
            console.log(JSON.stringify(res, null, 2))
          process.exit()
        }]))
      )
    else if (typeof cmdType == 'object' && cmdType) {
      // it may be a sub-object manifest, try getting usage for it
      usage(cmd, manifest, rpc)
    }
    else {
      console.error('Invalid Manifest:', cmdType, 'is not a valid method-type')
      process.exit(1)
    }
  }
}

},
"JiDq3TTh72unEa8io/h4/K4spOUvqsx33q7DNNgh5o4=":
function (require, module, exports, __dirname, __filename) {
'use strict';

function id (item) { return item }

function prop (key) {
  return (
    'string' == typeof key
    ? function (data) { return data[key] }
    : 'object' === typeof key && 'function' === typeof key.exec //regexp
    ? function (data) { var v = map.exec(data); return v && v[0] }
    : key
  )
}

function tester (test) {
  return (
    'object' === typeof test && 'function' === typeof test.test //regexp
    ? function (data) { return test.test(data) }
    : prop (test) || id
  )
}

var sources = require('./sources')
var sinks = require('./sinks')

var map = exports.map =

function (map) {
  if(!map) return id
  map = prop(map)
  return function (read) {
    return function (abort, cb) {
      read(abort, function (end, data) {
        try {
        data = !end ? map(data) : null
        } catch (err) {
          return read(err, function () {
            return cb(err)
          })
        }
        cb(end, data)
      })
    }
  }
}

var asyncMap = exports.asyncMap =
function async (map) {
  if(!map) return id
  map = prop(map)
  var busy = false, abortCb, aborted
  return function (read) {
    return function next (abort, cb) {
      if(aborted) return cb(aborted)
      if(abort) {
        aborted = abort
        if(!busy) read(abort, cb)
        else read(abort, function () {
          //if we are still busy, wait for the mapper to complete.
          if(busy) abortCb = cb
          else cb(abort)
        })
      }
      else
        read(null, function (end, data) {
          if(end) {
            cb(end)
            if(abortCb) cb(end, data)
          }
          else {
            busy = true
            map(data, function (err, data) {
              busy = false
              if(aborted) {
                cb(aborted)
                abortCb(aborted)
              }
              else if(err) next (err, cb)
              else cb(null, data)
            })
          }
        })
    }
  }
}


function asyncMap (map) {
  if(!map) return id //when read is passed, pass it on.
  return function (read) {
    return function (end, cb) {
      if(end) return read(end, cb) //abort
      read(null, function (end, data) {
        if(end) return cb(end, data)
        map(data, cb)
      })
    }
  }
}

var filter = exports.filter =
function (test) {
  //regexp
  test = tester(test)
  return function (read) {
    return function next (end, cb) {
      var sync, loop = true
      while(loop) {
        loop = false
        sync = true
        read(end, function (end, data) {
          if(!end && !test(data))
            return sync ? loop = true : next(end, cb)
          cb(end, data)
        })
        sync = false
      }
    }
  }
}

var filterNot = exports.filterNot =
function (test) {
  test = tester(test)
  return filter(function (data) { return !test(data) })
}

//a pass through stream that doesn't change the value.
var through = exports.through =
function (op, onEnd) {
  var a = false

  function once (abort) {
    if(a || !onEnd) return
    a = true
    onEnd(abort === true ? null : abort)
  }

  return function (read) {
    return function (end, cb) {
      if(end) once(end)
      return read(end, function (end, data) {
        if(!end) op && op(data)
        else once(end)
        cb(end, data)
      })
    }
  }
}

//read a number of items and then stop.
var take = exports.take =
function (test, opts) {
  opts = opts || {}
  var last = opts.last || false // whether the first item for which !test(item) should still pass
  var ended = false
  if('number' === typeof test) {
    last = true
    var n = test; test = function () {
      return --n
    }
  }

  return function (read) {

    function terminate (cb) {
      read(true, function (err) {
        last = false; cb(err || true)
      })
    }

    return function (end, cb) {
      if(ended)            last ? terminate(cb) : cb(ended)
      else if(ended = end) read(ended, cb)
      else
        read(null, function (end, data) {
          if(ended = ended || end) {
            //last ? terminate(cb) :
            cb(ended)
          }
          else if(!test(data)) {
            ended = true
            last ? cb(null, data) : terminate(cb)
          }
          else
            cb(null, data)
        })
    }
  }
}

//drop items you have already seen.
var unique = exports.unique = function (field, invert) {
  field = prop(field) || id
  var seen = {}
  return filter(function (data) {
    var key = field(data)
    if(seen[key]) return !!invert //false, by default
    else seen[key] = true
    return !invert //true by default
  })
}

//passes an item through when you see it for the second time.
var nonUnique = exports.nonUnique = function (field) {
  return unique(field, true)
}

//convert a stream of arrays or streams into just a stream.
var flatten = exports.flatten = function () {
  return function (read) {
    var _read
    return function (abort, cb) {
      if (abort) { //abort the current stream, and then stream of streams.
        _read ? _read(abort, function(err) {
          read(err || abort, cb)
        }) : read(abort, cb)
      }
      else if(_read) nextChunk()
      else nextStream()

      function nextChunk () {
        _read(null, function (err, data) {
          if (err === true) nextStream()
          else if (err) {
            read(true, function(abortErr) {
              // TODO: what do we do with the abortErr?
              cb(err)
            })
          }
          else cb(null, data)
        })
      }
      function nextStream () {
        _read = null
        read(null, function (end, stream) {
          if(end)
            return cb(end)
          if(Array.isArray(stream) || stream && 'object' === typeof stream)
            stream = sources.values(stream)
          else if('function' != typeof stream)
            throw new Error('expected stream of streams')
          _read = stream
          nextChunk()
        })
      }
    }
  }
}







},
"Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=":
function (require, module, exports, __dirname, __filename) {
var u      = require('pull-core')
var sources = require('./sources')
var sinks = require('./sinks')

var prop   = u.prop
var id     = u.id
var tester = u.tester

var map = exports.map = 
function (read, map) {
  map = prop(map) || id
  return function (end, cb) {
    read(end, function (end, data) {
      var data = !end ? map(data) : null
      cb(end, data)
    })
  }
}

var asyncMap = exports.asyncMap =
function (read, map) {
  if(!map) return read
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    read(null, function (end, data) {
      if(end) return cb(end, data)
      map(data, cb)
    })
  }
}

var paraMap = exports.paraMap =
function (read, map, width) {
  if(!map) return read
  var ended = false, queue = [], _cb

  function drain () {
    if(!_cb) return
    var cb = _cb
    _cb = null
    if(queue.length)
      return cb(null, queue.shift())
    else if(ended && !n)
      return cb(ended)
    _cb = cb
  }

  function pull () {
    read(null, function (end, data) {
      if(end) {
        ended = end
        return drain()
      }
      n++
      map(data, function (err, data) {
        n--

        queue.push(data)
        drain()
      })

      if(n < width && !ended)
        pull()
    })
  }

  var n = 0
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    //continue to read while there are less than 3 maps in flight
    _cb = cb
    if(queue.length || ended)
      pull(), drain()
    else pull()
  }
  return highWaterMark(asyncMap(read, map), width)
}

var filter = exports.filter =
function (read, test) {
  //regexp
  test = tester(test)
  return function next (end, cb) {
    read(end, function (end, data) {
      if(!end && !test(data))
        return next(end, cb)
      cb(end, data)
    })
  }
}

var filterNot = exports.filterNot =
function (read, test) {
  test = tester(test)
  return filter(read, function (e) {
    return !test(e)
  })
}

var through = exports.through = 
function (read, op, onEnd) {
  var a = false
  function once (abort) {
    if(a || !onEnd) return
    a = true
    onEnd(abort === true ? null : abort)
  }

  return function (end, cb) {
    if(end) once(end)
    return read(end, function (end, data) {
      if(!end) op && op(data)
      else once(end)
      cb(end, data)
    })
  }
}

var take = exports.take =
function (read, test) {
  var ended = false
  if('number' === typeof test) {
    var n = test; test = function () {
      return n --
    }
  }

  return function (end, cb) {
    if(ended) return cb(ended)
    if(ended = end) return read(ended, cb)

    read(null, function (end, data) {
      if(ended = ended || end) return cb(ended)
      if(!test(data)) {
        ended = true
        read(true, function (end, data) {
          cb(ended, data)
        })
      }
      else
        cb(null, data)
    })
  }
}

var unique = exports.unique = function (read, field, invert) {
  field = prop(field) || id
  var seen = {}
  return filter(read, function (data) {
    var key = field(data)
    if(seen[key]) return !!invert //false, by default
    else seen[key] = true
    return !invert //true by default
  })
}

var nonUnique = exports.nonUnique = function (read, field) {
  return unique(read, field, true)
}

var group = exports.group =
function (read, size) {
  var ended; size = size || 5
  var queue = []

  return function (end, cb) {
    //this means that the upstream is sending an error.
    if(end) return read(ended = end, cb)
    //this means that we read an end before.
    if(ended) return cb(ended)

    read(null, function next(end, data) {
      if(ended = ended || end) {
        if(!queue.length)
          return cb(ended)

        var _queue = queue; queue = []
        return cb(null, _queue)
      }
      queue.push(data)
      if(queue.length < size)
        return read(null, next)

      var _queue = queue; queue = []
      cb(null, _queue)
    })
  }
}

var flatten = exports.flatten = function (read) {
  var _read
  return function (abort, cb) {
    if(_read) nextChunk()
    else      nextStream()

    function nextChunk () {
      _read(null, function (end, data) {
        if(end) nextStream()
        else    cb(null, data)
      })
    }
    function nextStream () {
      read(null, function (end, stream) {
        if(end)
          return cb(end)
        if(Array.isArray(stream))
          stream = sources.values(stream)
        else if('function' != typeof stream)
          throw new Error('expected stream of streams')
        
        _read = stream
        nextChunk()
      })
    }
  }
}

var prepend =
exports.prepend =
function (read, head) {

  return function (abort, cb) {
    if(head !== null) {
      if(abort)
        return read(abort, cb)
      var _head = head
      head = null
      cb(null, _head)
    } else {
      read(abort, cb)
    }
  }

}

//var drainIf = exports.drainIf = function (op, done) {
//  sinks.drain(
//}

var _reduce = exports._reduce = function (read, reduce, initial) {
  return function (close, cb) {
    if(close) return read(close, cb)
    if(ended) return cb(ended)

    sinks.drain(function (item) {
      initial = reduce(initial, item)
    }, function (err, data) {
      ended = err || true
      if(!err) cb(null, initial)
      else     cb(ended)
    })
    (read)
  }
}

var nextTick = process.nextTick

var highWaterMark = exports.highWaterMark = 
function (read, highWaterMark) {
  var buffer = [], waiting = [], ended, reading = false
  highWaterMark = highWaterMark || 10

  function readAhead () {
    while(waiting.length && (buffer.length || ended))
      waiting.shift()(ended, ended ? null : buffer.shift())
  }

  function next () {
    if(ended || reading || buffer.length >= highWaterMark)
      return
    reading = true
    return read(ended, function (end, data) {
      reading = false
      ended = ended || end
      if(data != null) buffer.push(data)
      
      next(); readAhead()
    })
  }

  nextTick(next)

  return function (end, cb) {
    ended = ended || end
    waiting.push(cb)

    next(); readAhead()
  }
}




},
"JssbMjuxexnirfhxu+zGTuXhpF3BrL7FxznLcyk86Ls=":
function (require, module, exports, __dirname, __filename) {
var pl   = require('pull-level')
var pull = require('pull-stream')

module.exports = function (db, update, get) {
  var waiting = [], ready = false
  pull(
    pl.read(db, {
      onSync: function () {
        ready = true
        while(waiting.length) {
          waiting.shift()()
        }
      },
      live: true
    }),
    pull.drain(update)
  )

  function call (opts, cb) {
    var value
    try { value = get(opts) }
    catch (err) { return cb(err) }
    cb(null, value)
  }

  return function (opts, cb) {
    if(!cb) cb = opts, opts = null
    if(ready) call(opts, cb)
    else waiting.push(function () { call(opts, cb) })
  }

}

},
"K8ZPcklseHPK+Tf4w92pBUTWsYxXAzMGizaTAz0XbnU=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')
var fs   = require('fs')
var path = require('path')
var split = require('pull-split')

var readdir =
exports.readdir =
pull.Source(function (dir, match) {
  var ls, ended = false
  match = (
    !match                           ? null
  : 'function' === typeof match      ? match
  : 'function' === typeof match.test ? match.test.bind(match)
  :                                    null
  )
  return function (abort, cb) {
    if(ended || abort) {
      cb(ended = ended || abort)
    }
    else if(!ls)
      fs.readdir(dir, function (err, _ls) {
        if(err)             cb(ended = err)
        else if(!_ls.length) cb(ended = true)
        else {
          if(match)
            _ls = _ls.filter(match)
          ls = _ls.map(function (f) {
            return path.resolve(dir, f)
          })
          if(ls.length)
            cb(null, ls.shift())
          else
            cb(true)
        }
      })
    else if(!ls.length) cb(ended = true)
    else                cb(null, ls.shift())  
  }
})

var blocksize = 512

var read = 
exports.read =
pull.Source(function (path, options) {

  //C/P from
  // https://github.com/joyent/node/blob/master/lib/fs.js#L172-L202
  /*
    [fs.js](https://github.com/joyent/node/blob/
    2f88272ba298f20f5756415d2a69e6f6617fcbbe/lib/fs.js#L172-L204)
  */
  if (typeof options === 'function' || !options) {
    options = { encoding: null, flag: 'r' };
  } else if (typeof options === 'string') {
    options = { encoding: options, flag: 'r' };
  } else if (!options) {
    options = { encoding: null, flag: 'r' };
  } else if (typeof options !== 'object') {
    throw new TypeError('Bad arguments');
  }

  var encoding = options.encoding;

  var fd, _cb, read, ended
  var flag = options.flag || 'r';
  fs.open(path, flag, 438 /*=0666*/, function(er, fd_) {
    if (er) {
      ended = er
      if(_cb)
        _cb(ended)
    }
    fd = fd_;
    var buffer = new Buffer(blocksize)
    read = function (abort, cb) {
      fs.read(fd, buffer, 0, blocksize, -1, function (err, bytes, buffer) {

        if(err)         return cb(ended = err)
        if(bytes === 0) return cb(true)
        var b = buffer.slice(0, bytes)
        cb(null, encoding ? b.toString(encoding) : b)
      })
    }
    read(null, _cb)
  })

  return function (abort, cb) {
    if(!read) _cb = cb
    else read(abort, cb)
  }
})

//var write =
//exports.write = 
//pull.Sink(function (read, path, options, done) {
//
//  if(!done)
//    done = function () {}
//  
//  if (typeof options === 'function' || !options) {
//    options = { encoding: null, flag: 'w' };
//  } else if (typeof options === 'string') {
//    options = { encoding: options, flag: 'w' };
//  } else if (!options) {
//    options = { encoding: null, flag: 'w' };
//  } else if (typeof options !== 'object') {
//    throw new TypeError('Bad arguments');
//  }
//
//  var fd, _cb, read, ended
//  var flag = options.flag || 'r';
//  fs.open(path, flag, 438 /*=0666*/, function(er, fd_) {
//    if(er) {
//      return read(er, function () {
//        return done(er)
//      })
//    }
//    read(null, function next (err, data) {
//
//    })
//  })
//})

var exists =
exports.exists =
function (test) {
  test = test || function (e) {
    return !!e
  }
  return pull.asyncMap(function (e, cb) {
    fs.stat(e, function (err, stat) {
      if(stat && test(stat))
        cb(null, e)
      else
        cb(null, null)
    })
  }).pipe(pull.filter(Boolean))
}

function testStat(test) {
  return function () {
    return exists(test)
  }
}


var isFile = 
exports.isFile =
testStat(function (e) { return e.isFile() })

var isDirectory = 
exports.isDirectory =
testStat(function (e) { return e.isDirectory() })

var isBlockDevice = 
exports.isBlockDevice =
testStat(function (e) { return e.isBlockDevice() })

var isCharacterDevice = 
exports.isCharacterDevice =
testStat(function (e) { return e.isCharacterDevice() })

var isSymbolicLink = 
exports.isSymbolicLink =
testStat(function (e) { return e.isSymbolicLink() })

var isFIFO = 
exports.isFIFO =
testStat(function (e) { return e.isFIFO() })

var isSocket = 
exports.isSocket =
testStat(function (e) { return e.isSocket() })

},
"KCsyZM1BSztba/sqbrPZbpOq4EmCWwlI89lAkPSClY4=":
function (require, module, exports, __dirname, __filename) {
var isWindows = process.platform === 'win32'
var path = require('path')
var exec = require('child_process').exec
var osTmpdir = require('os-tmpdir')
var osHomedir = require('os-homedir')

// looking up envs is a bit costly.
// Also, sometimes we want to have a fallback
// Pass in a callback to wait for the fallback on failures
// After the first lookup, always returns the same thing.
function memo (key, lookup, fallback) {
  var fell = false
  var falling = false
  exports[key] = function (cb) {
    var val = lookup()
    if (!val && !fell && !falling && fallback) {
      fell = true
      falling = true
      exec(fallback, function (er, output, stderr) {
        falling = false
        if (er) return // oh well, we tried
        val = output.trim()
      })
    }
    exports[key] = function (cb) {
      if (cb) process.nextTick(cb.bind(null, null, val))
      return val
    }
    if (cb && !falling) process.nextTick(cb.bind(null, null, val))
    return val
  }
}

memo('user', function () {
  return ( isWindows
         ? process.env.USERDOMAIN + '\\' + process.env.USERNAME
         : process.env.USER
         )
}, 'whoami')

memo('prompt', function () {
  return isWindows ? process.env.PROMPT : process.env.PS1
})

memo('hostname', function () {
  return isWindows ? process.env.COMPUTERNAME : process.env.HOSTNAME
}, 'hostname')

memo('tmpdir', function () {
  return osTmpdir()
})

memo('home', function () {
  return osHomedir()
})

memo('path', function () {
  return (process.env.PATH ||
          process.env.Path ||
          process.env.path).split(isWindows ? ';' : ':')
})

memo('editor', function () {
  return process.env.EDITOR ||
         process.env.VISUAL ||
         (isWindows ? 'notepad.exe' : 'vi')
})

memo('shell', function () {
  return isWindows ? process.env.ComSpec || 'cmd'
         : process.env.SHELL || 'bash'
})

},
"KLt4rvLMI8kmsSqkDrC40OBTJnsaUVGF206qJWgXq/0=":
function (require, module, exports, __dirname, __filename) {
var Buffer = require('buffer').Buffer

module.exports = function(buffer) {
  return Buffer.isBuffer(buffer);
}

},
"KSG+p01Q0K7rkgg4S+w8AXaj/V8Ydh5/v8kmumpWm/c=":
function (require, module, exports, __dirname, __filename) {
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if it is array or isn't object
		if (typeof obj !== 'object' || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = target[key]; // source value
			val = obj[key]; // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
}

},
"Koy6Upg+6tVpJ8fCj7jgeQeLrXxPjG6mXq8kx61qGtU=":
function (require, module, exports, __dirname, __filename) {
var ref = require('ssb-ref')

function isObject(o) {
  return o && 'object' === typeof o
}
var DEFAULT_PORT = 8008

var isArray = Array.isArray

var isInteger = Number.isInteger

function isString (s) {
  return 'string' === typeof s
}

var find = exports.find = function find(ary, test) {
  for(var i in ary)
    if(test(ary[i], i, ary)) return ary[i]
}

var clone = exports.clone = function clone (obj, mapper) {
  function map(v, k) {
    return isObject(v) ? clone(v, mapper) : mapper(v, k)
  }
  if(isArray(obj))
    return obj.map(map)
  else if(isObject(obj)) {
    var o = {}
    for(var k in obj)
      o[k] = map(obj[k], k)
    return o
  }
  else
    return map(obj)
}

var mergeKeys = exports.mergeKeys = function (a, b, iter) {
  var o = {}
  for(var k in a) {
    if(!isUndefined(a[k]))
      o[k] = iter(v[k], b[k], k)
  }
  for(var k in b) {
    if(isUndefined(a[a]))
      o[k] = iter(undefined, b[k], k)
  }
  return o
}

exports.merge = function (a, b) {

  //merge a and b objects

  if(isArray(a) != isArray(b))
    throw new Error('cannot merge array with non-array')
  if(isObject(a) != isObject(b))
    throw new Error('cannot merge object with non-object')

  a = clone(a)

  var keys

  if(isObject(b)) {
    for(var k in b)
      a[k] = b
  }
}

exports.stringifyAddress = function (e) {
  if(isString(e)) return e
  return [e.host, e.port || DEFAULT_PORT, e.key].join(':')
}

exports.parseAddress = function (e) {
  if(isString(e)) {
    var parts = e.split(':')
    var id = parts.pop(), port = parts.pop(), host = parts.join(':')
    var e = {
      host: host,
      port: +(port || DEFAULT_PORT),
      key: id
    }
    return e
  }
  return e
}

exports.isAddress = function (addr) {
  return (
    ref.isFeedId(addr.key || addr.link)
    && isInteger(addr.port)
    && typeof addr.host === 'string' && !!addr.host
  )
}

exports.toAddress = function (e) {
  e = exports.parseAddress(e)
  e.port = e.port || DEFAULT_PORT
  e.host = e.host || 'localhost'
  return e
}

},
"L1KJLWYAj835nhUrdAjhiRrXoy4RjuY2oDQvpFoEIto=":
function (require, module, exports, __dirname, __filename) {
// require typewise first to extend with core typewise functionality
require('typewise')

// TODO: bytewise-binary encoding -- no hex parsing or toString hackery
module.exports = require('bytewise-core')

},
"L88a7VdTLTIGreE14E5zYY10SbMoiZ9SfC6axiGRDds=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "AElig": "",
  "AMP": "&",
  "Aacute": "",
  "Abreve": "",
  "Acirc": "",
  "Acy": "",
  "Afr": "",
  "Agrave": "",
  "Alpha": "",
  "Amacr": "",
  "And": "",
  "Aogon": "",
  "Aopf": "",
  "ApplyFunction": "",
  "Aring": "",
  "Ascr": "",
  "Assign": "",
  "Atilde": "",
  "Auml": "",
  "Backslash": "",
  "Barv": "",
  "Barwed": "",
  "Bcy": "",
  "Because": "",
  "Bernoullis": "",
  "Beta": "",
  "Bfr": "",
  "Bopf": "",
  "Breve": "",
  "Bscr": "",
  "Bumpeq": "",
  "CHcy": "",
  "COPY": "",
  "Cacute": "",
  "Cap": "",
  "CapitalDifferentialD": "",
  "Cayleys": "",
  "Ccaron": "",
  "Ccedil": "",
  "Ccirc": "",
  "Cconint": "",
  "Cdot": "",
  "Cedilla": "",
  "CenterDot": "",
  "Cfr": "",
  "Chi": "",
  "CircleDot": "",
  "CircleMinus": "",
  "CirclePlus": "",
  "CircleTimes": "",
  "ClockwiseContourIntegral": "",
  "CloseCurlyDoubleQuote": "",
  "CloseCurlyQuote": "",
  "Colon": "",
  "Colone": "",
  "Congruent": "",
  "Conint": "",
  "ContourIntegral": "",
  "Copf": "",
  "Coproduct": "",
  "CounterClockwiseContourIntegral": "",
  "Cross": "",
  "Cscr": "",
  "Cup": "",
  "CupCap": "",
  "DD": "",
  "DDotrahd": "",
  "DJcy": "",
  "DScy": "",
  "DZcy": "",
  "Dagger": "",
  "Darr": "",
  "Dashv": "",
  "Dcaron": "",
  "Dcy": "",
  "Del": "",
  "Delta": "",
  "Dfr": "",
  "DiacriticalAcute": "",
  "DiacriticalDot": "",
  "DiacriticalDoubleAcute": "",
  "DiacriticalGrave": "`",
  "DiacriticalTilde": "",
  "Diamond": "",
  "DifferentialD": "",
  "Dopf": "",
  "Dot": "",
  "DotDot": "",
  "DotEqual": "",
  "DoubleContourIntegral": "",
  "DoubleDot": "",
  "DoubleDownArrow": "",
  "DoubleLeftArrow": "",
  "DoubleLeftRightArrow": "",
  "DoubleLeftTee": "",
  "DoubleLongLeftArrow": "",
  "DoubleLongLeftRightArrow": "",
  "DoubleLongRightArrow": "",
  "DoubleRightArrow": "",
  "DoubleRightTee": "",
  "DoubleUpArrow": "",
  "DoubleUpDownArrow": "",
  "DoubleVerticalBar": "",
  "DownArrow": "",
  "DownArrowBar": "",
  "DownArrowUpArrow": "",
  "DownBreve": "",
  "DownLeftRightVector": "",
  "DownLeftTeeVector": "",
  "DownLeftVector": "",
  "DownLeftVectorBar": "",
  "DownRightTeeVector": "",
  "DownRightVector": "",
  "DownRightVectorBar": "",
  "DownTee": "",
  "DownTeeArrow": "",
  "Downarrow": "",
  "Dscr": "",
  "Dstrok": "",
  "ENG": "",
  "ETH": "",
  "Eacute": "",
  "Ecaron": "",
  "Ecirc": "",
  "Ecy": "",
  "Edot": "",
  "Efr": "",
  "Egrave": "",
  "Element": "",
  "Emacr": "",
  "EmptySmallSquare": "",
  "EmptyVerySmallSquare": "",
  "Eogon": "",
  "Eopf": "",
  "Epsilon": "",
  "Equal": "",
  "EqualTilde": "",
  "Equilibrium": "",
  "Escr": "",
  "Esim": "",
  "Eta": "",
  "Euml": "",
  "Exists": "",
  "ExponentialE": "",
  "Fcy": "",
  "Ffr": "",
  "FilledSmallSquare": "",
  "FilledVerySmallSquare": "",
  "Fopf": "",
  "ForAll": "",
  "Fouriertrf": "",
  "Fscr": "",
  "GJcy": "",
  "GT": ">",
  "Gamma": "",
  "Gammad": "",
  "Gbreve": "",
  "Gcedil": "",
  "Gcirc": "",
  "Gcy": "",
  "Gdot": "",
  "Gfr": "",
  "Gg": "",
  "Gopf": "",
  "GreaterEqual": "",
  "GreaterEqualLess": "",
  "GreaterFullEqual": "",
  "GreaterGreater": "",
  "GreaterLess": "",
  "GreaterSlantEqual": "",
  "GreaterTilde": "",
  "Gscr": "",
  "Gt": "",
  "HARDcy": "",
  "Hacek": "",
  "Hat": "^",
  "Hcirc": "",
  "Hfr": "",
  "HilbertSpace": "",
  "Hopf": "",
  "HorizontalLine": "",
  "Hscr": "",
  "Hstrok": "",
  "HumpDownHump": "",
  "HumpEqual": "",
  "IEcy": "",
  "IJlig": "",
  "IOcy": "",
  "Iacute": "",
  "Icirc": "",
  "Icy": "",
  "Idot": "",
  "Ifr": "",
  "Igrave": "",
  "Im": "",
  "Imacr": "",
  "ImaginaryI": "",
  "Implies": "",
  "Int": "",
  "Integral": "",
  "Intersection": "",
  "InvisibleComma": "",
  "InvisibleTimes": "",
  "Iogon": "",
  "Iopf": "",
  "Iota": "",
  "Iscr": "",
  "Itilde": "",
  "Iukcy": "",
  "Iuml": "",
  "Jcirc": "",
  "Jcy": "",
  "Jfr": "",
  "Jopf": "",
  "Jscr": "",
  "Jsercy": "",
  "Jukcy": "",
  "KHcy": "",
  "KJcy": "",
  "Kappa": "",
  "Kcedil": "",
  "Kcy": "",
  "Kfr": "",
  "Kopf": "",
  "Kscr": "",
  "LJcy": "",
  "LT": "<",
  "Lacute": "",
  "Lambda": "",
  "Lang": "",
  "Laplacetrf": "",
  "Larr": "",
  "Lcaron": "",
  "Lcedil": "",
  "Lcy": "",
  "LeftAngleBracket": "",
  "LeftArrow": "",
  "LeftArrowBar": "",
  "LeftArrowRightArrow": "",
  "LeftCeiling": "",
  "LeftDoubleBracket": "",
  "LeftDownTeeVector": "",
  "LeftDownVector": "",
  "LeftDownVectorBar": "",
  "LeftFloor": "",
  "LeftRightArrow": "",
  "LeftRightVector": "",
  "LeftTee": "",
  "LeftTeeArrow": "",
  "LeftTeeVector": "",
  "LeftTriangle": "",
  "LeftTriangleBar": "",
  "LeftTriangleEqual": "",
  "LeftUpDownVector": "",
  "LeftUpTeeVector": "",
  "LeftUpVector": "",
  "LeftUpVectorBar": "",
  "LeftVector": "",
  "LeftVectorBar": "",
  "Leftarrow": "",
  "Leftrightarrow": "",
  "LessEqualGreater": "",
  "LessFullEqual": "",
  "LessGreater": "",
  "LessLess": "",
  "LessSlantEqual": "",
  "LessTilde": "",
  "Lfr": "",
  "Ll": "",
  "Lleftarrow": "",
  "Lmidot": "",
  "LongLeftArrow": "",
  "LongLeftRightArrow": "",
  "LongRightArrow": "",
  "Longleftarrow": "",
  "Longleftrightarrow": "",
  "Longrightarrow": "",
  "Lopf": "",
  "LowerLeftArrow": "",
  "LowerRightArrow": "",
  "Lscr": "",
  "Lsh": "",
  "Lstrok": "",
  "Lt": "",
  "Map": "",
  "Mcy": "",
  "MediumSpace": "",
  "Mellintrf": "",
  "Mfr": "",
  "MinusPlus": "",
  "Mopf": "",
  "Mscr": "",
  "Mu": "",
  "NJcy": "",
  "Nacute": "",
  "Ncaron": "",
  "Ncedil": "",
  "Ncy": "",
  "NegativeMediumSpace": "",
  "NegativeThickSpace": "",
  "NegativeThinSpace": "",
  "NegativeVeryThinSpace": "",
  "NestedGreaterGreater": "",
  "NestedLessLess": "",
  "NewLine": "\n",
  "Nfr": "",
  "NoBreak": "",
  "NonBreakingSpace": "",
  "Nopf": "",
  "Not": "",
  "NotCongruent": "",
  "NotCupCap": "",
  "NotDoubleVerticalBar": "",
  "NotElement": "",
  "NotEqual": "",
  "NotEqualTilde": "",
  "NotExists": "",
  "NotGreater": "",
  "NotGreaterEqual": "",
  "NotGreaterFullEqual": "",
  "NotGreaterGreater": "",
  "NotGreaterLess": "",
  "NotGreaterSlantEqual": "",
  "NotGreaterTilde": "",
  "NotHumpDownHump": "",
  "NotHumpEqual": "",
  "NotLeftTriangle": "",
  "NotLeftTriangleBar": "",
  "NotLeftTriangleEqual": "",
  "NotLess": "",
  "NotLessEqual": "",
  "NotLessGreater": "",
  "NotLessLess": "",
  "NotLessSlantEqual": "",
  "NotLessTilde": "",
  "NotNestedGreaterGreater": "",
  "NotNestedLessLess": "",
  "NotPrecedes": "",
  "NotPrecedesEqual": "",
  "NotPrecedesSlantEqual": "",
  "NotReverseElement": "",
  "NotRightTriangle": "",
  "NotRightTriangleBar": "",
  "NotRightTriangleEqual": "",
  "NotSquareSubset": "",
  "NotSquareSubsetEqual": "",
  "NotSquareSuperset": "",
  "NotSquareSupersetEqual": "",
  "NotSubset": "",
  "NotSubsetEqual": "",
  "NotSucceeds": "",
  "NotSucceedsEqual": "",
  "NotSucceedsSlantEqual": "",
  "NotSucceedsTilde": "",
  "NotSuperset": "",
  "NotSupersetEqual": "",
  "NotTilde": "",
  "NotTildeEqual": "",
  "NotTildeFullEqual": "",
  "NotTildeTilde": "",
  "NotVerticalBar": "",
  "Nscr": "",
  "Ntilde": "",
  "Nu": "",
  "OElig": "",
  "Oacute": "",
  "Ocirc": "",
  "Ocy": "",
  "Odblac": "",
  "Ofr": "",
  "Ograve": "",
  "Omacr": "",
  "Omega": "",
  "Omicron": "",
  "Oopf": "",
  "OpenCurlyDoubleQuote": "",
  "OpenCurlyQuote": "",
  "Or": "",
  "Oscr": "",
  "Oslash": "",
  "Otilde": "",
  "Otimes": "",
  "Ouml": "",
  "OverBar": "",
  "OverBrace": "",
  "OverBracket": "",
  "OverParenthesis": "",
  "PartialD": "",
  "Pcy": "",
  "Pfr": "",
  "Phi": "",
  "Pi": "",
  "PlusMinus": "",
  "Poincareplane": "",
  "Popf": "",
  "Pr": "",
  "Precedes": "",
  "PrecedesEqual": "",
  "PrecedesSlantEqual": "",
  "PrecedesTilde": "",
  "Prime": "",
  "Product": "",
  "Proportion": "",
  "Proportional": "",
  "Pscr": "",
  "Psi": "",
  "QUOT": "\"",
  "Qfr": "",
  "Qopf": "",
  "Qscr": "",
  "RBarr": "",
  "REG": "",
  "Racute": "",
  "Rang": "",
  "Rarr": "",
  "Rarrtl": "",
  "Rcaron": "",
  "Rcedil": "",
  "Rcy": "",
  "Re": "",
  "ReverseElement": "",
  "ReverseEquilibrium": "",
  "ReverseUpEquilibrium": "",
  "Rfr": "",
  "Rho": "",
  "RightAngleBracket": "",
  "RightArrow": "",
  "RightArrowBar": "",
  "RightArrowLeftArrow": "",
  "RightCeiling": "",
  "RightDoubleBracket": "",
  "RightDownTeeVector": "",
  "RightDownVector": "",
  "RightDownVectorBar": "",
  "RightFloor": "",
  "RightTee": "",
  "RightTeeArrow": "",
  "RightTeeVector": "",
  "RightTriangle": "",
  "RightTriangleBar": "",
  "RightTriangleEqual": "",
  "RightUpDownVector": "",
  "RightUpTeeVector": "",
  "RightUpVector": "",
  "RightUpVectorBar": "",
  "RightVector": "",
  "RightVectorBar": "",
  "Rightarrow": "",
  "Ropf": "",
  "RoundImplies": "",
  "Rrightarrow": "",
  "Rscr": "",
  "Rsh": "",
  "RuleDelayed": "",
  "SHCHcy": "",
  "SHcy": "",
  "SOFTcy": "",
  "Sacute": "",
  "Sc": "",
  "Scaron": "",
  "Scedil": "",
  "Scirc": "",
  "Scy": "",
  "Sfr": "",
  "ShortDownArrow": "",
  "ShortLeftArrow": "",
  "ShortRightArrow": "",
  "ShortUpArrow": "",
  "Sigma": "",
  "SmallCircle": "",
  "Sopf": "",
  "Sqrt": "",
  "Square": "",
  "SquareIntersection": "",
  "SquareSubset": "",
  "SquareSubsetEqual": "",
  "SquareSuperset": "",
  "SquareSupersetEqual": "",
  "SquareUnion": "",
  "Sscr": "",
  "Star": "",
  "Sub": "",
  "Subset": "",
  "SubsetEqual": "",
  "Succeeds": "",
  "SucceedsEqual": "",
  "SucceedsSlantEqual": "",
  "SucceedsTilde": "",
  "SuchThat": "",
  "Sum": "",
  "Sup": "",
  "Superset": "",
  "SupersetEqual": "",
  "Supset": "",
  "THORN": "",
  "TRADE": "",
  "TSHcy": "",
  "TScy": "",
  "Tab": "\t",
  "Tau": "",
  "Tcaron": "",
  "Tcedil": "",
  "Tcy": "",
  "Tfr": "",
  "Therefore": "",
  "Theta": "",
  "ThickSpace": "",
  "ThinSpace": "",
  "Tilde": "",
  "TildeEqual": "",
  "TildeFullEqual": "",
  "TildeTilde": "",
  "Topf": "",
  "TripleDot": "",
  "Tscr": "",
  "Tstrok": "",
  "Uacute": "",
  "Uarr": "",
  "Uarrocir": "",
  "Ubrcy": "",
  "Ubreve": "",
  "Ucirc": "",
  "Ucy": "",
  "Udblac": "",
  "Ufr": "",
  "Ugrave": "",
  "Umacr": "",
  "UnderBar": "_",
  "UnderBrace": "",
  "UnderBracket": "",
  "UnderParenthesis": "",
  "Union": "",
  "UnionPlus": "",
  "Uogon": "",
  "Uopf": "",
  "UpArrow": "",
  "UpArrowBar": "",
  "UpArrowDownArrow": "",
  "UpDownArrow": "",
  "UpEquilibrium": "",
  "UpTee": "",
  "UpTeeArrow": "",
  "Uparrow": "",
  "Updownarrow": "",
  "UpperLeftArrow": "",
  "UpperRightArrow": "",
  "Upsi": "",
  "Upsilon": "",
  "Uring": "",
  "Uscr": "",
  "Utilde": "",
  "Uuml": "",
  "VDash": "",
  "Vbar": "",
  "Vcy": "",
  "Vdash": "",
  "Vdashl": "",
  "Vee": "",
  "Verbar": "",
  "Vert": "",
  "VerticalBar": "",
  "VerticalLine": "|",
  "VerticalSeparator": "",
  "VerticalTilde": "",
  "VeryThinSpace": "",
  "Vfr": "",
  "Vopf": "",
  "Vscr": "",
  "Vvdash": "",
  "Wcirc": "",
  "Wedge": "",
  "Wfr": "",
  "Wopf": "",
  "Wscr": "",
  "Xfr": "",
  "Xi": "",
  "Xopf": "",
  "Xscr": "",
  "YAcy": "",
  "YIcy": "",
  "YUcy": "",
  "Yacute": "",
  "Ycirc": "",
  "Ycy": "",
  "Yfr": "",
  "Yopf": "",
  "Yscr": "",
  "Yuml": "",
  "ZHcy": "",
  "Zacute": "",
  "Zcaron": "",
  "Zcy": "",
  "Zdot": "",
  "ZeroWidthSpace": "",
  "Zeta": "",
  "Zfr": "",
  "Zopf": "",
  "Zscr": "",
  "aacute": "",
  "abreve": "",
  "ac": "",
  "acE": "",
  "acd": "",
  "acirc": "",
  "acute": "",
  "acy": "",
  "aelig": "",
  "af": "",
  "afr": "",
  "agrave": "",
  "alefsym": "",
  "aleph": "",
  "alpha": "",
  "amacr": "",
  "amalg": "",
  "amp": "&",
  "and": "",
  "andand": "",
  "andd": "",
  "andslope": "",
  "andv": "",
  "ang": "",
  "ange": "",
  "angle": "",
  "angmsd": "",
  "angmsdaa": "",
  "angmsdab": "",
  "angmsdac": "",
  "angmsdad": "",
  "angmsdae": "",
  "angmsdaf": "",
  "angmsdag": "",
  "angmsdah": "",
  "angrt": "",
  "angrtvb": "",
  "angrtvbd": "",
  "angsph": "",
  "angst": "",
  "angzarr": "",
  "aogon": "",
  "aopf": "",
  "ap": "",
  "apE": "",
  "apacir": "",
  "ape": "",
  "apid": "",
  "apos": "'",
  "approx": "",
  "approxeq": "",
  "aring": "",
  "ascr": "",
  "ast": "*",
  "asymp": "",
  "asympeq": "",
  "atilde": "",
  "auml": "",
  "awconint": "",
  "awint": "",
  "bNot": "",
  "backcong": "",
  "backepsilon": "",
  "backprime": "",
  "backsim": "",
  "backsimeq": "",
  "barvee": "",
  "barwed": "",
  "barwedge": "",
  "bbrk": "",
  "bbrktbrk": "",
  "bcong": "",
  "bcy": "",
  "bdquo": "",
  "becaus": "",
  "because": "",
  "bemptyv": "",
  "bepsi": "",
  "bernou": "",
  "beta": "",
  "beth": "",
  "between": "",
  "bfr": "",
  "bigcap": "",
  "bigcirc": "",
  "bigcup": "",
  "bigodot": "",
  "bigoplus": "",
  "bigotimes": "",
  "bigsqcup": "",
  "bigstar": "",
  "bigtriangledown": "",
  "bigtriangleup": "",
  "biguplus": "",
  "bigvee": "",
  "bigwedge": "",
  "bkarow": "",
  "blacklozenge": "",
  "blacksquare": "",
  "blacktriangle": "",
  "blacktriangledown": "",
  "blacktriangleleft": "",
  "blacktriangleright": "",
  "blank": "",
  "blk12": "",
  "blk14": "",
  "blk34": "",
  "block": "",
  "bne": "=",
  "bnequiv": "",
  "bnot": "",
  "bopf": "",
  "bot": "",
  "bottom": "",
  "bowtie": "",
  "boxDL": "",
  "boxDR": "",
  "boxDl": "",
  "boxDr": "",
  "boxH": "",
  "boxHD": "",
  "boxHU": "",
  "boxHd": "",
  "boxHu": "",
  "boxUL": "",
  "boxUR": "",
  "boxUl": "",
  "boxUr": "",
  "boxV": "",
  "boxVH": "",
  "boxVL": "",
  "boxVR": "",
  "boxVh": "",
  "boxVl": "",
  "boxVr": "",
  "boxbox": "",
  "boxdL": "",
  "boxdR": "",
  "boxdl": "",
  "boxdr": "",
  "boxh": "",
  "boxhD": "",
  "boxhU": "",
  "boxhd": "",
  "boxhu": "",
  "boxminus": "",
  "boxplus": "",
  "boxtimes": "",
  "boxuL": "",
  "boxuR": "",
  "boxul": "",
  "boxur": "",
  "boxv": "",
  "boxvH": "",
  "boxvL": "",
  "boxvR": "",
  "boxvh": "",
  "boxvl": "",
  "boxvr": "",
  "bprime": "",
  "breve": "",
  "brvbar": "",
  "bscr": "",
  "bsemi": "",
  "bsim": "",
  "bsime": "",
  "bsol": "\\",
  "bsolb": "",
  "bsolhsub": "",
  "bull": "",
  "bullet": "",
  "bump": "",
  "bumpE": "",
  "bumpe": "",
  "bumpeq": "",
  "cacute": "",
  "cap": "",
  "capand": "",
  "capbrcup": "",
  "capcap": "",
  "capcup": "",
  "capdot": "",
  "caps": "",
  "caret": "",
  "caron": "",
  "ccaps": "",
  "ccaron": "",
  "ccedil": "",
  "ccirc": "",
  "ccups": "",
  "ccupssm": "",
  "cdot": "",
  "cedil": "",
  "cemptyv": "",
  "cent": "",
  "centerdot": "",
  "cfr": "",
  "chcy": "",
  "check": "",
  "checkmark": "",
  "chi": "",
  "cir": "",
  "cirE": "",
  "circ": "",
  "circeq": "",
  "circlearrowleft": "",
  "circlearrowright": "",
  "circledR": "",
  "circledS": "",
  "circledast": "",
  "circledcirc": "",
  "circleddash": "",
  "cire": "",
  "cirfnint": "",
  "cirmid": "",
  "cirscir": "",
  "clubs": "",
  "clubsuit": "",
  "colon": ":",
  "colone": "",
  "coloneq": "",
  "comma": ",",
  "commat": "@",
  "comp": "",
  "compfn": "",
  "complement": "",
  "complexes": "",
  "cong": "",
  "congdot": "",
  "conint": "",
  "copf": "",
  "coprod": "",
  "copy": "",
  "copysr": "",
  "crarr": "",
  "cross": "",
  "cscr": "",
  "csub": "",
  "csube": "",
  "csup": "",
  "csupe": "",
  "ctdot": "",
  "cudarrl": "",
  "cudarrr": "",
  "cuepr": "",
  "cuesc": "",
  "cularr": "",
  "cularrp": "",
  "cup": "",
  "cupbrcap": "",
  "cupcap": "",
  "cupcup": "",
  "cupdot": "",
  "cupor": "",
  "cups": "",
  "curarr": "",
  "curarrm": "",
  "curlyeqprec": "",
  "curlyeqsucc": "",
  "curlyvee": "",
  "curlywedge": "",
  "curren": "",
  "curvearrowleft": "",
  "curvearrowright": "",
  "cuvee": "",
  "cuwed": "",
  "cwconint": "",
  "cwint": "",
  "cylcty": "",
  "dArr": "",
  "dHar": "",
  "dagger": "",
  "daleth": "",
  "darr": "",
  "dash": "",
  "dashv": "",
  "dbkarow": "",
  "dblac": "",
  "dcaron": "",
  "dcy": "",
  "dd": "",
  "ddagger": "",
  "ddarr": "",
  "ddotseq": "",
  "deg": "",
  "delta": "",
  "demptyv": "",
  "dfisht": "",
  "dfr": "",
  "dharl": "",
  "dharr": "",
  "diam": "",
  "diamond": "",
  "diamondsuit": "",
  "diams": "",
  "die": "",
  "digamma": "",
  "disin": "",
  "div": "",
  "divide": "",
  "divideontimes": "",
  "divonx": "",
  "djcy": "",
  "dlcorn": "",
  "dlcrop": "",
  "dollar": "$",
  "dopf": "",
  "dot": "",
  "doteq": "",
  "doteqdot": "",
  "dotminus": "",
  "dotplus": "",
  "dotsquare": "",
  "doublebarwedge": "",
  "downarrow": "",
  "downdownarrows": "",
  "downharpoonleft": "",
  "downharpoonright": "",
  "drbkarow": "",
  "drcorn": "",
  "drcrop": "",
  "dscr": "",
  "dscy": "",
  "dsol": "",
  "dstrok": "",
  "dtdot": "",
  "dtri": "",
  "dtrif": "",
  "duarr": "",
  "duhar": "",
  "dwangle": "",
  "dzcy": "",
  "dzigrarr": "",
  "eDDot": "",
  "eDot": "",
  "eacute": "",
  "easter": "",
  "ecaron": "",
  "ecir": "",
  "ecirc": "",
  "ecolon": "",
  "ecy": "",
  "edot": "",
  "ee": "",
  "efDot": "",
  "efr": "",
  "eg": "",
  "egrave": "",
  "egs": "",
  "egsdot": "",
  "el": "",
  "elinters": "",
  "ell": "",
  "els": "",
  "elsdot": "",
  "emacr": "",
  "empty": "",
  "emptyset": "",
  "emptyv": "",
  "emsp13": "",
  "emsp14": "",
  "emsp": "",
  "eng": "",
  "ensp": "",
  "eogon": "",
  "eopf": "",
  "epar": "",
  "eparsl": "",
  "eplus": "",
  "epsi": "",
  "epsilon": "",
  "epsiv": "",
  "eqcirc": "",
  "eqcolon": "",
  "eqsim": "",
  "eqslantgtr": "",
  "eqslantless": "",
  "equals": "=",
  "equest": "",
  "equiv": "",
  "equivDD": "",
  "eqvparsl": "",
  "erDot": "",
  "erarr": "",
  "escr": "",
  "esdot": "",
  "esim": "",
  "eta": "",
  "eth": "",
  "euml": "",
  "euro": "",
  "excl": "!",
  "exist": "",
  "expectation": "",
  "exponentiale": "",
  "fallingdotseq": "",
  "fcy": "",
  "female": "",
  "ffilig": "",
  "fflig": "",
  "ffllig": "",
  "ffr": "",
  "filig": "",
  "fjlig": "fj",
  "flat": "",
  "fllig": "",
  "fltns": "",
  "fnof": "",
  "fopf": "",
  "forall": "",
  "fork": "",
  "forkv": "",
  "fpartint": "",
  "frac12": "",
  "frac13": "",
  "frac14": "",
  "frac15": "",
  "frac16": "",
  "frac18": "",
  "frac23": "",
  "frac25": "",
  "frac34": "",
  "frac35": "",
  "frac38": "",
  "frac45": "",
  "frac56": "",
  "frac58": "",
  "frac78": "",
  "frasl": "",
  "frown": "",
  "fscr": "",
  "gE": "",
  "gEl": "",
  "gacute": "",
  "gamma": "",
  "gammad": "",
  "gap": "",
  "gbreve": "",
  "gcirc": "",
  "gcy": "",
  "gdot": "",
  "ge": "",
  "gel": "",
  "geq": "",
  "geqq": "",
  "geqslant": "",
  "ges": "",
  "gescc": "",
  "gesdot": "",
  "gesdoto": "",
  "gesdotol": "",
  "gesl": "",
  "gesles": "",
  "gfr": "",
  "gg": "",
  "ggg": "",
  "gimel": "",
  "gjcy": "",
  "gl": "",
  "glE": "",
  "gla": "",
  "glj": "",
  "gnE": "",
  "gnap": "",
  "gnapprox": "",
  "gne": "",
  "gneq": "",
  "gneqq": "",
  "gnsim": "",
  "gopf": "",
  "grave": "`",
  "gscr": "",
  "gsim": "",
  "gsime": "",
  "gsiml": "",
  "gt": ">",
  "gtcc": "",
  "gtcir": "",
  "gtdot": "",
  "gtlPar": "",
  "gtquest": "",
  "gtrapprox": "",
  "gtrarr": "",
  "gtrdot": "",
  "gtreqless": "",
  "gtreqqless": "",
  "gtrless": "",
  "gtrsim": "",
  "gvertneqq": "",
  "gvnE": "",
  "hArr": "",
  "hairsp": "",
  "half": "",
  "hamilt": "",
  "hardcy": "",
  "harr": "",
  "harrcir": "",
  "harrw": "",
  "hbar": "",
  "hcirc": "",
  "hearts": "",
  "heartsuit": "",
  "hellip": "",
  "hercon": "",
  "hfr": "",
  "hksearow": "",
  "hkswarow": "",
  "hoarr": "",
  "homtht": "",
  "hookleftarrow": "",
  "hookrightarrow": "",
  "hopf": "",
  "horbar": "",
  "hscr": "",
  "hslash": "",
  "hstrok": "",
  "hybull": "",
  "hyphen": "",
  "iacute": "",
  "ic": "",
  "icirc": "",
  "icy": "",
  "iecy": "",
  "iexcl": "",
  "iff": "",
  "ifr": "",
  "igrave": "",
  "ii": "",
  "iiiint": "",
  "iiint": "",
  "iinfin": "",
  "iiota": "",
  "ijlig": "",
  "imacr": "",
  "image": "",
  "imagline": "",
  "imagpart": "",
  "imath": "",
  "imof": "",
  "imped": "",
  "in": "",
  "incare": "",
  "infin": "",
  "infintie": "",
  "inodot": "",
  "int": "",
  "intcal": "",
  "integers": "",
  "intercal": "",
  "intlarhk": "",
  "intprod": "",
  "iocy": "",
  "iogon": "",
  "iopf": "",
  "iota": "",
  "iprod": "",
  "iquest": "",
  "iscr": "",
  "isin": "",
  "isinE": "",
  "isindot": "",
  "isins": "",
  "isinsv": "",
  "isinv": "",
  "it": "",
  "itilde": "",
  "iukcy": "",
  "iuml": "",
  "jcirc": "",
  "jcy": "",
  "jfr": "",
  "jmath": "",
  "jopf": "",
  "jscr": "",
  "jsercy": "",
  "jukcy": "",
  "kappa": "",
  "kappav": "",
  "kcedil": "",
  "kcy": "",
  "kfr": "",
  "kgreen": "",
  "khcy": "",
  "kjcy": "",
  "kopf": "",
  "kscr": "",
  "lAarr": "",
  "lArr": "",
  "lAtail": "",
  "lBarr": "",
  "lE": "",
  "lEg": "",
  "lHar": "",
  "lacute": "",
  "laemptyv": "",
  "lagran": "",
  "lambda": "",
  "lang": "",
  "langd": "",
  "langle": "",
  "lap": "",
  "laquo": "",
  "larr": "",
  "larrb": "",
  "larrbfs": "",
  "larrfs": "",
  "larrhk": "",
  "larrlp": "",
  "larrpl": "",
  "larrsim": "",
  "larrtl": "",
  "lat": "",
  "latail": "",
  "late": "",
  "lates": "",
  "lbarr": "",
  "lbbrk": "",
  "lbrace": "{",
  "lbrack": "[",
  "lbrke": "",
  "lbrksld": "",
  "lbrkslu": "",
  "lcaron": "",
  "lcedil": "",
  "lceil": "",
  "lcub": "{",
  "lcy": "",
  "ldca": "",
  "ldquo": "",
  "ldquor": "",
  "ldrdhar": "",
  "ldrushar": "",
  "ldsh": "",
  "le": "",
  "leftarrow": "",
  "leftarrowtail": "",
  "leftharpoondown": "",
  "leftharpoonup": "",
  "leftleftarrows": "",
  "leftrightarrow": "",
  "leftrightarrows": "",
  "leftrightharpoons": "",
  "leftrightsquigarrow": "",
  "leftthreetimes": "",
  "leg": "",
  "leq": "",
  "leqq": "",
  "leqslant": "",
  "les": "",
  "lescc": "",
  "lesdot": "",
  "lesdoto": "",
  "lesdotor": "",
  "lesg": "",
  "lesges": "",
  "lessapprox": "",
  "lessdot": "",
  "lesseqgtr": "",
  "lesseqqgtr": "",
  "lessgtr": "",
  "lesssim": "",
  "lfisht": "",
  "lfloor": "",
  "lfr": "",
  "lg": "",
  "lgE": "",
  "lhard": "",
  "lharu": "",
  "lharul": "",
  "lhblk": "",
  "ljcy": "",
  "ll": "",
  "llarr": "",
  "llcorner": "",
  "llhard": "",
  "lltri": "",
  "lmidot": "",
  "lmoust": "",
  "lmoustache": "",
  "lnE": "",
  "lnap": "",
  "lnapprox": "",
  "lne": "",
  "lneq": "",
  "lneqq": "",
  "lnsim": "",
  "loang": "",
  "loarr": "",
  "lobrk": "",
  "longleftarrow": "",
  "longleftrightarrow": "",
  "longmapsto": "",
  "longrightarrow": "",
  "looparrowleft": "",
  "looparrowright": "",
  "lopar": "",
  "lopf": "",
  "loplus": "",
  "lotimes": "",
  "lowast": "",
  "lowbar": "_",
  "loz": "",
  "lozenge": "",
  "lozf": "",
  "lpar": "(",
  "lparlt": "",
  "lrarr": "",
  "lrcorner": "",
  "lrhar": "",
  "lrhard": "",
  "lrm": "",
  "lrtri": "",
  "lsaquo": "",
  "lscr": "",
  "lsh": "",
  "lsim": "",
  "lsime": "",
  "lsimg": "",
  "lsqb": "[",
  "lsquo": "",
  "lsquor": "",
  "lstrok": "",
  "lt": "<",
  "ltcc": "",
  "ltcir": "",
  "ltdot": "",
  "lthree": "",
  "ltimes": "",
  "ltlarr": "",
  "ltquest": "",
  "ltrPar": "",
  "ltri": "",
  "ltrie": "",
  "ltrif": "",
  "lurdshar": "",
  "luruhar": "",
  "lvertneqq": "",
  "lvnE": "",
  "mDDot": "",
  "macr": "",
  "male": "",
  "malt": "",
  "maltese": "",
  "map": "",
  "mapsto": "",
  "mapstodown": "",
  "mapstoleft": "",
  "mapstoup": "",
  "marker": "",
  "mcomma": "",
  "mcy": "",
  "mdash": "",
  "measuredangle": "",
  "mfr": "",
  "mho": "",
  "micro": "",
  "mid": "",
  "midast": "*",
  "midcir": "",
  "middot": "",
  "minus": "",
  "minusb": "",
  "minusd": "",
  "minusdu": "",
  "mlcp": "",
  "mldr": "",
  "mnplus": "",
  "models": "",
  "mopf": "",
  "mp": "",
  "mscr": "",
  "mstpos": "",
  "mu": "",
  "multimap": "",
  "mumap": "",
  "nGg": "",
  "nGt": "",
  "nGtv": "",
  "nLeftarrow": "",
  "nLeftrightarrow": "",
  "nLl": "",
  "nLt": "",
  "nLtv": "",
  "nRightarrow": "",
  "nVDash": "",
  "nVdash": "",
  "nabla": "",
  "nacute": "",
  "nang": "",
  "nap": "",
  "napE": "",
  "napid": "",
  "napos": "",
  "napprox": "",
  "natur": "",
  "natural": "",
  "naturals": "",
  "nbsp": "",
  "nbump": "",
  "nbumpe": "",
  "ncap": "",
  "ncaron": "",
  "ncedil": "",
  "ncong": "",
  "ncongdot": "",
  "ncup": "",
  "ncy": "",
  "ndash": "",
  "ne": "",
  "neArr": "",
  "nearhk": "",
  "nearr": "",
  "nearrow": "",
  "nedot": "",
  "nequiv": "",
  "nesear": "",
  "nesim": "",
  "nexist": "",
  "nexists": "",
  "nfr": "",
  "ngE": "",
  "nge": "",
  "ngeq": "",
  "ngeqq": "",
  "ngeqslant": "",
  "nges": "",
  "ngsim": "",
  "ngt": "",
  "ngtr": "",
  "nhArr": "",
  "nharr": "",
  "nhpar": "",
  "ni": "",
  "nis": "",
  "nisd": "",
  "niv": "",
  "njcy": "",
  "nlArr": "",
  "nlE": "",
  "nlarr": "",
  "nldr": "",
  "nle": "",
  "nleftarrow": "",
  "nleftrightarrow": "",
  "nleq": "",
  "nleqq": "",
  "nleqslant": "",
  "nles": "",
  "nless": "",
  "nlsim": "",
  "nlt": "",
  "nltri": "",
  "nltrie": "",
  "nmid": "",
  "nopf": "",
  "not": "",
  "notin": "",
  "notinE": "",
  "notindot": "",
  "notinva": "",
  "notinvb": "",
  "notinvc": "",
  "notni": "",
  "notniva": "",
  "notnivb": "",
  "notnivc": "",
  "npar": "",
  "nparallel": "",
  "nparsl": "",
  "npart": "",
  "npolint": "",
  "npr": "",
  "nprcue": "",
  "npre": "",
  "nprec": "",
  "npreceq": "",
  "nrArr": "",
  "nrarr": "",
  "nrarrc": "",
  "nrarrw": "",
  "nrightarrow": "",
  "nrtri": "",
  "nrtrie": "",
  "nsc": "",
  "nsccue": "",
  "nsce": "",
  "nscr": "",
  "nshortmid": "",
  "nshortparallel": "",
  "nsim": "",
  "nsime": "",
  "nsimeq": "",
  "nsmid": "",
  "nspar": "",
  "nsqsube": "",
  "nsqsupe": "",
  "nsub": "",
  "nsubE": "",
  "nsube": "",
  "nsubset": "",
  "nsubseteq": "",
  "nsubseteqq": "",
  "nsucc": "",
  "nsucceq": "",
  "nsup": "",
  "nsupE": "",
  "nsupe": "",
  "nsupset": "",
  "nsupseteq": "",
  "nsupseteqq": "",
  "ntgl": "",
  "ntilde": "",
  "ntlg": "",
  "ntriangleleft": "",
  "ntrianglelefteq": "",
  "ntriangleright": "",
  "ntrianglerighteq": "",
  "nu": "",
  "num": "#",
  "numero": "",
  "numsp": "",
  "nvDash": "",
  "nvHarr": "",
  "nvap": "",
  "nvdash": "",
  "nvge": "",
  "nvgt": ">",
  "nvinfin": "",
  "nvlArr": "",
  "nvle": "",
  "nvlt": "<",
  "nvltrie": "",
  "nvrArr": "",
  "nvrtrie": "",
  "nvsim": "",
  "nwArr": "",
  "nwarhk": "",
  "nwarr": "",
  "nwarrow": "",
  "nwnear": "",
  "oS": "",
  "oacute": "",
  "oast": "",
  "ocir": "",
  "ocirc": "",
  "ocy": "",
  "odash": "",
  "odblac": "",
  "odiv": "",
  "odot": "",
  "odsold": "",
  "oelig": "",
  "ofcir": "",
  "ofr": "",
  "ogon": "",
  "ograve": "",
  "ogt": "",
  "ohbar": "",
  "ohm": "",
  "oint": "",
  "olarr": "",
  "olcir": "",
  "olcross": "",
  "oline": "",
  "olt": "",
  "omacr": "",
  "omega": "",
  "omicron": "",
  "omid": "",
  "ominus": "",
  "oopf": "",
  "opar": "",
  "operp": "",
  "oplus": "",
  "or": "",
  "orarr": "",
  "ord": "",
  "order": "",
  "orderof": "",
  "ordf": "",
  "ordm": "",
  "origof": "",
  "oror": "",
  "orslope": "",
  "orv": "",
  "oscr": "",
  "oslash": "",
  "osol": "",
  "otilde": "",
  "otimes": "",
  "otimesas": "",
  "ouml": "",
  "ovbar": "",
  "par": "",
  "para": "",
  "parallel": "",
  "parsim": "",
  "parsl": "",
  "part": "",
  "pcy": "",
  "percnt": "%",
  "period": ".",
  "permil": "",
  "perp": "",
  "pertenk": "",
  "pfr": "",
  "phi": "",
  "phiv": "",
  "phmmat": "",
  "phone": "",
  "pi": "",
  "pitchfork": "",
  "piv": "",
  "planck": "",
  "planckh": "",
  "plankv": "",
  "plus": "+",
  "plusacir": "",
  "plusb": "",
  "pluscir": "",
  "plusdo": "",
  "plusdu": "",
  "pluse": "",
  "plusmn": "",
  "plussim": "",
  "plustwo": "",
  "pm": "",
  "pointint": "",
  "popf": "",
  "pound": "",
  "pr": "",
  "prE": "",
  "prap": "",
  "prcue": "",
  "pre": "",
  "prec": "",
  "precapprox": "",
  "preccurlyeq": "",
  "preceq": "",
  "precnapprox": "",
  "precneqq": "",
  "precnsim": "",
  "precsim": "",
  "prime": "",
  "primes": "",
  "prnE": "",
  "prnap": "",
  "prnsim": "",
  "prod": "",
  "profalar": "",
  "profline": "",
  "profsurf": "",
  "prop": "",
  "propto": "",
  "prsim": "",
  "prurel": "",
  "pscr": "",
  "psi": "",
  "puncsp": "",
  "qfr": "",
  "qint": "",
  "qopf": "",
  "qprime": "",
  "qscr": "",
  "quaternions": "",
  "quatint": "",
  "quest": "?",
  "questeq": "",
  "quot": "\"",
  "rAarr": "",
  "rArr": "",
  "rAtail": "",
  "rBarr": "",
  "rHar": "",
  "race": "",
  "racute": "",
  "radic": "",
  "raemptyv": "",
  "rang": "",
  "rangd": "",
  "range": "",
  "rangle": "",
  "raquo": "",
  "rarr": "",
  "rarrap": "",
  "rarrb": "",
  "rarrbfs": "",
  "rarrc": "",
  "rarrfs": "",
  "rarrhk": "",
  "rarrlp": "",
  "rarrpl": "",
  "rarrsim": "",
  "rarrtl": "",
  "rarrw": "",
  "ratail": "",
  "ratio": "",
  "rationals": "",
  "rbarr": "",
  "rbbrk": "",
  "rbrace": "}",
  "rbrack": "]",
  "rbrke": "",
  "rbrksld": "",
  "rbrkslu": "",
  "rcaron": "",
  "rcedil": "",
  "rceil": "",
  "rcub": "}",
  "rcy": "",
  "rdca": "",
  "rdldhar": "",
  "rdquo": "",
  "rdquor": "",
  "rdsh": "",
  "real": "",
  "realine": "",
  "realpart": "",
  "reals": "",
  "rect": "",
  "reg": "",
  "rfisht": "",
  "rfloor": "",
  "rfr": "",
  "rhard": "",
  "rharu": "",
  "rharul": "",
  "rho": "",
  "rhov": "",
  "rightarrow": "",
  "rightarrowtail": "",
  "rightharpoondown": "",
  "rightharpoonup": "",
  "rightleftarrows": "",
  "rightleftharpoons": "",
  "rightrightarrows": "",
  "rightsquigarrow": "",
  "rightthreetimes": "",
  "ring": "",
  "risingdotseq": "",
  "rlarr": "",
  "rlhar": "",
  "rlm": "",
  "rmoust": "",
  "rmoustache": "",
  "rnmid": "",
  "roang": "",
  "roarr": "",
  "robrk": "",
  "ropar": "",
  "ropf": "",
  "roplus": "",
  "rotimes": "",
  "rpar": ")",
  "rpargt": "",
  "rppolint": "",
  "rrarr": "",
  "rsaquo": "",
  "rscr": "",
  "rsh": "",
  "rsqb": "]",
  "rsquo": "",
  "rsquor": "",
  "rthree": "",
  "rtimes": "",
  "rtri": "",
  "rtrie": "",
  "rtrif": "",
  "rtriltri": "",
  "ruluhar": "",
  "rx": "",
  "sacute": "",
  "sbquo": "",
  "sc": "",
  "scE": "",
  "scap": "",
  "scaron": "",
  "sccue": "",
  "sce": "",
  "scedil": "",
  "scirc": "",
  "scnE": "",
  "scnap": "",
  "scnsim": "",
  "scpolint": "",
  "scsim": "",
  "scy": "",
  "sdot": "",
  "sdotb": "",
  "sdote": "",
  "seArr": "",
  "searhk": "",
  "searr": "",
  "searrow": "",
  "sect": "",
  "semi": ";",
  "seswar": "",
  "setminus": "",
  "setmn": "",
  "sext": "",
  "sfr": "",
  "sfrown": "",
  "sharp": "",
  "shchcy": "",
  "shcy": "",
  "shortmid": "",
  "shortparallel": "",
  "shy": "",
  "sigma": "",
  "sigmaf": "",
  "sigmav": "",
  "sim": "",
  "simdot": "",
  "sime": "",
  "simeq": "",
  "simg": "",
  "simgE": "",
  "siml": "",
  "simlE": "",
  "simne": "",
  "simplus": "",
  "simrarr": "",
  "slarr": "",
  "smallsetminus": "",
  "smashp": "",
  "smeparsl": "",
  "smid": "",
  "smile": "",
  "smt": "",
  "smte": "",
  "smtes": "",
  "softcy": "",
  "sol": "/",
  "solb": "",
  "solbar": "",
  "sopf": "",
  "spades": "",
  "spadesuit": "",
  "spar": "",
  "sqcap": "",
  "sqcaps": "",
  "sqcup": "",
  "sqcups": "",
  "sqsub": "",
  "sqsube": "",
  "sqsubset": "",
  "sqsubseteq": "",
  "sqsup": "",
  "sqsupe": "",
  "sqsupset": "",
  "sqsupseteq": "",
  "squ": "",
  "square": "",
  "squarf": "",
  "squf": "",
  "srarr": "",
  "sscr": "",
  "ssetmn": "",
  "ssmile": "",
  "sstarf": "",
  "star": "",
  "starf": "",
  "straightepsilon": "",
  "straightphi": "",
  "strns": "",
  "sub": "",
  "subE": "",
  "subdot": "",
  "sube": "",
  "subedot": "",
  "submult": "",
  "subnE": "",
  "subne": "",
  "subplus": "",
  "subrarr": "",
  "subset": "",
  "subseteq": "",
  "subseteqq": "",
  "subsetneq": "",
  "subsetneqq": "",
  "subsim": "",
  "subsub": "",
  "subsup": "",
  "succ": "",
  "succapprox": "",
  "succcurlyeq": "",
  "succeq": "",
  "succnapprox": "",
  "succneqq": "",
  "succnsim": "",
  "succsim": "",
  "sum": "",
  "sung": "",
  "sup1": "",
  "sup2": "",
  "sup3": "",
  "sup": "",
  "supE": "",
  "supdot": "",
  "supdsub": "",
  "supe": "",
  "supedot": "",
  "suphsol": "",
  "suphsub": "",
  "suplarr": "",
  "supmult": "",
  "supnE": "",
  "supne": "",
  "supplus": "",
  "supset": "",
  "supseteq": "",
  "supseteqq": "",
  "supsetneq": "",
  "supsetneqq": "",
  "supsim": "",
  "supsub": "",
  "supsup": "",
  "swArr": "",
  "swarhk": "",
  "swarr": "",
  "swarrow": "",
  "swnwar": "",
  "szlig": "",
  "target": "",
  "tau": "",
  "tbrk": "",
  "tcaron": "",
  "tcedil": "",
  "tcy": "",
  "tdot": "",
  "telrec": "",
  "tfr": "",
  "there4": "",
  "therefore": "",
  "theta": "",
  "thetasym": "",
  "thetav": "",
  "thickapprox": "",
  "thicksim": "",
  "thinsp": "",
  "thkap": "",
  "thksim": "",
  "thorn": "",
  "tilde": "",
  "times": "",
  "timesb": "",
  "timesbar": "",
  "timesd": "",
  "tint": "",
  "toea": "",
  "top": "",
  "topbot": "",
  "topcir": "",
  "topf": "",
  "topfork": "",
  "tosa": "",
  "tprime": "",
  "trade": "",
  "triangle": "",
  "triangledown": "",
  "triangleleft": "",
  "trianglelefteq": "",
  "triangleq": "",
  "triangleright": "",
  "trianglerighteq": "",
  "tridot": "",
  "trie": "",
  "triminus": "",
  "triplus": "",
  "trisb": "",
  "tritime": "",
  "trpezium": "",
  "tscr": "",
  "tscy": "",
  "tshcy": "",
  "tstrok": "",
  "twixt": "",
  "twoheadleftarrow": "",
  "twoheadrightarrow": "",
  "uArr": "",
  "uHar": "",
  "uacute": "",
  "uarr": "",
  "ubrcy": "",
  "ubreve": "",
  "ucirc": "",
  "ucy": "",
  "udarr": "",
  "udblac": "",
  "udhar": "",
  "ufisht": "",
  "ufr": "",
  "ugrave": "",
  "uharl": "",
  "uharr": "",
  "uhblk": "",
  "ulcorn": "",
  "ulcorner": "",
  "ulcrop": "",
  "ultri": "",
  "umacr": "",
  "uml": "",
  "uogon": "",
  "uopf": "",
  "uparrow": "",
  "updownarrow": "",
  "upharpoonleft": "",
  "upharpoonright": "",
  "uplus": "",
  "upsi": "",
  "upsih": "",
  "upsilon": "",
  "upuparrows": "",
  "urcorn": "",
  "urcorner": "",
  "urcrop": "",
  "uring": "",
  "urtri": "",
  "uscr": "",
  "utdot": "",
  "utilde": "",
  "utri": "",
  "utrif": "",
  "uuarr": "",
  "uuml": "",
  "uwangle": "",
  "vArr": "",
  "vBar": "",
  "vBarv": "",
  "vDash": "",
  "vangrt": "",
  "varepsilon": "",
  "varkappa": "",
  "varnothing": "",
  "varphi": "",
  "varpi": "",
  "varpropto": "",
  "varr": "",
  "varrho": "",
  "varsigma": "",
  "varsubsetneq": "",
  "varsubsetneqq": "",
  "varsupsetneq": "",
  "varsupsetneqq": "",
  "vartheta": "",
  "vartriangleleft": "",
  "vartriangleright": "",
  "vcy": "",
  "vdash": "",
  "vee": "",
  "veebar": "",
  "veeeq": "",
  "vellip": "",
  "verbar": "|",
  "vert": "|",
  "vfr": "",
  "vltri": "",
  "vnsub": "",
  "vnsup": "",
  "vopf": "",
  "vprop": "",
  "vrtri": "",
  "vscr": "",
  "vsubnE": "",
  "vsubne": "",
  "vsupnE": "",
  "vsupne": "",
  "vzigzag": "",
  "wcirc": "",
  "wedbar": "",
  "wedge": "",
  "wedgeq": "",
  "weierp": "",
  "wfr": "",
  "wopf": "",
  "wp": "",
  "wr": "",
  "wreath": "",
  "wscr": "",
  "xcap": "",
  "xcirc": "",
  "xcup": "",
  "xdtri": "",
  "xfr": "",
  "xhArr": "",
  "xharr": "",
  "xi": "",
  "xlArr": "",
  "xlarr": "",
  "xmap": "",
  "xnis": "",
  "xodot": "",
  "xopf": "",
  "xoplus": "",
  "xotime": "",
  "xrArr": "",
  "xrarr": "",
  "xscr": "",
  "xsqcup": "",
  "xuplus": "",
  "xutri": "",
  "xvee": "",
  "xwedge": "",
  "yacute": "",
  "yacy": "",
  "ycirc": "",
  "ycy": "",
  "yen": "",
  "yfr": "",
  "yicy": "",
  "yopf": "",
  "yscr": "",
  "yucy": "",
  "yuml": "",
  "zacute": "",
  "zcaron": "",
  "zcy": "",
  "zdot": "",
  "zeetrf": "",
  "zeta": "",
  "zfr": "",
  "zhcy": "",
  "zigrarr": "",
  "zopf": "",
  "zscr": "",
  "zwj": "",
  "zwnj": ""
}

},
"L95YTXfSPIo+UzYLicokHBJYqOXERzIwqqRVituYe40=":
function (require, module, exports, __dirname, __filename) {
module.exports = function pull (a) {
  var length = arguments.length
  if (typeof a === 'function' && a.length === 1) {
    var args = new Array(length)
    for(var i = 0; i < length; i++)
      args[i] = arguments[i]
    return function (read) {
      args.unshift(read)
      return pull.apply(null, args)
    }
  }

  var read = a

  if (read && typeof read.source === 'function') {
    read = read.source
  }

  for (var i = 1; i < length; i++) {
    var s = arguments[i]
    if (typeof s === 'function') {
      read = s(read)
    } else if (s && typeof s === 'object') {
      s.sink(read)
      read = s.source
    }
  }

  return read
}






},
"LMQxJicX49Ft3e9Rk6mjx04nKVIZInlSC0ovJ7iarMk=":
function (require, module, exports, __dirname, __filename) {
/*!
 * word-wrap <https://github.com/jonschlinkert/word-wrap>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 *
 * Adapted from http://james.padolsey.com/javascript/wordwrap-for-javascript/
 * @attribution
 */

module.exports = function(str, options) {
  options = options || {};
  if (str == null) {
    return str;
  }

  var width = options.width || 50;
  var indent = (typeof options.indent === 'string')
    ? options.indent
    : '  ';

  var newline = options.newline || '\n' + indent;

  var re = new RegExp('.{1,' + width + '}(\\s+|$)|\\S+?(\\s+|$)', 'g');

  if (options.cut) {
    re = new RegExp('.{1,' + width + '}', 'g');
  }

  var lines = str.match(re) || [];
  var res = indent + lines.join(newline);

  if (options.trim === true) {
    res = res.replace(/[ \t]*$/gm, '');
  }
  return res;
};

},
"LTjjv1uG8PjDpE+u0OPBJ4Jh5aOxbTlBAN7hA+lR5W0=":
function (require, module, exports, __dirname, __filename) {
module.exports = rimraf
rimraf.sync = rimrafSync

var assert = require("assert")
var path = require("path")
var fs = require("fs")

// for EMFILE handling
var timeout = 0
exports.EMFILE_MAX = 1000
exports.BUSYTRIES_MAX = 3

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  defaults(options)

  if (!cb) throw new Error("No callback passed to rimraf()")

  var busyTries = 0
  rimraf_(p, options, function CB (er) {
    if (er) {
      if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY") &&
          busyTries < exports.BUSYTRIES_MAX) {
        busyTries ++
        var time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(function () {
          rimraf_(p, options, CB)
        }, time)
      }

      // this one won't happen if graceful-fs is used.
      if (er.code === "EMFILE" && timeout < exports.EMFILE_MAX) {
        return setTimeout(function () {
          rimraf_(p, options, CB)
        }, timeout ++)
      }

      // already gone
      if (er.code === "ENOENT") er = null
    }

    timeout = 0
    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.unlink(p, function (er) {
    if (er) {
      if (er.code === "ENOENT")
        return cb(null)
      if (er.code === "EPERM")
        return (isWindows)
          ? fixWinEPERM(p, options, er, cb)
          : rmdir(p, options, er, cb)
      if (er.code === "EISDIR")
        return rmdir(p, options, er, cb)
    }
    return cb(er)
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, 666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, 666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p)
  assert(options)

  try {
    options.unlinkSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "EPERM")
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    if (er.code !== "EISDIR")
      throw er
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })
  options.rmdirSync(p, options)
}

},
"LiOnuzi4/BU48BjvK+3W7ivMOMV/Bj/UOVuqRv8jM74=":
function (require, module, exports, __dirname, __filename) {
var wrappy = require('wrappy')
var reqs = Object.create(null)
var once = require('once')

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)
    for (var i = 0; i < len; i++) {
      cbs[i].apply(null, args)
    }
    if (cbs.length > len) {
      // added more in the interim.
      // de-zalgo, just in case, but don't call again.
      cbs.splice(0, len)
      process.nextTick(function () {
        RES.apply(null, args)
      })
    } else {
      delete reqs[key]
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}

},
"LxnHm5ibtd2DEXFCkxKC2J4C+AKlyJpgEo/GuuLsFzw=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "nbsp": "",
  "iexcl": "",
  "cent": "",
  "pound": "",
  "curren": "",
  "yen": "",
  "brvbar": "",
  "sect": "",
  "uml": "",
  "copy": "",
  "ordf": "",
  "laquo": "",
  "not": "",
  "shy": "",
  "reg": "",
  "macr": "",
  "deg": "",
  "plusmn": "",
  "sup2": "",
  "sup3": "",
  "acute": "",
  "micro": "",
  "para": "",
  "middot": "",
  "cedil": "",
  "sup1": "",
  "ordm": "",
  "raquo": "",
  "frac14": "",
  "frac12": "",
  "frac34": "",
  "iquest": "",
  "Agrave": "",
  "Aacute": "",
  "Acirc": "",
  "Atilde": "",
  "Auml": "",
  "Aring": "",
  "AElig": "",
  "Ccedil": "",
  "Egrave": "",
  "Eacute": "",
  "Ecirc": "",
  "Euml": "",
  "Igrave": "",
  "Iacute": "",
  "Icirc": "",
  "Iuml": "",
  "ETH": "",
  "Ntilde": "",
  "Ograve": "",
  "Oacute": "",
  "Ocirc": "",
  "Otilde": "",
  "Ouml": "",
  "times": "",
  "Oslash": "",
  "Ugrave": "",
  "Uacute": "",
  "Ucirc": "",
  "Uuml": "",
  "Yacute": "",
  "THORN": "",
  "szlig": "",
  "agrave": "",
  "aacute": "",
  "acirc": "",
  "atilde": "",
  "auml": "",
  "aring": "",
  "aelig": "",
  "ccedil": "",
  "egrave": "",
  "eacute": "",
  "ecirc": "",
  "euml": "",
  "igrave": "",
  "iacute": "",
  "icirc": "",
  "iuml": "",
  "eth": "",
  "ntilde": "",
  "ograve": "",
  "oacute": "",
  "ocirc": "",
  "otilde": "",
  "ouml": "",
  "divide": "",
  "oslash": "",
  "ugrave": "",
  "uacute": "",
  "ucirc": "",
  "uuml": "",
  "yacute": "",
  "thorn": "",
  "yuml": "",
  "fnof": "",
  "Alpha": "",
  "Beta": "",
  "Gamma": "",
  "Delta": "",
  "Epsilon": "",
  "Zeta": "",
  "Eta": "",
  "Theta": "",
  "Iota": "",
  "Kappa": "",
  "Lambda": "",
  "Mu": "",
  "Nu": "",
  "Xi": "",
  "Omicron": "",
  "Pi": "",
  "Rho": "",
  "Sigma": "",
  "Tau": "",
  "Upsilon": "",
  "Phi": "",
  "Chi": "",
  "Psi": "",
  "Omega": "",
  "alpha": "",
  "beta": "",
  "gamma": "",
  "delta": "",
  "epsilon": "",
  "zeta": "",
  "eta": "",
  "theta": "",
  "iota": "",
  "kappa": "",
  "lambda": "",
  "mu": "",
  "nu": "",
  "xi": "",
  "omicron": "",
  "pi": "",
  "rho": "",
  "sigmaf": "",
  "sigma": "",
  "tau": "",
  "upsilon": "",
  "phi": "",
  "chi": "",
  "psi": "",
  "omega": "",
  "thetasym": "",
  "upsih": "",
  "piv": "",
  "bull": "",
  "hellip": "",
  "prime": "",
  "Prime": "",
  "oline": "",
  "frasl": "",
  "weierp": "",
  "image": "",
  "real": "",
  "trade": "",
  "alefsym": "",
  "larr": "",
  "uarr": "",
  "rarr": "",
  "darr": "",
  "harr": "",
  "crarr": "",
  "lArr": "",
  "uArr": "",
  "rArr": "",
  "dArr": "",
  "hArr": "",
  "forall": "",
  "part": "",
  "exist": "",
  "empty": "",
  "nabla": "",
  "isin": "",
  "notin": "",
  "ni": "",
  "prod": "",
  "sum": "",
  "minus": "",
  "lowast": "",
  "radic": "",
  "prop": "",
  "infin": "",
  "ang": "",
  "and": "",
  "or": "",
  "cap": "",
  "cup": "",
  "int": "",
  "there4": "",
  "sim": "",
  "cong": "",
  "asymp": "",
  "ne": "",
  "equiv": "",
  "le": "",
  "ge": "",
  "sub": "",
  "sup": "",
  "nsub": "",
  "sube": "",
  "supe": "",
  "oplus": "",
  "otimes": "",
  "perp": "",
  "sdot": "",
  "lceil": "",
  "rceil": "",
  "lfloor": "",
  "rfloor": "",
  "lang": "",
  "rang": "",
  "loz": "",
  "spades": "",
  "clubs": "",
  "hearts": "",
  "diams": "",
  "quot": "\"",
  "amp": "&",
  "lt": "<",
  "gt": ">",
  "OElig": "",
  "oelig": "",
  "Scaron": "",
  "scaron": "",
  "Yuml": "",
  "circ": "",
  "tilde": "",
  "ensp": "",
  "emsp": "",
  "thinsp": "",
  "zwnj": "",
  "zwj": "",
  "lrm": "",
  "rlm": "",
  "ndash": "",
  "mdash": "",
  "lsquo": "",
  "rsquo": "",
  "sbquo": "",
  "ldquo": "",
  "rdquo": "",
  "bdquo": "",
  "dagger": "",
  "Dagger": "",
  "permil": "",
  "lsaquo": "",
  "rsaquo": "",
  "euro": ""
}

},
"M2waEw6vcov0DK2BRKoWlCliMH8ZJJjGMyHW/1nZqqw=":
function (require, module, exports, __dirname, __filename) {
/*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports)
    module.exports = definition()
  else
    context[name] = definition()
})('prr', this, function() {

  var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
          Object.defineProperty(obj, key, options)
          return obj
        }
      : function (obj, key, options) { // < es5
          obj[key] = options.value
          return obj
        }

    , makeOptions = function (value, options) {
        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
              return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
            }

        return {
            enumerable   : op('enumerable')
          , configurable : op('configurable')
          , writable     : op('writable')
          , value        : value
        }
      }

    , prr = function (obj, key, value, options) {
        var k

        options = makeOptions(value, options)

        if (typeof key == 'object') {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k]
              setProperty(obj, k, options)
            }
          }
          return obj
        }

        return setProperty(obj, key, options)
      }

  return prr
})
},
"MPt8C16/vEjBz4HvZWE4nL0TRrByiC2xv/wtHIxN044=":
function (require, module, exports, __dirname, __filename) {

module.exports = function endable (goodbye) {
  var ended, waiting, sentEnd
  function h (read) {
    return function (abort, cb) {
      read(abort, function (end, data) {
        if(end && !sentEnd) {
          sentEnd = true
          return cb(null, goodbye)
        }
        //send end message...

        if(end && ended) cb(end)
        else if(end)     waiting = cb
        else             cb(null, data)
      })
    }
  }
  h.end = function () {
    ended = true
    if(waiting) waiting(ended)
    return h
  }
  return h
}


},
"MQVuDgrI76qntvQrqUTYlK4JBM1Gi8RGICgtMySbaog=":
function (require, module, exports, __dirname, __filename) {
//
// generic comparator implementations our types can use
//
var collation = exports

//
// scalar comparisons
//
collation.inequality = function (a, b) {
  return a < b ? -1 : ( a > b ? 1 : 0 )
}

collation.difference = function (a, b) {
  return a - b
}

//
// recursive collations have to be provided a collation function to delegate to
//
collation.recursive = {}

//
// element by element (comparison for list-like structures
//
collation.recursive.elementwise = function (compare, shortlex) {
  return function (a, b) {
    var aLength = a.length
    var bLength = b.length
    var difference

    //
    // short-circuit on length difference for shortlex semantics
    //
    if (shortlex && aLength !== bLength)
        return aLength - bLength

    for (var i = 0, length = Math.min(aLength, bLength); i < length; ++i) {
      if (difference = compare(a[i], b[i]))
        return difference
    }

    return aLength - bLength
  }
}

//
// field by field comparison of record-like structures
//
collation.recursive.fieldwise = function (compare, shortlex) {
  return function (a, b) {
    var aKeys = Object.keys(a)
    var bKeys = Object.keys(b)
    var aLength = aKeys.length
    var bLength = bKeys.length
    var difference

    //
    // short-circuit on length difference for shortlex semantics
    //
    if (shortlex && aLength !== bLength)
        return aLength - bLength

    for (var i = 0, length = Math.min(aLength, bLength); i < length; ++i) {
      //
      // first compare keys
      //
      if (difference = compare(aKeys[i], bKeys[i]))
        return difference

      //
      // then compare values
      //
      if (difference = compare(a[aKeys[i]], b[bKeys[i]]))
        return difference
    }

    return aLength - bLength
  }
}

//
// elementwise compare with inequality can be used for binary equality
//
collation.bitwise = collation.recursive.elementwise(exports.inequality)


},
"MZNAuf/Vk6btL7qAEyf1tKcUS0ojiXtWJ1bT9eyhPic=":
function (require, module, exports, __dirname, __filename) {
var maybeCallback = require("continuable/maybe-callback")

module.exports = maybeCallback(list)

//  list := (tasks:Array<Continuable<T>>)
//      => Continuable<Array<T>>
function list(tasks) {
    return function continuable(callback) {
        var result = []
        var count = 0

        if (tasks.length === 0) {
            return callback(null, result)
        }

        tasks.forEach(function invokeSource(source, index) {
            source(function continuation(err, value) {
                if (err && result) {
                    result = null
                    callback(err)
                } else if (!err && result) {
                    result[index] = value
                    if (++count === tasks.length) {
                        callback(null, result)
                    }
                }
            })
        })
    }
}

},
"MjvLr/xOseyqvTTmpIHI8bgRJsCpKTL5QuFJFStCwCs=":
function (require, module, exports, __dirname, __filename) {
// both := (Continuable) => Continuable<[Error, Any]>
module.exports = both

function both(source) {
    return function continuable(callback) {
        source(function (err, value) {
            callback(null, [err || null, value])
        })
    }
}

},
"N8LjoCvPlTO60kSpIIp1FXFWfnpbaIelthGBLQKWoC4=":
function (require, module, exports, __dirname, __filename) {

var sodium = require('chloride')
var crypto = require('crypto')
var scalarmult = sodium.crypto_scalarmult
var box  = sodium.crypto_box_easy
var secretbox = sodium.crypto_secretbox_easy
var secretbox_open = sodium.crypto_secretbox_open_easy
var keypair = sodium.crypto_box_keypair
var concat = Buffer.concat

function randombytes(n) {
  return crypto.randomBytes(n)
}

const MAX = 7

exports.multibox = function (msg, recipients) {

  if(recipients.length > MAX)
    throw new Error('max recipients is:'+MAX+' found:'+recipients.length)

  var nonce = randombytes(24)
  var key = randombytes(32)
  var onetime = keypair()

  var _key = concat([new Buffer([recipients.length & MAX]), key])
  return concat([
    nonce,
    onetime.publicKey,
    concat(recipients.map(function (r_pk, i) {
      return secretbox(_key, nonce, scalarmult(onetime.secretKey, r_pk))
    })),
    secretbox(msg, nonce, key)
  ])
}

function get_key(ctxt, my_key) {

}

exports.multibox_open = function (ctxt, sk) { //, groups...

  var nonce = ctxt.slice(0, 24)
  var onetime_pk = ctxt.slice(24, 24+32)
  var my_key = scalarmult(sk, onetime_pk)
  var _key, key, length, start = 24+32, size = 32+1+16
  for(var i = 0; i <= MAX; i++) {
    var s = start+size*i
    if(s + size > (ctxt.length - 16)) continue
    _key = secretbox_open(ctxt.slice(s, s + size), nonce, my_key)
    if(_key) {
      length = _key[0]
      key = _key.slice(1)
      continue
    }
  }

  if(!key) return
  return secretbox_open(ctxt.slice(start+length*size), nonce, key)
}

},
"N8f/jIHdxf2l5Qph+qBh6oc5h7KzLv8Sy7rl2ZlbXQc=":
function (require, module, exports, __dirname, __filename) {

var level = require('level')
var sublevel = require('level-sublevel/bytewise')
var opts = require('./defaults')
var SSB = require('./')

module.exports = function (path, opts, keys) {
  opts = opts || require('./defaults')
  return SSB(
    sublevel(level(path, {
      valueEncoding: opts.codec
    })), opts, keys)
}

},
"NTk6rNF2KaxspTPm2FuaEhe+GLQf12wOpIeatNSqwYg=":
function (require, module, exports, __dirname, __filename) {
//
// extend core typewise
//
require('./collation')

module.exports = require('typewise-core/base')

},
"NiilpOW06Z8s3QFV4KAPadHb3+SjjljNaSnowOkYu7k=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/**
 * Get the count of the longest repeating streak of
 * `character` in `value`.
 *
 * @example
 *   longestStreak('` foo `` bar `', '`') // 2
 *
 * @param {string} value - Content, coerced to string.
 * @param {string} character - Single character to look
 *   for.
 * @return {number} - Number of characters at the place
 *   where `character` occurs in its longest streak in
 *   `value`.
 * @throws {Error} - when `character` is not a single
 *   character.
 */
function longestStreak(value, character) {
    var count = 0;
    var maximum = 0;
    var index = -1;
    var length;

    value = String(value);
    length = value.length;

    if (typeof character !== 'string' || character.length !== 1) {
        throw new Error('Expected character');
    }

    while (++index < length) {
        if (value.charAt(index) === character) {
            count++;

            if (count > maximum) {
                maximum = count;
            }
        } else {
            count = 0;
        }
    }

    return maximum;
}

/*
 * Expose.
 */

module.exports = longestStreak;

},
"NrgusNWSj+tC7T7mjNi3av4lHuSRS1RjTi0Miewg8Vo=":
function (require, module, exports, __dirname, __filename) {
exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = require("path")
var minimatch = require("minimatch")
var isAbsolute = require("path-is-absolute")
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  self.cwdAbs = makeAbs(self, self.cwd)
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

},
"O3u8m0ktqGMfJKI7Vof4O4v8UpFgpqewAc8X5/68m6Y=":
function (require, module, exports, __dirname, __filename) {
var color = require('bash-color')

// logging plugin
// subscribes to 'log:*' events
// and emits using lovely colors

var LOG_LEVELS = [
  'error',
  'warning',
  'notice',
  'info'
]
var DEFAULT_LEVEL = LOG_LEVELS.indexOf('notice')

function indent (o) {
  return o.split('\n').map(function (e) {
    return '  ' + e
  }).join('\n')
}

function isString(s) {
  return 'string' === s
}

function formatter(id, level) {
  var b = id.substring(0, 4)
  return function (ary) {
    var plug = ary[0].substring(0, 4).toUpperCase()
    var id = ary[1]
    var verb = ary[2]
    var data = ary.length > 4 ? ary.slice(3) : ary[3]
    var _data = (isString(data) ? data : JSON.stringify(data)) || ''

    var pre = [plug, id, color.cyan(verb)].join(' ')
    var length = (5 + pre.length + 1 + _data.length)
    var lines = isString(data) && data.split('\n').length > 1

    var c = process.stdout.columns
    if((process.stdout.columns > length) && !lines)
      console.log([level, b, pre, _data].join(' '))
    else {
      console.log([level, b, pre].join(' '))
      if(lines)
        console.log(indent(data))
      else if(data && data.stack)
        console.log(indent(data.stack))
      else if(data) {
        console.log(indent(JSON.stringify(data, null, 2)))
      }
    }
  }
}

module.exports = function logging (server, conf) {
  var level = conf.logging && conf.logging.level && LOG_LEVELS.indexOf(conf.logging.level) || DEFAULT_LEVEL
  if (level === -1) {
    console.log('Warning, logging.level configured to an invalid value:', conf.logging.level)
    console.log('Should be one of:', LOG_LEVELS.join(', '))
    level = DEFAULT_LEVEL
  }
  console.log('Log level:', LOG_LEVELS[level])

  var id = server.id
  if (level >= LOG_LEVELS.indexOf('info'))
    server.on('log:info',    formatter(id, color.green('info')))
  if (level >= LOG_LEVELS.indexOf('notice'))
    server.on('log:notice',  formatter(id, color.blue('note')))
  if (level >= LOG_LEVELS.indexOf('warning'))
    server.on('log:warning', formatter(id, color.yellow('warn')))
  if (level >= LOG_LEVELS.indexOf('error'))
    server.on('log:error',   formatter(id, color.red('err!')))
}

module.exports.init = module.exports

},
"OCUK+m/XMENrewhaAdti/9mYmufhgZNjVKR+LehBuNs=":
function (require, module, exports, __dirname, __filename) {
var pull     = require('pull-stream')
var toPull   = require('stream-to-pull-stream')
var pushable = require('pull-pushable')
var cat      = require('pull-cat')
var pw       = require('pull-window')
var post     = require('level-post')

function read(db, opts) {
  return toPull.read1(db.createReadStream(opts))
}

var live =
exports.live =
function (db, opts) {
  opts = opts || {}

  var l = pushable()

  var cleanup = post(db, opts, function (ch) {
    if(opts.keys === false)
      l.push(ch.value)
    else if(opts.values === false)
      l.push(ch.key)
    else
      l.push(ch)
  })

  return pull(l, pull.through(null, cleanup))

}

exports.read =
exports.readStream =
exports.createReadStream = function (db, opts) {
  opts = opts || {}
  if(!(opts.tail || opts.live))
    return read(db, opts)

  //optionally notify when we switch from reading history to realtime
  var sync = opts.onSync && function (abort, cb) {
      opts.onSync(abort); cb(abort || true)
    }

  return cat([read(db, opts), sync, live(db, opts)])
}

exports.write =
exports.writeStream =
exports.createWriteStream = function (db, opts, done) {
  if('function' === typeof opts)
    done = opts, opts = null
  opts = opts || {}
  return pull(
    pull.map(function (e) {
      if(e.type) return e
      return {
        key   : e.key, 
        value : e.value,
        type  : e.value == null ? 'del' : 'put'
      }
    }),
    pw.recent(opts.windowSize, opts.windowTime),
    pull.asyncMap(function (batch, cb) {
      db.batch(batch, cb)
    }),
    pull.drain(null, done)
  )
}


},
"OI4ldP9EFYFcCUmfhlS7Q4KHkjeiYfJ5lEewbwvxQ0E=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var createError   = require('errno').create
  , LevelUPError  = createError('LevelUPError')
  , NotFoundError = createError('NotFoundError', LevelUPError)

NotFoundError.prototype.notFound = true
NotFoundError.prototype.status   = 404

module.exports = {
    LevelUPError        : LevelUPError
  , InitializationError : createError('InitializationError', LevelUPError)
  , OpenError           : createError('OpenError', LevelUPError)
  , ReadError           : createError('ReadError', LevelUPError)
  , WriteError          : createError('WriteError', LevelUPError)
  , NotFoundError       : NotFoundError
  , EncodingError       : createError('EncodingError', LevelUPError)
}

},
"OJC3Y+gKyIbkUu7nAeMXXz1olqbUwuDoqcbylaZ7b6g=":
function (require, module, exports, __dirname, __filename) {
/*!
	strip-json-comments
	Strip comments from JSON. Lets you use comments in your JSON files!
	https://github.com/sindresorhus/strip-json-comments
	by Sindre Sorhus
	MIT License
*/
(function () {
	'use strict';

	function stripJsonComments(str) {
		var currentChar;
		var nextChar;
		var insideString = false;
		var insideComment = false;
		var ret = '';

		for (var i = 0; i < str.length; i++) {
			currentChar = str[i];
			nextChar = str[i + 1];

			if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
				insideString = !insideString;
			}

			if (insideString) {
				ret += currentChar;
				continue;
			}

			if (!insideComment && currentChar + nextChar === '//') {
				insideComment = 'single';
				i++;
			} else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
				insideComment = false;
				i++;
			} else if (insideComment === 'single' && currentChar === '\n') {
				insideComment = false;
			} else if (!insideComment && currentChar + nextChar === '/*') {
				insideComment = 'multi';
				i++;
				continue;
			} else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
				insideComment = false;
				i++;
				continue;
			}

			if (insideComment) {
				continue;
			}

			ret += currentChar;
		}

		return ret;
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = stripJsonComments;
	} else {
		window.stripJsonComments = stripJsonComments;
	}
})();

},
"OWCgfT4DvjogMWRocC8BAVantZuLyjcsL2GZikdZ5mI=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/*
 * Constants.
 */

var WHITE_SPACE_COLLAPSABLE = /\s+/g;
var SPACE = ' ';

/**
 * Replace multiple white-space characters with a single space.
 *
 * @example
 *   collapse(' \t\nbar \nbaz\t'); // ' bar baz '
 *
 * @param {string} value - Value with uncollapsed white-space,
 *   coerced to string.
 * @return {string} - Value with collapsed white-space.
 */
function collapse(value) {
    return String(value).replace(WHITE_SPACE_COLLAPSABLE, SPACE);
}

/*
 * Expose.
 */

module.exports = collapse;

},
"OX9hSq+gLxYQEbVxgKeceVT7ZQFFSC5nfUw6imsdkg0=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "0": "",
  "128": "",
  "130": "",
  "131": "",
  "132": "",
  "133": "",
  "134": "",
  "135": "",
  "136": "",
  "137": "",
  "138": "",
  "139": "",
  "140": "",
  "142": "",
  "145": "",
  "146": "",
  "147": "",
  "148": "",
  "149": "",
  "150": "",
  "151": "",
  "152": "",
  "153": "",
  "154": "",
  "155": "",
  "156": "",
  "158": "",
  "159": ""
}

},
"Oa9cTT4VO6tbR1dj7/CoSgWsf8kuz2ckFSdcssWBtKA=":
function (require, module, exports, __dirname, __filename) {


var cc   = require('./lib/utils')
var join = require('path').join
var deepExtend = require('deep-extend')
var etc = '/etc'
var win = process.platform === "win32"
var home = win
           ? process.env.USERPROFILE
           : process.env.HOME

module.exports = function (name, defaults, argv, parse) {
  if('string' !== typeof name)
    throw new Error('rc(name): name *must* be string')
  if(!argv)
    argv = require('minimist')(process.argv.slice(2))
  defaults = (
      'string' === typeof defaults
    ? cc.json(defaults) : defaults
    ) || {}

  parse = parse || cc.parse

  var env = cc.env(name + '_')

  var configs = [defaults]
  var configFiles = []
  function addConfigFile (file) {
    if (configFiles.indexOf(file) >= 0) return
    var fileConfig = cc.file(file)
    if (fileConfig) {
      configs.push(parse(fileConfig))
      configFiles.push(file)
    }
  }

  // which files do we look at?
  if (!win)
   [join(etc, name, 'config'),
    join(etc, name + 'rc')].forEach(addConfigFile)
  if (home)
   [join(home, '.config', name, 'config'),
    join(home, '.config', name),
    join(home, '.' + name, 'config'),
    join(home, '.' + name + 'rc')].forEach(addConfigFile)
  addConfigFile(cc.find('.'+name+'rc'))
  if (env.config) addConfigFile(env.config)
  if (argv.config) addConfigFile(argv.config)

  return deepExtend.apply(null, configs.concat([
    env,
    argv,
    configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : undefined,
  ]))
}

if(!module.parent) {
  console.log(
    JSON.stringify(module.exports(process.argv[2]), false, 2)
  )
}

},
"Ofp/3pHGnR/xhrB0q5TIvQrTtz5GW+A+PkWMdavBy0o=":
function (require, module, exports, __dirname, __filename) {
var maybeCallback = require("continuable/maybe-callback")

module.exports = maybeCallback(hash)

//  hash := (tasks:Object<String, Continuable<T>>)
//      => Continuable<Object<String, T>>
function hash(tasks) {
    return function continuable(callback) {
        var keys = Object.keys(tasks)
        var count = 0
        var result = {}

        if (keys.length === 0) {
            return callback(null, result)
        }

        keys.forEach(function (key) {
            tasks[key](function (err, value) {
                if (err && result) {
                    result = null
                    callback(err)
                } else if (!err && result) {
                    result[key] = value
                    if (++count === keys.length) {
                        callback(null, result)
                    }
                }
            })
        })
    }
}

},
"OrYNToTYMBilUu07SzPoW1JZ+oG+KL+kXegvMV9CjCc=":
function (require, module, exports, __dirname, __filename) {
var DuplexStream = require('readable-stream/duplex')
  , util         = require('util')


function BufferList (callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == 'function') {
    this._callback = callback

    var piper = function piper (err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function onPipe (src) {
      src.on('error', piper)
    })
    this.on('unpipe', function onUnpipe (src) {
      src.removeListener('error', piper)
    })
  } else {
    this.append(callback)
  }

  DuplexStream.call(this)
}


util.inherits(BufferList, DuplexStream)


BufferList.prototype._offset = function _offset (offset) {
  var tot = 0, i = 0, _t
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length
    if (offset < _t)
      return [ i, offset - tot ]
    tot = _t
  }
}


BufferList.prototype.append = function append (buf) {
  var i = 0
    , newBuf

  if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i])
  } else if (buf instanceof BufferList) {
    // unwrap argument into individual BufferLists
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i])
  } else if (buf != null) {
    // coerce number arguments to strings, since Buffer(number) does
    // uninitialized memory allocation
    if (typeof buf == 'number')
      buf = buf.toString()

    newBuf = Buffer.isBuffer(buf) ? buf : new Buffer(buf)
    this._bufs.push(newBuf)
    this.length += newBuf.length
  }

  return this
}


BufferList.prototype._write = function _write (buf, encoding, callback) {
  this.append(buf)

  if (typeof callback == 'function')
    callback()
}


BufferList.prototype._read = function _read (size) {
  if (!this.length)
    return this.push(null)

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}


BufferList.prototype.end = function end (chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}


BufferList.prototype.get = function get (index) {
  return this.slice(index, index + 1)[0]
}


BufferList.prototype.slice = function slice (start, end) {
  return this.copy(null, 0, start, end)
}


BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != 'number' || srcStart < 0)
    srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length)
    srcEnd = this.length
  if (srcStart >= this.length)
    return dst || new Buffer(0)
  if (srcEnd <= 0)
    return dst || new Buffer(0)

  var copy   = !!dst
    , off    = this._offset(srcStart)
    , len    = srcEnd - srcStart
    , bytes  = len
    , bufoff = (copy && dstStart) || 0
    , start  = off[1]
    , l
    , i

  // copy/slice everything
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy) // slice, just return a full concat
      return Buffer.concat(this._bufs)

    // copy, need to copy individual buffers
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  }

  if (!copy) // a slice, we need something to copy in to
    dst = new Buffer(len)

  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start

    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start)
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      break
    }

    bufoff += l
    bytes -= l

    if (start)
      start = 0
  }

  return dst
}

BufferList.prototype.toString = function toString (encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function consume (bytes) {
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }
  }
  return this
}


BufferList.prototype.duplicate = function duplicate () {
  var i = 0
    , copy = new BufferList()

  for (; i < this._bufs.length; i++)
    copy.append(this._bufs[i])

  return copy
}


BufferList.prototype.destroy = function destroy () {
  this._bufs.length = 0
  this.length = 0
  this.push(null)
}


;(function () {
  var methods = {
      'readDoubleBE' : 8
    , 'readDoubleLE' : 8
    , 'readFloatBE'  : 4
    , 'readFloatLE'  : 4
    , 'readInt32BE'  : 4
    , 'readInt32LE'  : 4
    , 'readUInt32BE' : 4
    , 'readUInt32LE' : 4
    , 'readInt16BE'  : 2
    , 'readInt16LE'  : 2
    , 'readUInt16BE' : 2
    , 'readUInt16LE' : 2
    , 'readInt8'     : 1
    , 'readUInt8'    : 1
  }

  for (var m in methods) {
    (function (m) {
      BufferList.prototype[m] = function (offset) {
        return this.slice(offset, offset + methods[m])[m](0)
      }
    }(m))
  }
}())


module.exports = BufferList

},
"OxrH6ISJxYUK85T47M9jPqLrR9SEojc1uXgKH2NDTHA=":
function (require, module, exports, __dirname, __filename) {
/**
 * Module Dependencies
 */

var slice = [].slice;
var wrap = require('wrap-fn');

/**
 * Expose `Ware`.
 */

module.exports = Ware;

/**
 * Throw an error.
 *
 * @param {Error} error
 */

function fail (err) {
  throw err;
}

/**
 * Initialize a new `Ware` manager, with optional `fns`.
 *
 * @param {Function or Array or Ware} fn (optional)
 */

function Ware (fn) {
  if (!(this instanceof Ware)) return new Ware(fn);
  this.fns = [];
  if (fn) this.use(fn);
}

/**
 * Use a middleware `fn`.
 *
 * @param {Function or Array or Ware} fn
 * @return {Ware}
 */

Ware.prototype.use = function (fn) {
  if (fn instanceof Ware) {
    return this.use(fn.fns);
  }

  if (fn instanceof Array) {
    for (var i = 0, f; f = fn[i++];) this.use(f);
    return this;
  }

  this.fns.push(fn);
  return this;
};

/**
 * Run through the middleware with the given `args` and optional `callback`.
 *
 * @param {Mixed} args...
 * @param {Function} callback (optional)
 * @return {Ware}
 */

Ware.prototype.run = function () {
  var fns = this.fns;
  var ctx = this;
  var i = 0;
  var last = arguments[arguments.length - 1];
  var done = 'function' == typeof last && last;
  var args = done
    ? slice.call(arguments, 0, arguments.length - 1)
    : slice.call(arguments);

  // next step
  function next (err) {
    if (err) return (done || fail)(err);
    var fn = fns[i++];
    var arr = slice.call(args);

    if (!fn) {
      return done && done.apply(null, [null].concat(args));
    }

    wrap(fn, next).apply(ctx, arr);
  }

  next();

  return this;
};

},
"P23qVKyabQwgczTjXPp9kSOS+Opd38HO7X1pA51LTuQ=":
function (require, module, exports, __dirname, __filename) {
module.exports = globSync
globSync.GlobSync = GlobSync

var fs = require('fs')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var Glob = require('./glob.js').Glob
var util = require('util')
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var common = require('./common.js')
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = fs.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this.matches[index][e] = true
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  var abs = this._makeAbs(e)
  if (this.mark)
    e = this._mark(e)

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[this._makeAbs(e)]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true
  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    // lstat failed, doesn't exist
    return null
  }

  var isSym = lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this.matches[index][prefix] = true
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      return false
    }

    if (lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c !== 'DIR')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

},
"P5Sjk+0rMJ4NE3vfN59/AWUdUiOr8/elhZRxx91MBQw=":
function (require, module, exports, __dirname, __filename) {

var pushable = require('pull-pushable')

module.exports = function () {

  var listeners = {}, n = 0

  function notify (msg) {
    for(var k in listeners) listeners[k].push(msg)
  }

  notify.listen = function () {
    var k = ++n
    return listeners[k] = pushable(function () {
      delete listeners[k]
    })
  }

  notify.abort = function (err) {
    for(var k in listeners) listeners[k].end(err)
  }

  notify.end = function () {
    return notify.abort(true)
  }

  return notify
}

},
"PAaTzAYpPRSJewAOLaGmErjMkmyZdxw6kdC1T75dmCE=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var fs   = require('fs')
var ini  = require('ini')
var path = require('path')
var stripJsonComments = require('strip-json-comments')

var parse = exports.parse = function (content) {

  //if it ends in .json or starts with { then it must be json.
  //must be done this way, because ini accepts everything.
  //can't just try and parse it and let it throw if it's not ini.
  //everything is ini. even json with a syntax error.

  if(/^\s*{/.test(content))
    return JSON.parse(stripJsonComments(content))
  return ini.parse(content)

}

var file = exports.file = function () {
  var args = [].slice.call(arguments).filter(function (arg) { return arg != null })

  //path.join breaks if it's a not a string, so just skip this.
  for(var i in args)
    if('string' !== typeof args[i])
      return

  var file = path.join.apply(null, args)
  var content
  try {
    return fs.readFileSync(file,'utf-8')
  } catch (err) {
    return
  }
}

var json = exports.json = function () {
  var content = file.apply(null, arguments)
  return content ? parse(content) : null
}

var env = exports.env = function (prefix, env) {
  env = env || process.env
  var obj = {}
  var l = prefix.length
  for(var k in env) {
    if((k.indexOf(prefix)) === 0) {

      var keypath = k.substring(l).split('__')

      // Trim empty strings from keypath array
      var _emptyStringIndex
      while ((_emptyStringIndex=keypath.indexOf('')) > -1) {
        keypath.splice(_emptyStringIndex, 1)
      }

      var cursor = obj
      keypath.forEach(function _buildSubObj(_subkey,i){

        // (check for _subkey first so we ignore empty strings)
        // (check for cursor to avoid assignment to primitive objects)
        if (!_subkey || typeof cursor !== 'object')
          return

        // If this is the last key, just stuff the value in there
        // Assigns actual value from env variable to final key
        // (unless it's just an empty string- in that case use the last valid key)
        if (i === keypath.length-1)
          cursor[_subkey] = env[k]


        // Build sub-object if nothing already exists at the keypath
        if (cursor[_subkey] === undefined)
          cursor[_subkey] = {}

        // Increment cursor used to track the object at the current depth
        cursor = cursor[_subkey]

      })

    }

  }

  return obj
}

var find = exports.find = function () {
  var rel = path.join.apply(null, [].slice.call(arguments))

  function find(start, rel) {
    var file = path.join(start, rel)
    try {
      fs.statSync(file)
      return file
    } catch (err) {
      if(path.dirname(start) !== start) // root
        return find(path.dirname(start), rel)
    }
  }
  return find(process.cwd(), rel)
}


},
"PZDoywImBDx0kqFuCBJoRMdJKdK18hRBHkLun3eTMJ4=":
function (require, module, exports, __dirname, __filename) {
var u      = require('pull-core')
var sources = require('./sources')
var sinks = require('./sinks')

var prop   = u.prop
var id     = u.id
var tester = u.tester

var map = exports.map =
function (read, map) {
  map = prop(map) || id
  return function (abort, cb) {
    read(abort, function (end, data) {
      try {
      data = !end ? map(data) : null
      } catch (err) {
        return read(err, function () {
          return cb(err)
        })
      }
      cb(end, data)
    })
  }
}

var asyncMap = exports.asyncMap =
function (read, map) {
  if(!map) return read
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    read(null, function (end, data) {
      if(end) return cb(end, data)
      map(data, cb)
    })
  }
}

var paraMap = exports.paraMap =
function (read, map, width) {
  if(!map) return read
  var ended = false, queue = [], _cb

  function drain () {
    if(!_cb) return
    var cb = _cb
    _cb = null
    if(queue.length)
      return cb(null, queue.shift())
    else if(ended && !n)
      return cb(ended)
    _cb = cb
  }

  function pull () {
    read(null, function (end, data) {
      if(end) {
        ended = end
        return drain()
      }
      n++
      map(data, function (err, data) {
        n--

        queue.push(data)
        drain()
      })

      if(n < width && !ended)
        pull()
    })
  }

  var n = 0
  return function (end, cb) {
    if(end) return read(end, cb) //abort
    //continue to read while there are less than 3 maps in flight
    _cb = cb
    if(queue.length || ended)
      pull(), drain()
    else pull()
  }
  return highWaterMark(asyncMap(read, map), width)
}

var filter = exports.filter =
function (read, test) {
  //regexp
  test = tester(test)
  return function next (end, cb) {
    var sync, loop = true
    while(loop) {
      loop = false
      sync = true
      read(end, function (end, data) {
        if(!end && !test(data))
          return sync ? loop = true : next(end, cb)
        cb(end, data)
      })
      sync = false
    }
  }
}

var filterNot = exports.filterNot =
function (read, test) {
  test = tester(test)
  return filter(read, function (e) {
    return !test(e)
  })
}

var through = exports.through =
function (read, op, onEnd) {
  var a = false
  function once (abort) {
    if(a || !onEnd) return
    a = true
    onEnd(abort === true ? null : abort)
  }

  return function (end, cb) {
    if(end) once(end)
    return read(end, function (end, data) {
      if(!end) op && op(data)
      else once(end)
      cb(end, data)
    })
  }
}

var take = exports.take =
function (read, test) {
  var ended = false
  if('number' === typeof test) {
    var n = test; test = function () {
      return n --
    }
  }

  return function (end, cb) {
    if(ended) return cb(ended)
    if(ended = end) return read(ended, cb)

    read(null, function (end, data) {
      if(ended = ended || end) return cb(ended)
      if(!test(data)) {
        ended = true
        read(true, function (end, data) {
          cb(ended, data)
        })
      }
      else
        cb(null, data)
    })
  }
}

var unique = exports.unique = function (read, field, invert) {
  field = prop(field) || id
  var seen = {}
  return filter(read, function (data) {
    var key = field(data)
    if(seen[key]) return !!invert //false, by default
    else seen[key] = true
    return !invert //true by default
  })
}

var nonUnique = exports.nonUnique = function (read, field) {
  return unique(read, field, true)
}

var group = exports.group =
function (read, size) {
  var ended; size = size || 5
  var queue = []

  return function (end, cb) {
    //this means that the upstream is sending an error.
    if(end) return read(ended = end, cb)
    //this means that we read an end before.
    if(ended) return cb(ended)

    read(null, function next(end, data) {
      if(ended = ended || end) {
        if(!queue.length)
          return cb(ended)

        var _queue = queue; queue = []
        return cb(null, _queue)
      }
      queue.push(data)
      if(queue.length < size)
        return read(null, next)

      var _queue = queue; queue = []
      cb(null, _queue)
    })
  }
}

var flatten = exports.flatten = function (read) {
  var _read
  return function (abort, cb) {
    if(_read) nextChunk()
    else      nextStream()

    function nextChunk () {
      _read(null, function (end, data) {
        if(end) nextStream()
        else    cb(null, data)
      })
    }
    function nextStream () {
      read(null, function (end, stream) {
        if(end)
          return cb(end)
        if(Array.isArray(stream) || stream && 'object' === typeof stream)
          stream = sources.values(stream)
        else if('function' != typeof stream)
          throw new Error('expected stream of streams')
        _read = stream
        nextChunk()
      })
    }
  }
}

var prepend =
exports.prepend =
function (read, head) {

  return function (abort, cb) {
    if(head !== null) {
      if(abort)
        return read(abort, cb)
      var _head = head
      head = null
      cb(null, _head)
    } else {
      read(abort, cb)
    }
  }

}

//var drainIf = exports.drainIf = function (op, done) {
//  sinks.drain(
//}

var _reduce = exports._reduce = function (read, reduce, initial) {
  return function (close, cb) {
    if(close) return read(close, cb)
    if(ended) return cb(ended)

    sinks.drain(function (item) {
      initial = reduce(initial, item)
    }, function (err, data) {
      ended = err || true
      if(!err) cb(null, initial)
      else     cb(ended)
    })
    (read)
  }
}

var nextTick = process.nextTick

var highWaterMark = exports.highWaterMark =
function (read, highWaterMark) {
  var buffer = [], waiting = [], ended, ending, reading = false
  highWaterMark = highWaterMark || 10

  function readAhead () {
    while(waiting.length && (buffer.length || ended))
      waiting.shift()(ended, ended ? null : buffer.shift())

    if (!buffer.length && ending) ended = ending;
  }

  function next () {
    if(ended || ending || reading || buffer.length >= highWaterMark)
      return
    reading = true
    return read(ended || ending, function (end, data) {
      reading = false
      ending = ending || end
      if(data != null) buffer.push(data)

      next(); readAhead()
    })
  }

  process.nextTick(next)

  return function (end, cb) {
    ended = ended || end
    waiting.push(cb)

    next(); readAhead()
  }
}

var flatMap = exports.flatMap =
function (read, mapper) {
  mapper = mapper || id
  var queue = [], ended

  return function (abort, cb) {
    if(queue.length) return cb(null, queue.shift())
    else if(ended)   return cb(ended)

    read(abort, function next (end, data) {
      if(end) ended = end
      else {
        var add = mapper(data)
        while(add && add.length)
          queue.push(add.shift())
      }

      if(queue.length) cb(null, queue.shift())
      else if(ended)   cb(ended)
      else             read(null, next)
    })
  }
}


},
"QbBAnlKjGwS4ho0HyZrUU5KmmrwJIm/uHDHweItcF7g=":
function (require, module, exports, __dirname, __filename) {

var sodium = require('libsodium-wrappers')

function I(b) {
  return Buffer.isBuffer(b) ? new Uint8Array(b) : b
}

function B(b) {
  return (b instanceof Uint8Array) ? new Buffer(b) : b
}

function bufferize(fn) {
  if('function' !== typeof fn)
    throw new Error('not a function')
  return function () {
    var args = [].map.call(arguments, I)
    var r =  B(fn.apply(this, args))
    return r
  }
}

function keys (k) {
  return {
    publicKey: B(k.publicKey),
    secretKey: B(k.secretKey || k.privateKey)
  }
}

exports.crypto_sign_seed_keypair = function (seed) {
  return keys(sodium.crypto_sign_seed_keypair(I(seed)))
}

exports.crypto_sign_keypair = function () {
  return keys(sodium.crypto_sign_keypair())
}

exports.crypto_box_keypair = function () {
  return keys(sodium.crypto_box_keypair())
}

;[
  'sign_verify_detached',
  'sign_detached',
  'sign',
  'sign_open',
  'sign_ed25519_pk_to_curve25519',
  'sign_ed25519_sk_to_curve25519',
  'scalarmult',
  'secretbox_easy',
  'secretbox_open_easy',
  'box_easy',
  'box_open_easy',
  'auth',
  'auth_verify',
  'hash'
].forEach(function (name) {
  if(name === 'auth_verify') {
    //this is inconsistent with sign_verify!!
    var fn = bufferize(sodium.crypto_auth_verify)
    exports['crypto_'+name] = function (msg, tok, key) { return fn(msg, tok, key) ? 0 : 1 }
  }
  else
    exports['crypto_'+name] = bufferize(sodium['crypto_'+name])
})

var Sha256 = require('sha.js/sha256')
exports.crypto_hash_sha256 = function (msg) {
  return new Sha256().update(msg).digest()
}

function nullIfThrew (fn) {
  return function () {
    try { return fn.apply(this, [].slice.call(arguments)) }
    catch (err) { return null }
  }
}

exports.crypto_secretbox_open_easy = nullIfThrew(exports.crypto_secretbox_open_easy)
exports.crypto_box_open_easy = nullIfThrew(exports.crypto_box_open_easy)


},
"Qkr+G+EkbtY6snDl3WUkMKM6fM5axK0aigO1ecfPfzU=":
function (require, module, exports, __dirname, __filename) {
var SecretStack = require('secret-stack')
var create     = require('secure-scuttlebutt/create')
var ssbKeys    = require('ssb-keys')
var path       = require('path')
var osenv      = require('osenv')
var mkdirp     = require('mkdirp')
var rimraf     = require('rimraf')
var mdm        = require('mdmanifest')
var cmdAliases = require('./lib/cli-cmd-aliases')
var valid      = require('./lib/validators')
var apidocs    = require('./lib/apidocs.js')

function isString(s) { return 'string' === typeof s }

// create SecretStack definition
var manifest = mdm.manifest(apidocs._)
manifest.usage = 'sync'
var SSB = {
  manifest: manifest,
  permissions: {
    master: {allow: null, deny: null},
    anonymous: {allow: ['createHistoryStream'], deny: null}
  },
  init: function (api, opts) {

    // .temp: use a /tmp data directory
    // (useful for testing)
    if(opts.temp) {
      var name = isString(opts.temp) ? opts.temp : ''+Date.now()
      opts.path = path.join(osenv.tmpdir(), name)
      rimraf.sync(opts.path)
    }

    // load/create secure scuttlebutt data directory
    var dbPath = path.join(opts.path, 'db')
    mkdirp.sync(dbPath)

    if(!opts.keys)
      opts.keys = ssbKeys.generate('ed25519', opts.seed && new Buffer(opts.seed, 'base64'))

    if(!opts.path)
      throw new Error('opts.path *must* be provided, or use opts.temp=name to create a test instance')

    // main interface
    var ssb = create(path.join(opts.path, 'db'), null, opts.keys)
    var feed = ssb.createFeed(opts.keys)
    return {
      id                       : feed.id,
      keys                     : opts.keys,

      usage                    : valid.sync(usage, 'string?|boolean?'),

      publish                  : valid.async(feed.add, 'string|msgContent'),
      add                      : valid.async(ssb.add, 'msg'),
      get                      : valid.async(ssb.get, 'msgId'),

      pre                      : ssb.pre,
      post                     : ssb.post,

      getPublicKey             : ssb.getPublicKey,
      latest                   : ssb.latest,
      getLatest                : valid.async(ssb.getLatest, 'feedId'),
      latestSequence           : valid.async(ssb.latestSequence, 'feedId'),
      createFeed               : ssb.createFeed,
      whoami                   : function () { return { id: feed.id } },
      relatedMessages          : valid.async(ssb.relatedMessages, 'relatedMessagesOpts'),
      query                    : ssb.query,
      createFeedStream         : valid.source(ssb.createFeedStream, 'readStreamOpts?'),
      createHistoryStream      : valid.source(ssb.createHistoryStream, ['createHistoryStreamOpts'], ['feedId', 'number?', 'boolean?']),
      createLogStream          : valid.source(ssb.createLogStream, 'readStreamOpts?'),
      createUserStream         : valid.source(ssb.createUserStream, 'createUserStreamOpts'),
      links                    : valid.source(ssb.links, 'linksOpts'),
      sublevel                 : ssb.sublevel,
      messagesByType           : valid.source(ssb.messagesByType, 'string|messagesByTypeOpts'),
      createWriteStream        : ssb.createWriteStream,
//      createLatestLookupStream : ssb.createLatestLookupStream,
    }
  }
}

// live help RPC method
function usage (cmd) {
  var path = (cmd||'').split('.')
  if ((path[0] && apidocs[path[0]]) || (cmd && apidocs[cmd])) {
    // return usage for the plugin
    cmd = path.slice(1).join('.')
    return mdm.usage(apidocs[path[0]], cmd, { prefix: path[0] })
  }
  if (!cmd) {
    // return usage for all docs
    return Object.keys(apidocs).map(function (name) {
      if (name == '_')
        return mdm.usage(apidocs[name], null, { nameWidth: 20 })

      var text = mdm.usage(apidocs[name], null, { prefix: name, nameWidth: 20 })
      return text.slice(text.indexOf('Commands:') + 10) // skip past the toplevel summary, straight to the cmd list
    }).join('\n\n')
  }
  // toplevel cmd usage
  cmd = cmdAliases[cmd] || cmd
  return mdm.usage(apidocs._, cmd)
}

module.exports = SecretStack({
  appKey: require('./lib/ssb-cap')
})
.use(SSB)


},
"Qu4l//F7UrFHfxoG1dj2ywQrbU0tezhIHB+N1dgocSw=":
function (require, module, exports, __dirname, __filename) {

module.exports = require('sodium-browserify')

},
"R9ZuMFYKxjmmMSPDytmCGNTazrY44ybnKjnA7TKOyJk=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015-2016 Titus Wormer
 * @license MIT
 * @module remark:defaults
 * @version 3.2.2
 * @fileoverview Default values for parse and
 *  stringification settings.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Note that `stringify.entities` is a string.
 */

module.exports = {
    'parse': {
        'position': true,
        'gfm': true,
        'yaml': true,
        'commonmark': false,
        'footnotes': false,
        'pedantic': false,
        'breaks': false
    },
    'stringify': {
        'gfm': true,
        'commonmark': false,
        'entities': 'false',
        'setext': false,
        'closeAtx': false,
        'looseTable': false,
        'spacedTable': true,
        'incrementListMarker': true,
        'fences': false,
        'fence': '`',
        'bullet': '-',
        'listItemIndent': 'tab',
        'rule': '*',
        'ruleSpaces': true,
        'ruleRepetition': 3,
        'strong': '*',
        'emphasis': '_'
    }
};

},
"RfPtNcdFUNPcsuSnAB6CmhEHT3CR8j3Lia/BOoDZqIQ=":
function (require, module, exports, __dirname, __filename) {
var valid = require('muxrpc-validation')
var zerr  = require('zerr')
var ref   = require('ssb-ref')

// errors
var MissingAttr = zerr('Usage', 'Param % must have a .% of type "%"')
var AttrType = zerr('Usage', '.% of param % must be of type "%"')

function isFilter (v) {
  return (v == '@' || v == '%' || v == '&')
}

module.exports = valid({
  msgId: function (v) {
    if (!ref.isMsg(v))
      return 'type'
  },
  feedId: function (v) {
    if (!ref.isFeed(v))
      return 'type'
  },
  blobId: function (v) {
    if (!ref.isBlob(v))
      return 'type'
  },

  msgContent: function (v, n) {
    var err = this.get('object')(v, n)
    if (err) return err
    if (!v.type || typeof v.type != 'string')
      return MissingAttr(n, 'type', 'string')
  },

  msg: function (v, n) {
    var err = this.get('object')(v, n)
    if (err)
      return err
    
    // .content
    var err = this.get('object')(v.content, n)
    if (err) 
      return MissingAttr(n, 'content', 'object')

    // .content.type
    if (!v.content.type || typeof v.content.type != 'string')
      return MissingAttr(n, 'content.type', 'string')

    // .author
    if (!ref.isFeed(v.author))
      return MissingAttr(n, 'author', 'feedId')

    // .sequence
    if (typeof v.sequence != 'number')
      return MissingAttr(n, 'sequence', 'number')

    // .previous
    if (v.sequence > 1 && !ref.isMsg(v.previous))
      return MissingAttr(n, 'previous', 'msgId')
    else if(v.sequence == 1 && v.previous != null)
      return MissingAttr(n, 'previous', 'null')

    // .timestamp
    if (typeof v.timestamp != 'number')
      return MissingAttr(n, 'timestamp', 'number')

    // .hash
    if (v.hash != 'sha256')
      return zerr('Usage', 'Param % must have .hash set to "sha256"')(n)

    // .signature
    if (typeof v.signature != 'string')
      return MissingAttr(n, 'signature', 'string')
  },

  readStreamOpts: function (v, n) {
    var err = this.get('object')(v, n)
    if (err)
      return err

    // .live
    if (v.live && typeof v.live != 'boolean' && typeof v.live != 'number')
      return AttrType(n, 'live', 'boolean')

    // .reverse
    if (v.reverse && typeof v.reverse != 'boolean' && typeof v.reverse != 'number')
      return AttrType(n, 'reverse', 'boolean')

    // .keys
    if (v.keys && typeof v.keys != 'boolean' && typeof v.keys != 'number')
      return AttrType(n, 'keys', 'boolean')

    // .values
    if (v.values && typeof v.values != 'boolean' && typeof v.values != 'number')
      return AttrType(n, 'values', 'boolean')

    // .limit
    if (v.limit && typeof v.limit != 'number')
      return AttrType(n, 'limit', 'number')

    // .fillCache
    if (v.fillCache && typeof v.fillCache != 'boolean' && typeof v.fillCache != 'number')
      return AttrType(n, 'fillCache', 'boolean')
  },

  createHistoryStreamOpts: function (v, n) {
    // .id
    if (!ref.isFeed(v.id))
      return MissingAttr(n, 'id', 'feedId')

    // .seq
    if (v.seq && typeof v.seq != 'number')
      return AttrType(n, 'seq', 'number')

    // .live
    if (v.live && typeof v.live != 'boolean' && typeof v.live != 'number')
      return AttrType(n, 'live', 'boolean')
  },

  createUserStreamOpts: function (v, n) {
    var err = this.get('readStreamOpts')(v, n)
    if (err)
      return err

    // .id
    if (!ref.isFeed(v.id))
      return MissingAttr(n, 'id', 'feedId')
  },

  messagesByTypeOpts: function (v, n) {
    var err = this.get('readStreamOpts')(v, n)
    if (err)
      return err

    // .type
    if (typeof v.type != 'string')
      return MissingAttr(n, 'type', 'string')
  },

  linksOpts: function (v, n) {
    var err = this.get('object')(v, n)
    if (err)
      return err

    // .source
    if (v.source && !ref.isLink(v.source) && !isFilter(v.source))
      return AttrType(n, 'source', 'id|filter')

    // .dest
    if (v.dest && !ref.isLink(v.dest) && !isFilter(v.dest))
      return AttrType(n, 'dest', 'id|filter')

    // .rel
    if (v.rel && typeof v.rel != 'string')
      return AttrType(n, 'rel', 'string')

    // .live
    if (v.live && typeof v.live != 'boolean' && typeof v.live != 'number')
      return AttrType(n, 'live', 'boolean')

    // .reverse
    if (v.reverse && typeof v.reverse != 'boolean' && typeof v.reverse != 'number')
      return AttrType(n, 'reverse', 'boolean')

    // .keys
    if (v.keys && typeof v.keys != 'boolean' && typeof v.keys != 'number')
      return AttrType(n, 'keys', 'boolean')

    // .values
    if (v.values && typeof v.values != 'boolean' && typeof v.values != 'number')
      return AttrType(n, 'values', 'boolean')
  },

  relatedMessagesOpts: function (v, n) {
    var err = this.get('object')(v, n)
    if (err)
      return err

    // .id
    if (!ref.isMsg(v.id))
      return MissingAttr(n, 'id', 'msgId')

    // .rel
    if (v.rel && typeof v.rel != 'string')
      return AttrType(n, 'rel', 'string')

    // .count
    if (v.count && typeof v.count != 'boolean' && typeof v.count != 'number')
      return AttrType(n, 'count', 'boolean')

    // .parent
    if (v.parent && typeof v.parent != 'boolean' && typeof v.parent != 'number')
      return AttrType(n, 'parent', 'boolean')
  },

  isBlockedOpts: function (v, n) {
    var err = this.get('object')(v, n)
    if (err)
      return err

    // .source
    if (v.source && !ref.isFeed(v.source))
      return AttrType(n, 'source', 'feedId')

    // .dest
    if (v.dest && !ref.isFeed(v.dest))
      return AttrType(n, 'dest', 'feedId')
  },

  createFriendStreamOpts: function (v, n) {
    var err = this.get('object')(v, n)
    if (err)
      return err

    // .start
    if (v.start && !ref.isFeed(v.start))
      return AttrType(n, 'start', 'feedId')

    // .graph
    if (v.graph && typeof v.graph != 'string')
      return AttrType(n, 'graph', 'string')

    // .dunbar
    if (v.dunbar && typeof v.dunbar != 'number')
      return AttrType(n, 'dunbar', 'number')

    // .hops
    if (v.hops && typeof v.hops != 'number')
      return AttrType(n, 'hops', 'number')
  }
})

},
"RlPhdIphX7MUYy+8s1d9Iix0VU074O4LrgWpwz7yF+s=":
function (require, module, exports, __dirname, __filename) {


/*
all pull streams have these states:

{
  START: {
    read: READING,
    abort: ABORTING
  },
  READY: {
    read: READING,
    abort: ABORTING
  },
  READING: {
    cb: READY,
    err: ERROR,
    end: END
  },
  ABORTING: {
    cb: END
  },
  ERROR: {},
  END: {}
}

this module takes a collection of pull-streams,
and interleaves their states.
if all the streams have ended, it ends.
If it is in reading state, and one stream goes has READING->cb
it goes into READY

on read, trigger read on every stream in START or READY

on abort, trigger abort on every stream in START or READY

if a stream is in READY, and big stream is in ABORT,
trigger abort

if every stream is in END or ERROR, trigger end or error

could you describe this declaritively or something?
*/

module.exports = function (ary) {

  var capped = !!ary
  var inputs = (ary || []).map(create), i = 0, abort, cb

  function create (stream) {
    return {ready: false, reading: false, ended: false, read: stream, data: null}
  }

  function check () {
    if(!cb) return
    clean()
    var l = inputs.length
    var _cb = cb
    if(l === 0 && (abort || capped)) {
      cb = null; _cb(abort ||  true)
      return
    }

    //scan the inputs to check whether there is one we can use.
    for(var j = 0; j < l; j++) {
      var current = inputs[(i + j) % l]
      if(current.ready && !current.ended) {
        var data = current.data
        current.ready = false
        current.data = null
        i ++; cb = null
        return _cb(null, data)
      }
    }
  }

  function clean () {
    var l = inputs.length
    //iterate backwards so that we can remove items.
    while(l--) {
      if(inputs[l].ended)
        inputs.splice(l, 1)
    }
  }

  function next () {
    var l = inputs.length
    while(l--)
      (function (current) {
        //read the next item if we aren't already
        if(l > inputs.length) throw new Error('this should never happen')
        if(current.reading || current.ended || current.ready) return
        current.reading = true
        var sync = true
        current.read(abort, function next (end, data) {
          current.data = data
          current.ready = true
          current.reading = false

          if(end === true || abort) current.ended = true
          else if(end) abort = current.ended = end
          //check whether we need to abort this stream.
          if(abort && !end) current.read(abort, next)
          if(!sync) check()
        })
        sync = false
      })(inputs[l])

    //scan the feed
    check()
  }

  function read (_abort, _cb) {
    abort = abort || _abort; cb = _cb; next()
  }

  read.add = function (stream) {
    if(!stream) {
      //the stream will now end when all the streams end.
      capped = true
      //we just changed state, so we may need to cb
      return next()
    }
    inputs.push(create(stream))
    next()
  }

  read.cap = function (err) {
    read.add(null)
  }

  return read
}

},
"SFofC9bpbqbfdY9juvX9g0bPGJ5h7/9vwHAb1F73Yxk=":
function (require, module, exports, __dirname, __filename) {

if(process.env.CHLORIDE_JS)
  return module.exports = require('./browser')

try {
  module.exports = require('./bindings')
} catch (err) {
  console.error('error loading sodium bindings:', err.message)
  console.error('falling back to javascript version.')
  module.exports = require('./browser')
}


},
"SgzHYHyCtp8nabeDFLt/quzO1EOBnJL8HcvdClUzNuE=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/*
 * Constants.
 */

var LINE = '\n';

/**
 * Remove final newline characters from `value`.
 *
 * @example
 *   trimTrailingLines('foo\nbar'); // 'foo\nbar'
 *   trimTrailingLines('foo\nbar\n'); // 'foo\nbar'
 *   trimTrailingLines('foo\nbar\n\n'); // 'foo\nbar'
 *
 * @param {string} value - Value with trailing newlines,
 *   coerced to string.
 * @return {string} - Value without trailing newlines.
 */
function trimTrailingLines(value) {
    var index;

    value = String(value);
    index = value.length;

    while (value.charAt(--index) === LINE) { /* empty */ }

    return value.slice(0, index + 1);
}

/*
 * Expose.
 */

module.exports = trimTrailingLines;

},
"TpjKcH6xji3EnvvaQOSp9pm3BnTU7mD46aVYP5wk+YM=":
function (require, module, exports, __dirname, __filename) {
function flat(err) {
  if(!err) return err
  if(err === true) return true
  return {message: err.message, name: err.name, stack: err.stack}
}

module.exports = function (opts) {
  return new PacketStream(opts)
}

function PacketStream (opts) {
  this.ended = false
  this.opts  = opts // must release, may capture `this`

  this._req_counter = 1
  this._requests    = {} // must release, may capture `this`
  this._instreams   = {} // must release, may capture `this`
  this._outstreams  = {} // must release, may capture `this`
  this._closecbs    = [] // must release, may capture `this`
  this._closing     = false
  this._closed      = false
  if (opts.close)
    this._closecbs.push(opts.close)
}

// Sends a single message to the other end
PacketStream.prototype.message = function (obj) {
  this.read({req: 0, stream: false, end: false, value: obj})
}

// Sends a message to the other end, expects an (err, obj) response
PacketStream.prototype.request = function (obj, cb) {
  var rid = this._req_counter++
  var self = this
  this._requests[rid] = function (err, value) {
    delete self._requests[rid]
    cb(err, value)
    self._maybedone()
  }
  this.read({ req:rid, stream: false, end: false, value: obj })
}

// Sends a request to the other end for a stream
PacketStream.prototype.stream = function () {
  var rid = this._req_counter++
  var self = this
  this._outstreams[rid] = new PacketStreamSubstream(rid, this, function() { delete self._outstreams[rid] })
  return this._outstreams[rid]
}

// Marks the packetstream to close when all current IO is finished
PacketStream.prototype.close = function (cb) {
  if(!cb) throw new Error('packet-stream.close *must* have callback')
  if (this._closed)
    return cb()
  this._closecbs.push(cb)
  this._closing = true
  this._maybedone()
}

// Forces immediate close of the PacketStream
// - usually triggered by an `end` packet from the other end
PacketStream.prototype.destroy = function (end) {
  end = end || flat(end)
  this.ended = end

  var err = (end === true)
    ? new Error('unexpected end of parent stream')
    : end

  // force-close all requests and substreams
  var numended = 0
  for (var k in this._requests)   { numended++; this._requests[k](err) }
  for (var k in this._instreams)  { numended++; this._instreams[k].destroy(err) }
  for (var k in this._outstreams) { numended++; this._outstreams[k].destroy(err) }

  //from the perspective of the outside stream it's not an error
  //if the stream was in a state that where end was okay. (no open requests/streams)
  if (numended === 0 && end === true)
    err = null
  this._closing = true
  this._maybedone(err)
}

PacketStream.prototype._maybedone = function (err) {
  if (this._closed || !this._closing)
    return

  // check if all requests and streams finished
  if (Object.keys(this._requests).length !== 0 ||
      Object.keys(this._instreams).length !== 0 ||
      Object.keys(this._outstreams).length !== 0)
    return // not yet

  // close
  this._closed = true
  this._closecbs.forEach(function (cb) { cb(err) })
  this.read(null, err || true)

  // deallocate
  this.opts = null
  this._closecbs.length = 0
  this.read = closedread
}

function closedread (msg) {
  console.error('packet-stream asked to read after closed', msg)
}

// Sends data out to the other end
// - to be overridden by the PacketStream consumer
PacketStream.prototype.read = function (msg) {
  console.error('please overwrite read method to do IO', msg)
}

// Accepts data from the other end
PacketStream.prototype.write = function (msg, end) {
  if (this.ended)
    return

  if (end)                         this.destroy(end)
  else if (msg.req && !msg.stream) this._onrequest(msg)
  else if (msg.req && msg.stream)  this._onstream(msg)
  else                             this._onmessage(msg)
}

// Internal handler of incoming message msgs
PacketStream.prototype._onmessage = function (msg) {
  if (this.opts && 'function' === typeof this.opts.message)
    this.opts.message(msg.value)
}

// Internal handler of incoming request msgs
PacketStream.prototype._onrequest = function (msg) {
  var rid = msg.req*-1
  if(msg.req < 0) {
    // A incoming response
    if (typeof this._requests[rid] == 'function')
      this._requests[rid](
        msg.end ? msg.value: null,
        msg.end ? null : msg.value
      )
  }
  else {
    // An incoming request
    if (this.opts && typeof this.opts.request == 'function') {
      var once = false
      var self = this
      this.opts.request(msg.value, function (err, value) {
        if(once) throw new Error('cb called twice from local api')
        once = true
        if(err) self.read({ value: flat(err), end: true, req: rid })
        else    self.read({ value: value, end: false, req: rid })
        self._maybedone()
      })
    } else {
      if (this.ended) {
        var err = (this.ended === true)
          ? new Error('unexpected end of parent stream')
          : this.ended
        this.read({ value: flat(err), end: true, stream: false, req: rid })
      }
      else
        this.read({ value: {
            message: 'Unable to handle requests',
            name: 'NO_REQUEST_HANDLER', stack: null
          },
          end: true, stream: false, req: rid
        })
      this._maybedone()
    }
  }
}

// Internal handler of incoming stream msgs
PacketStream.prototype._onstream = function (msg) {
  if(msg.req < 0) {
    // Incoming stream data
    var rid = msg.req*-1
    var outs = this._outstreams[rid]
    if (!outs)
      return console.error('no stream for incoming msg', msg)

    if (msg.end) {
      if (outs.writeEnd)
        delete this._outstreams[rid]
      outs.readEnd = true
      outs.read(null, msg.value)
      this._maybedone()
    }
    else
      outs.read(msg.value)
  }
  else {
    // Incoming stream request
    var rid = msg.req
    var ins = this._instreams[rid]

    if (!ins) {
      // New stream
      var self = this
      ins = this._instreams[rid] = new PacketStreamSubstream(rid*-1, this, function() { delete self._instreams[rid] })
      if (this.opts && typeof this.opts.stream == 'function')
        this.opts.stream(ins)
    }

    if (!ins.read)
      return console.error('no .read for stream:', ins.id, 'dropped:', msg)

    if (msg.end) {
      if (ins.writeEnd)
        delete this._instreams[rid]
      ins.readEnd = true
      ins.read(null, msg.value)
      this._maybedone()
    }
    else
      ins.read(msg.value)
  }
}


function PacketStreamSubstream (id, ps, remove) {
  this.id       = id
  this.read     = null // must release, may capture `this`
  this.writeEnd = null
  this.readEnd  = null

  this._ps          = ps     // must release, may capture `this`
  this._remove      = remove // must release, may capture `this`
  this._seq_counter = 1
}

PacketStreamSubstream.prototype.write = function (data, err) {
  if (err) {
    this.writeEnd = err
    var ps = this._ps
    if (ps) {
      ps.read({ req: this.id, stream: true, end: true, value: flat(err) })
      if (this.readEnd)
        this.destroy()
      ps._maybedone()
    }
  }
  else {
    if (this._ps) this._ps.read({ req: this.id, stream: true, end: false, value: data })
  }
}

// Send the `end` message for the substream
PacketStreamSubstream.prototype.end = function (err) {
  this.write(null, flat(err || true))
}

PacketStreamSubstream.prototype.destroy = function (err) {
  if (!this.writeEnd) {
    this.writeEnd = true
    if (!this.readEnd) {
      this.readEnd = true
      try {
        // catch errors to ensure cleanup
        this.read(null, err)
      } catch (e) {
        console.error('Exception thrown by PacketStream substream end handler', e)
        console.error(e.stack)
      }
    }
    this.write(null, err)
  }
  else if (!this.readEnd) {
    this.readEnd = true
    try {
      // catch errors to ensure cleanup
      this.read(null, err)
    } catch (e) {
      console.error('Exception thrown by PacketStream substream end handler', e)
      console.error(e.stack)
    }
  }

  // deallocate
  if (this._ps) {
    this._remove()
    this._remove = null
    this.read = closedread
    this._ps = null
  }
}

},
"TwN904Pbk2x8kf0U+1KbO6uCGct232JweCOA9nSkiw4=":
function (require, module, exports, __dirname, __filename) {
module.exports = rimraf
rimraf.sync = rimrafSync

var assert = require("assert")
var path = require("path")
var fs = require("fs")
var glob = require("glob")

var defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  fs.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, 666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, 666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      fs.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er
      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })
  options.rmdirSync(p, options)
}

},
"U2WijCKGwWcUA6JkyFmVMV2BBkppsRzwhAoaycsp0ys=":
function (require, module, exports, __dirname, __filename) {
var Buffer = require('buffer').Buffer

var proto = {}
  , rex = /write.+/
  , buildFn

buildFn = function(key) {
  var code = '' +
    'return buf.' + key + '(' + ['a', 'b', 'c'].join(',' ) + ')'

  return new Function(['buf', 'a', 'b', 'c'], code)
}

module.exports = proto

for(var key in Buffer.prototype) {
  if(rex.test(key)) {
    proto[key] = buildFn(key)
  }
}

},
"UXIBpQcqu1norAR3+X3cgevzgHnsylA/WGFh9VKvirI=":
function (require, module, exports, __dirname, __filename) {
var sources  = require('./sources')
var sinks    = require('./sinks')
var throughs = require('./throughs')
var u        = require('pull-core')

function isThrough (fun) {
  return fun.type === "Through" || fun.length === 1
}

var exports = module.exports = function pull () {
  var args = [].slice.call(arguments)

  if(isThrough(args[0]))
    return function (read) {
      args.unshift(read)
      return pull.apply(null, args)
    }

  var read = args.shift()
  while(args.length)
    read = args.shift() (read)
  return read
}

for(var k in sources)
  exports[k] = u.Source(sources[k])

for(var k in throughs)
  exports[k] = u.Through(throughs[k])

for(var k in sinks)
  exports[k] = u.Sink(sinks[k])

var maybe = require('./maybe')(exports)

for(var k in maybe)
  exports[k] = maybe[k]

exports.Duplex  = 
exports.Through = exports.pipeable       = u.Through
exports.Source  = exports.pipeableSource = u.Source
exports.Sink    = exports.pipeableSink   = u.Sink



},
"V7ZajPdslcM0uSAxCxMeAYZ+VZEGxAskmB9WAu40vvg=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var EventEmitter = require('events').EventEmitter
var u = require('./util')
var explain = require('explain-error')

function isFunction (f) {
  return 'function' === typeof f
}

function isObject (o) {
  return o && 'object' === typeof o
}

function noop (err) {
  if (err) throw explain(err, 'callback not provided')
}

module.exports = function (path, remoteApi, _remoteCall) {

  var emitter = new EventEmitter()

  function remoteCall(type, name, args) {
    var cb = isFunction (args[args.length - 1]) ? args.pop() : noop
    var value

    try { value = _remoteCall(type, name, args, cb) }
    catch(err) { return u.errorAsStreamOrCb(type, err, cb)}

    return value
  }

  //add all the api methods to emitter recursively
  ;(function recurse (obj, api, path) {
    for(var name in api) (function (name, type) {
      var _path = path ? path.concat(name) : [name]
      obj[name] =
          isObject(type)
        ? recurse({}, type, _path)
        : function () {
            return remoteCall(type, _path, [].slice.call(arguments))
          }
    })(name, api[name])
    return obj
  })(emitter, remoteApi, path)

  //legacy local emit, from when remote emit was supported.
  emitter._emit = emitter.emit

  return emitter
}


},
"VZrm/qFKpUbpXLdOvQa9cQ4RuB8AWEl/R0FQZSTmu6A=":
function (require, module, exports, __dirname, __filename) {

var BufferList = require('bl')

module.exports = function () {

  var bl = new BufferList()

  function get (n) {
    var len = n == null ? bl.length : n
    var data = bl.slice(0, len)
    bl.consume(n)
    return data
  }

  return {
    data: bl,
    add: function (data) {
      bl.append(data)
      return this
    },
    has: function (n) {
      if(n == null) return bl.length > 0
      return bl.length >= n

    },
    get: function (n) {
      if(n == null) return get()
      if(!this.has(n))
        throw new Error(
          'current length is:'+bl.length
          + ', could not get:'+n + ' bytes'
        )
      return get(n)
    }
  }

  var soFar = new Buffer(0)

  return {
    data: soFar,
    add: function (data) {
      if(!Buffer.isBuffer(data))
        throw new Error('data must be a buffer, was: ' + JSON.stringify(data))
      this.data = soFar = Buffer.concat([soFar, data])
      return this
    },
    has: function (n) {
      if(null == n) return soFar.length > 0
      return soFar.length - (n || 0) >= 0
    },
    get: function (n) {
      var next
      if(null == n) {
        next = soFar
        soFar = new Buffer(0)
        return next
      }
      next = soFar.slice(0, n)
      if(soFar.length < n) throw new Error('current length is:'+soFar.length + ', could not get:'+n + ' bytes')
      soFar = soFar.slice(n, soFar.length)
      return next
    }
  }

}

},
"Vb6mMU0vc4x3R8riil6ujf6QXdnLhd83zDfmivCKls8=":
function (require, module, exports, __dirname, __filename) {
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},
"VeEkjVfnqryqbxUNCx17+zBHU1JEsoDbTRoFhNgl6sM=":
function (require, module, exports, __dirname, __filename) {
module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            if (o[key] === undefined) o[key] = {};
            o = o[key];
        });

        var key = keys[keys.length - 1];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /true|false/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


},
"VfDYCpgyAb8hjK+9Wv3YewTxwdW+yg71eiJ23r6jgi4=":
function (require, module, exports, __dirname, __filename) {
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // create the two objects needed to store the corked requests
  // they are not a linked list, as no new elements are inserted in there
  this.corkedRequestsFree = new CorkedRequest(this);
  this.corkedRequestsFree.next = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    state.corkedRequestsFree = holder.next;
    holder.next = null;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
},
"VsEMAVfSnZ+1GDylFAK6HhnhGGV4I2xTkYWxF9t0KgY=":
function (require, module, exports, __dirname, __filename) {

var keys = exports.keys =
function (object) {
  return values(Object.keys(object))
}

var once = exports.once =
function (value) {
  return function (abort, cb) {
    if(abort) return cb(abort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}

var values = exports.values = exports.readArray =
function (array) {
  if(!array)
    return function (abort, cb) {
      return cb(abort || true)
    }
  if(!Array.isArray(array))
    array = Object.keys(array).map(function (k) {
      return array[k]
    })
  var i = 0
  return function (end, cb) {
    if(end)
      return cb && cb(end)
    cb(i >= array.length || null, array[i++])
  }
}


var count = exports.count =
function (max) {
  var i = 0; max = max || Infinity
  return function (end, cb) {
    if(end) return cb && cb(end)
    if(i > max)
      return cb(true)
    cb(null, i++)
  }
}

var infinite = exports.infinite =
function (generate) {
  generate = generate || Math.random
  return function (end, cb) {
    if(end) return cb && cb(end)
    return cb(null, generate())
  }
}

var defer = exports.defer = function () {
  var _read, cbs = [], _end

  var read = function (end, cb) {
    if(!_read) {
      _end = end
      cbs.push(cb)
    } 
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    while(cbs.length)
      _read(_end, cbs.shift())
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}

var empty = exports.empty = function () {
  return function (abort, cb) {
    cb(true)
  }
}

var error = exports.error = function (err) {
  return function (abort, cb) {
    cb(err)
  }
}

var depthFirst = exports.depthFirst =
function (start, createStream) {
  var reads = []

  reads.unshift(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        //if this stream has ended, go to the next queue
        reads.shift()
        return next(null, cb)
      }
      reads.unshift(createStream(data))
      cb(end, data)
    })
  }
}
//width first is just like depth first,
//but push each new stream onto the end of the queue
var widthFirst = exports.widthFirst =
function (start, createStream) {
  var reads = []

  reads.push(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        return next(null, cb)
      }
      reads.push(createStream(data))
      cb(end, data)
    })
  }
}

//this came out different to the first (strm)
//attempt at leafFirst, but it's still a valid
//topological sort.
var leafFirst = exports.leafFirst =
function (start, createStream) {
  var reads = []
  var output = []
  reads.push(once(start))

  return function next (end, cb) {
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        if(!output.length)
          return cb(true)
        return cb(null, output.shift())
      }
      reads.unshift(createStream(data))
      output.unshift(data)
      next(null, cb)
    })
  }
}


},
"Vxc0K5KObuGi8t/7fV9bw76ZJDNNL4NNbupciAiIgGk=":
function (require, module, exports, __dirname, __filename) {
/*!
	strip-json-comments
	Strip comments from JSON. Lets you use comments in your JSON files!
	https://github.com/sindresorhus/strip-json-comments
	by Sindre Sorhus
	MIT License
*/
(function () {
	'use strict';

	var singleComment = 1;
	var multiComment = 2;

	function stripJsonComments(str) {
		var currentChar;
		var nextChar;
		var insideString = false;
		var insideComment = false;
		var ret = '';

		for (var i = 0; i < str.length; i++) {
			currentChar = str[i];
			nextChar = str[i + 1];

			if (!insideComment && currentChar === '"') {
				var escaped = str[i - 1] === '\\' && str[i - 2] !== '\\';
				if (!insideComment && !escaped && currentChar === '"') {
					insideString = !insideString;
				}
			}

			if (insideString) {
				ret += currentChar;
				continue;
			}

			if (!insideComment && currentChar + nextChar === '//') {
				insideComment = singleComment;
				i++;
			} else if (insideComment === singleComment && currentChar + nextChar === '\r\n') {
				insideComment = false;
				i++;
				ret += currentChar;
				ret += nextChar;
				continue;
			} else if (insideComment === singleComment && currentChar === '\n') {
				insideComment = false;
			} else if (!insideComment && currentChar + nextChar === '/*') {
				insideComment = multiComment;
				i++;
				continue;
			} else if (insideComment === multiComment && currentChar + nextChar === '*/') {
				insideComment = false;
				i++;
				continue;
			}

			if (insideComment) {
				continue;
			}

			ret += currentChar;
		}

		return ret;
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = stripJsonComments;
	} else {
		window.stripJsonComments = stripJsonComments;
	}
})();

},
"W6LTmT8UTvH92ky4b8BVj2NvF6KykPKHctl1BcSfXFI=":
function (require, module, exports, __dirname, __filename) {
'use strict';

var contpara  = require('cont').para
var pull      = require('pull-stream')
var pl        = require('pull-level')
var paramap   = require('pull-paramap')
var timestamp = require('monotonic-timestamp')
var assert    = require('assert')
var ltgt      = require('ltgt')
var mlib      = require('ssb-msgs')
var explain   = require('explain-error')
var mynosql   = require('mynosql')
var pdotjson  = require('./package.json')
var createFeed = require('ssb-feed')
var cat       = require('pull-cat')
var mynosql   = require('mynosql')
var ssbref    = require('ssb-ref')
var ssbKeys   = require('ssb-keys')

var Validator = require('ssb-feed/validator')

var isFeedId = ssbref.isFeedId
var isMsgId  = ssbref.isMsgId
var isBlobId = ssbref.isBlobId

//var u         = require('./util')

//53 bit integer
var MAX_INT  = 0x1fffffffffffff

function isNumber (n) {
  return typeof n === 'number'
}

function isString (s) {
  return 'string' === typeof s
}

function isObject (o) {
  return o && 'object' === typeof o && !Array.isArray(o)
}

function all (stream) {
  return function (cb) {
    pull(stream, pull.collect(cb))
  }
}

function compare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0
}

function getVMajor () {
  var version = require('./package.json').version
  return (version.split('.')[0])|0
}

module.exports = function (db, opts, keys) {
  db = mynosql(db)
  var sysDB   = db.sublevel('sys')
  var logDB   = db.sublevel('log')
  var feedDB  = db.sublevel('fd')
  var clockDB = db.sublevel('clk')
  var lastDB  = db.sublevel('lst')
  var indexDB = db.sublevel('idx')
  var appsDB  = db.sublevel('app')

  function get (db, key) {
    return function (cb) { db.get(key, cb) }
  }

  db.opts = opts

  db.add = Validator(db)

  db.pre(function (op, add, _batch) {
    var msg = op.value
    var id = op.key
    // index by sequence number

    add({
      key: [msg.author, msg.sequence], value: id,
      type: 'put', prefix: clockDB
    })

    // index my timestamp, used to generate feed.
    add({
      key: [msg.timestamp, msg.author], value: id,
      type: 'put', prefix: feedDB
    })

    var localtime = op.timestamp = timestamp()

    // index the latest message from each author
    add({
      key: msg.author, value: {sequence: msg.sequence, ts: localtime },
      type: 'put', prefix: lastDB
    })

    // index messages in the order _received_
    // this will be used to pass to plugins which
    // must create their indexes asyncly.

// local time is now handled by 
//    add({
//      key: localtime, value: id,
//      type: 'put', prefix: logDB
//    })

    indexMsg(add, localtime, id, msg)

  })

  function indexMsg (add, localtime, id, msg) {
    //DECRYPT the message, if possible
    //to enable indexing. If external apis
    //are not provided that may access indexes
    //then this will not leak information.
    //otherwise, we may need to figure something out.

    var content = (keys && isString(msg.content))
      ? ssbKeys.unbox(msg.content, keys)
      : msg.content

    if(!content) return

    if(isString(content.type))
      add({
        key: ['type', content.type.toString().substring(0, 32), localtime],
        value: id, type: 'put', prefix: indexDB
      })

    mlib.indexLinks(content, function (obj, rel) {
      add({
        key: ['link', msg.author, rel, obj.link, msg.sequence, id],
        value: obj,
        type: 'put', prefix: indexDB
      })
      add({
        key: ['_link', obj.link, rel, msg.author, msg.sequence, id],
        value: obj,
        type: 'put', prefix: indexDB
      })
    })
  }

  db.createFeed = function (keys) {
    return createFeed(db, keys, opts)
  }

  db.needsRebuild = function (cb) {
    sysDB.get('vmajor', function (err, dbvmajor) {
      dbvmajor = (dbvmajor|0) || 0
      cb(null, dbvmajor < getVMajor())
    })
  }

  db.rebuildIndex = function (cb) {
    // remove all entries from the index
    pull(
      pl.read(indexDB, { keys: true, values: false }),
      paramap(function (key, cb) { indexDB.del(key, cb) }),
      pull.drain(null, next)
    )

    function next (err) {
      if (err)
        return cb(err)

      // replay the log
      pull(
        db.createLogStream({ keys: true, values: true }),
        pull.map(function (msg) {
          var ops = []
          function add (item) { ops.push(item) }
          indexMsg(add, msg.timestamp, msg.key, msg.value)
          return ops
        }),
        pull.flatten(),
        pl.write(indexDB, next2)
      )
      function next2 (err) {
        if (err)
          return cb(err)

        sysDB.put('vmajor', getVMajor(), cb)
      }
    }
  }

  // opts standardized to work like levelup api
  function stdopts (opts) {
    opts = opts || {}
    if (opts.keys !== false)
      opts.keys = true
    if (opts.values !== false)
      opts.values = true
    return opts
  }
  function msgFmt (keys, values, obj) {
    if (keys && values)
      return obj
    if (keys)
      return obj.key
    if (values)
      return obj.value
    return null // i guess?
  }

  //TODO: eventually, this should filter out authors you do not follow.
  db.createFeedStream = function (opts) {
    opts = stdopts(opts)
    ltgt.toLtgt(opts, opts, function (value) {
      return [value, LO]
    }, LO, HI)
    var _keys = opts.keys
    var _values = opts.values
    opts.keys = false
    opts.values = true

    return pull(
      pl.read(feedDB, opts),
      lookup(_keys, _values)
    )
  }

  //latest was stored as author: seq
  //but for the purposes of replication back pressure
  //we need to know when we last replicated with someone.
  //instead store as: {sequence: seq, ts: localtime}
  //then, peers can request a max number of posts per feed.

  function toSeq (latest) {
    return isNumber(latest) ? latest : latest.sequence
  }

  db.latest = function (opts) {
    return pull(
      pl.read(lastDB, opts),
      pull.map(function (data) {
        var d = {id: data.key, sequence: toSeq(data.value), ts: data.value.ts }
        return d
      })
    )
  }

  function lookup(keys, values) {
    return paramap(function (key, cb) {
      if(key.sync) return cb(null, key)
      if(!values) return cb(null, key)
      db.get(key, function (err, msg) {
        if (err) cb(err)
        else cb(null, msgFmt(keys, values, { key: key, value: msg }))
      })
    })
  }

  db.createHistoryStream = function (id, seq, live) {
    var _keys = true, _values = true, limit
    if(!isFeedId(id)) {
      var opts = stdopts(id)
      id       = opts.id
      seq      = opts.sequence || opts.seq || 0
      live     = !!opts.live
      limit    = opts.limit
      _keys    = opts.keys !== false
      _values  = opts.values !== false
    }
    return pull(
      pl.read(clockDB, {
        gte:  [id, seq],
        lte:  [id, MAX_INT],
        live: live,
        keys: false,
        sync: opts && opts.sync,
        limit: limit,
        onAbort: opts && opts.onAbort
      }),
      lookup(_keys, _values)
    )
  }


  db.createUserStream = function (opts) {
    opts = stdopts(opts)
    ltgt.toLtgt(opts, opts, function (value) {
      return [opts.id, value]
    }, LO, HI)
    var _keys = opts.keys
    var _values = opts.values

    opts.keys = false
    opts.values = true
    return pull(
      pl.read(clockDB, opts),
      lookup(_keys, _values)
    )
  }


  //writeStream - used in replication.
  db.createWriteStream = function (cb) {
    return pull(
      paramap(function (data, cb) {
        db.add(data, function (err, msg) {
          db.emit('invalid', err, msg)
          cb()
        })
      }),
      pull.drain(null, cb)
    )
  }

  db.createFeed = function (keys) {
    if(!keys)
      keys = opts.keys.generate()
    return createFeed(db, keys, opts)
  }

  db.latestSequence = function (id, cb) {
    lastDB.get(id, cb)
  }

  db.getLatest = function (id, cb) {
    lastDB.get(id, function (err, v) {
      if(err) return cb(err)
      clockDB.get([id, toSeq(v)], function (err, hash) {
        if(err) return cb(err)
        db.get(hash, function (err, msg) {
          cb(err, {key: hash, value: msg})
        })
      })
    })
  }

  db.createLogStream = function (opts) {
    opts = stdopts(opts)
    var live = opts.live || opts.tail; delete opts.live
    var keys = opts.keys; delete opts.keys
    var values = opts.values; delete opts.values

    var old = pull(
      pl.read(logDB, opts),
      paramap(function (data, cb) {
        if(data.sync) return cb(null, data)
        var key = data.value
        var seq = data.key
        db.get(key, function (err, value) {
          if (err) cb(err)
          else cb(null, msgFmt(keys, values, {key: key, value: value, timestamp: seq}))
        })
      })
    )
    if(!live) return old

    return cat([old, pull.values([{sync: true}]), pl.live(db)])

  }

  var HI = undefined, LO = null

  db.messagesByType = function (opts) {
    if(!opts)
      throw new Error('must provide {type: string} to messagesByType')

    if(isString(opts))
      opts = {type: opts}

    opts = stdopts(opts)
    var _keys   = opts.keys
    var _values = opts.values
    opts.values = true

    ltgt.toLtgt(opts, opts, function (value) {
      return ['type', opts.type, value]
    }, LO, HI)

    return pull(
      pl.read(indexDB, opts),
      paramap(function (data, cb) {
        var id = _keys ? data.value : data
        db.get(id, function (err, msg) {
          var ts = opts.keys ? data.key[2] : undefined
          cb(null, msgFmt(_keys, _values, {key: id, ts: ts, value: msg}))
        })
      }),
      pull.filter()
    )
  }

  function format(opts, op, key, value) {
    var meta = opts.meta !== false  //default: true
    var keys = opts.keys !== false  //default: true
    var vals = opts.values === true //default: false
    if(!meta&&!keys&&!vals)
      throw new Error('a stream without any values does not make sense')
    if(!meta) return (
          keys && vals  ? {key: op.key, value: value}
        : keys          ? op.key
                        : value
      )
    else {
      if(vals)  op.value = value
      if(!keys) delete op.key
      return op
    }
  }

  function type(t) { return {feed: '@', msg: '%', blob: '&'}[t] || t }

  db.links = function (opts) {
    if(!opts) throw new Error('opts *must* be provided')
    opts.meta = opts.meta !== false //default: true
    opts.keys = opts.keys !== false //default: true
    if(!opts.values&&!opts.meta&&!opts.keys)
      throw new Error('makes no sense to return stream without results'
        + 'set at least one of {keys, values, meta} to true')

    function tolink (v) {
      return (ssbref.isLink(v)) ? v : null
    }

    var src = type(opts.source), dst = type(opts.dest), rel = opts.rel

    var back = dst && !src
    var from = back ? dst : src, to = back ? src : dst

    function range(value, end, def) {
      return !value ? def : /^[@%&]$/.test(value) ? value + end : value
    }
    function lo(value) { return range(value, "!", LO) }
    function hi(value) { return range(value, "~", HI) }


    var index = back ? '_link' : 'link'
    var gte = [index, lo(from), rel || LO, lo(to), LO, LO]
    var lte = [index, hi(from), rel || HI, hi(to), HI, HI]

    function testLink (a, e) { //actual, expected
      return e ? e.length === 1 ? a[0]==e[0] : a===e : true
    }

    return pull(
      pl.read(indexDB, { gte: gte, lte: lte, live: opts.live, reverse: opts.reverse }),
      pull.map(function (op) {
        return {
          source: op.key[back?3:1],
          rel: op.key[2],
          dest: op.key[back?1:3],
          key: op.key[5]
        }
      }),
      // in case source and dest are known but not rel,
      // this will scan all links from the source
      // and filter out those to the dest. not efficient
      // but probably a rare query.
      pull.filter(function (data) {
        if(rel && rel !== data.rel) return false
        if(!testLink(data.dest, dst)) return false
        if(!testLink(data.source, src)) return false
        return true
      }),
      ! opts.values
      ? pull.map(function (op) {
          return format(opts, op, op.key, null)
        })
      : paramap(function (op, cb) {
          db.get(op.key, function (err, msg) {
            if(err) return cb(err)
            cb(null, format(opts, op, op.key, msg))
          })
      })
    )
  }

  //get all messages that link to a given message.
  db.relatedMessages = function (opts, cb) {
    if(isString(opts)) opts = {key: opts}
    if(!opts) throw new Error('opts *must* be object')
    var key = opts.id || opts.key

    var n = 1
    var msgs = {key: key, value: null}
    db.get(key, function (err, msg) {
      msgs.value = msg
      if (err && err.notFound)
        err = null // ignore not found
      done(err)
    })

    related(msgs)

    function related (msg) {
      if (n<0) return
      n++
      all(db.links({dest: msg.key, rel: opts.rel, keys: true, values:true, meta: false, type:'msg'}))
      (function (err, ary) {
        if(ary && ary.length) {
          ary.sort(function (a, b) {
            return compare(a.value.timestamp, b.value.timestamp) || compare(a.key, b.key)
          })
          msg.related = ary
          ary.forEach(related)
        }
        done(err)
      })
    }

    function count (msg) {
      if(!msg.related)
        return msg
      var c = 0
      msg.related.forEach(function (_msg) {
        if(opts.parent) _msg.parent = msg.key
        c += 1 + (count(_msg).count || 0)
      })
      if(opts.count) msg.count = c
      return msg
    }

    function done (err) {
      if(err && n > 0) {
        n = -1
        return cb(err)
      }
      if(--n) return
      cb(null, count(msgs))
    }
  }

  return db
}

},
"W9ZK9jX9K5O0exf3Esv3FIc/4ANSX6+V8LGr9UNZi/Y=":
function (require, module, exports, __dirname, __filename) {

var sodium = require('chloride')
var net = require('net')
var toPull = require('stream-to-pull-stream')
var shs = require('./')
var isBuffer = Buffer.isBuffer
var pull = require('pull-stream')
var Defer = require('pull-defer/duplex')

function assertOpts (opts) {
  if(!(opts && 'object' === typeof opts))
    throw new Error('opts *must* be provided')
}
function assertKeys (opts) {
  if(!(
      opts.keys
    && isBuffer(opts.keys.publicKey)
    && isBuffer(opts.keys.secretKey)
  ))
    throw new Error('opts.keys = ed25519 key pair *must* be provided.')
}
function assertAppKey (opts) {
  if(!isBuffer(opts.appKey))
    throw new Error('appKey must be provided')
}

function assertAddr (addr) {
  if(!isBuffer(addr.key))
    throw new Error('opts.key *must* be an ed25519 public key')
  if(!Number.isInteger(+addr.port))
    throw new Error('opts.port *must* be provided')
  if(!('string' === typeof addr.host || null == addr.host))
    throw new Error('opts.host must be string or null')
}

module.exports = function createNode (opts) {
  var keys =
    isBuffer(opts.seed)
    ? sodium.crypto_sign_seed_keypair(opts.seed)
    : opts.keys

  assertOpts(opts); assertKeys({keys: keys}); assertAppKey(opts)

  var create = shs.createClient(keys, opts.appKey, opts.timeout)

  return {
    publicKey: keys.publicKey,
    createServer: function (onConnect) {
      if('function' !== typeof opts.authenticate)
        throw new Error('function opts.authenticate(pub, cb)'
          + '*must* be provided in order to receive connections')
      var createServerStream =
        shs.createServer(keys, opts.authenticate, opts.appKey, opts.timeout)
      var server
      return server = net.createServer(function (stream) {
        stream = toPull.duplex(stream)
        pull(
          stream,
          createServerStream(function (err, stream) {
            if(err) return server.emit('unauthenticated', err)
            onConnect(stream)
          }),
          stream
        )
      })
    },
    connect: function (addr, cb) {
      assertAddr(addr)
      var stream = toPull.duplex(net.connect(addr.port, addr.host))

      if(cb) {
        pull(
          stream,
          create(addr.key, cb),
          stream
        )
      }
      else {

        var defer = Defer()

        pull(
          stream,
          create(addr.key, function (err, stream) {
            if(err)
              defer.resolve({
                source: function (abort, cb) { cb(err) },
                sink: function (read) { read(err, function (){}) }
              })
            else defer.resolve(stream)
          }),
          stream
        )

        return defer

      }
    }
  }
}

},
"WbGGkbXE072ELwpIugZuNTPk/+pFO11qXzmSHyh8Vls=":
function (require, module, exports, __dirname, __filename) {

function isObject(o) {
  return o && 'object' === typeof o
}

var isArray = Array.isArray

function isUndefined (u) {
  return 'undefined' === typeof u
}

var find = exports.find = function find(ary, test) {
  for(var i in ary)
    if(test(ary[i], i, ary)) return ary[i]
}

exports = module.exports = merge
exports.merge = exports

var clone = exports.clone = function clone (obj, mapper) {
  function map(v, k) {
    return isObject(v) ? clone(v, mapper) : mapper(v, k)
  }
  if(isArray(obj))
    return obj.map(map)
  else if(isObject(obj)) {
    var o = {}
    for(var k in obj)
      o[k] = map(obj[k], k)
    return o
  }
  else
    return map(obj)
}

var mergeKeys = exports.mergeKeys = function (a, b, iter) {
  var o = {}
  for(var k in a) {
    if(!isUndefined(a[k]))
      o[k] = iter(a[k], b[k], k)
  }
  for(var k in b) {
    if(isUndefined(a[k]))
      o[k] = iter(undefined, b[k], k)
  }
  return o
}

var mergeArrays = exports.mergeArrays = function (a, b, iter) {
  var o = []
  a.forEach(function (v, i) {
    var j = b.indexOf(v)
    o.push(iter(v, b[j], o.length))
  })
  b.forEach(function (v, i) {
    var j = a.indexOf(v)
    if(!~j)
      o.push(iter(undefined, b[i], o.length))
  })
  return o
}

function merge (a, b, merge) {

  //merge a and b objects

  merge = merge || function (x, y) {
    return y == null ? x : y
  }

  function merger(a, b, k) {

    if(isArray(a) && isArray(b))
      return mergeArrays(a, b, merger)
    else if(isObject(a) && isObject(b)) {
      return mergeKeys(a, b, merger)
    }
    else
      return merge(a, b, k)

  }

  return merger(a, b, undefined)


}

},
"WmiMLAqhIyzZ49drQNtJW0XZQCEuEwxGmeTVaXHXucY=":
function (require, module, exports, __dirname, __filename) {
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},
"X/czNPPP6SHtDdPmH8KUCH2AfW0cdVfTBqGr7zTty04=":
function (require, module, exports, __dirname, __filename) {
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = require('fs')
var minimatch = require('minimatch')
var Minimatch = minimatch.Minimatch
var inherits = require('inherits')
var EE = require('events').EventEmitter
var path = require('path')
var assert = require('assert')
var isAbsolute = require('path-is-absolute')
var globSync = require('./sync.js')
var common = require('./common.js')
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = require('inflight')
var util = require('util')
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = require('once')

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set
  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  var n = this.minimatch.set.length
  this._processing = 0
  this.matches = new Array(n)

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    fs.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (this.matches[index][e])
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = this._makeAbs(e)

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  if (this.mark)
    e = this._mark(e)

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er)
      return cb()

    var isSym = lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && !stat.isDirectory())
    return cb(null, false, stat)

  var c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c !== 'DIR')
    return cb()

  return cb(null, c, stat)
}

},
"X6726CvmbG5t9SZoxWAjT6CYOb4CoXkljoy39fGuGmk=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/**
 * Normalize `uri`. This only works when both `encodeURI`
 * and `decodeURI` are available, and when
 * decoding/encoding fails, just returns `uri`.
 *
 * @example
 *   normalizeURI('foo bar'); // 'foo%20bar'
 *   normalizeURI('foo%20bar'); // 'foo%20bar'
 *
 * @param {string} uri - Value with and/or without
 *   encoded, entities.
 * @return {string} - Encoded URI (when encoding succeeds,
 * or `uri`).
 */
function normalizeURI(uri) {
    try {
        uri = encodeURI(decodeURI(uri));
    } catch (exception) { /* empty */ }

    return uri;
}

/*
 * Expose.
 */

module.exports = normalizeURI;

},
"XC4OLRd/OAzztR25n7mdLXTuMI7irpLLHwoOFC/FbLo=":
function (require, module, exports, __dirname, __filename) {
var ip = exports,
    Buffer = require('buffer').Buffer,
    os = require('os');

ip.toBuffer = function toBuffer(ip, buff, offset) {
  offset = ~~offset;

  var result;

  if (/^(\d{1,3}\.){3,3}\d{1,3}$/.test(ip)) {
    result = buff || new Buffer(offset + 4);
    ip.split(/\./g).map(function(byte) {
      result[offset++] = parseInt(byte, 10) & 0xff;
    });
  } else if (/^[a-f0-9:]+$/.test(ip)) {
    var s = ip.split(/::/g, 2),
        head = (s[0] || '').split(/:/g, 8),
        tail = (s[1] || '').split(/:/g, 8);

    if (tail.length === 0) {
      // xxxx::
      while (head.length < 8) head.push('0000');
    } else if (head.length === 0) {
      // ::xxxx
      while (tail.length < 8) tail.unshift('0000');
    } else {
      // xxxx::xxxx
      while (head.length + tail.length < 8) head.push('0000');
    }

    result = buff || new Buffer(offset + 16);
    head.concat(tail).map(function(word) {
      word = parseInt(word, 16);
      result[offset++] = (word >> 8) & 0xff;
      result[offset++] = word & 0xff;
    });
  } else {
    throw Error('Invalid ip address: ' + ip);
  }

  return result;
};

ip.toString = function toString(buff, offset, length) {
  offset = ~~offset;
  length = length || (buff.length - offset);

  var result = [];
  if (length === 4) {
    // IPv4
    for (var i = 0; i < length; i++) {
      result.push(buff[offset + i]);
    }
    result = result.join('.');
  } else if (length === 16) {
    // IPv6
    for (var i = 0; i < length; i += 2) {
      result.push(buff.readUInt16BE(offset + i).toString(16));
    }
    result = result.join(':');
    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    result = result.replace(/:{3,4}/, '::');
  }

  return result;
};

ip.fromPrefixLen = function fromPrefixLen(prefixlen, family) {
  if (prefixlen > 32) {
    family = 'ipv6';
  } else {
    family = _normalizeFamily(family);
  }

  var len = 4;
  if (family === 'ipv6') {
    len = 16;
  }
  var buff = new Buffer(len);

  for (var i = 0, n = buff.length; i < n; ++i) {
    var bits = 8;
    if (prefixlen < 8) {
      bits = prefixlen;
    }
    prefixlen -= bits;

    buff[i] = ~(0xff >> bits);
  }

  return ip.toString(buff);
};

ip.mask = function mask(addr, mask) {
  addr = ip.toBuffer(addr);
  mask = ip.toBuffer(mask);

  var result = new Buffer(Math.max(addr.length, mask.length));

  // Same protocol - do bitwise and
  if (addr.length === mask.length) {
    for (var i = 0; i < addr.length; i++) {
      result[i] = addr[i] & mask[i];
    }
  } else if (mask.length === 4) {
    // IPv6 address and IPv4 mask
    // (Mask low bits)
    for (var i = 0; i < mask.length; i++) {
      result[i] = addr[addr.length - 4  + i] & mask[i];
    }
  } else {
    // IPv6 mask and IPv4 addr
    for (var i = 0; i < result.length - 6; i++) {
      result[i] = 0;
    }

    // ::ffff:ipv4
    result[10] = 0xff;
    result[11] = 0xff;
    for (var i = 0; i < addr.length; i++) {
      result[i + 12] = addr[i] & mask[i + 12];
    }
  }

  return ip.toString(result);
};

ip.cidr = function cidr(cidrString) {
  var cidrParts = cidrString.split('/');

  if (cidrParts.length != 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var addr = cidrParts[0];
  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.mask(addr, mask);
}

ip.subnet = function subnet(addr, mask) {
  var networkAddress = ip.toLong(ip.mask(addr, mask));

  // Calculate the mask's length.
  var maskBuffer = ip.toBuffer(mask);
  var maskLength = 0;

  for (var i = 0; i < maskBuffer.length; i++) {
    if (maskBuffer[i] == 0xff) {
      maskLength += 8;
    } else {
      var octet = maskBuffer[i] & 0xff;
      while (octet) {
        octet = (octet << 1) & 0xff;
        maskLength++;
      }
    }
  }

  var numberOfAddresses = Math.pow(2, 32 - maskLength);

  return {
    networkAddress: ip.fromLong(networkAddress),
    firstAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress) :
                    ip.fromLong(networkAddress + 1),
    lastAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
                    ip.fromLong(networkAddress + numberOfAddresses - 2),
    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
    subnetMask: mask,
    subnetMaskLength: maskLength,
    numHosts: numberOfAddresses <= 2 ?
                numberOfAddresses : numberOfAddresses - 2,
    length: numberOfAddresses
  };
}

ip.cidrSubnet = function cidrSubnet(cidrString) {
  var cidrParts = cidrString.split('/');

  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var addr = cidrParts[0];
  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.subnet(addr, mask);
}

ip.not = function not(addr) {
  var buff = ip.toBuffer(addr);
  for (var i = 0; i < buff.length; i++) {
    buff[i] = 0xff ^ buff[i];
  }
  return ip.toString(buff);
};

ip.or = function or(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // same protocol
  if (a.length == b.length) {
    for (var i = 0; i < a.length; ++i) {
      a[i] |= b[i];
    }
    return ip.toString(a);

  // mixed protocols
  } else {
    var buff = a;
    var other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }

    var offset = buff.length - other.length;
    for (var i = offset; i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }

    return ip.toString(buff);
  }
};

ip.isEqual = function isEqual(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // Same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // Swap
  if (b.length === 4) {
    var t = b;
    b = a;
    a = t;
  }

  // a - IPv4, b - IPv6
  for (var i = 0; i < 10; i++) {
    if (b[i] !== 0) return false;
  }

  var word = b.readUInt16BE(10);
  if (word !== 0 && word !== 0xffff) return false;

  for (var i = 0; i < 4; i++) {
    if (a[i] !== b[i + 12]) return false;
  }

  return true;
};

ip.isPrivate = function isPrivate(addr) {
  return addr.match(/^10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/) != null ||
    addr.match(/^192\.168\.([0-9]{1,3})\.([0-9]{1,3})/) != null ||
    addr.match(
        /^172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})/) != null ||
    addr.match(/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/) != null ||
    addr.match(/^169\.254\.([0-9]{1,3})\.([0-9]{1,3})/) != null ||
    addr.match(/^fc00:/) != null || addr.match(/^fe80:/) != null ||
    addr.match(/^::1$/) != null || addr.match(/^::$/) != null;
};

ip.isPublic = function isPublic(addr) {
  return !ip.isPrivate(addr);
}

ip.isLoopback = function isLoopback(addr) {
  return /^127\.0\.0\.1$/.test(addr)
    || /^fe80::1$/.test(addr)
    || /^::1$/.test(addr)
    || /^::$/.test(addr);
};

ip.loopback = function loopback(family) {
  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  if (family !== 'ipv4' && family !== 'ipv6') {
    throw new Error('family must be ipv4 or ipv6');
  }

  return family === 'ipv4'
    ? '127.0.0.1'
    : 'fe80::1';
};

//
// ### function address (name, family)
// #### @name {string|'public'|'private'} **Optional** Name or security
//      of the network interface.
// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
//      to ipv4).
//
// Returns the address for the network interface on the current system with
// the specified `name`:
//   * String: First `family` address of the interface.
//             If not found see `undefined`.
//   * 'public': the first public ip address of family.
//   * 'private': the first private ip address of family.
//   * undefined: First address with `ipv4` or loopback addres `127.0.0.1`.
//
ip.address = function address(name, family) {
  var interfaces = os.networkInterfaces(),
      all;

  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  //
  // If a specific network interface has been named,
  // return the address.
  //
  if (name && !~['public', 'private'].indexOf(name)) {
    return interfaces[name].filter(function (details) {
      details.family = details.family.toLowerCase();
      return details.family === family;
    })[0].address;
  }

  var all = Object.keys(interfaces).map(function (nic) {
    //
    // Note: name will only be `public` or `private`
    // when this is called.
    //
    var addresses = interfaces[nic].filter(function (details) {
      details.family = details.family.toLowerCase();
      if (details.family !== family || ip.isLoopback(details.address)) {
        return false;
      }
      else if (!name) {
        return true;
      }

      return name === 'public'
        ? !ip.isPrivate(details.address)
        : ip.isPrivate(details.address)
    });

    return addresses.length
      ? addresses[0].address
      : undefined;
  }).filter(Boolean);

  return !all.length
    ? ip.loopback(family)
    : all[0];
};

ip.toLong = function toInt(ip){
  var ipl=0;
  ip.split('.').forEach(function( octet ) {
      ipl<<=8;
      ipl+=parseInt(octet);
  });
  return(ipl >>>0);
};

ip.fromLong = function fromInt(ipl){
  return ( (ipl>>>24) +'.' +
      (ipl>>16 & 255) +'.' +
      (ipl>>8 & 255) +'.' +
      (ipl & 255) );
};

function _normalizeFamily(family) {
  return family ? family.toLowerCase() : 'ipv4';
}

},
"XO4i6x9dyK06H1BrvHImoaIKgJIAUnVCXRb6HJ+RYIs=":
function (require, module, exports, __dirname, __filename) {

var sodium      = require('chloride')

var keypair     = sodium.crypto_box_keypair
var shared      = sodium.crypto_scalarmult
var hash        = sodium.crypto_hash_sha256
var sign        = sodium.crypto_sign_detached
var verify      = sodium.crypto_sign_verify_detached
var auth        = sodium.crypto_auth
var verify_auth = sodium.crypto_auth_verify
var curvify_pk  = sodium.crypto_sign_ed25519_pk_to_curve25519
var curvify_sk  = sodium.crypto_sign_ed25519_sk_to_curve25519
var box         = sodium.crypto_secretbox_easy
var unbox       = sodium.crypto_secretbox_open_easy

var concat = Buffer.concat

var nonce = new Buffer(24); nonce.fill(0)

var challenge_length = 64
var client_auth_length = 16+32+64
var server_auth_length = 16+64
var mac_length = 16

//this is a simple secure handshake,
//the client public key is passed in plain text,

module.exports = State

function State (app_key, local, remote) {
  if(!(this instanceof State)) return new State(app_key, local, remote)
  this.app_key = app_key
  var kx = keypair()
  this.local = {
    kx_pk: kx.publicKey,
    kx_sk: kx.secretKey,
    public: local.publicKey,
    secret: local.secretKey
  }
  this.remote = {
    public: remote || null
  }

}

var proto = State.prototype

proto.createChallenge =
function createChallenge () {
  var state = this

  state.local.app_mac = auth(state.local.kx_pk, state.app_key)
  return concat([state.local.app_mac, state.local.kx_pk])
}

proto.verifyChallenge =
function verifyChallenge (challenge) {
  var state = this

  var mac = challenge.slice(0, 32)
  var remote_pk = challenge.slice(32, challenge.length)
  if(0 !== verify_auth(mac, remote_pk, state.app_key))
    return null

  state.remote.kx_pk = remote_pk
  state.remote.app_mac = mac
  state.secret = shared(state.local.kx_sk, state.remote.kx_pk)
  state.shash = hash(state.secret)

  return true
}


proto.createClientAuth =
function createClientAuth () {
  var state = this
  //now we have agreed on the secret.
  //this can be an encryption secret,
  //or a hmac secret.

  // shared(local.kx, remote.public)
  var a_bob = shared(state.local.kx_sk, curvify_pk(state.remote.public))
  state.a_bob = a_bob
  state.secret2 = hash(concat([state.app_key, state.secret, a_bob]))

  var signed = concat([state.app_key, state.remote.public, state.shash])
  var sig = sign(signed, state.local.secret)

  state.local.hello = Buffer.concat([sig, state.local.public])
  return box(state.local.hello, nonce, state.secret2)
}

proto.verifyClientAuth =
function verifyClientAuth (data) {
  var state = this

  var a_bob = shared(curvify_sk(state.local.secret), state.remote.kx_pk)
  state.a_bob = a_bob
  state.secret2 = hash(concat([state.app_key, state.secret, a_bob]))

  state.remote.hello = unbox(data, nonce, state.secret2)
  if(!state.remote.hello)
    return null

  var sig = state.remote.hello.slice(0, 64)
  var public = state.remote.hello.slice(64, client_auth_length)

  var signed = concat([state.app_key, state.local.public, state.shash])
  if(!verify(sig, signed, public))
    return null

  state.remote.public = public

  return true
}

proto.createServerAccept =
function createServerAccept () {
  var state = this

  //shared key between my local ephemeral key + remote public
  var b_alice = shared(state.local.kx_sk, curvify_pk(state.remote.public))
  state.b_alice = b_alice
  state.secret3 = hash(concat([state.app_key, state.secret, state.a_bob, state.b_alice]))

  var signed = concat([state.app_key, state.remote.hello, state.shash])
  var okay = sign(signed, state.local.secret)
  return box(okay, nonce, state.secret3)
}

proto.verifyServerAccept =
function verifyServerAccept (boxed_okay) {
  var state = this

  var b_alice = shared(curvify_sk(state.local.secret), state.remote.kx_pk)
  state.b_alice = b_alice
//  state.secret3 = hash(concat([state.secret2, b_alice]))
  state.secret3 = hash(concat([state.app_key, state.secret, state.a_bob, state.b_alice]))

  var sig = unbox(boxed_okay, nonce, state.secret3)
  if(!sig) return null
  var signed = concat([state.app_key, state.local.hello, state.shash])
  if(!verify(sig, signed, state.remote.public))
      return null
  return true
}

proto.cleanSecrets =
function cleanSecrets () {
  var state = this

  // clean away all the secrets for forward security.
  // use a different secret hash(secret3) in the rest of the session,
  // and so that a sloppy application cannot compromise the handshake.

  delete state.local.secret
  state.shash.fill(0)
  state.secret.fill(0)
  state.a_bob.fill(0)
  state.b_alice.fill(0)
  state.secret = hash(state.secret3)
  state.secret2.fill(0)
  state.secret3.fill(0)
  state.local.kx_sk.fill(0)

  delete state.shash
  delete state.secret2
  delete state.secret3
  delete state.a_bob
  delete state.b_alice
  delete state.local.kx_sk

  return state
}


},
"Xz71w1g5FDlgcpQB1RsYHmnE9+BZfKrwfQyi9hcFlUM=":
function (require, module, exports, __dirname, __filename) {
var of = require("./of")

module.exports = either

//  either := (source: Continuable<A>,
//             left: (Error, cb?: Callback<B>) => Continuable<B>,
//             right?: (A) => Continuable<B>)
//      => Continuable<B>
function either(cont, left, right) {
    right = right || of

    return function continuable(callback) {
        cont(function (err, value) {
            if (!err) {
                return right(value)(callback)
            }

            // the left function takes either a callback or
            // it returns a continuable. Both are valid
            var cont = left(err, callback)

            if (cont) {
                cont(callback)
            }
        })
    }
}

},
"Y5pw+kokySMDzz5F2Mt3RhXuxC1via/TEY/tLtGxrUI=":
function (require, module, exports, __dirname, __filename) {
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},
"Y6cbT3Y4EA7HbMEu7Fz44pPPNcsjbpjVQfTH/KE98pA=":
function (require, module, exports, __dirname, __filename) {
//this is the key for accessing the ssb protocol.
//this will be updated whenever breaking changes are made.
//(see secret-handshake paper for a full explaination)
module.exports =
  new Buffer('1KHLiKZvAvjbY1ziZEHMXawbCEIM6qwjCDm3VYRan/s=', 'base64')

//there is nothing special about this value.
//I generated it in the node repl with:
//
// > crypto.randomBytes(32).toString('base64')
//
//and copied it here.


},
"Y8SANSpzUvF0ZNG71Ty/9x68C4fLGcOM1udPmjA8kqk=":
function (require, module, exports, __dirname, __filename) {
/*!
 * Node.JS module "Deep Extend"
 * @description Recursive object extending.
 * @author Viacheslav Lotsmanov (unclechu) <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Extening object that entered in first argument.
 * Returns extended object or false if have no target object or incorrect type.
 * If you wish to clone object, simply use that:
 *  deepExtend({}, yourObj_1, [yourObj_N]) - first arg is new empty object
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) return arguments[0];

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var key, val, src, clone, tmpBuf;

	args.forEach(function (obj) {
		if (typeof obj !== 'object') return;

		for (key in obj) {
			if ( ! (key in obj)) continue;

			src = target[key];
			val = obj[key];

			if (val === target) continue;

			if (typeof val !== 'object' || val === null) {
				target[key] = val;
				continue;
			} else if (val instanceof Buffer) {
				tmpBuf = new Buffer(val.length);
				val.copy(tmpBuf);
				target[key] = tmpBuf;
				continue;
			} else if (val instanceof Date) {
				target[key] = new Date(val.getTime());
				continue;
			}

			if (typeof src !== 'object' || src === null) {
				clone = (Array.isArray(val)) ? [] : {};
				target[key] = deepExtend(clone, val);
				continue;
			}

			if (Array.isArray(val)) {
				clone = (Array.isArray(src)) ? src : [];
			} else {
				clone = (!Array.isArray(src)) ? src : {};
			}

			target[key] = deepExtend(clone, val);
		}
	});

	return target;
}

},
"Ygd/2ZmAGygm+d3qRvI/4hmD/6thxJIyWAni6iDRFjA=":
function (require, module, exports, __dirname, __filename) {
var Pushable = require('pull-pushable')
var Stats = require('statistics')
var pull = require('pull-stream')

module.exports = function (opts) {
  var timeout = opts && opts.timeout || 5*60*1000 //default: 5 minutes
  var serve = false, timer
  var source = Pushable()
  var rtt = Stats(), skew = Stats()

  function ping () {
    //serve the ping pong, opponent
    //will volley it back to us, keeping connection alive
    //and revealing clock skew.
    serve = true
    source.push(ts = Date.now())
  }

  //we send the first ping
  if(opts && opts.serve) ping()

  return {
    source: source,
    sink: pull.drain(function (remote_ts) {
      if(serve) {
        var ts2 = Date.now()
        rtt.value(ts2 - ts)
        //if their time is behind half a round trip behing ts2
        //consider that to be negative skew.
        skew.value(remote_ts - ((ts2 + ts)/2))
        serve = false
      }
      else {
        //volley timestamp back to opponent.
        source.push(ts = Date.now())
        //we'll serve next time.
        timer = setTimeout(ping, timeout)
      }
    }, function (err) {
      clearTimeout(timer)
    }),
    rtt: rtt, skew: skew
  }

}

},
"YtwUE7q53jpxZqodrQL7wICJdflcYFqdRhowlP73ZpM=":
function (require, module, exports, __dirname, __filename) {
/**
 * Extend an object with another.
 *
 * @param {Object, ...} src, ...
 * @return {Object} merged
 * @api private
 */

module.exports = function(src) {
  var objs = [].slice.call(arguments, 1), obj;

  for (var i = 0, len = objs.length; i < len; i++) {
    obj = objs[i];
    for (var prop in obj) {
      src[prop] = obj[prop];
    }
  }

  return src;
}

},
"Yu76t+DKfnA75RFAqcScJ3XCdzDeuPe8X0/wXqLI3ak=":
function (require, module, exports, __dirname, __filename) {
module.exports = chain

// chain := (Continuable<A>, lambda:(A) => Continuable<B>) => Continuable<B>
function chain(source, lambda) {
    return function continuable(callback) {
        source(function continuation(err, value) {
            if (err) {
                return callback(err)
            }

            lambda(value)(callback)
        })
    }
}

},
"YvTDcG4MPZeDJV/mDDjsaByNy1BxVNaoXiDKl1sRluU=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},
"YvXzIl17mGQOhwd/k52N/lK3o/e2qw3npQdBLvbjdu4=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')
var paramap = require('pull-paramap')

module.exports = function (sbot, blobs, userQuotas, cb) {
  var listeners = []

  //recalculate the quota, with live updates.

  // share a file size between the feeds that link to it.
  // At the time we download it.

  // More feeds might link to it later, and these
  // won't be included in the calculation.
  // but it's simplest to do it this way.

  // this is only in memory, so it will be recalculated
  // when sbot is restarted.

  var total = 0
  var start = Date.now()
  var inflight = 0

  pull(
    blobs.ls({long: true, live: true}),
    paramap(function (data, cb) {
      if(data.sync) return cb(null, data)

      var acc = {}, count = 0
      total += data.size

      inflight ++
      pull(
        sbot.links({dest: '&'+data.id}),
        pull.drain(function (link) {
          if(!acc[link.source]) {
            acc[link.source] = true
            count ++
          }
          return acc
        }, function (err) {
          inflight --
          if(err) return cb(err)
          var size = data.size
          for(var k in acc)
            userQuotas[k] = (userQuotas[k] || 0) + size/count

          if(inflight === 0)
            while (listeners.length) listeners.shift()()

         cb(null, data)
        })
      )
    }),
    pull.drain()
  )

  return function (listener) {
    if(!inflight) listener()
    else          listeners.push(listener)
  }
}

},
"YxfZdrk91FH8ygDyPW9Y7gLxjR12usWzinKUekQp/dM=":
function (require, module, exports, __dirname, __filename) {
var Blake2s = require('blake2s')
var createHash = require('crypto').createHash
var hash    = require('crypto')
var path    = require('path')
var pull    = require('pull-stream')

var isBuffer = Buffer.isBuffer

exports.toPath = function (dir, hash) {
  var i = hash.indexOf('.')
  var alg = hash.substring(i+1)

  var h = new Buffer(hash.substring(0, i), 'base64').toString('hex')
  return path.join(dir, alg, h.substring(0,2), h.substring(2))
}

var algs = {
  blake2s: function () { return new Blake2s() },
  sha256: function () { return createHash('sha256') }
}

exports.createHash = function (alg) {
  alg = alg || 'blake2s'
  var hash = algs[alg]()

  var hasher = pull.through(function (data) {
    data = isBuffer(data) ? data : new Buffer(data)
    hasher.size += data.length
    hash.update(data)
  }, function () {
    var digest = hash.digest('base64') + '.' + alg
    hasher.digest = digest
  })

  hasher.size = 0
  return hasher
}

function isString (s) {
  return 'string' === typeof s
}

exports.isHash = function (data) {
  return isString(data) && /^[A-Za-z0-9\/+]{43}=\.(?:blake2s|sha256)$/.test(data)
}

},
"Z6u3/pIaEWkm9xY7PmuyqbPY0G7rC3usowa0WV54KnI=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "_args": [
    [
      "leveldown@~1.4.0",
      "/home/dominic/c/scuttlebot/node_modules/level"
    ]
  ],
  "_from": "leveldown@>=1.4.0 <1.5.0",
  "_id": "leveldown@1.4.4",
  "_inCache": true,
  "_installable": true,
  "_location": "/leveldown",
  "_nodeVersion": "5.5.0",
  "_npmUser": {
    "email": "ralphtheninja@riseup.net",
    "name": "ralphtheninja"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {
    "xtend": "4.0.1"
  },
  "_requested": {
    "name": "leveldown",
    "raw": "leveldown@~1.4.0",
    "rawSpec": "~1.4.0",
    "scope": null,
    "spec": ">=1.4.0 <1.5.0",
    "type": "range"
  },
  "_requiredBy": [
    "/level",
    "/level-test"
  ],
  "_resolved": "https://registry.npmjs.org/leveldown/-/leveldown-1.4.4.tgz",
  "_shasum": "5978b7b3e7ffa595b179391126035a9717ead765",
  "_shrinkwrap": null,
  "_spec": "leveldown@~1.4.0",
  "_where": "/home/dominic/c/scuttlebot/node_modules/level",
  "bugs": {
    "url": "https://github.com/level/leveldown/issues"
  },
  "contributors": [
    {
      "name": "David Bjrklund",
      "email": "david.bjorklund@gmail.com",
      "url": "https://github.com/kesla"
    },
    {
      "name": "Rod Vagg",
      "email": "r@va.gg",
      "url": "https://github.com/rvagg"
    },
    {
      "name": "Jake Verbaten",
      "email": "raynos2@gmail.com",
      "url": "https://github.com/raynos"
    },
    {
      "name": "Dominic Tarr",
      "email": "dominic.tarr@gmail.com",
      "url": "https://github.com/dominictarr"
    },
    {
      "name": "Max Ogden",
      "email": "max@maxogden.com",
      "url": "https://github.com/maxogden"
    },
    {
      "name": "Lars-Magnus Skog",
      "email": "ralphtheninja@riseup.net",
      "url": "https://github.com/ralphtheninja"
    },
    {
      "name": "John Chesley",
      "email": "john@chesl.es",
      "url": "https://github.com/chesles/"
    },
    {
      "name": "Julian Gruber",
      "email": "julian@juliangruber.com",
      "url": "https://github.com/juliangruber"
    },
    {
      "name": "Paolo Fragomeni",
      "email": "paolo@async.ly",
      "url": "https://github.com/hij1nx"
    },
    {
      "name": "Anton Whalley",
      "email": "anton.whalley@nearform.com",
      "url": "https://github.com/No9"
    },
    {
      "name": "Matteo Collina",
      "email": "matteo.collina@gmail.com",
      "url": "https://github.com/mcollina"
    },
    {
      "name": "Pedro Teixeira",
      "email": "pedro.teixeira@gmail.com",
      "url": "https://github.com/pgte"
    },
    {
      "name": "James Halliday",
      "email": "mail@substack.net",
      "url": "https://github.com/substack"
    }
  ],
  "dependencies": {
    "abstract-leveldown": "~2.4.0",
    "bindings": "~1.2.1",
    "fast-future": "~1.0.0",
    "nan": "~2.2.0",
    "prebuild": "^2.8.0"
  },
  "description": "A Node.js LevelDB binding, primary backend for LevelUP",
  "devDependencies": {
    "async": "~1.5.0",
    "delayed": "~1.0.1",
    "du": "~0.1.0",
    "faucet": "0.0.1",
    "mkfiletree": "~1.0.1",
    "monotonic-timestamp": "~0.0.8",
    "node-uuid": "~1.4.3",
    "optimist": "~0.6.1",
    "readfiletree": "~0.0.1",
    "rimraf": "~2.5.0",
    "slump": "~2.0.0",
    "tape": "~4.3.0"
  },
  "directories": {},
  "dist": {
    "shasum": "5978b7b3e7ffa595b179391126035a9717ead765",
    "tarball": "http://registry.npmjs.org/leveldown/-/leveldown-1.4.4.tgz"
  },
  "gitHead": "c283125217b59bd86edb75d88237eb10f5e4e8c4",
  "gypfile": true,
  "homepage": "https://github.com/level/leveldown",
  "keywords": [
    "level",
    "leveldb"
  ],
  "license": "MIT",
  "main": "leveldown.js",
  "maintainers": [
    {
      "name": "rvagg",
      "email": "rod@vagg.org"
    },
    {
      "name": "ralphtheninja",
      "email": "ralphtheninja@riseup.net"
    },
    {
      "name": "juliangruber",
      "email": "julian@juliangruber.com"
    }
  ],
  "name": "leveldown",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/level/leveldown.git"
  },
  "scripts": {
    "install": "prebuild --install",
    "prebuild": "prebuild --all --strip --verbose",
    "rebuild": "prebuild --compile",
    "test": "tape test/*-test.js | faucet"
  },
  "version": "1.4.4"
}

},
"ZEG4aHL+0usxgN0tnFuO+zMVRiJNCChiy42kLL1EyWc=":
function (require, module, exports, __dirname, __filename) {
module.exports = require('util').inherits

},
"ZVphO2Wydam0lfVtLNjQwiFEGAriKimAucbSJ9g8jtQ=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')

var Handshake = require('pull-handshake')
var State = require('./state')

var challenge_length = 64
var client_auth_length = 16+32+64
var server_auth_length = 16+64
var mac_length = 16

//client is Alice
//create the client stream with the public key you expect to connect to.
exports.client =
exports.createClientStream = function (alice, app_key, timeout) {

  return function (bob_pub, cb) {
    var state = new State(app_key, alice, bob_pub)

    var stream = Handshake({timeout: timeout}, cb)
    var shake = stream.handshake
    delete stream.handshake

    function abort(err, reason) {
      if(err && err !== true) shake.abort(err, cb)
      else                    shake.abort(new Error(reason), cb)
    }

    shake.write(state.createChallenge())

    shake.read(challenge_length, function (err, msg) {
      if(err) return abort(err, 'challenge not accepted')
      //create the challenge first, because we need to generate a local key
      if(!state.verifyChallenge(msg))
        return abort(null, 'wrong protocol (version?)')

      shake.write(state.createClientAuth())

      shake.read(server_auth_length, function (err, boxed_sig) {
        if(err) return abort(err, 'hello not accepted')

        if(!state.verifyServerAccept(boxed_sig))
          return abort(null, 'server not authenticated')

        cb(null, shake.rest(), state.cleanSecrets())
      })
    })

    return stream
  }
}

//server is Bob.
exports.server =
exports.createServerStream = function (bob, authorize, app_key, timeout) {

  return function (cb) {
    var state = new State(app_key, bob)
    var stream = Handshake({timeout: timeout}, cb)

    var shake = stream.handshake
    delete stream.handshake

    function abort (err, reason) {
      if(err && err !== true) shake.abort(err, cb)
      else                    shake.abort(new Error(reason), cb)
    }

    shake.read(challenge_length, function (err, challenge) {
      if(err) return abort(err, 'expected challenge')
      if(!state.verifyChallenge(challenge))
        return shake.abort(new Error('wrong protocol/version'))

      shake.write(state.createChallenge())
      shake.read(client_auth_length, function (err, hello) {
        if(err) return abort(err, 'expected hello')
        if(!state.verifyClientAuth(hello)) {
          //we know who the client was, but chose not to answer:
          if(state.remote.public)
            return abort(null, 'unauthenticated client:' + state.remote.public.toString('hex'), cb)
          //client dialed wrong number... (we don't know who they where)
          else
            return abort(null, 'wrong number')
        }
        //check if the user wants to speak to alice.
        authorize(state.remote.public, function (err, auth) {
          if(auth == null && !err) err = new Error('client unauthorized')
          if(!auth) return abort(err, 'client authentication rejected')
          state.auth = auth
          shake.write(state.createServerAccept())
          cb(null, shake.rest(), state.cleanSecrets())
        })
      })
    })
    return stream
  }
}



},
"Zfyxlza+kGu/b36r2+mmQDgHZGLxocYERlAlfZwiMIY=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

// NOTE: we are fixed to readable-stream@1.0.x for now
// for pure Streams2 across Node versions
var Readable      = require('readable-stream').Readable
  , inherits      = require('util').inherits
  , extend        = require('xtend')
  , EncodingError = require('./errors').EncodingError
  , util          = require('./util')



function ReadStream (options, makeData) {
  if (!(this instanceof ReadStream))
    return new ReadStream(options, makeData)

  Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark })

  // purely to keep `db` around until we're done so it's not GCed if the user doesn't keep a ref

  this._waiting = false
  this._options = options
  this._makeData = makeData
}

inherits(ReadStream, Readable)

ReadStream.prototype.setIterator = function (it) {
  var self = this
  this._iterator = it
  if(this._destroyed) return it.end(function () {})
  if(this._waiting) {
    this._waiting = false
    return this._read()
  }
  return this
}

ReadStream.prototype._read = function read () {
  var self = this
  if (self._destroyed)
    return
  if(!self._iterator)
    return this._waiting = true

  self._iterator.next(function(err, key, value) {
    if (err || (key === undefined && value === undefined)) {
      if (!err && !self._destroyed)
        self.push(null)
      return self._cleanup(err)
    }


    try {
      value = self._makeData(key, value)
    } catch (e) {
      return self._cleanup(new EncodingError(e))
    }
    if (!self._destroyed)
      self.push(value)
  })
}

ReadStream.prototype._cleanup = function (err) {
  if (this._destroyed)
    return

  this._destroyed = true

  var self = this
  if (err)
    self.emit('error', err)

  if (self._iterator) {
    self._iterator.end(function () {
      self._iterator = null
      self.emit('close')
    })
  } else {
    self.emit('close')
  }
}

ReadStream.prototype.destroy = function () {
  this._cleanup()
}

ReadStream.prototype.toString = function () {
  return 'LevelUP.ReadStream'
}


module.exports = ReadStream


},
"Zqy0Lw2YKPXlFFGbs/oagyalzIQxiarMajOra0kmFnc=":
function (require, module, exports, __dirname, __filename) {
var hooks = require('./hooks')
var ltgt = require('ltgt')

function isFunction (f) {
  return 'function' === typeof f
}

function getPrefix (db) {
  if(db == null) return db
  if(isFunction(db.prefix)) return db.prefix()
  return db
}

function has(obj, name) {
  return Object.hasOwnProperty.call(obj, name)
}

function clone (_obj) {
  var obj = {}
  for(var k in _obj)
    obj[k] = _obj[k]
  return obj
}

module.exports = function (db, precodec, codec, compare) {
  var prehooks = hooks(compare)
  var posthooks = hooks(compare)
  var waiting = [], ready = false

  function encodePrefix(prefix, key, opts1, opts2) {
    return precodec.encode([ prefix, codec.encodeKey(key, opts1, opts2 ) ])
  }

  function decodePrefix(data) {
    return precodec.decode(data)
  }

  function addEncodings(op, prefix) {
    if(prefix && prefix.options) {
      op.keyEncoding =
        op.keyEncoding || prefix.options.keyEncoding
      op.valueEncoding =
        op.valueEncoding || prefix.options.valueEncoding
    }
    return op
  }

  function start () {
    ready = true
    while(waiting.length)
      waiting.shift()()
  }

  if(isFunction(db.isOpen)) {
    if(db.isOpen())
      ready = true
    else
      db.open(start)
  } else {
    db.open(start)
  }

  return {
    apply: function (ops, opts, cb) {
      //apply prehooks here.
      for(var i = 0; i < ops.length; i++) {
        var op = ops[i]

        function add(op) {
          if(op === false) return delete ops[i]
          ops.push(op)
        }

        addEncodings(op, op.prefix)
        op.prefix = getPrefix(op.prefix)
        prehooks.trigger([op.prefix, op.key], [op, add, ops])
      }

      opts = opts || {}

      if('object' !== typeof opts) throw new Error('opts must be object, was:'+ opts) 

      if('function' === typeof opts) cb = opts, opts = {}

      if(ops.length)
        (db.db || db).batch(
          ops.map(function (op) {
            return {
              key: encodePrefix(op.prefix, op.key, opts, op),
              value:
                  op.type !== 'del'
                ? codec.encodeValue(
                    op.value,
                    opts,
                    op
                  )
                : undefined,
              type:
                op.type || (op.value === undefined ? 'del' : 'put')
            }
          }),
          opts,
          function (err) {
              if(err) return cb(err)
            ops.forEach(function (op) {
              posthooks.trigger([op.prefix, op.key], [op])
            })
            cb()
          }
        )
      else
        cb()
    },
    get: function (key, prefix, opts, cb) {
      opts.asBuffer = codec.isValueAsBuffer(opts)
      return (db.db || db).get(
        encodePrefix(prefix, key, opts),
        opts,
        function (err, value) {
          if(err) cb(err)
          else    cb(null, codec.decodeValue(value, opts))
        }
      )
    },
    pre: prehooks.add,
    post: posthooks.add,
    createDecoder: function (opts) {
      if(opts.keys !== false && opts.values !== false)
        return function (key, value) {
          return {
            key: codec.decodeKey(precodec.decode(key)[1], opts),
            value: codec.decodeValue(value, opts)
          }
        }
      if(opts.values !== false)
        return function (_, value) {
          return codec.decodeValue(value, opts)
        }
      if(opts.keys !== false)
        return function (key) {
          return codec.decodeKey(precodec.decode(key)[1], opts)
        }
      return function () {}
    },
    isOpen: function isOpen() {
      if (db.db && isFunction(db.db.isOpen))
        return db.db.isOpen()

      return db.isOpen()
    },
    isClosed: function isClosed() {
      if (db.db && isFunction(db.db.isClosed))
        return db.db.isClosed()

      return db.isClosed()
    },
    close: function close (cb) {
      return db.close(cb)
    },
    iterator: function (_opts, cb) {
      var opts = clone(_opts || {})
      var prefix = _opts.prefix || []

      function encodeKey(key) {
        return encodePrefix(prefix, key, opts, {})
      }

      ltgt.toLtgt(_opts, opts, encodeKey, precodec.lowerBound, precodec.upperBound)

      // if these legacy values are in the options, remove them

      opts.prefix = null

      //************************************************
      //hard coded defaults, for now...
      //TODO: pull defaults and encoding out of levelup.
      opts.keyAsBuffer = opts.valueAsBuffer = false
      //************************************************


      //this is vital, otherwise limit: undefined will
      //create an empty stream.
      if ('number' !== typeof opts.limit)
        opts.limit = -1

      opts.keyAsBuffer = precodec.buffer
      opts.valueAsBuffer = codec.isValueAsBuffer(opts)

      function wrapIterator (iterator) {
        return {
          next: function (cb) {
            return iterator.next(cb)
          },
          end: function (cb) {
            iterator.end(cb)
          }
        }
      }

      if(ready)
        return wrapIterator((db.db || db).iterator(opts))
      else
        waiting.push(function () {
          cb(null, wrapIterator((db.db || db).iterator(opts)))
        })

    }
  }

}

},
"ZtU4268sTUITGLs2TBqdeEpFlar2N6nUb+xsMo+OUl4=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var extend         = require('xtend')
  , LevelUPError   = require('level-errors').LevelUPError
  , format         = require('util').format
  , defaultOptions = {
        createIfMissing : true
      , errorIfExists   : false
      , keyEncoding     : 'utf8'
      , valueEncoding   : 'utf8'
      , compression     : true
    }

  , leveldown

function getOptions (options) {
  if (typeof options == 'string')
    options = { valueEncoding: options }
  if (typeof options != 'object')
    options = {}
  return options
}

function getLevelDOWN () {
  if (leveldown)
    return leveldown

  var requiredVersion  = require('../package.json').devDependencies.leveldown
    , leveldownVersion

  try {
    leveldownVersion = require('leveldown/package').version
  } catch (e) {
    throw requireError(e)
  }

  if (!require('semver').satisfies(leveldownVersion, requiredVersion)) {
    throw new LevelUPError(
        'Installed version of LevelDOWN ('
      + leveldownVersion
      + ') does not match required version ('
      + requiredVersion
      + ')'
    )
  }

  try {
    return leveldown = require('leveldown')
  } catch (e) {
    throw requireError(e)
  }
}

function requireError (e) {
  var template = 'Failed to require LevelDOWN (%s). Try `npm install leveldown` if it\'s missing'
  return new LevelUPError(format(template, e.message))
}

function dispatchError (db, error, callback) {
  typeof callback == 'function' ? callback(error) : db.emit('error', error)
}

function isDefined (v) {
  return typeof v !== 'undefined'
}

module.exports = {
    defaultOptions  : defaultOptions
  , getOptions      : getOptions
  , getLevelDOWN    : getLevelDOWN
  , dispatchError   : dispatchError
  , isDefined       : isDefined
}

},
"a9irYcSSS0gtnrygil3AqyBt6JgtdkZhBTNS4BEmO6I=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var encodings = require('./encodings')

function getKeyEncoder (options, op) {
  var type = ((op && op.keyEncoding) || options.keyEncoding) || 'utf8'
  return encodings[type] || type
}

function getValueEncoder (options, op) {
  var type = (((op && (op.valueEncoding || op.encoding))
      || options.valueEncoding || options.encoding)) || 'utf8'
  return encodings[type] || type
}

/*
  Encode a key.
  This method takes two options, because the leveldb instance
  has options, and this operation (a put, del, or batch)
  also has options that may override the leveldb's options.
*/

function encodeKey (key, options, op) {
  return getKeyEncoder(options, op).encode(key)
}

/*
  Encode a value.
  Takes 2 options, for the same reason as encodeKey
*/

function encodeValue (value, options, op) {
  return getValueEncoder(options, op).encode(value)
}

/*
  Decode an encoded key
*/

function decodeKey (key, options) {
  return getKeyEncoder(options).decode(key)
}

/*
  Decode an encoded value
*/

function decodeValue (value, options) {
  return getValueEncoder(options).decode(value)
}

/*
  check whether this value should be requested as a buffer
  (if false, then it will be a string)
  this allows an optimization in leveldown where leveldown
  retrives a string directly, and thus avoids a memory copy.
*/

function isValueAsBuffer (options, op) {
  return getValueEncoder(options, op).buffer
}

/*
  check whether a given key should be requested as a buffer.
*/

function isKeyAsBuffer (options, op) {
  return getKeyEncoder(options, op).buffer
}


module.exports = {
    encodeKey       : encodeKey
  , encodeValue     : encodeValue
  , isValueAsBuffer : isValueAsBuffer
  , isKeyAsBuffer   : isKeyAsBuffer
  , decodeValue     : decodeValue
  , decodeKey       : decodeKey
}

},
"aRb/yDtQKWPdj2Gc5FenMcwXMOKqr3f6P4vLtgNFyp0=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},
"aZEQb5NsYMvQpWY1OvcEuO+5Sj1FAlDq0NM5q8OPZFg=":
function (require, module, exports, __dirname, __filename) {

module.exports = require('ssb-keys')
module.exports.codec = require('./codec')
module.exports.keys = module.exports


},
"an9dxouVGOFt+pPYLCmIvQ3cMN+eGDewAEmBPGhlX6s=":
function (require, module, exports, __dirname, __filename) {

var Source = require('./source')
var Sink = require('./sink')

module.exports = function () {

  var source = Source()
  var sink = Sink()

  return {
    source: source,
    sink: sink,
    resolve: function (duplex) {
      source.resolve(duplex.source)
      sink.resolve(duplex.sink)

    }
  }


}

},
"aolUdv936jEVloODMTkigCDeZ1Olo7Qddu4mXyVZvws=":
function (require, module, exports, __dirname, __filename) {

//
// caluclate simple statistics
//

module.exports = Stats

function Stats () {
  if (!(this instanceof Stats)) return new Stats()
  this.sum = 0
  this.sqsum = 0
  this.mean = 0
  this.count = 0
  this.max = null
  this.min = null
}

Stats.prototype = {
  value: function (val) {
    this.sum += val
    this.sqsum += val*val
    this.count ++
    this.mean = this.sum / this.count
    this.max = 
        this.max === null ? val 
      : val > this.max ? val
      : this.max 
    this.min = 
        this.min === null ? val 
      : val < this.min ? val
      : this.min 
    return this
  },
  get variance () {
    return this.sqsum / this.count - (this.mean * this.mean)
  },
  get stdev() {
    return Math.sqrt(this.variance)
  },
  toJSON: function () {
    return {mean: this.mean, count: this.count, stdev: this.stdev}
  }
}

},
"ap3iIy8iwWqq+wjloxfLq1T76n5Jxge27khF9jPmU2s=":
function (require, module, exports, __dirname, __filename) {

var core = require('./core')
var util = require('./util')

for(var k in core)
  exports[k] = core[k]
for(var k in util)
  exports[k] = util[k]


},
"b5zczG7/hQGGi3HW3ZFba0kyy4IyXtK2nDpdCZglylA=":
function (require, module, exports, __dirname, __filename) {

var util = require('../util')
var ltgt = require('ltgt')
var pull = require('pull-stream')
var pl   = require('pull-level')

var HI = undefined
var LO = null

module.exports = function (db, path) {

  util.assertDepth(path, 'createDiskIndex')

  var index = {
    path: path,
    read: function (opts) {
      opts = ltgt.toLtgt(opts, opts, function (value, isUpper) {
        var bound = isUpper ? HI : LO
        return [path, value, bound]
      })
      return pull(
        pl.read(db.sublevel('idx'), opts),
        pull.map(function (e) {
          return e[2]
        })
      )
    },
    pre: function (data) {
      return util.eachpath(path, data.value)
        .map(function (values) {
          if(!values.length) return
          if(!values.every(util.isUndef))
            return {
              key: [path, values, data.key], value: '', type: 'put'
            }
        }).filter(Boolean)
    }
  }

  return index
}

},
"bDJXRfHwQQgCZLXZdgjYSo4HwvJzGOortTI8nFRPCeA=":
function (require, module, exports, __dirname, __filename) {

module.exports = function () {
  var read, reader, cb, abort, stream

  function delayed (_read) {
    //if we already have the stream, go!
    if(stream) return stream(_read)

    read = _read
    return function (_abort, _cb) {
      if(reader) reader(_abort, _cb)
      else abort = _abort, cb = _cb

    }
  }

  delayed.resolve = function (_stream) {
    if(stream) throw new Error('already resolved')
    stream = _stream
    if(!stream) throw new Error('resolve *must* be passed a transform stream')
    if(read) {
      reader = stream(read)
      if(cb) reader(abort, cb)
    }
  }

  return delayed
}

},
"bDc8i7r6H4gyCnypTyBvGRbkEntFS9wthfMPAAlmTB8=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module remark:html:compilers
 * @fileoverview Compilers to transform mdast nodes to HTML.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var trim = require('trim');
var detab = require('detab');
var collapse = require('collapse-white-space');
var normalizeURI = require('normalize-uri');
var trimLines = require('trim-lines');
var visit = require('unist-util-visit');
var h = require('./h.js');

/*
 * Compilers.
 */

var visitors = {};

/**
 * Return the content of a reference without definition
 * as markdown.
 *
 * @example
 *   failsafe({
 *     identifier: 'foo',
 *     referenceType: 'shortcut',
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }, {}); // '[foo]'
 *
 * @param {Node} node - Node to compile.
 * @param {Node?} definition - Definition node, when
 *   existing.
 * @param {HTMLCompiler} context - Instance.
 * @return {string?} - If without definition, returns a
 *   string, returns nothing otherwise.
 */
function failsafe(node, definition, context) {
    var result;

    if (node.referenceType === 'shortcut' && !definition.link) {
        result = node.children ? context.all(node).join('') : node.alt;

        return (node.type === 'imageReference' ? '!' : '') +
            '[' + result + ']';
    }

    return '';
}

/**
 * Stringify all footnote definitions, if any.
 *
 * @example
 *   generateFootnotes(); // '<div class="footnotes">\n<hr>\n...'
 *
 * @return {string} - Compiled footnotes, if any.
 * @this {HTMLCompiler}
 */
function generateFootnotes() {
    var self = this;
    var definitions = self.footnotes;
    var length = definitions.length;
    var index = -1;
    var results = [];
    var def;

    if (!length) {
        return '';
    }

    while (++index < length) {
        def = definitions[index];

        results[index] = self.listItem({
            'type': 'listItem',
            'data': {
                'htmlAttributes': {
                    'id': 'fn-' + def.identifier
                }
            },
            'children': def.children.concat({
                'type': 'link',
                'href': '#fnref-' + def.identifier,
                'data': {
                    'htmlAttributes': {
                        'class': 'footnote-backref'
                    }
                },
                'children': [{
                    'type': 'text',
                    'value': ''
                }]
            }),
            'position': def.position
        }, {});
    }

    return h(self, null, {
        'name': 'div',
        'attributes': {
            'class': 'footnotes'
        },
        'content': h(self, null, {
                'name': 'hr'
            }) +
            '\n' +
            h(self, null, {
                'name': 'ol',
                'content': results.join('\n')
            }, null, true)
    }, null, true) + '\n';
}

/**
 * Stringify an unknown node.
 *
 * @example
 *   unknown({
 *     data: {
 *       htmlName: 'section'
 *     },
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<section>foo</section>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function unknown(node) {
    var content = 'children' in node ? this.all(node).join('') : node.value;

    return h(this, node, {
        'name': 'div',
        'content': content || ''
    }, node.data);
}

/**
 * Visit a node.
 *
 * @example
 *   var compiler = new Compiler();
 *
 *   compiler.visit({
 *     type: 'strong',
 *     children: [{
 *       type: 'text',
 *       value: 'Foo'
 *     }]
 *   });
 *   // '**Foo**'
 *
 * @param {Object} node - Node.
 * @param {Object?} [parent] - `node`s parent.
 * @return {string} - Compiled `node`.
 */
function one(node, parent) {
    var self = this;
    var type = node && node.type;
    var fn = typeof self[type] === 'function' ? type : 'unknown';

    if (!type) {
        self.file.fail('Expected node `' + node + '`');
    }

    return self[fn](node, parent);
}

/**
 * Stringify the children of `node`.
 *
 * @example
 *   all({
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // 'foo'
 *
 * @param {Node} parent - Parent to visit.
 * @return {Array.<string>} - List of compiled nodes.
 * @this {HTMLCompiler}
 */
function all(parent) {
    var self = this;
    var nodes = parent.children;
    var values = [];
    var index = -1;
    var length = nodes.length;
    var value;
    var prev;

    while (++index < length) {
        value = self.visit(nodes[index], parent);

        if (value) {
            if (prev && prev.type === 'break') {
                value = trim.left(value);
            }

            values.push(value);
        }

        prev = nodes[index];
    }

    return values;
}

/**
 * Stringify a root object.
 *
 * @example
 *   // This will additionally include defined footnotes,
 *   // when applicable.
 *   root({
 *     children: [
 *       {
 *         type: 'paragraph',
 *         children: [
 *           {
 *             type: 'text',
 *             value: 'foo'
 *           }
 *         ]
 *       }
 *     ]
 *   }); // '<p>foo</p>\n'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function root(node) {
    var self = this;
    var definitions = {};
    var footnotes = [];
    var result;

    self.definitions = definitions;
    self.footnotes = footnotes;

    visit(node, 'definition', function (definition) {
        definitions[definition.identifier.toUpperCase()] = definition;
    });

    visit(node, 'footnoteDefinition', function (definition) {
        footnotes.push(definition);
    });

    result = self.all(node).join('\n');

    return (result ? result + '\n' : '') + self.generateFootnotes();
}

/**
 * Stringify a block quote.
 *
 * @example
 *   blockquote({
 *     children: [
 *       {
 *         type: 'paragraph',
 *         children: [
 *           {
 *             type: 'text',
 *             value: 'foo'
 *           }
 *         ]
 *       }
 *     ]
 *   }); // '<blockquote>\n<p>foo</p>\n</blockquote>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function blockquote(node) {
    return h(this, node, {
        'name': 'blockquote',
        'content': this.all(node).join('\n')
    }, node.data, true);
}

/**
 * Stringify an inline footnote.
 *
 * @example
 *   // This additionally adds a definition at the bottem
 *   // of the document.
 *   footnote({
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<sup id="fnref-1"><a href="#fn-1">1</a></sup>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function footnote(node) {
    var self = this;
    var definitions = self.footnotes;
    var index = -1;
    var length = definitions.length;
    var identifiers = [];
    var identifier;

    while (++index < length) {
        identifiers[index] = definitions[index].identifier;
    }

    index = -1;
    identifier = 1;

    while (identifiers.indexOf(String(identifier)) !== -1) {
        identifier++;
    }

    identifier = String(identifier);

    self.footnotes.push({
        'type': 'footnoteDefinition',
        'identifier': identifier,
        'children': node.children,
        'position': node.position
    });

    return self.footnoteReference({
        'type': 'footnoteReference',
        'identifier': identifier,
        'position': node.position
    });
}

/**
 * Stringify a list.
 *
 * @example
 *   list({
 *     ordered: true
 *     loose: false
 *     children: [
 *       {
 *         type: 'listItem',
 *         children: [
 *           {
 *             type: 'paragraph',
 *             children: [
 *               {
 *                 type: 'text',
 *                 value: 'foo'
 *               }
 *             ]
 *           }
 *         ]
 *       }
 *     ]
 *   }); // '<ol>\n<li>foo</li>\n</ol>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function list(node) {
    return h(this, node, {
        'name': node.ordered ? 'ol' : 'ul',
        'attributes': {
            'start': node.start !== 1 ? node.start : null
        },
        'content': this.all(node).join('\n')
    }, node.data, true);
}

/**
 * Stringify a list-item.
 *
 * @example
 *   listItem({
 *     children: [
 *       {
 *         type: 'paragraph',
 *         children: [
 *           {
 *             type: 'text',
 *             value: 'foo'
 *           }
 *         ]
 *       }
 *     ]
 *   }, {
 *     loose: false
 *   }); // '<li>foo</li>'
 *
 * @param {Node} node - Node to compile.
 * @param {Node} parent - Parent of `node`.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function listItem(node, parent) {
    var single;
    var result;

    single = !parent.loose &&
        node.children.length === 1 &&
        node.children[0].children;

    result = this.all(single ? node.children[0] : node)
        .join(single ? '' : '\n');

    return h(this, node, {
        'name': 'li',
        'content': result
    }, node.data, !single);
}

/**
 * Stringify a heading.
 *
 * @example
 *   heading({
 *     depth: 3,
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<h3>foo</h3>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function heading(node) {
    return h(this, node, {
        'name': 'h' + node.depth,
        'content': this.all(node).join('')
    }, node.data);
}

/**
 * Stringify a paragraph.
 *
 * @example
 *   paragraph({
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // 'foo'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function paragraph(node) {
    return h(this, node, {
        'name': 'p',
        'content': trim(detab(this.all(node).join('')))
    }, node.data);
}

/**
 * Stringify a code block.
 *
 * @example
 *   code({
 *     value: 'foo &amp; bar;'
 *   }); // '<pre><code>foo &amp;amp; bar\n</code></pre>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function code(node) {
    var self = this;
    var value = node.value ? detab(node.value + '\n') : '';

    return h(self, node, {
        'name': 'pre',
        'content': h(self, node, {
            'name': 'code',
            'content': self.encode(value)
        }, node.data)
    });
}

/**
 * Stringify a table.
 *
 * @example
 *   table({
 *     children: [
 *       {
 *         type: 'tableRow',
 *         ...
 *       }
 *     ]
 *   }); // '<table><thead>...'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function table(node) {
    var self = this;
    var rows = node.children;
    var index = rows.length;
    var align = node.align;
    var alignLength = align.length;
    var pos;
    var result = [];
    var row;
    var out;
    var name;
    var cell;

    while (index--) {
        pos = alignLength;
        row = rows[index].children;
        out = [];
        name = index === 0 ? 'th' : 'td';

        while (pos--) {
            cell = row[pos];
            out[pos] = h(self, cell, {
                'name': name,
                'attributes': {
                    'align': align[pos]
                },
                'content': cell ? self.all(cell).join('\n') : ''
            }, cell && cell.data);
        }

        result[index] = h(self, rows[index], {
            'name': 'tr',
            'content': out.join('\n')
        }, rows[index], true);
    }

    return h(self, node, {
        'name': 'table',
        'content': h(self, node, {
                'name': 'thead',
                'content': result[0]
            }, null, true) +
            '\n' +
            h(self, node, {
                'name': 'tbody',
                'content': result.slice(1).join('\n')
            }, null, true)
    }, node.data, true);
}

/**
 * Stringify a literal HTML.
 *
 * @example
 *   html({
 *     value: '<i>italic</i>'
 *   }); // '<i>italic</i>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function html(node) {
    return this.options.sanitize ? this.encode(node.value) : node.value;
}

/**
 * Stringify a horizontal rule.
 *
 * @example
 *   rule(); // '<hr>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function rule(node) {
    return h(this, node, {
        'name': 'hr'
    }, node.data);
}

/**
 * Stringify inline code.
 *
 * @example
 *   inlineCode({
 *     value: 'foo &amp; bar;'
 *   }); // '<code>foo &amp;amp; bar;</code>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function inlineCode(node) {
    return h(this, node, {
        'name': 'code',
        'content': collapse(this.encode(node.value))
    }, node.data);
}

/**
 * Stringify strongly emphasised content.
 *
 * @example
 *   strong({
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<strong>foo</strong>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function strong(node) {
    return h(this, node, {
        'name': 'strong',
        'content': this.all(node).join('')
    }, node.data);
}

/**
 * Stringify emphasised content.
 *
 * @example
 *   emphasis({
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<em>foo</em>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function emphasis(node) {
    return h(this, node, {
        'name': 'em',
        'content': this.all(node).join('')
    }, node.data);
}

/**
 * Stringify an inline break.
 *
 * @example
 *   hardBreak(); // '<br>\n'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function hardBreak(node) {
    return h(this, node, {
        'name': 'br'
    }, node.data) + '\n';
}

/**
 * Stringify a link.
 *
 * @example
 *   link({
 *     href: 'http://example.com',
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<a href="http://example.com">foo</a>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function link(node) {
    return h(this, node, {
        'name': 'a',
        'attributes': {
            'href': normalizeURI(node.href),
            'title': node.title
        },
        'content': this.all(node).join('')
    }, node.data);
}

/**
 * Stringify a reference to a footnote.
 *
 * @example
 *   // If a definition was added previously:
 *   footnoteReference({
 *     identifier: 'foo'
 *   });
 *   // <sup id="fnref-foo">
 *   //   <a class="footnote-ref" href="#fn-foo">foo</a>
 *   // </sup>
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function footnoteReference(node) {
    var identifier = node.identifier;

    return h(this, node, {
        'name': 'sup',
        'attributes': {
            'id': 'fnref-' + identifier
        },
        'content': h(this, node, {
            'name': 'a',
            'attributes': {
                'href': '#fn-' + identifier,
                'class': 'footnote-ref'
            },
            'content': identifier
        })
    }, node.data);
}

/**
 * Stringify a reference to a link.
 *
 * @example
 *   // If a definition was added previously:
 *   linkReference({
 *     identifier: 'foo'
 *   }); // '<a href="http://example.com/fav.ico"></a>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function linkReference(node) {
    var self = this;
    var def = self.definitions[node.identifier.toUpperCase()] || {};

    return failsafe(node, def, self) || h(self, node, {
        'name': 'a',
        'attributes': {
            'href': normalizeURI(def.link || ''),
            'title': def.title
        },
        'content': self.all(node).join('')
    }, node.data);
}

/**
 * Stringify a reference to an image.
 *
 * @example
 *   // If a definition was added previously:
 *   imageReference({
 *     identifier: 'foo'
 *   }); // '<img src="http://example.com/fav.ico" alt="">'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function imageReference(node) {
    var self = this;
    var def = self.definitions[node.identifier.toUpperCase()] || {};

    return failsafe(node, def, self) || h(self, node, {
        'name': 'img',
        'attributes': {
            'src': normalizeURI(def.link || ''),
            'alt': node.alt || '',
            'title': def.title
        }
    }, node.data);
}

/**
 * Stringify an image.
 *
 * @example
 *   image({
 *     src: 'http://example.com/fav.ico'
 *   }); // '<img src="http://example.com/fav.ico" alt="">'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function image(node) {
    return h(this, node, {
        'name': 'img',
        'attributes': {
            'src': normalizeURI(node.src),
            'alt': node.alt || '',
            'title': node.title
        }
    }, node.data);
}

/**
 * Stringify a deletion.
 *
 * @example
 *   strikethrough({
 *     children: [
 *       {
 *         type: 'text',
 *         value: 'foo'
 *       }
 *     ]
 *   }); // '<del>foo</del>'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function strikethrough(node) {
    return h(this, node, {
        'name': 'del',
        'content': this.all(node).join('')
    }, node.data);
}

/**
 * Stringify text.
 *
 * @example
 *   text({value: '&'}); // '&amp;'
 *
 *   text({value: 'foo'}); // 'foo'
 *
 * @param {Node} node - Node to compile.
 * @return {string} - Compiled node.
 * @this {HTMLCompiler}
 */
function text(node) {
    return trimLines(this.encode(node.value));
}

/**
 * Return an empty string for nodes which are ignored.
 *
 * @example
 *   ignore(); // ''
 *
 * @return {string} - Empty string.
 * @this {HTMLCompiler}
 */
function ignore() {
    return '';
}

/*
 * Helpers.
 */

visitors.visit = one;
visitors.all = all;
visitors.unknown = unknown;
visitors.generateFootnotes = generateFootnotes;

/*
 * Ignored nodes.
 */

visitors.yaml = ignore;
visitors.definition = ignore;
visitors.footnoteDefinition = ignore;

/*
 * Compilers.
 */

visitors.footnote = footnote;
visitors.root = root;
visitors.blockquote = blockquote;
visitors.list = list;
visitors.listItem = listItem;
visitors.paragraph = paragraph;
visitors.heading = heading;
visitors.table = table;
visitors.code = code;
visitors.html = html;
visitors.horizontalRule = rule;
visitors.inlineCode = inlineCode;
visitors.strong = strong;
visitors.emphasis = emphasis;
visitors.break = hardBreak;
visitors.link = link;
visitors.image = image;
visitors.footnoteReference = footnoteReference;
visitors.linkReference = linkReference;
visitors.imageReference = imageReference;
visitors.delete = strikethrough;
visitors.text = text;
visitors.escape = escape;

/*
 * Expose.
 */

module.exports = visitors;

},
"bLkkinq+cfH+K+vvafbEW9Pb1Xqndze6qheqOjJgGu8=":
function (require, module, exports, __dirname, __filename) {

var udp = require('dgram')
var pipe = require('stream').prototype.pipe
var os = require('os')

module.exports = function (port, loopback) {

  var addresses = {}
  var socket = udp.createSocket('udp4')

  socket.readable = socket.writable = true

  socket.write = function (message) {
    if('string' === typeof message)
      message = new Buffer(message, 'utf8')
    socket.send(message, 0, message.length, port, '255.255.255.255')
    return true
  }

  socket.end = function () {
    socket.close()
  }

  socket.on('close', function () {
    socket.emit('end')
  })

  var latest = null

  socket.on('message', function (msg, other) {
    if(addresses[other.address] && other.port === port) {
      if(loopback === false) return
      msg.loopback = true
    }

    msg.port = other.port
    msg.address = other.address

    //if paused, remember the latest item.
    //otherwise just drop those messages.
    if(socket.paused)
      return latest = msg

    latest = null
    socket.emit('data', msg)
  })

  socket.pause = function () {
    socket.paused = true
    return this
  }

  socket.resume = function () {
    socket.paused = false
    if(latest) {
      var msg = latest
      latest = null
      socket.emit('data', msg)
    }
    return this
  }

  socket.bind(port)
  socket.on('listening', function () {
    var ifaces = os.networkInterfaces()
    for(var k in ifaces)
      ifaces[k].forEach(function (address) {
        addresses[address.address] = true
      })
    socket.setBroadcast(true)
  })

  socket.pipe = pipe

  return socket
}

},
"bUb+wYxOM0+YvOoCWqSLdq3+rpm4/RFCxHx7vmWoBlc=":
function (require, module, exports, __dirname, __filename) {
var concatMap = require('concat-map');
var balanced = require('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}


},
"bYNzYibpIaLtH8GoFR/x2iKSULNSpoTREns6fvCLx7A=":
function (require, module, exports, __dirname, __filename) {
var looper = require('looper')
var Through = require('pull-core').Through

var window = module.exports =
Through(function (read, init, start) {
  start = start || function (start, data) {
    return {start: start, data: data}
  }
  var windows = [], output = [], ended = null
  var data, end
  var j = 0

  return function (abort, cb) {
    if(output.length)
      return cb(null, output.shift())
    if(ended)
      return cb(ended)
    var i = 0
    var k = j ++
    read(abort, looper(function (end, data) {
      var next = this
      var reduce, update, once = false
      if(end)
        ended = end

      function _update (end, _data) {
        if(once) return
        once = true
        delete windows[windows.indexOf(update)]
        output.push(start(data, _data))
      }

      if(!ended)
        update = init(data, _update)

      if(update)
        windows.push(update)
      else
        //don't allow data unless a window started here!
        once = true

      windows.forEach(function (update, i) {
        update(end, data)
      })

      if(output.length)
        return cb(null, output.shift())
      else if(ended)
        return cb(ended)
      else
        read(null, next)

  }))
  }
})

window.recent = function (size, time) {
  var current = null
  return window(function (data, cb) {
    if(current) return
    current = []
    var timer
      
    function done () {
      var _current = current
      current = null
      clearTimeout(timer)
      cb(null, _current)
    }

    if(time)
      timer = setTimeout(done, time)

    return function (end, data) {
      if(end) return done()
      current.push(data)
      if(size != null && current.length >= size)
        done()
    }
  }, function (_, data) {
    return data
  })
}

window.sliding = function (reduce, width) {
  width = width || 10
  var k = 0
  return window(function (data, cb) {
    var acc
    var i = 0
    var l = k++
    return function (end, data) {
      if(end) return
      acc = reduce(acc, data)
      if(width <= ++ i)
        cb(null, acc)
    }
  })
}

},
"bhC0gmXSZmRC+aw7OypLcenR25uM+NIQdraXNT9EWsA=":
function (require, module, exports, __dirname, __filename) {
var Buffer = require('buffer').Buffer

var BLAKE2s = (function () {
    function BLAKE2s(digestLength, key) {
        if (typeof digestLength === "undefined") { digestLength = 32; }
        this.isFinished = false;
        this.digestLength = 32;
        this.blockLength = 64;
        this.iv = [
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
        ];
        //TODO tree mode.
        if (digestLength <= 0) {
            digestLength = this.digestLength;
        } else if (digestLength > 32) {
            throw 'digestLength is too large';
        }
        var keyLength = 0;
        if (typeof key == 'string') {
            key = this.stringToUtf8Array(key);
            keyLength = key.length;
        } else if (typeof key == 'object') {
            keyLength = key.length;
        }
        if (keyLength > 32) {
            throw 'key too long';
        }

        var param = [digestLength & 0xff, keyLength, 1, 1];
        this.h = this.iv.slice(0);

        // XOR part of parameter block.
        this.h[0] ^= this.load32(param, 0);

        this.x = new Array(64);
        this.t0 = 0;
        this.t1 = 0;
        this.f0 = 0;
        this.f1 = 0;
        this.nx = 0;
        this.digestLength = digestLength;

        if (keyLength > 0) {
            for (var i = 0; i < keyLength; i++) {
                this.x[i] = key[i];
            }
            for (var i = keyLength; i < 64; i++) {
                this.x[i] = 0;
            }
            this.nx = 64;
        }
    }
    BLAKE2s.prototype.load32 = function (p, pos) {
        return ((p[pos] & 0xff) | ((p[pos + 1] & 0xff) << 8) | ((p[pos + 2] & 0xff) << 16) | ((p[pos + 3] & 0xff) << 24)) >>> 0;
    };

    BLAKE2s.prototype.store32 = function (p, pos, v) {
        p[pos] = (v >>> 0) & 0xff;
        p[pos + 1] = (v >>> 8) & 0xff;
        p[pos + 2] = (v >>> 16) & 0xff;
        p[pos + 3] = (v >>> 24) & 0xff;
    };

    BLAKE2s.prototype.processBlock = function (length) {
        this.t0 += length;
        if (this.t0 != this.t0 >>> 0) {
            this.t0 = 0;
            this.t1++;
        }

        var v0 = this.h[0], v1 = this.h[1], v2 = this.h[2], v3 = this.h[3], v4 = this.h[4], v5 = this.h[5], v6 = this.h[6], v7 = this.h[7], v8 = this.iv[0], v9 = this.iv[1], v10 = this.iv[2], v11 = this.iv[3], v12 = this.iv[4] ^ this.t0, v13 = this.iv[5] ^ this.t1, v14 = this.iv[6] ^ this.f0, v15 = this.iv[7] ^ this.f1;

        var m0 = this.load32(this.x, 0), m1 = this.load32(this.x, 4), m2 = this.load32(this.x, 8), m3 = this.load32(this.x, 12), m4 = this.load32(this.x, 16), m5 = this.load32(this.x, 20), m6 = this.load32(this.x, 24), m7 = this.load32(this.x, 28), m8 = this.load32(this.x, 32), m9 = this.load32(this.x, 36), m10 = this.load32(this.x, 40), m11 = this.load32(this.x, 44), m12 = this.load32(this.x, 48), m13 = this.load32(this.x, 52), m14 = this.load32(this.x, 56), m15 = this.load32(this.x, 60);

        // Round 1.
        v0 += m0;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m2;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m4;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m6;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m5;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m7;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m3;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m1;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m8;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m10;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m12;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m14;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m13;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m15;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m11;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m9;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 2.
        v0 += m14;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m4;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m9;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m13;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m15;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m6;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m8;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m10;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m1;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m0;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m11;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m5;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m7;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m3;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m2;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m12;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 3.
        v0 += m11;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m12;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m5;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m15;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m2;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m13;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m0;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m8;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m10;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m3;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m7;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m9;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m1;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m4;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m6;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m14;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 4.
        v0 += m7;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m3;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m13;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m11;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m12;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m14;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m1;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m9;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m2;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m5;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m4;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m15;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m0;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m8;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m10;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m6;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 5.
        v0 += m9;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m5;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m2;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m10;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m4;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m15;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m7;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m0;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m14;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m11;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m6;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m3;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m8;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m13;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m12;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m1;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 6.
        v0 += m2;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m6;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m0;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m8;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m11;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m3;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m10;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m12;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m4;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m7;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m15;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m1;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m14;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m9;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m5;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m13;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 7.
        v0 += m12;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m1;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m14;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m4;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m13;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m10;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m15;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m5;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m0;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m6;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m9;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m8;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m2;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m11;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m3;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m7;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 8.
        v0 += m13;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m7;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m12;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m3;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m1;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m9;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m14;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m11;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m5;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m15;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m8;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m2;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m6;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m10;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m4;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m0;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 9.
        v0 += m6;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m14;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m11;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m0;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m3;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m8;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m9;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m15;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m12;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m13;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m1;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m10;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m4;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m5;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m7;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v0 += m2;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 7) | v5 >>> 7;

        // Round 10.
        v0 += m10;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v1 += m8;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v2 += m7;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v3 += m1;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v2 += m6;
        v2 += v6;
        v14 ^= v2;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v10 += v14;
        v6 ^= v10;
        v6 = v6 << (32 - 7) | v6 >>> 7;
        v3 += m5;
        v3 += v7;
        v15 ^= v3;
        v15 = v15 << (32 - 8) | v15 >>> 8;
        v11 += v15;
        v7 ^= v11;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v1 += m4;
        v1 += v5;
        v13 ^= v1;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v9 += v13;
        v5 ^= v9;
        v5 = v5 << (32 - 7) | v5 >>> 7;
        v0 += m2;
        v0 += v4;
        v12 ^= v0;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v8 += v12;
        v4 ^= v8;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v0 += m15;
        v0 += v5;
        v15 ^= v0;
        v15 = v15 << (32 - 16) | v15 >>> 16;
        v10 += v15;
        v5 ^= v10;
        v5 = v5 << (32 - 12) | v5 >>> 12;
        v1 += m9;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 16) | v12 >>> 16;
        v11 += v12;
        v6 ^= v11;
        v6 = v6 << (32 - 12) | v6 >>> 12;
        v2 += m3;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 16) | v13 >>> 16;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 12) | v7 >>> 12;
        v3 += m13;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 16) | v14 >>> 16;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 12) | v4 >>> 12;
        v2 += m12;
        v2 += v7;
        v13 ^= v2;
        v13 = v13 << (32 - 8) | v13 >>> 8;
        v8 += v13;
        v7 ^= v8;
        v7 = v7 << (32 - 7) | v7 >>> 7;
        v3 += m0;
        v3 += v4;
        v14 ^= v3;
        v14 = v14 << (32 - 8) | v14 >>> 8;
        v9 += v14;
        v4 ^= v9;
        v4 = v4 << (32 - 7) | v4 >>> 7;
        v1 += m14;
        v1 += v6;
        v12 ^= v1;
        v12 = v12 << (32 - 8) | v12 >>> 8;
        v11 += v12;
        v6 ^= v11;
        v6 = (v6 << (32 - 7)) | (v6 >>> 7);
        v0 += m11;
        v0 += v5;
        v15 ^= v0;
        v15 = (v15 << (32 - 8)) | (v15 >>> 8);
        v10 += v15;
        v5 ^= v10;
        v5 = (v5 << (32 - 7)) | (v5 >>> 7);

        this.h[0] ^= v0 ^ v8;
        this.h[1] ^= v1 ^ v9;
        this.h[2] ^= v2 ^ v10;
        this.h[3] ^= v3 ^ v11;
        this.h[4] ^= v4 ^ v12;
        this.h[5] ^= v5 ^ v13;
        this.h[6] ^= v6 ^ v14;
        this.h[7] ^= v7 ^ v15;
    };

    BLAKE2s.prototype.stringToUtf8Array = function (s) {
        var arr = [];
        for (var i = 0; i < s.length; i++) {
            var c = s.charCodeAt(i);
            if (c < 128) {
                arr.push(c);
            } else if (c > 127 && c < 2048) {
                arr.push((c >> 6) | 192);
                arr.push((c & 63) | 128);
            } else {
                arr.push((c >> 12) | 224);
                arr.push(((c >> 6) & 63) | 128);
                arr.push((c & 64) | 128);
            }
        }
        return arr;
    };

    BLAKE2s.prototype._update = function (p, offset, length) {
        if (typeof offset === "undefined") { offset = 0; }
        if (typeof length === "undefined") { length = p.length; }
        if (this.isFinished) {
            throw 'update() after calling digest()';
        }
        if (typeof p == 'string') {
            if (offset != 0) {
                throw 'offset not supported for strings';
            }
            p = this.stringToUtf8Array(p);
            length = p.length;
            offset = 0;
        } else if (typeof p != 'object') {
            throw 'unsupported object: string or array required';
        }
        if (length == 0) {
            return;
        }
        var left = 64 - this.nx;
        if (length > left) {
            for (var i = 0; i < left; i++) {
                this.x[this.nx + i] = p[offset + i];
            }
            this.processBlock(64);
            offset += left;
            length -= left;
            this.nx = 0;
        }
        while (length > 64) {
            for (var i = 0; i < 64; i++) {
                this.x[i] = p[offset + i];
            }
            this.processBlock(64);
            offset += 64;
            length -= 64;
            this.nx = 0;
        }
        for (var i = 0; i < length; i++) {
            this.x[this.nx + i] = p[offset + i];
        }
        this.nx += length;
    };

    BLAKE2s.prototype.update = function (buffer, enc) {
      if(enc)
        buffer = new Buffer(buffer, enc)
      this._update(buffer)
      return this
    }

    BLAKE2s.prototype.digest = function (enc) {
        if (this.isFinished) {
            return this.result;
        }

        for (var i = this.nx; i < 64; i++) {
            this.x[i] = 0;
        }

        // Set last block flag.
        this.f0 = 0xffffffff;

        //TODO in tree mode, set f1 to 0xffffffff.
        this.processBlock(this.nx);

        var out = new Buffer(32);
        for (var i = 0; i < 8; i++) {
            var h = this.h[i];
            out[i * 4 + 0] = (h >>> 0) & 0xff;
            out[i * 4 + 1] = (h >>> 8) & 0xff;
            out[i * 4 + 2] = (h >>> 16) & 0xff;
            out[i * 4 + 3] = (h >>> 24) & 0xff;
        }
        this.result = out.slice(0, this.digestLength);
        this.isFinished = true;
        return enc ? this.result.toString(enc) : this.result;
    };

    return BLAKE2s;
})();

if('undefined' === typeof module)
  window.Blake2s = BLAKE2s
else
  module.exports = BLAKE2s

},
"bk9dbSa68ZTPS7tNghEARu1iFSBbQSxXp7UJfcFiPqw=":
function (require, module, exports, __dirname, __filename) {
var path = require('path');
var fs = require('fs');
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};

},
"bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=":
function (require, module, exports, __dirname, __filename) {
exports.id = 
function (item) {
  return item
}

exports.prop = 
function (map) {  
  if('string' == typeof map) {
    var key = map
    return function (data) { return data[key] }
  }
  return map
}

exports.tester = function (test) {
  if(!test) return exports.id
  if('object' === typeof test
    && 'function' === typeof test.test)
      return test.test.bind(test)
  return exports.prop(test) || exports.id
}

exports.addPipe = addPipe

function addPipe(read) {
  if('function' !== typeof read)
    return read

  read.pipe = read.pipe || function (reader) {
    if('function' != typeof reader && 'function' != typeof reader.sink)
      throw new Error('must pipe to reader')
    var pipe = addPipe(reader.sink ? reader.sink(read) : reader(read))
    return reader.source || pipe;
  }
  
  read.type = 'Source'
  return read
}

var Source =
exports.Source =
function Source (createRead) {
  function s() {
    var args = [].slice.call(arguments)
    return addPipe(createRead.apply(null, args))
  }
  s.type = 'Source'
  return s
}


var Through =
exports.Through = 
function (createRead) {
  return function () {
    var args = [].slice.call(arguments)
    var piped = []
    function reader (read) {
      args.unshift(read)
      read = createRead.apply(null, args)
      while(piped.length)
        read = piped.shift()(read)
      return read
      //pipeing to from this reader should compose...
    }
    reader.pipe = function (read) {
      piped.push(read) 
      if(read.type === 'Source')
        throw new Error('cannot pipe ' + reader.type + ' to Source')
      reader.type = read.type === 'Sink' ? 'Sink' : 'Through'
      return reader
    }
    reader.type = 'Through'
    return reader
  }
}

var Sink =
exports.Sink = 
function Sink(createReader) {
  return function () {
    var args = [].slice.call(arguments)
    if(!createReader)
      throw new Error('must be createReader function')
    function s (read) {
      args.unshift(read)
      return createReader.apply(null, args)
    }
    s.type = 'Sink'
    return s
  }
}


exports.maybeSink = 
exports.maybeDrain = 
function (createSink, cb) {
  if(!cb)
    return Through(function (read) {
      var ended
      return function (close, cb) {
        if(close) return read(close, cb)
        if(ended) return cb(ended)

        createSink(function (err, data) {
          ended = err || true
          if(!err) cb(null, data)
          else     cb(ended)
        }) (read)
      }
    })()

  return Sink(function (read) {
    return createSink(cb) (read)
  })()
}


},
"c3ID2FYTPmynJDt0D+aTeRypUW+XX8JUDD5RCi0H2rM=":
function (require, module, exports, __dirname, __filename) {
var path = require('path')
var home = require('osenv').home
var nonPrivate = require('non-private-ip')
var merge = require('deep-extend')

var RC = require('rc')

module.exports = function (name, override) {
  name = name || 'ssb'
  return RC(name || 'ssb', merge({
    //just use an ipv4 address by default.
    //there have been some reports of seemingly non-private
    //ipv6 addresses being returned and not working.
    //https://github.com/ssbc/scuttlebot/pull/102
    party: true,
    host: nonPrivate.v4 || '',
    port: 8008,
    timeout: 30000,
    pub: true,
    local: true,
    friends: {
      dunbar: 150,
      hops: 3
    },
    gossip: {
      connections: 2
    },
    path: path.join(home(), '.' + name),
    master: [],
    logging: { level: 'notice' }
  }, override || {}))
}

},
"cN+YzkA5pxEnj0g9BajTh83qOdf3OsYkF6AlUW2Oa8U=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var ltgt = require('ltgt')

var has = exports.has = function (obj, prop) {
  return Object.hasOwnProperty.call(obj, prop)
}

var isString = exports.isString = function (s) {
  return 'string' === typeof s
}

var isUndef = exports.isUndef = function isUndef (u) {
  return 'undefined' === typeof u
}


var find = exports.find = function (ary, test) {
  for(var i = 0; i < ary.length; i++)
    if(test(ary[i], i, ary)) return ary[i]
}

var first = exports.first = function (ary, map) {
  for(var i = 0; i < ary.length; i++) {
    var v = map(ary[i], i, ary)
    if(v) return v
  }
}

var path = exports.path = function (path, obj) {

  if(isString(path))
    return obj[path]

  var l = path.length

  for(var i = 0; i < l; i++) {
    obj = obj[path[i]]
    if(null == obj) return obj
  }

  return obj
}

var glob = exports.glob = function (path, obj) {

  if(isString(path)) path = [path]//throw new Error('path must be array')

  var collection = []

  ;(function recurse(obj, i) {
    if(path.length <= i) collection.push(obj)
    else if(path[i] === true) {
      for(var k in obj)
        recurse(obj[k], i + 1)
    }
    else if(obj != null)
      recurse(obj[path[i]], i + 1)
  })(obj, 0)

  return collection

}

var eachpath = exports.eachpath = function (paths, value) {
  if(isString(paths[0])) paths = [paths]
  var values = paths.map(function (p) {
    return glob(p, value)
  })

  var maxlen = values.reduce(function (M, a) {
    return Math.max(M, a.length)
  }, 0)

  var o = new Array(maxlen)
  for(var i = 0; i < maxlen; i++) o[i] = []

  values.forEach(function (a, j) {
    for(var i = 0; i < maxlen; i++) {
      o[i][j] = a[i%a.length]
    }
  })
  return o
}

exports.createInit = function (setup) {
  var ready = false, waiting = []
  setup(function (err) {
    ready = true
    while(waiting.length) waiting.shift()(err)
  })

  return function (cb) {
    if(ready) return cb()
    waiting.push(cb)
  }
}

var range = exports.range = function (query, value) {

  var matches = true
  if(has(query, 'lt')   && !(value <  query.lt))   matches = false
  if(has(query, 'lte')  && !(value <= query.lte))  matches = false
  if(has(query, 'gt')   && !(value >  query.gt))   matches = false
  if(has(query, 'gte')  && !(value >= query.gte))  matches = false
  if(has(query, 'eq')   && !(value === query.eq))  matches = false
  if(has(query, 'neq')  && !(value !== query.neq)) matches = false
  if(has(query, 'ok')   && !(!!value))             matches = false
  if(has(query, 'nok')  && !(!value))              matches = false

  return matches
}

var isArray = Array.isArray

function filter(query, data) {
  return glob(query.path, data).some(function (value) {
    return range(query, value)
  })
}

exports.createFilter = function (query) {
  return function (data) {
    if(isArray(query)) {
      for(var i = 0; i < query.length; i++)
        if(!filter(query[i], data)) return false
      return true
    }
    return filter(query, data)
  }
}

//get the nesting depth (number of arrays inside arrays)
exports.depth = function depth (ary) {
  if(!isArray(ary)) return 0
  return 1 + ary.reduce(function (M, a) {
    return Math.max(M, depth(a))
  }, 0)
}

exports.assertDepth = function (path, name) {
  var d = exports.depth(path)
  if(d !== 2)
    throw new Error(
      (name ? name + ': ' : '')
    + 'depth of path:' + JSON.stringify(path) + ' was ' + d + '. '
    + 'expected a path of depth 2 [[path,...], ...]'
    )
}

var hasRange = function (opts) {
  return (
    has(opts, 'lt') ||
    has(opts, 'gt') ||
    has(opts, 'lte') ||
    has(opts, 'gte')
  )
}

exports.toIndexable = function (subq) {
  var opts
  if(has(subq, 'eq'))
    opts = {path: [subq.path], gte: [subq.eq], lte: [subq.eq]}
  else if(hasRange(subq)){
    opts = ltgt.toLtgt(
      subq, {path: [subq.path]},
      function (value) { return [value] }
    )
  }
  return opts
}

},
"cUUx3xsGWn1/AacfQFVmqU7IqYBZhB/mOgmOeGtwMVQ=":
function (require, module, exports, __dirname, __filename) {
//
// extend core typewise collations
//
var collation = require('typewise-core/collation')

// TODO: set, map

module.exports = collation

},
"ch3b4XdlyANbo95l1vTW6wtEx9xiH1YBtKit7ABCMoU=":
function (require, module, exports, __dirname, __filename) {
'use strict';

var bops = require('bops')

var compare = function(a, b) {
  var result;
  for (var i = 0, end = Math.min(a.length, b.length); i < end; i++) {
    result = a.get(i) - b.get(i);
    if (result) return result;
  }
  return a.length - b.length;
};

var _type = {
  function: {
    parse: function() {
      throw new Error('Fallback for function reviving NYI');
    },
    serialize: function() {
      throw new Error('Fallback for function serializing NYI');
    }
  }
};

// Attempt to use utilities from optional `typewise` dependency
try {
  var typewise = require('typewise');
  compare = typewise.comparators.bytewise;
  _type.function = typewise.types.function;
}
catch (e) {}

// Sort tags used to preserve binary total order
// The tag is 1 byte, which gives us plenty of room to grow.
// We leave some space between the various types for possible future compatibility with extensions.

// 0x00 reserved for termination character
var NULL = 0x10;
var FALSE = 0x20;
var TRUE = 0x21;
var NEGATIVE_INFINITY = 0x40;
var NEGATIVE_NUMBER = 0x41; // packed in an inverted form to sort bitwise ascending
var POSITIVE_NUMBER = 0x42;
var POSITIVE_INFINITY = 0x43;
var DATE_PRE_EPOCH = 0x51; // packed identically to a NEGATIVE_NUMBER
var DATE_POST_EPOCH = 0x52; // packed identically to a POSITIVE_NUMBER
var BUFFER = 0x60;
var STRING = 0x70;
var ARRAY = 0xa0; // escapes nested types with bit shifting where necessary to maintain order
var OBJECT = 0xb0; // just like couchdb member order is preserved and matters for collation
var REGEXP = 0xd0; // packed as tuple of two strings, the end being flags
var FUNCTION = 0xe0; // packed as array, revived by safe eval in an isolated environment (if available)
var UNDEFINED = 0xf0;
// 0xff reserved for high-key sentinal


var flatTypes = [ BUFFER, STRING ];
var structuredTypes = [ ARRAY, OBJECT, FUNCTION, REGEXP ];
var nullaryTypes = [ NULL, FALSE, TRUE, NEGATIVE_INFINITY, POSITIVE_INFINITY, UNDEFINED ];
var fixedSizeTypes = {};
fixedSizeTypes[NEGATIVE_NUMBER] = 8;
fixedSizeTypes[POSITIVE_NUMBER] = 8;
fixedSizeTypes[DATE_PRE_EPOCH] = 8;
fixedSizeTypes[DATE_POST_EPOCH] = 8;


function encode(source) {

  if (source === void 0) return tag(UNDEFINED);
  if (source === null) return tag(NULL);

  // Unbox possible natives

  var value = source != null && source.valueOf ? source.valueOf() : source;
  var type;

  // NaN and Invalid Date not permitted
  if (value !== value) {
    if (source instanceof Date) throw new TypeError('Invalid Date not permitted');
    throw new TypeError('NaN not permitted');
  }

  if (value === false) return tag(FALSE);
  if (value === true) return tag(TRUE);

  if (source instanceof Date) {
    // Normalize -0 values to 0
    if (Object.is(value, -0)) value = 0;
    type = value < 0 ? DATE_PRE_EPOCH : DATE_POST_EPOCH;
    return tag(type, encodeNumber(value));
  }

  if (typeof value === 'number') {
    if (value === Number.NEGATIVE_INFINITY) return tag(NEGATIVE_INFINITY);
    if (value === Number.POSITIVE_INFINITY) return tag(POSITIVE_INFINITY);
    // Normalize -0 values to 0
    if (Object.is(value, -0)) value = 0;
    type = value < 0 ? NEGATIVE_NUMBER : POSITIVE_NUMBER;
    return tag(type, encodeNumber(value));
  }

  if (bops.is(value)) {
    return tag(BUFFER, value);
  }

  if (typeof value === 'string') {
    return tag(STRING, bops.from(value, 'utf8'));
  }

  // RegExp
  if (value instanceof RegExp) {
    // TODO
    throw new Error('Not Implemented Yet');
  }

  // Function
  if (typeof value === 'function') {
    return tag(FUNCTION, encodeList(_type['function'].serialize(value)));
  }

  // Array
  // TODO better handling for sparse arrays
  if (Array.isArray(value)) {
    return tag(ARRAY, encodeList(value));
  }

  // Object
  if (typeof value === 'object' && Object.prototype.toString.call(value) === '[object Object]') {
    // Packs into an array, e.g. [ k1, v1, k2, v2, ... ]
    var items = [];
    Object.keys(value).forEach(function(key) {
      items.push(key);
      items.push(value[key]);
    });
    return tag(OBJECT, encodeList(items));
  }

  // TODO RegExp and other types from Structured Clone algorithm (Blob, File, FileList)

  throw new Error('Cannot encode unknown type: ' + source);
}

function decode(buffer) {

  var type = bops.readUInt8(buffer, 0);

  // Nullary types
  if (~nullaryTypes.indexOf(type)) {
    if (buffer.length !== 1) throw new Error('Invalid encoding in buffer: ' + buffer);

    if (type === UNDEFINED) return;
    if (type === NULL) return null;
    if (type === FALSE) return false;
    if (type === TRUE) return true;
    if (type === NEGATIVE_INFINITY) return Number.NEGATIVE_INFINITY;
    if (type === POSITIVE_INFINITY) return Number.POSITIVE_INFINITY;
  }

  // Fixed size types
  var chunk = bops.subarray(buffer, 1);
  var chunkSize = fixedSizeTypes[type];
  if (chunkSize) {
    if (chunk.length !== chunkSize) throw new Error('Invalid size for buffer: ' + buffer);

    if (type === NEGATIVE_NUMBER || type === POSITIVE_NUMBER) {
      return decodeNumber(chunk, type === NEGATIVE_NUMBER);
    }
    if (type === DATE_PRE_EPOCH || type === DATE_POST_EPOCH) {
      return new Date(decodeNumber(chunk, type === DATE_PRE_EPOCH));
    }
  }

  // Flat types
  if (type === BUFFER) return chunk;
  if (type === STRING) return bops.to(chunk, 'utf8');

  // Structured types
  if (~structuredTypes.indexOf(type)) {
    var result = parseHead(buffer);
    if (result[1] !== buffer.length) {
      throw new Error('List deserialization fail: ' + bops.readUInt8(result, 1) + '!=' + bops.length(buffer));
    }
    return result[0];
  }

}


function tag(type, buffer) {
  // Just return tag byte for nullary types (no buffer provided)
  type = bops.from([ type ]);
  if (!buffer) return type;
  // Prepend a type tag byte to buffer
  return bops.join([ type, buffer ]);
}

function encodeNumber(value) {
  var buffer = bops.create(8);
  if (value < 0) {
    bops.writeDoubleBE(buffer, -value, 0);
    return invert(buffer);
  }
  bops.writeDoubleBE(buffer, value, 0);
  return buffer;
}

function decodeNumber(buffer, negative) {
  if (negative) buffer = invert(buffer);
  var value = bops.readDoubleBE(buffer, 0);
  return negative ? -value : value;
}


function encodeList(items) {
  // TODO pass around a map of references already encoded to detect cycles
  var buffers = [];
  var chunk;
  for (var i = 0, end = items.length; i < end; ++i) {
    chunk = encode(items[i]);
    var type = bops.readUInt8(chunk, 0);
    // We need to escape a few bytes in string and buffer types to prevent confusion with the end byte
    if (~flatTypes.indexOf(type)) chunk = flatEscape(chunk);
    buffers.push(chunk);
  }
  // Close the list with an end byte
  buffers.push(bops.create([ 0 ]));
  return bops.join(buffers);
}

// TODO expose in public API
function flatEscape(buffer) {
  // Escape high and low bytes 0x00 and 0xff (and by necessity, 0x01 and 0xfe)
  var b, bytes = [];
  for (var i = 0, end = buffer.length; i < end; ++i) {
    b = buffer[i];
    // Escape low bytes with 0x01 and by adding 1
    if (b === 0x01 || b === 0x00) bytes.push(0x01, b + 1);
    // Escape high bytes with 0xfe and by subtracting 1
    else if (b === 0xfe || b === 0xff) bytes.push(0xfe, b - 1);
    // Otherwise no escapement needed
    else bytes.push(b);
  }
  // Add end byte
  bytes.push(0);
  return bops.from(bytes);
}

// TODO expose in public API
function flatUnescape(buffer) {
  var b, bytes = [];
  // Don't escape last byte
  for (var i = 0, end = buffer.length; i < end; ++i) {
    b = bops.readUInt8(buffer, i);
    // If low-byte escape tag use the following byte minus 1
    if (b === 0x01) bytes.push(bops.readUInt8(buffer, ++i) - 1);
    // If high-byte escape tag use the following byte plus 1
    else if (b === 0xfe) bytes.push(bops.readUInt8(buffer, ++i) + 1);
    // Otherwise no unescapement needed
    else bytes.push(b);
  }
  return bops.from(bytes);
}


function parseHead(buffer) {
  // Parses and returns the first type on the buffer and the total bytes consumed
  var type = bops.readUInt8(buffer, 0);
  // Nullary
  if (~nullaryTypes.indexOf(type)) return [ decode(bops.from([ type ])), 1 ];
  // Fixed
  var size = fixedSizeTypes[type];
  if (size++) return [ decode(bops.subarray(buffer, 0, size)), size ];
  // Flat
  var index;
  var end;
  if (~flatTypes.indexOf(type)) {
    // Find end byte
    for (index = 1, end = buffer.length; index < end; ++index) {
      if (bops.readUInt8(buffer, index) === 0x00) break;
    }
    if (index >= buffer.length) throw new Error('No ending byte found for list');
    var chunk = flatUnescape(bops.subarray(buffer, 0, index));
    // Add 1 to index to skip over end byte
    return [ decode(chunk), index + 1 ];
  }
  
  // Nested, recurse for each item
  var list = [];
  index = 1;
  var next;
  while ((next = bops.readUInt8(buffer, index)) !== 0) {
    var result = parseHead(bops.subarray(buffer, index));
    list.push(result[0]);
    index += result[1];
    if (index >= buffer.length) throw new Error('No ending byte found for nested list');
  }
  return [ structure(type, list), index + 1 ];
}

function structure(type, list) {
  if (type === ARRAY) return list;
  if (type === FUNCTION) {
    return _type['function'].parse(list);
  }
  var i, end;
  if (type === OBJECT) {
    var object = Object.create(null);
    for (i = 0, end = list.length; i < end; ++i) {
      object[list[i]] = list[++i];
    }
    return object;
  }
  throw new Error('Unknown type: ' + type);
}


function invert(buffer) {
  var bytes = [];
  for (var i = 0, end = buffer.length; i < end; ++i) {
    bytes.push(~bops.readUInt8(buffer, i));
  }
  return bops.from(bytes);
}

exports.encode = encode;
exports.decode = decode;
exports.compare = compare;
exports.buffer = true;
exports.type = 'bytewise';

},
"cmcRqa+IsEsc2DIUeGXoK+grYAXQPGL4p7ftDNw4G6g=":
function (require, module, exports, __dirname, __filename) {

var looper = module.exports = function (fun) {
  (function next () {
    var loop = true, returned = false, sync = false
    do {
      sync = true; loop = false
      fun.call(this, function () {
        if(sync) loop = true
        else     next()
      })
      sync = false
    } while(loop)
  })()
}

},
"coegeFa4TmC7NW+WMdonAGyaTsOmLfMvl1usTNAkhyU=":
function (require, module, exports, __dirname, __filename) {
var cont     = require('cont')
var pull     = require('pull-stream')
var defer    = require('pull-defer')
var path     = require('path')
var toPull   = require('stream-to-pull-stream')
var explain  = require('explain-error')
var mkdirp   = require('mkdirp')
var rimraf   = require('rimraf')
var fs       = require('fs')
var glob     = require('pull-glob')
var paramap  = require('pull-paramap')
var cat      = require('pull-cat')
var Notify   = require('pull-notify')

var u = require('./util')
var createHash = u.createHash, toPath = u.toPath, isHash = u.isHash

function write (filename, cb) {
  return toPull.sink(fs.createWriteStream(filename), cb)
}

function read (filename) {
  return toPull.source(fs.createReadStream(filename))
}

function toArray (h) {
  return Array.isArray(h) ? h : [h]
}

var Blobs = module.exports = function (config) {
  var dir
  if('string' === typeof config)
    dir = config, config = {dir: dir}

  var newBlob = Notify()

  config = config || {}
  config.hash = config.hash || config.alg || 'blake2s'

  dir = config.dir

  var n = 0
  var waiting = [], tmp = false, clean = false

  function init (cb) {
    if(tmp) return cb()
    else waiting.push(cb)
  }

  var tmpdir = path.join(dir, 'tmp')

  rimraf(tmpdir, function () {
    mkdirp(tmpdir, function () {
      tmp = true; while(waiting.length) waiting.shift()()
    })
  })

  function has (hash) {
    return function (cb) {
      fs.stat(toPath(dir, hash), function (err, stat) {
        cb(null, !!stat)
      })
    }
  }

  function size (hash) {
    return function (cb) {
      fs.stat(toPath(dir, hash), function (err, stat) {
        cb(null, stat ? stat.size : null)
      })
    }
  }

  function createTester (test) {
    return function (hashes, cb) {
      var n = !Array.isArray(hashes)
      cont.para(toArray(hashes).map(test)) (function (_, ary) {
        // This will only error if the hash is not present,
        // so never callback an error.
        // PS. if you have a situation where you never error
        // add a comment like this one to explain why.
        if(n) cb(null, ary[0])
        else  cb(null, ary)
      })
      return cb
    }
  }

  function toHash(filename) {
    var parts = filename.replace(dir+'/', '').split('/')
    var alg = parts.shift()
    return new Buffer(parts.join(''), 'hex').toString('base64')+'.'+alg
  }

  var listeners = []


  return {
    get: function (opts) {
      if(isHash(opts))
        return read(toPath(dir, opts))

      var hash = opts.key || opts.hash
      if(!isHash(hash))
        return pull.error(new Error(
          'multiblob.get: {hash} is mandatory'
        ))

      var stream = defer.source()
      fs.stat(toPath(dir, hash), function (err, stat) {
        if(opts.size != null && opts.size !== stat.size)
          stream.abort(new Error('incorrect file length,'
            + ' requested:' + opts.size + ' file was:' + stat.size
            + ' for file:' + hash
          ))

        else if(opts.max != null && opts.max < stat.size)
          stream.abort(new Error('incorrect file length,'
            + ' requested:' + opts.size + ' file was:' + stat.size
            + ' for file:' + hash
          ))

        else
          stream.resolve(read(toPath(dir, hash)))
      })

      return stream
    },

    size: createTester(size),

    has: createTester(has),

    add: function (hash, cb) {
      if(!cb) cb = hash, hash = null

      if(!cb) cb = function (err) {
        if(err) explain(err, 'no callback provided')
      }

      var deferred = defer.sink()
      init(function () {
        var tmpfile = path.join(dir, 'tmp', Date.now() + '-' + n++)
        var hasher = createHash(config.hash)
        var size = 0

        deferred.resolve(pull(
          hasher,
          pull.through(function (data) {
            size += data.length
          }),
          write(tmpfile, function (err) {
            if(err) return cb(explain(err, 'could not write to tmpfile'))

            if(hash && hash !== hasher.digest)
              return cb(new Error('actual hash:'+ hasher.digest
                + ' did not match expected hash:'+hash), hasher.digest)

            var p = toPath(dir, hash || hasher.digest)

            mkdirp(path.dirname(p), function () {
              fs.rename(tmpfile, p, function (err) {
                if(err) cb(explain(err, 'could not move file'))
                else    newBlob({id:toHash(p), size: size, ts: Date.now()}), cb(null, hasher.digest)
              })
            })
          })
        ))
      })

      return deferred
    },
    ls: function (opts) {
      opts = opts || {}
      var long = (opts.size || opts.long)
      var source = pull(
        glob(path.join(dir, '*', '*', '*')),
        long
        ? paramap(function (filename, cb) {
            fs.stat(filename, function (err, stat) {
              cb(err, {id: toHash(filename), size: stat.size, ts: +stat.ctime})
            })
          }, 32)
        : pull.map(toHash)
      )

      if(!opts.live) return source

      return cat([
        source,
        pull.once({sync: true}),
          long
          ? newBlob.listen()
          : pull(newBlob.listen(), pull.map(function (e) { return e.id }))
      ])
      
    },
    rm: function (hash, cb) {
      fs.unlink(toPath(dir, hash), cb)
    },
    resolve: function (hash) {
      return toPath(dir, hash)
    }
  }
}

},
"d6cv1s6pAyR8nN6Cy140raurSSAruTn8p2pokFargeE=":
function (require, module, exports, __dirname, __filename) {
var proto = {}
  , rex = /read.+/
  , buildFn

buildFn = function(key) {
  var code = '' +
    'return buf.' + key + '(' + ['a', 'b', 'c'].join(',' ) + ')'

  return new Function(['buf', 'a', 'b', 'c'], code)
}

module.exports = proto

for(var key in Buffer.prototype) {
  if(rex.test(key)) {
    proto[key] = buildFn(key)
  }
}

},
"dExQ/iUTH58eRBQlgKuvDTqkq6YXtil9WVSvlx4tbs8=":
function (require, module, exports, __dirname, __filename) {
var Graphmitter = require('graphmitter')
var pull        = require('pull-stream')
var mlib        = require('ssb-msgs')
var memview     = require('level-memview')
var pushable    = require('pull-pushable')
var mdm         = require('mdmanifest')
var valid       = require('../lib/validators')
var apidoc      = require('../lib/apidocs').friends

// friends plugin
// methods to analyze the social graph
// maintains a 'follow' and 'flag' graph

function isFunction (f) {
  return 'function' === typeof f
}

function isString (s) {
  return 'string' === typeof s
}

exports.name = 'friends'
exports.version = '1.0.0'
exports.manifest = mdm.manifest(apidoc)

exports.init = function (sbot, config) {

  var graphs = {
    follow: new Graphmitter(),
    flag: new Graphmitter()
  }

  // view processor
  var syncCbs = []
  function awaitSync (cb) {
    if (syncCbs) syncCbs.push(cb)
    else cb()
  }

  // read/watch the log for changes to the social graph
  pull(sbot.createLogStream({ live: true }), pull.drain(function (msg) {

    if (msg.sync) {
      syncCbs.forEach(function (cb) { cb() })
      syncCbs = null
      return
    }

    var c = msg.value.content
    if (c.type == 'contact') {
      mlib.asLinks(c.contact).forEach(function (link) {
        if ('following' in c) {
          if (c.following)
            graphs.follow.edge(msg.value.author, link.link, true)
          else
            graphs.follow.del(msg.value.author, link.link)

        }
        if ('flagged' in c) {
          if (c.flagged)
            graphs.flag.edge(msg.value.author, link.link, c.flagged)
          else
            graphs.flag.del(msg.value.author, link.link)
        }
      })
    }
  }))

  return {

    get: valid.sync(function (opts) {
      var g = graphs[opts.graph || 'follow']
      if(!g) throw new Error('opts.graph must be provided')
      return g.get(opts.source, opts.dest)
    }, 'object?'),

    all: valid.async(function (graph, cb) {
      if (typeof graph == 'function') {
        cb = graph
        graph = null
      }
      if (!graph)
        graph = 'follow'
      awaitSync(function () {
        cb(null, graphs[graph] ? graphs[graph].toJSON() : null)
      })
    }, 'string?'),

    path: valid.sync(function (opts) {
      if(isString(opts))
        opts = {source: sbot.id, dest: opts}
      return graphs.follow.path(opts)

    }, 'string|object'),
    
    createFriendStream: valid.source(function (opts) {
      opts = opts || {}
      var live = opts.live === true
      var meta = opts.meta === true
      var start = opts.start || sbot.id
      var graph = graphs[opts.graph || 'follow']
      if(!graph)
        return pull.error(new Error('unknown graph:' + opts.graph))
      var cancel, ps = pushable(function () {
        cancel && cancel()
      })

      function push (to, hops) {
        return ps.push(meta ? {id: to, hops: hops} : to)
      }

      //by default, also emit your own key.
      if(opts.self !== false)
        push(start, 0)

      var conf = config.friends || {}
      cancel = graph.traverse({
        start: start,
        hops: opts.hops || conf.hops || 3,
        max: opts.dunbar || conf.dunbar || 150,
        each: function (_, to, hops) {
          if(to !== start) push(to, hops)
        }
      })

      if(!live) { cancel(); ps.end() }

      return ps
    }, 'createFriendStreamOpts?'),

    hops: valid.async(function (start, graph, opts, cb) {
      if (typeof opts == 'function') { // (start|opts, graph, cb)
        cb = opts
        opts = null
      } else if (typeof graph == 'function') { // (start|opts, cb)
        cb = graph
        opts = graph = null
      }
      opts = opts || {}
      if(isString(start)) { // (start, ...)
        // first arg is id string
        opts.start = start
      } else if (start && typeof start == 'object') { // (opts, ...)
        // first arg is opts
        for (var k in start)
          opts[k] = start[k]
      }

      var conf = config.friends || {}
      opts.start  = opts.start  || sbot.id
      opts.dunbar = opts.dunbar || conf.dunbar || 150
      opts.hops   = opts.hops   || conf.hops   || 3

      var g = graphs[graph || 'follow']
      if (!g)
        return cb(new Error('Invalid graph type: '+graph))

      awaitSync(function () {
        cb(null, g.traverse(opts))
      })
    }, ['feedId', 'string?', 'object?'], ['createFriendStreamOpts'])
  }
}

},
"dJExb2QIXWVtCYEVjUZImSHXrDegUkHDIbJ8QrcZBWM=":
function (require, module, exports, __dirname, __filename) {

var endable = require('./endable')
var pull = require('pull-stream')
module.exports = function (stream, goodbye) {
  goodbye = goodbye || 'GOODBYE'
  var e = endable(goodbye)

  return {
    // when the source ends,
    // send the goodbye and then wait to recieve
    // the other goodbye.
    source: pull(stream.source, e),
    sink: pull(
      //when the goodbye is received, allow the source to end.
      pull.filter(function (data) {
        if(data !== goodbye) return true
        e.end()
      }),
      stream.sink
    )
  }

}

},
"dKtews1S4sHvaZhZ+ceqemQI9/cjFXbbOwtWrx2X2WY=":
function (require, module, exports, __dirname, __filename) {
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},
"dSyQjl7jHQye3+fIwCpbUl0+ow/aj50QE4Hthzcp464=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2014 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var encodingNames = [
        'hex'
      , 'utf8'
      , 'utf-8'
      , 'ascii'
      , 'binary'
      , 'base64'
      , 'ucs2'
      , 'ucs-2'
      , 'utf16le'
      , 'utf-16le'
    ]

module.exports = (function () {
  function isBinary (data) {
    return data === undefined || data === null || Buffer.isBuffer(data)
  }

  var encodings = {}

  encodings.utf8 = encodings['utf-8'] = {
      encode : function (data) {
        return isBinary(data) ? data : String(data)
      }
    , decode : function (data) { return data }
    , buffer : false
    , type   : 'utf8'
  }

  encodings.json = {
      encode : JSON.stringify
    , decode : JSON.parse
    , buffer : false
    , type   : 'json'
  }

  encodings.binary = {
      encode : function (data) {
        return isBinary(data) ? data : new Buffer(data)
      }
    , decode : function (data) {
        return data
      }
    , buffer : true
    , type   : 'binary'
  }

  encodingNames.forEach(function (type) {
    if (encodings[type])
      return

    encodings[type] = {
        encode : function (data) {
          return isBinary(data) ? data : new Buffer(data, type)
        }
      , decode : function (buffer) {
          return buffer.toString(type)
        }
      , buffer : true
      , type   : type // useful for debugging purposes
    }
  })

  return encodings
})()


},
"dTPouclBa8UNPDemLXOS7XGs5BZpoD3RzibOMvm3NPY=":
function (require, module, exports, __dirname, __filename) {
var bash_codes = exports.bash_codes = {
	"BLACK" : {
		"text" : "\033[0;30m",
		"underline": "\033[4;30m",
		"background": "\033[40m",
		"bold":"\033[1;30m",
		"hi_text":"\033[0;90m",
		"hi_bold" : "\033[1;90m",
		"hi_background" : "\033[0;100m"
	},
	"RED" : {
		"text" : "\033[0;31m",
		"bold":"\033[1;31m",
		"underline": "\033[4;31m",
		"background": "\033[41m",
		"hi_text":"\033[0;91m",
		"hi_bold" : "\033[1;91m",
		"hi_background" : "\033[0;101m"
	},
	"GREEN" : {
		"text" : "\033[0;32m",
		"bold":"\033[1;32m",
		"underline": "\033[4;32m",
		"background": "\033[42m",
		"hi_text":"\033[0;92m",
		"hi_bold" : "\033[1;92m",
		"hi_background" : "\033[0;102m"
	},
	"YELLOW" : {
		"text" : "\033[0;33m",
		"bold":"\033[1;33m",
		"underline": "\033[4;33m",
		"background": "\033[43m",
		"hi_text":"\033[0;93m",
		"hi_bold" : "\033[1;93m",
		"hi_background" : "\033[0;103m"
	},
	"BLUE" : {
		"text" : "\033[0;34m",
		"bold":"\033[1;34m",
		"underline": "\033[4;34m",
		"background": "\033[44m",
		"hi_text":"\033[0;94m",
		"hi_bold" : "\033[1;94m",
		"hi_background" : "\033[0;104m"
	},
	"PURPLE" : {
		"text" : "\033[0;35m",
		"bold":"\033[1;35m",
		"underline": "\033[4;35m",
		"background": "\033[45m",
		"hi_text":"\033[0;95m",
		"hi_bold" : "\033[1;95m",
		"hi_background" : "\033[0;105m"
	},
	"CYAN" : {
		"text" : "\033[0;36m",
		"bold":"\033[1;36m",
		"underline": "\033[4;36m",
		"background": "\033[46m",
		"hi_text":"\033[0;96m",
		"hi_bold" : "\033[1;96m",
		"hi_background" : "\033[0;106m"
	},
	"WHITE" : {
		"text" : "\033[0;37m",
		"bold":"\033[1;37m",
		"underline": "\033[4;37m",
		"background": "\033[47m",
		"hi_text":"\033[0;97m",
		"hi_bold" : "\033[1;97m",
		"hi_background" : "\033[0;107m"
	}
};

exports.colors = {
	BLACK: "BLACK",
	RED: "RED",
	GREEN: "GREEN",
	YELLOW: "YELLOW",
	BLUE: "BLUE",
	PURPLE: "PURPLE",
	CYAN: "CYAN",
	WHITE: "WHITE"
};

var styles = exports.styles = {
	bold: "bold",
	underline: "underline",
	background: "background",
	hi_text: "hi_text",
	hi_bold: "hi_bold",
	hi_background: "hi_background"
};

var REMOVE_COLOR = exports.REMOVE_COLOR = "\033[0m";


// various logical inconsistencies in the code below - renderColor and wrap seem like they should be combined, but I'm letting wrap basically stand on its own
// in case anyone wants access to explicitly handle background or underline stuff. I feel like those are a bit more special-casey, and generally speakign
// users are going to want to quickly turn a word or phrase into a single color without worrying about background or underline. So the .colorName methods
// are just syntactic sugar.
exports.wrap = function(str, color, style) {
	var c = bash_codes[color.toUpperCase()];
	var s = styles[style] || "text";
	
	return render(c[s], str);
};

exports.black = function(str, hi) {
	return renderColor(str, bash_codes.BLACK, hi);
};

exports.red = function(str, hi) {
	return renderColor(str, bash_codes.RED, hi);
};

exports.green = function(str, hi) {
	return renderColor(str, bash_codes.GREEN, hi);
};

exports.yellow = function(str, hi) {
	return renderColor(str, bash_codes.YELLOW, hi);
};

exports.blue = function(str, hi) {
	return renderColor(str, bash_codes.BLUE, hi);
};

exports.purple = function(str, hi) {
	return renderColor(str, bash_codes.PURPLE, hi);
};

exports.cyan = function(str, hi) {
	return renderColor(str, bash_codes.CYAN, hi);
};

exports.white = function(str, hi) {
	return renderColor(str, bash_codes.WHITE, hi);
};


function renderColor(str, color, hi) {
	return render(hi ? color.hi_text : color.text, str);
}

function render(code, str) {
	return code + str + REMOVE_COLOR;
}
},
"ddQSwKSorBAH2XLt15Ve7AfB+NHG68HpNmye+Er9PyA=":
function (require, module, exports, __dirname, __filename) {
var zerr = require('zerr')
var pull = require('pull-stream')

module.exports = function (addedValidators) {
  var api = {}
  var validators = {}

  // validator control
  api.get = function (name) {
    return validators[name]
  }
  api.set = function (name, fn) {
    if (name && typeof name == 'object')
      for (var k in name) 
        api.set(k, name[k].bind(api))
    else
      validators[name] = fn
  }

  // set validator registry
  api.set({
    number: function (param, n) {
      var asNum = +param
      if (isNaN(asNum) || asNum != param)
        return 'type'
    },
    string: function (param, n) {
      var asString = ''+param
      if (asString != param)
        return 'type'
    },
    boolean: function (param, n) {
      if (typeof param != 'boolean')
        return 'type'
    },
    object: function (param, n) {
      if (typeof param != 'object' || !param)
        return 'type'
    },
    array: function (param, n) {
      if (!Array.isArray(param))
        return 'type'
    },
    function: function (param, n) {
      if (typeof param != 'function')
        return 'type'
    }
  })
  api.set(addedValidators)

  // rpc method wrappers
  api.sync = function (fn) {
    var spec = Array.prototype.slice.call(arguments, 1)
    return function () {
      var args = Array.prototype.slice.call(arguments)

      // run validation
      var err = validate(args, spec)
      if (err) throw err

      // run sync fn
      return apply(this, fn, args)
    }
  }
  api.sink = 
  api.async = function (fn) {
    var spec = Array.prototype.slice.call(arguments, 1)
    return function () {
      var args = Array.prototype.slice.call(arguments)
      var hasCb = (typeof args[args.length - 1] == 'function')

      // get cb
      var cb = (hasCb)
        ? args[args.length - 1]
        : function (err) { if (err) { throw err; } }

      // run validation
      var err = validate((hasCb) ? args.slice(0,args.length-1) : args, spec)
      if (err) return cb(err)

      // run async fn
      return apply(this, fn, args)
    }
  }
  api.source = function (fn) {
    var spec = Array.prototype.slice.call(arguments, 1)
    return function () {
      var args = Array.prototype.slice.call(arguments)

      // run validation
      var err = validate(args, spec)
      if (err) return pull.error(err)

      // run stream fn
      return apply(this, fn, args)
    }
  }

  // run validation against a spec
  function validate (args, spec) {
    var err

    // multiple specs?
    if (Array.isArray(spec[0])) {
      for (var i=0; i < spec.length; i++) {
        err = validate(args, spec[i])
        if (!err)
          return false // spec passed
      }
      return err // give the last error
    }

    // iterate the spec
    for (var i=0; i < spec.length; i++) {
      var types = parse(spec[i])

      for (var j=0; j < types.length; j++) {
        var type = types[j]

        // falsey?
        if (!args[i]) {
          err = (type.optional) ? false : errs.MissingParam(''+i)
          break
        }

        // get & run validator
        var validator = validators[type.name]
        if (!validator)
          throw new Error('Validator not found: ' + type.name)
        err = validator(args[i], ''+i)

        // did the validator pass? break out of this type
        if (!err)
          break

        // error aliases
        if (err == 'type')
          err = errs.Type(''+i, type.name)
      }

      // none of the types passed? return the error
      if (err)
        return err
    }
    return false
  }

  return api
}

var errs =
module.exports.errors = {
  MissingParam: zerr('Usage', 'Param % is required'),
  Type: zerr('Type', 'Param % must by of type %')
}

// parse spec token
function parse (token) {
  return token.split('|').map(function (token) {
    if (token.charAt(token.length - 1) == '?')
      return { name: token.slice(0, token.length - 1), optional: true }
    return { name: token, optional: false }
  })
}

// helper to avoid apply, for performance
function apply (self, fn, args) {
  if (args.length == 0)
    return fn.call(self)
  if (args.length == 1)
    return fn.call(self, args[0])
  if (args.length == 2)
    return fn.call(self, args[0], args[1])
  if (args.length == 3)
    return fn.call(self, args[0], args[1], args[2])
  if (args.length == 4)
    return fn.call(self, args[0], args[1], args[2], args[3])
  return fn.apply(self, args)
}
},
"dftqxcGO2g5pkgkngPYas9uqxLkZF7tQTr7upFrTqyA=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "_args": [
    [
      "level-sublevel@~6.3.1",
      "/home/dominic/c/scuttlebot/node_modules/level-live-stream"
    ]
  ],
  "_from": "level-sublevel@>=6.3.1 <6.4.0",
  "_id": "level-sublevel@6.3.17",
  "_inCache": true,
  "_installable": true,
  "_location": "/level-sublevel",
  "_npmUser": {
    "email": "dominic.tarr@gmail.com",
    "name": "dominictarr"
  },
  "_npmVersion": "1.4.26",
  "_phantomChildren": {
    "pull-core": "1.0.0"
  },
  "_requested": {
    "name": "level-sublevel",
    "raw": "level-sublevel@~6.3.1",
    "rawSpec": "~6.3.1",
    "scope": null,
    "spec": ">=6.3.1 <6.4.0",
    "type": "range"
  },
  "_requiredBy": [
    "#DEV:/",
    "/level-live-stream"
  ],
  "_resolved": "https://registry.npmjs.org/level-sublevel/-/level-sublevel-6.3.17.tgz",
  "_shasum": "6d514fe432619199fa300911bfdfa3f98de761cb",
  "_shrinkwrap": null,
  "_spec": "level-sublevel@~6.3.1",
  "_where": "/home/dominic/c/scuttlebot/node_modules/level-live-stream",
  "author": {
    "email": "dominic.tarr@gmail.com",
    "name": "Dominic Tarr",
    "url": "http://dominictarr.com"
  },
  "bugs": {
    "url": "https://github.com/dominictarr/level-sublevel/issues"
  },
  "dependencies": {
    "bytewise": "~0.7.1",
    "levelup": "~0.19.0",
    "ltgt": "~2.0.0",
    "pull-stream": "~2.21.0",
    "typewiselite": "~1.0.0",
    "xtend": "~4.0.0"
  },
  "description": "partition levelup databases",
  "devDependencies": {
    "level": "~0.18.0",
    "level-test": ">=1.5.1 <2",
    "leveldown": "~0.10.2",
    "monotonic-timestamp": "0.0.8",
    "pull-level": "~1.1.1",
    "rimraf": "~2.1.4",
    "shasum": "0.0.2",
    "stream-to-pull-stream": "~1.2.0",
    "tape": "~2.14.0",
    "through": "~2.3.4"
  },
  "directories": {},
  "dist": {
    "shasum": "6d514fe432619199fa300911bfdfa3f98de761cb",
    "tarball": "http://registry.npmjs.org/level-sublevel/-/level-sublevel-6.3.17.tgz"
  },
  "gitHead": "92ccff2af8ef5c41559ec894bc97e1975862ec59",
  "homepage": "https://github.com/dominictarr/level-sublevel",
  "license": "MIT",
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    }
  ],
  "name": "level-sublevel",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/level-sublevel.git"
  },
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "stability": "unstable",
  "testling": {
    "browsers": [
      "android-browser/4.2..latest",
      "chrome/22..latest",
      "chrome/canary",
      "firefox/17..latest",
      "firefox/nightly",
      "ie/8..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest"
    ],
    "files": "test/*.js"
  },
  "version": "6.3.17"
}

},
"djG/C5jBgtYsQnanf/GoixGB+vZCqiu/PJYMoshkYp0=":
function (require, module, exports, __dirname, __filename) {
var through = require('pull-through')

module.exports = function split (matcher, mapper, reverse) {
  var soFar = ''
  if('function' === typeof matcher)
    mapper = matcher, matcher = null
  if (!matcher)
    matcher = '\n'

  return through(function (buffer) {
    var stream = this
      , pieces = ( reverse
        ? buffer + soFar
        : soFar + buffer
      ).split(matcher)

    soFar = reverse ? pieces.shift() : pieces.pop()

    var l = pieces.length
    for (var i = 0; i < l; i++) {
      var piece = pieces[reverse ? l - 1 - i : i ]
      if(mapper) {
        piece = mapper(piece)
        if('undefined' !== typeof piece)
          stream.queue(piece)
      }
      else
        stream.queue(piece)
    }
  },
  function () {
    if(soFar != null)
      this.queue(soFar)
    this.queue(null)
  })
}


},
"dpb5/pv0fQ1ZoEZzQQ7eBYy5aYv4T8MK7dCNndAHvM8=":
function (require, module, exports, __dirname, __filename) {
module.exports = function(source, from, to) {
  return arguments.length === 2 ?
    source.slice(from) :
    source.slice(from, to)
}

},
"drw4M9duI28aRjy8NYzMWkJ6ZLuyHEuyg+Fza07nqGU=":
function (require, module, exports, __dirname, __filename) {


module.exports = function (buf) {
  var len = buf.length, i

  for(i = len - 1; buf[i] === 255; i--) buf[i] = 0
  if(~i) buf[i] = buf[i] + 1

  return buf
}

},
"e65U0US9WQREHH2+n3aFvYJVSCSGiBdA8QmnvN+VxBk=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "name": "scuttlebot",
  "description": "A bot-server for the phoenix network",
  "version": "8.0.0",
  "homepage": "https://github.com/pfraze/scuttlebot",
  "repository": {
    "type": "git",
    "url": "git://github.com/pfraze/scuttlebot.git"
  },
  "dependencies": {
    "bash-color": "~0.0.3",
    "broadcast-stream": "~0.0.0",
    "cont": "~1.0.3",
    "explain-error": "~1.0.1",
    "graphmitter": "^1.6.3",
    "ip": "^0.3.3",
    "level-memview": "~0.0.0",
    "map-merge": "~1.1.0",
    "mdmanifest": "^1.0.4",
    "minimist": "~1.1.0",
    "mkdirp": "~0.5.0",
    "multiblob": "^1.8.1",
    "multicb": "^1.0.0",
    "muxrpc": "^6.1.1",
    "muxrpc-validation": "^2.0.0",
    "muxrpcli": "^1.0.0",
    "mynosql-query": "~1.0.0",
    "nomnom": "1.8.0",
    "non-private-ip": "~1.1.0",
    "observ": "~0.2.0",
    "observ-debounce": "^1.1.1",
    "on-wakeup": "^1.0.0",
    "osenv": "~0.1.0",
    "pull-abortable": "~4.0.0",
    "pull-cat": "~1.1.5",
    "pull-inactivity": "~2.1.1",
    "pull-many": "~1.0.6",
    "pull-notify": "0.0.0",
    "pull-paramap": "~1.1.1",
    "pull-ping": "^1.0.1",
    "pull-pushable": "^2.0.0",
    "pull-stream": "^3.0.0",
    "pull-stream-to-stream": "~1.3.0",
    "pull-stringify": "~1.2.2",
    "rimraf": "^2.4.2",
    "secret-stack": "^2.5.0",
    "secure-scuttlebutt": "^15.0.4",
    "ssb-client": "^3.0.1",
    "ssb-config": "^2.0.0",
    "ssb-feed": "^2.1.2",
    "ssb-keys": "^5.0.0",
    "ssb-msgs": "~5.0.0",
    "ssb-ref": "^2.0.0",
    "statistics": "^2.0.1",
    "stream-to-pull-stream": "~1.6.5",
    "zerr": "^1.0.0"
  },
  "devDependencies": {
    "cat-names": "~1.0.2",
    "deep-equal": "~1.0.0",
    "dog-names": "~1.0.2",
    "level-sublevel": "~6.3.15",
    "level-test": "^2.0.1",
    "noderify": "~1.0.0",
    "ssb-msg-schemas": "~3.2.0",
    "tape": "~4.0.0"
  },
  "bin": {
    "sbot": "./sbot.js"
  },
  "scripts": {
    "prepublish": "npm ls && npm test && noderify bin.js > sbot.js",
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "author": "Paul Frazee <pfrazee@gmail.com>",
  "license": "MIT"
}

},
"eGzPlApArJ01UO391c8/heE+XpGnA7Ik6hxyUc/BT0k=":
function (require, module, exports, __dirname, __filename) {
var wrappy = require('wrappy')
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

},
"ebjtEBu1j2MDcqBglWUZnTjrsjGA/EpV1DmPR9ynwUI=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module unherit
 * @fileoverview Create a custom constructor which can be modified
 *   without affecting the original class.
 * @example
 *   var EventEmitter = require('events').EventEmitter;
 *   var Emitter = unherit(EventEmitter);
 *   // Create a private class which acts just like
 *   // `EventEmitter`.
 *
 *   Emitter.prototype.defaultMaxListeners = 0;
 *   // Now, all instances of `Emitter` have no maximum
 *   // listeners, without affecting other `EventEmitter`s.
 */

'use strict';

/*
 * Dependencies.
 */

var clone = require('clone');
var inherits = require('inherits');

/**
 * Create a custom constructor which can be modified
 * without affecting the original class.
 *
 * @param {Function} Super - Super-class.
 * @return {Function} - Constructor acting like `Super`,
 *   which can be modified without affecting the original
 *   class.
 */
function unherit(Super) {
    var base = clone(Super.prototype);
    var result;
    var key;

    /**
     * Constructor accepting a single argument,
     * which itself is an `arguments` object.
     */
    function From(parameters) {
        return Super.apply(this, parameters);
    }

    /**
     * Constructor accepting variadic arguments.
     */
    function Of() {
        if (!(this instanceof Of)) {
            return new From(arguments);
        }

        return Super.apply(this, arguments);
    }

    inherits(Of, Super);
    inherits(From, Of);

    /*
     * Both do duplicate work. However, cloning the
     * prototype ensures clonable things are cloned
     * and thus used. The `inherits` call ensures
     * `instanceof` still thinks an instance subclasses
     * `Super`.
     */

    result = Of.prototype;

    for (key in base) {
        result[key] = base[key];
    }

    return Of;
}

/*
 * Expose.
 */

module.exports = unherit;

},
"eexK2bbiaGfRtB61rj+aXSrxmlbAX3QfMv9TVXs11hc=":
function (require, module, exports, __dirname, __filename) {
module.exports = function (onClose) {
  var buffer = [], ended, abort, cb

  function callback (err, val) {
    var _cb = cb
    if(err && onClose) {
      var c = onClose
      onClose = null
      c(err === true ? null : err)
    }
    cb = null
    _cb(err, val)

  }

  function drain() {
    if(!cb) return

    if(abort)                        callback(abort)
    else if(!buffer.length && ended) callback(ended)
    else if(buffer.length)           callback(null, buffer.shift())
  }

  function read (_abort, _cb) {
    if(_abort) {
      abort = _abort
      //if there is already a cb waiting, abort it.
      if(cb) callback(abort)
    }
    cb = _cb
    drain()
  }

  read.push = function (data) {
    if(ended) return
    buffer.push(data)
    drain()
  }

  read.end = function (end) {
    ended = ended || end || true;
    drain()
  }

  return read
}



},
"ehYsXs5R0lABf+amJUYjvniXLwtEZnaSOYB7PqSVOoE=":
function (require, module, exports, __dirname, __filename) {


var ecc = require('eccjs')
var crypto = require('crypto')
var Blake2s = require('blake2s')

var curve = ecc.curves.k256

function hash (message) {
  return new Blake2s().update(message).digest()
}

module.exports = {

  curves: ['k256'],

  generate: function (seed) {
    //we use eccjs.restore here, instead of eccjs.generate
    //because we trust node's random generator much more than
    //sjcl's (via crypto-browserify's polyfil this uses
    //webcrypto's random generator in the browser)

    var keys = ecc.restore(curve, seed || crypto.randomBytes(32))

    return {
      curve: 'k256',
      public: keys.public,
      private: keys.private
    }
  },

  sign: function (private, message) {
    return ecc.sign(curve, private, hash(message))
  },

  verify: function (public, sig, message) {
    return ecc.verify(curve, public, sig, hash(message))
  },

  restore: function (seed) {
    return ecc.restore(curve, seed)
  }

}

},
"fJcQ979xu3COBdOgCeVzEM9WPBS2p8E6kIqZjrNSkgY=":
function (require, module, exports, __dirname, __filename) {
var sources  = require('./sources')
var sinks    = require('./sinks')
var throughs = require('./throughs')

exports = module.exports = require('./pull')

for(var k in sources)
  exports[k] = sources[k]

for(var k in throughs)
  exports[k] = throughs[k]

for(var k in sinks)
  exports[k] = sinks[k]


},
"fwl9OubEPda7w0QMbyTfcvjVp4cpGe2J3kRdqeAn+8U=":
function (require, module, exports, __dirname, __filename) {
exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(b);
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};


exports.Range = Range;
function Range(range, loose) {
  if ((range instanceof Range) && range.loose === loose)
    return range;

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0- <1.3.0-
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm)
          M = +M + 1
        else
          m = +m + 1
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  return versions.filter(function(version) {
    return satisfies(version, range, loose);
  }).sort(function(a, b) {
    return rcompare(a, b, loose);
  })[0] || null;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

},
"g/YKZYeMdNHzmSh+69JS/7sQw1VVxrLt/PvGABttoys=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var LO = null
var HI = undefined
var util = require('../util')
var ltgt = require('ltgt')
var deepEqual = require('deep-equal')

module.exports = function Compound (db, query) {

  // the query must have an eq and a range/eq

  // say: name @ version

  /*
  okay so this:

    db.query([
      {path: ['name'], eq: 'mynosql'},
      {path: ['version'], gte: '1.0.0', lt: '2.0.0'}
    ])

  gets compared to this:

  [
    ...,
    {path: [['name'], ['version']], since:...},
    ...
  ]

  needs to become this:

    pl.read(db, {
      gte:
        [[['name'], ['version']], ['mynosql', '1.0.0'], LO],
      lt:
        [[['name'], ['version']], ['mynosql', '2.0.0'], HI],
    })

  */

  //iterate over the indexes, and check if this index have > 1

  return util.first(db.indexes, function (index) {

    //don't bother if this index has more values than the query.
    if(index.path.length > query.path) return

    //don't use this strategy for single indexes
    if(index.path.length <= 1) return

    var l = index.path.length

    var querypath = [], opts = {index: index.path, values: false}

    for(var i = 0; i < l; i++) {
      var last = i == l - 1
      //try and find a subquery that matches this path.
      var subquery = util.find(query, function (p) {
        return deepEqual(p.path, index.path[i])
      })

      if(!subquery) return

      if(util.has(subquery, 'eq'))
        querypath[i] = subquery.eq
      else if(last)
        opts = ltgt.toLtgt(subquery, opts, function (e, hi) {
          return querypath.concat(e)
        }, LO, HI)
      else
        return false //couldn't use this index.
    }

    //if the query didn't end in a range...
    if(!opts)
      opts.gte = opts.lte = querypath

    return {
      opts: opts,
      index: index,
      compound: true,
      name: 'compound',
      exec: function () {
        opts.index = index.path
        return db.readIndex(opts, util.createFilter(query))
      }
    }
  })

}

},
"g8DWzpBodxqzguiUewIJPfd9RQ42hGJAt32Ok6On0rA=":
function (require, module, exports, __dirname, __filename) {

var sr = require('string-range')
var defined = require('defined')
var beq = require('buffer-equal')

function eq (a, b) {
  if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {
    return beq(a, b)
  }
  else return a === b
}

module.exports = function post (db, opts, each) {
  if(!each)
    each = opts, opts = {}

  if('function' === typeof db.post)
    return db.post(opts, each)

  var encode = (opts && opts.keyEncoding && opts.keyEncoding.encode)
    || (db.options && db.options.keyEncoding && db.options.keyEncoding.encode)
    || function (x) { return x }

  var min = defined(opts.min, opts.gt, opts.gte, opts.start)
  var max = defined(opts.max, opts.lt, opts.lte, opts.end)

  var copts = {}
  if (min !== undefined) copts.min = encode(min)
  if (max !== undefined) copts.max = encode(max)
  var checker = sr.checker(copts)
 
  function cmp (key) {
    var ek = encode(key)
    if (opts.gt && eq(ek, copts.min)) return false
    if (opts.lt && eq(ek, copts.max)) return false
    return checker(ek)
  }

  function onPut (key, val) {
    if(cmp(key))
      each({type: 'put', key: key, value: val})
  }

  function onDel (key, val) {
    if(cmp(key))
      each({type: 'del', key: key, value: val})
  }

  function onBatch (ary) {
    ary.forEach(function (op) {
      if(cmp(op.key))
        each(op)
    })
  }

  db.on('put', onPut)
  db.on('del', onDel)
  db.on('batch', onBatch)

  return function () {
    db.removeListener('put', onPut)
    db.removeListener('del', onPut)
    db.removeListener('batch', onPut)
  }
}

},
"gKIYnJimHqSYfOZjXfjIaFBUqidMZy30uxz/AjsG+3Q=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},
"h1jrjtl3Kl6vXLm4kjf4kzLRRNPkpgIukEUI+VqJagE=":
function (require, module, exports, __dirname, __filename) {

var looper = module.exports = function (fun) {
  return function next (a, b, c) {
    var loop = true, returned = false, sync = false
    do {
      sync = true; loop = false
      fun.call(function (x, y, z) {
        if(sync) {
          a = x; b = y; c = z
          loop = true
        }
        else
          next(x, y, z)
      }, a, b, c)
      sync = false
    } while(loop)
  }
}

},
"hTH3Xn8niO+dYBJysjbstnudz8KRtu4AGmheqk/DxAs=":
function (require, module, exports, __dirname, __filename) {
var nonPrivate = require('non-private-ip')
var ip = require('ip')
var onWakeup = require('on-wakeup')
var Stats = require('statistics')
var os = require('os')
var pull = require('pull-stream')
var u = require('../../lib/util')

function rand(array) {
  return array[~~(Math.random()*array.length)]
}

function not (fn) {
  return function (e) { return !fn(e) }
}

function and () {
  var args = [].slice.call(arguments)
  return function (value) {
    return args.every(function (fn) { return fn.call(null, value) })
  }
}

//min delay (delay since last disconnect of most recent peer in unconnected set)
//unconnected filter delay peer < min delay
function delay (failures, factor, max) {
  return Math.min(Math.pow(2, failures)*factor, max || Infinity)
}

function maxStateChange (M, e) {
  return Math.max(M, e.stateChange || 0)
}

function peerNext(peer, opts) {
  return (peer.stateChange|0) + delay(peer.failure|0, opts.factor, opts.max)
}


//detect if not connected to wifi or other network
//(i.e. if there is only localhost)

function isOffline () {
  var lo = Object.keys(os.networkInterfaces())
  return lo.length === 1 && lo[0] === 'lo'
}

var isOnline = not(isOffline)

function isLocal (e) {
  return ip.isPrivate(e.host)
}

function isUnattempted (e) {
  return !e.stateChange
}

//select peers which have never been successfully connected to yet,
//but have been tried.
function isInactive (e) {
  return e.stateChange && e.duration.mean == 0
}

function isLongterm (e) {
  return e.ping && e.ping.rtt.mean > 0
}

//peers which we can connect to, but are not upgraded.
//select peers which we can connect to, but are not upgraded to LT.
//assume any peer is legacy, until we know otherwise...
function isLegacy (peer) {
  return peer.duration.mean > 0 && !exports.isLongterm(peer)
}

function isConnect (e) {
  return 'connected' === e.state || 'connecting' === e.state
}

//sort oldest to newest then take first n
function earliest(peers, n) {
  return peers.sort(function (a, b) {
    return a.stateChange - b.stateChange
  }).slice(0, Math.max(n, 0))
}

function select(peers, ts, filter, opts) {
  if(opts.disable) return []
  //opts: { quota, groupMin, min, factor, max }
  var type = peers.filter(filter)
  var unconnect = type.filter(not(isConnect))
  var count = Math.max(opts.quota - type.filter(isConnect).length, 0)
  var min = unconnect.reduce(maxStateChange, 0) + opts.groupMin
  if(ts < min) return []

  return earliest(unconnect.filter(function (peer) {
    return peerNext(peer, opts) < ts
  }), count)
}

var schedule = exports = module.exports =
function (gossip, config, server) { 

  var min = 60e3, hour = 60*60e3

  function conf(name, def) {
    if(!config.gossip) return def
    var value = config.gossip[name]
    return (value === undefined || value === '') ? def : value
  }

  function connect (peers, ts, name, filter, opts) {
    var connected = peers.filter(isConnect).filter(filter)
      .filter(function (peer) {
        return peer.stateChange + 10e3 < ts
      })

    if(connected.length > opts.quota) {
      return earliest(connected, connected.length - opts.quota)
        .forEach(function (peer) {
          console.log('Disconnect', name, u.stringifyAddress(peer))
          gossip.disconnect(peer)
        })
    }

    select(peers, ts, and(filter, isOnline), opts)
      .forEach(function (peer) {
        console.log('Connect', name, u.stringifyAddress(peer))
        gossip.connect(peer)
      })
  }


  function connections () {
    var ts = Date.now()
    var peers = gossip.peers()

    connect(peers, ts, 'attempt', exports.isUnattempted, {
        min: 0, quota: 10, factor: 0, max: 0, groupMin: 0,
        disable: !conf('global', true)
    })

    //quota, groupMin, min, factor, max
    connect(peers, ts, 'retry', exports.isInactive, {
        min: 0,
        quota: 3, factor: 5*60e3, max: 3*60*60e3, groupMin: 5*50e3
      })

    connect(peers, ts, 'legacy', exports.isLegacy, {
        quota: 3, factor: 5*min, max: 3*hour, groupMin: 5*min,
        disable: !conf('global', true)
      })

    connect(peers, ts, 'longterm', exports.isLongterm, {
      quota: 3, factor: 10e3, max: 10*min, groupMin: 5e3,
      disable: !conf('global', true)
    })

    connect(peers, ts, 'local', exports.isLocal, {
      quota: 3, factor: 2e3, max: 10*min, groupMin: 1e3,
      disable: !conf('local', true)
    })

  }

    pull(
      gossip.changes(),
      pull.drain(function (ev) {
        if(ev.type == 'disconnect')
          connections()
      })
    )

    setInterval(function () {
      connections()
    }, 2e3).unref()

    connections()

}

exports.isUnattempted = isUnattempted
exports.isInactive = isInactive
exports.isLongterm = isLongterm
exports.isLegacy = isLegacy
exports.isLocal = isLocal
exports.isConnectedOrConnecting = isConnect
exports.select = select










},
"hUNFvfmbnlJ2x524uul60HpFKDeCDGGqcZhvf3ag4wY=":
function (require, module, exports, __dirname, __filename) {

var keys = exports.keys =
function (object) {
  return values(Object.keys(object))
}

var once = exports.once =
function (value) {
  return function (abort, cb) {
    if(abort) return cb(abort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}

var values = exports.values = exports.readArray =
function (array) {
  if(!Array.isArray(array))
    array = Object.keys(array).map(function (k) {
      return array[k]
    })
  var i = 0
  return function (end, cb) {
    if(end)
      return cb && cb(end)
    cb(i >= array.length || null, array[i++])
  }
}


var count = exports.count =
function (max) {
  var i = 0; max = max || Infinity
  return function (end, cb) {
    if(end) return cb && cb(end)
    if(i > max)
      return cb(true)
    cb(null, i++)
  }
}

var infinite = exports.infinite =
function (generate) {
  generate = generate || Math.random
  return function (end, cb) {
    if(end) return cb && cb(end)
    return cb(null, generate())
  }
}

var defer = exports.defer = function () {
  var _read, cbs = [], _end

  var read = function (end, cb) {
    if(!_read) {
      _end = end
      cbs.push(cb)
    } 
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    while(cbs.length)
      _read(_end, cbs.shift())
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}

var empty = exports.empty = function () {
  return function (abort, cb) {
    cb(true)
  }
}

var depthFirst = exports.depthFirst =
function (start, createStream) {
  var reads = []

  reads.unshift(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        //if this stream has ended, go to the next queue
        reads.shift()
        return next(null, cb)
      }
      reads.unshift(createStream(data))
      cb(end, data)
    })
  }
}
//width first is just like depth first,
//but push each new stream onto the end of the queue
var widthFirst = exports.widthFirst =
function (start, createStream) {
  var reads = []

  reads.push(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        return next(null, cb)
      }
      reads.push(createStream(data))
      cb(end, data)
    })
  }
}

//this came out different to the first (strm)
//attempt at leafFirst, but it's still a valid
//topological sort.
var leafFirst = exports.leafFirst =
function (start, createStream) {
  var reads = []
  var output = []
  reads.push(once(start))

  return function next (end, cb) {
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        if(!output.length)
          return cb(true)
        return cb(null, output.shift())
      }
      reads.unshift(createStream(data))
      output.unshift(data)
      next(null, cb)
    })
  }
}


},
"hWA5jrXKjWIZGapjaLs5KFl/LxT17QJ2Q5Kgpkb46wk=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-core')

function destroy(stream, cb) {
  function onClose () {
    cleanup(); cb()
  }
  function onError (err) {
    cleanup(); cb(err)
  }
  function cleanup() {
    stream.removeListener('close', onClose)
    stream.removeListener('error', onError)
  }
  stream.on('close', onClose)
  stream.on('error', onError)
}

function write(read, stream) {
  var ended
  function onClose () {
    cleanup()
    if(!ended) read(ended = true, function () {})
  }
  function onError (err) {
    cleanup()
    if(!ended) read(ended = err, function () {})
  }
  function cleanup() {
    stream.removeListener('close', onClose)
    stream.removeListener('error', onError)
  }
  stream.on('close', onClose)
  stream.on('error', onError)
  process.nextTick(function next() {
    read(null, function (end, data) {
      if(end === true)
        return stream._isStdio || stream.end()
      if(ended = ended || end)
        return stream.emit('error', end)

      var pause = stream.write(data)
      if(pause === false)
        stream.once('drain', next)
      else next()
    })
  })
}

function first (emitter, events, handler) {
  function listener (val) {
    events.forEach(function (e) {
      emitter.removeListener(e, listener)
    })
    handler(val)
  } 
  events.forEach(function (e) {
    emitter.on(e, listener)
  })
  return emitter
}

function read2(stream) {
  var ended = false, waiting = false
  var _cb

  function read () {
    var data = stream.read()
    if(data !== null && _cb) {
      var cb = _cb; _cb = null
      cb(null, data)
    }
  }

  stream.on('readable', function () {
    waiting = true
    _cb && read()
  })
  .on('end', function () {
    ended = true
    _cb && _cb(ended)
  })
  .on('error', function (err) {
    ended = err
    _cb && _cb(ended)
  })

  return function (end, cb) {
    _cb = cb
    if(ended)
      cb(ended)
    else if(waiting)
      read()
  }
}

function read1(stream) {
  var buffer = [], cbs = [], ended, paused = false

  var draining
  function drain() {
    while((buffer.length || ended) && cbs.length)
      cbs.shift()(buffer.length ? null : ended, buffer.shift())
    if(!buffer.length && (paused)) {
      paused = false
      stream.resume()
    }
  }

  stream.on('data', function (data) {
    buffer.push(data)
    drain()
    if(buffer.length && stream.pause) {
      paused = true
      stream.pause()
    }
  })
  stream.on('end', function () {
    ended = true
    drain()
  })
  stream.on('error', function (err) {
    ended = err
    drain()
  })
  return function (abort, cb) {
    if(!cb) throw new Error('*must* provide cb')
    if(abort) {
      stream.once('close', function () {
        cb(abort)
      })
      stream.destroy()
    }
    cbs.push(cb)
    drain()
  }
}

function read (stream) {
  if('function' === typeof stream.read)
    return read2(stream)
  return read1(stream)
}

var sink = function (stream) {
  return pull.Sink(function (read) {
    return write(read, stream)
  })()
}

var source = function (stream) {
  return pull.Source(function () { return read(stream) })()
}

exports = module.exports = function (stream) {
  return (
    stream.writable
    ? stream.readable
      ? pull.Through(function(_read) {
          write(_read, stream); 
          return read(stream) 
        })()  
      : sink(stream)
    : source(stream)
  )
}

exports.sink = sink
exports.source = source
exports.read = read
exports.read1 = read1
exports.read2 = read2


},
"hlg3SRSmw8Ur6dO6z2g3mgrBIM7GhPeh8oJDe6IHncU=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream/pull')

function destroy(stream, cb) {
  function onClose () {
    cleanup(); cb()
  }
  function onError (err) {
    cleanup(); cb(err)
  }
  function cleanup() {
    stream.removeListener('close', onClose)
    stream.removeListener('error', onError)
  }
  stream.on('close', onClose)
  stream.on('error', onError)
}

function write(read, stream, cb) {
  var ended, closed = false, did
  function done () {
    if(did) return
    did = true
    cb && cb(ended === true ? null : ended)
  }

  function onClose () {
    if(closed) return
    closed = true
    cleanup()
    if(!ended) read(ended = true, done)
    else       done()
  }
  function onError (err) {
    cleanup()
    if(!ended) read(ended = err, done)
  }
  function cleanup() {
    stream.on('finish', onClose)
    stream.removeListener('close', onClose)
    stream.removeListener('error', onError)
  }
  stream.on('close', onClose)
  stream.on('finish', onClose)
  stream.on('error', onError)
  process.nextTick(function next() {
    read(null, function (end, data) {
      ended = ended || end
      //you can't "end" a stdout stream, so this needs to be handled specially.
      if(end === true)
        return stream._isStdio ? done() : stream.end()

      if(ended = ended || end) {
        stream.destroy && stream.destroy()
        return done(ended)
      }

      //I noticed a problem streaming to the terminal:
      //sometimes the end got cut off, creating invalid output.
      //it seems that stdout always emits "drain" when it ends.
      //so this seems to work, but i have been unable to reproduce this test
      //automatically, so you need to run ./test/stdout.js a few times and the end is valid json.
      if(stream._isStdio)
        stream.write(data, function () { next() })
      else {
        var pause = stream.write(data)
        if(pause === false)
          stream.once('drain', next)
        else next()
      }
    })
  })
}

function first (emitter, events, handler) {
  function listener (val) {
    events.forEach(function (e) {
      emitter.removeListener(e, listener)
    })
    handler(val)
  }
  events.forEach(function (e) {
    emitter.on(e, listener)
  })
  return emitter
}

function read2(stream) {
  var ended = false, waiting = false
  var _cb

  function read () {
    var data = stream.read()
    if(data !== null && _cb) {
      var cb = _cb; _cb = null
      cb(null, data)
    }
  }

  stream.on('readable', function () {
    waiting = true
    _cb && read()
  })
  .on('end', function () {
    ended = true
    _cb && _cb(ended)
  })
  .on('error', function (err) {
    ended = err
    _cb && _cb(ended)
  })

  return function (end, cb) {
    _cb = cb
    if(ended)
      cb(ended)
    else if(waiting)
      read()
  }
}

function read1(stream) {
  var buffer = [], cbs = [], ended, paused = false

  var draining
  function drain() {
    while((buffer.length || ended) && cbs.length)
      cbs.shift()(buffer.length ? null : ended, buffer.shift())
    if(!buffer.length && (paused)) {
      paused = false
      stream.resume()
    }
  }

  stream.on('data', function (data) {
    buffer.push(data)
    drain()
    if(buffer.length && stream.pause) {
      paused = true
      stream.pause()
    }
  })
  stream.on('end', function () {
    ended = true
    drain()
  })
  stream.on('error', function (err) {
    ended = err
    drain()
  })
  return function (abort, cb) {
    if(!cb) throw new Error('*must* provide cb')
    if(abort) {
      stream.once('close', function () {
        cb(abort)
      })
      stream.destroy()
    }
    cbs.push(cb)
    drain()
  }
}

var read = read1

var sink = function (stream, cb) {
  return function (read) {
    return write(read, stream, cb)
  }
}

var source = function (stream) {
  return read1(stream)
}

exports = module.exports = function (stream, cb) {
  return (
    (stream.writable && stream.write)
    ? stream.readable
      ? function(_read) {
          write(_read, stream, cb);
          return read1(stream)
        }
      : sink(stream, cb)
    : source(stream)
  )
}

exports.sink = sink
exports.source = source
exports.read = read
exports.read1 = read1
exports.read2 = read2
exports.duplex = function (stream, cb) {
  return {
    source: source(stream),
    sink: sink(stream, cb)
  }
}





},
"hyvm6Uek+a6PxXC+Q0h1FJl1to0v2InXv0u8z0sXrco=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var util = require('../util')
var ltgt = require('ltgt')
var deepEqual = require('deep-equal')

var LO = null
var HI = undefined

module.exports = function (db, query) {
  //choose the most indexable parameter
  //use eq instead of a range.

  var opts = util.first(query, function (q) {
    var index = db.getIndex([q.path])
    if(!index) return
    return util.toIndexable(q)
  })

  if(!opts) return

  opts.values = false

  util.assertDepth(opts.path, 'filteredIndex')

  return {
    opts: opts,
    query: query,
    name: 'filtered',
    exec: function () {
      return db.readIndex(opts, util.createFilter(query))
    }
  }
}

},
"i75Y/DjTsHGMRJlMRBKaTrGKTXTOYICtCylf/isTMgI=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')

module.exports = pull.Source(function (onClose) {
  var buffer = [], cbs = [], waiting = [], ended

  function drain() {
    var l
    while(waiting.length && ((l = buffer.length) || ended)) {
      var data = buffer.shift()
      var cb   = cbs.shift()
      waiting.shift()(l ? null : ended, data)
      cb && cb(ended === true ? null : ended)
    }
  }

  function read (end, cb) {
    ended = ended || end
    waiting.push(cb)
    drain()
    if(ended)
      onClose && onClose(ended === true ? null : ended)
  }

  read.push = function (data, cb) {
    if(ended)
      return cb && cb(ended === true ? null : ended)
    buffer.push(data); cbs.push(cb)
    drain()
  }

  read.end = function (end, cb) {
    if('function' === typeof end)
      cb = end, end = true
    ended = ended || end || true;
    if(cb) cbs.push(cb)
    drain()
    if(ended)
      onClose && onClose(ended === true ? null : ended)
  }

  return read
})


},
"i7hs1ROQ5c8UpROCVPsG/HxeXhdrV8iusVB8W5UPuvk=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')

function rate (s) {
  var recent = []
  var stream = pull.through(function (d) {
    stream.ts = Date.now()
    recent.push({size: d.length, ts: stream.ts})
    if(recent.length > 5)
      recent.shift()

  })

  stream.ts = Date.now()

  stream.rate = function () {
    var ts = Date.now()
    if(recent.length > 1) {
      var rate = (recent.reduce(function (size, item) {
        return size + item.size
      }, 0)/1000000) / ((ts - recent[0].ts)/1000)

      return rate
    }
  }

  return stream
}

module.exports = rate

},
"iF+IIiN4G/UyyCNXe4oEivaRyrIDw/pgJAQCrp3pChw=":
function (require, module, exports, __dirname, __filename) {
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},
"iKqYDfFKbruxu0Fa25YLgqBHhATPnQLI2olH5KWXjsI=":
function (require, module, exports, __dirname, __filename) {


module.exports = require('./inject')()

},
"iPuI5KqB2e09EXncyW4xp4GyK8WTemaPgHYnweyBhGA=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer. All rights reserved.
 * @module ccount
 * @fileoverview Count characters.
 */

'use strict';

/**
 * Count how many characters `character` occur in `value`.
 *
 * @example
 *   ccount('foo(bar(baz)', '(') // 2
 *   ccount('foo(bar(baz)', ')') // 1
 *
 * @param {string} value - Content, coerced to string.
 * @param {string} character - Single character to look
 *   for.
 * @return {number} - Count.
 * @throws {Error} - when `character` is not a single
 *   character.
 */
function ccount(value, character) {
    var index = -1;
    var count = 0;
    var length;

    value = String(value);
    length = value.length;

    if (typeof character !== 'string' || character.length !== 1) {
        throw new Error('Expected character');
    }

    while (++index < length) {
        if (value.charAt(index) === character) {
            count++;
        }
    }

    return count;
}

/*
 * Expose.
 */

module.exports = ccount;

},
"ib7Q4JzfN+w6M5eS/h54RLJGHRQSVr/IzcVHvYk7r8I=":
function (require, module, exports, __dirname, __filename) {
var fs   = require('fs')
var ini  = require('ini')
var path = require('path')
var stripJsonComments = require('strip-json-comments')

var parse = exports.parse = function (content, file) {

  //if it ends in .json or starts with { then it must be json.
  //must be done this way, because ini accepts everything.
  //can't just try and parse it and let it throw if it's not ini.
  //everything is ini. even json with a systax error.

  if((file && /\.json$/.test(file)) || /^\s*{/.test(content)) 
    return JSON.parse(stripJsonComments(content))
  return ini.parse(content)

}

var file = exports.file = function () {
  var args = [].slice.call(arguments).filter(function (arg) { return arg != null })

  //path.join breaks if it's a not a string, so just skip this.
  for(var i in args)
    if('string' !== typeof args[i])
      return

  var file = path.join.apply(null, args)
  var content
  try {
    return fs.readFileSync(file,'utf-8')
  } catch (err) {
    return
  }
}

var json = exports.json = function () {
  var content = file.apply(null, arguments)
  return content ? parse(content) : null
}

var env = exports.env = function (prefix, env) {
  env = env || process.env
  var obj = {}
  var l = prefix.length
  for(var k in env) {
    if((k.indexOf(prefix)) === 0) {

      var keypath = k.substring(l).split('__')

      // Trim empty strings from keypath array
      var _emptyStringIndex
      while ((_emptyStringIndex=keypath.indexOf('')) > -1) {
        keypath.splice(_emptyStringIndex, 1)
      }
      
      var cursor = obj
      keypath.forEach(function _buildSubObj(_subkey,i){

        // (check for _subkey first so we ignore empty strings)
        if (!_subkey)
          return

        // If this is the last key, just stuff the value in there
        // Assigns actual value from env variable to final key
        // (unless it's just an empty string- in that case use the last valid key)
        if (i === keypath.length-1)
          cursor[_subkey] = env[k]
          

        // Build sub-object if nothing already exists at the keypath
        if (cursor[_subkey] === undefined)
          cursor[_subkey] = {}

        // Increment cursor used to track the object at the current depth
        cursor = cursor[_subkey]

      })

    }

  }

  return obj
}

var find = exports.find = function () {
  var rel = path.join.apply(null, [].slice.call(arguments))

  function find(start, rel) {
    var file = path.join(start, rel)
    try {
      fs.statSync(file)
      return file
    } catch (err) {
      if(path.dirname(start) !== start) // root
        return find(path.dirname(start), rel)
    }
  }
  return find(process.cwd(), rel)
}


},
"idXWOOU5aAkEbOfCXcUPMyRNoNKjdW2gb06E9CVy490=":
function (require, module, exports, __dirname, __filename) {
var LIMIT = process.maxTickDepth / 2
  , factory = function () {
      var count = 0
      return function (callback) {
        if (count >= LIMIT){
          global.setImmediate(callback)
          count = 0
        } else
          process.nextTick(callback)
        count++
      }
    }

module.exports = global.setImmediate ? factory : function () { return process.nextTick }
},
"idbi74ue9H5hk3c8+1GwVZF2gsB/ERXMoaB6X+f7bQw=":
function (require, module, exports, __dirname, __filename) {
var handshake = require('./handshake')
var secure = require('./secure')

exports.client =
exports.createClient = function (alice, app_key, timeout) {
  var create = handshake.client(alice, app_key, timeout)

  return function (bob, cb) {
    if(!Buffer.isBuffer(bob) || bob.length != 32)
      throw new Error('createClient *must* be passed a public key')
    return create(bob, secure(cb))
  }

}
exports.server =
exports.createServer = function (bob, authorize, app_key, timeout) {
  var create = handshake.server(bob, authorize, app_key, timeout)

  return function (cb) {
    return create(secure(cb))
  }

}



},
"ifH0V1MmKcBhIyGfGe4MmbZlvz9DhamKNbgsS9M4TD4=":
function (require, module, exports, __dirname, __filename) {

module.exports = function zerr (name, msgTemplate) {
  // make sure the name ends with the word Error
  if (name.slice(-5) != 'Error')
    name += 'Error'

  function ZError () {
    // call as a class constructor if called as a function
    if (!(this instanceof ZError)) {
      // a bit tricker than usual, because we have to combine `apply()` with the `new` form...
      function ZE (args) { return ZError.apply(this, args) }
      ZE.prototype = ZError.prototype;
      return new ZE(arguments)
    }

    Error.call(this)
    Error.captureStackTrace(this, arguments.callee)
    this.name = name

    // if an error was passed, shift it out of the args
    var parentErr
    var args = Array.prototype.slice.call(arguments)
    if (args[0] instanceof Error)
      parentErr = args.shift()

    // create message
    if (msgTemplate)
      this.message = interp(msgTemplate, args)
    else if (typeof args[0] == 'string')
      this.message = args[0]

    // modify stack to show parent error
    if (parentErr) {
      var stack = removePrefix(getStack(this), getStack(parentErr)).join('\n')
      this.stack =
        this.name + ': ' + this.message + '\n' +
        stack + '\n  ' + parentErr.stack
    }
  }
  ZError.prototype = Object.create(Error.prototype)
  return ZError
}

// interpolate function
// - takes a template string and a list of strings to insert
// - replaces '%' token in tmpl using values in `args`
// eg interp('hello %, how are you % today?', ['bob', 'doing']) => 'hello bob, how are you doing today?'
// eg interp('hello %, how are you % today?', ['bob']) => 'hello bob, how are you  today?'
var re = /%/g
function interp (tmpl, args) {
  var n = 0
  return tmpl.replace(re, function () { return args[n++] || '' })
}


function getStack(err) {
  return err.stack.substring(err.name.length + 3 + err.message.length)
    .split('\n')
}

function removePrefix (a, b) {
  return a.filter(function (e) {
    return !~b.indexOf(e)
  })
}
},
"isVbQv3rY55XubiVQRFR7motFxY8BFaaKiEnoDv27ss=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015-2016 Titus Wormer
 * @license MIT
 * @module remark:parse
 * @version 3.2.2
 * @fileoverview Parse a markdown document into an
 *   abstract syntax tree.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var decode = require('parse-entities');
var repeat = require('repeat-string');
var trim = require('trim');
var trimTrailingLines = require('trim-trailing-lines');
var extend = require('extend.js');
var utilities = require('./utilities.js');
var defaultOptions = require('./defaults.js').parse;
var blockElements = require('./block-elements.json');

/*
 * Methods.
 */

var raise = utilities.raise;
var clean = utilities.clean;
var validate = utilities.validate;
var normalize = utilities.normalizeIdentifier;
var stateToggler = utilities.stateToggler;
var mergeable = utilities.mergeable;
var MERGEABLE_NODES = utilities.MERGEABLE_NODES;
var has = {}.hasOwnProperty;

/*
 * Numeric constants.
 */

var SPACE_SIZE = 1;
var TAB_SIZE = 4;
var CODE_INDENT_LENGTH = 4;
var MIN_FENCE_COUNT = 3;
var MAX_ATX_COUNT = 6;
var MAX_LINE_HEADING_INDENT = 3;
var HORIZONTAL_RULE_MARKER_COUNT = 3;
var MIN_CLOSING_HTML_NEWLINE_COUNT = 2;
var MIN_BREAK_LENGTH = 2;
var MIN_TABLE_COLUMNS = 2;
var MIN_TABLE_ROWS = 2;

/*
 * Error messages.
 */

var ERR_INFINITE_LOOP = 'Infinite loop';
var ERR_MISSING_LOCATOR = 'Missing locator: ';
var ERR_INCORRECTLY_EATEN = 'Incorrectly eaten value: please report this ' +
    'warning on http://git.io/vUYWz';

/*
 * Expressions.
 */

var EXPRESSION_BULLET = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var EXPRESSION_PEDANTIC_BULLET = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var EXPRESSION_INITIAL_INDENT = /^( {1,4}|\t)?/gm;
var EXPRESSION_INITIAL_TAB = /^( {4}|\t)?/gm;
var EXPRESSION_HTML_LINK_OPEN = /^<a /i;
var EXPRESSION_HTML_LINK_CLOSE = /^<\/a>/i;
var EXPRESSION_LOOSE_LIST_ITEM = /\n\n(?!\s*$)/;
var EXPRESSION_TASK_ITEM = /^\[([\ \t]|x|X)\][\ \t]/;

/*
 * Characters.
 */

var C_BACKSLASH = '\\';
var C_UNDERSCORE = '_';
var C_ASTERISK = '*';
var C_TICK = '`';
var C_AT_SIGN = '@';
var C_HASH = '#';
var C_PLUS = '+';
var C_DASH = '-';
var C_DOT = '.';
var C_PIPE = '|';
var C_DOUBLE_QUOTE = '"';
var C_SINGLE_QUOTE = '\'';
var C_COMMA = ',';
var C_SLASH = '/';
var C_COLON = ':';
var C_SEMI_COLON = ';';
var C_QUESTION_MARK = '?';
var C_CARET = '^';
var C_EQUALS = '=';
var C_EXCLAMATION_MARK = '!';
var C_TILDE = '~';
var C_LT = '<';
var C_GT = '>';
var C_BRACKET_OPEN = '[';
var C_BRACKET_CLOSE = ']';
var C_PAREN_OPEN = '(';
var C_PAREN_CLOSE = ')';
var C_SPACE = ' ';
var C_FORM_FEED = '\f';
var C_NEWLINE = '\n';
var C_CARRIAGE_RETURN = '\r';
var C_TAB = '\t';
var C_VERTICAL_TAB = '\v';
var C_NO_BREAK_SPACE = '\u00a0';
var C_OGHAM_SPACE = '\u1680';
var C_MONGOLIAN_VOWEL_SEPARATOR = '\u180e';
var C_EN_QUAD = '\u2000';
var C_EM_QUAD = '\u2001';
var C_EN_SPACE = '\u2002';
var C_EM_SPACE = '\u2003';
var C_THREE_PER_EM_SPACE = '\u2004';
var C_FOUR_PER_EM_SPACE = '\u2005';
var C_SIX_PER_EM_SPACE = '\u2006';
var C_FIGURE_SPACE = '\u2007';
var C_PUNCTUATION_SPACE = '\u2008';
var C_THIN_SPACE = '\u2009';
var C_HAIR_SPACE = '\u200a';
var C_LINE_SEPARATOR = '\u2028';
var C_PARAGRAPH_SEPARATOR = '\u2029';
var C_NARROW_NO_BREAK_SPACE = '\u202f';
var C_IDEOGRAPHIC_SPACE = '\u3000';
var C_ZERO_WIDTH_NO_BREAK_SPACE = '\ufeff';
var C_X_LOWER = 'x';

/*
 * Character codes.
 */

var CC_A_LOWER = 'a'.charCodeAt(0);
var CC_A_UPPER = 'A'.charCodeAt(0);
var CC_Z_LOWER = 'z'.charCodeAt(0);
var CC_Z_UPPER = 'Z'.charCodeAt(0);
var CC_0 = '0'.charCodeAt(0);
var CC_9 = '9'.charCodeAt(0);

/*
 * Protocols.
 */

var HTTP_PROTOCOL = 'http://';
var HTTPS_PROTOCOL = 'https://';
var MAILTO_PROTOCOL = 'mailto:';

var PROTOCOLS = [
    HTTP_PROTOCOL,
    HTTPS_PROTOCOL,
    MAILTO_PROTOCOL
];

var PROTOCOLS_LENGTH = PROTOCOLS.length;

/*
 * Textual constants.
 */

var YAML_FENCE = repeat(C_DASH, 3);
var CODE_INDENT = repeat(C_SPACE, CODE_INDENT_LENGTH);
var EMPTY = '';
var BLOCK = 'block';
var INLINE = 'inline';
var COMMENT_START = '<!--';
var COMMENT_END = '-->';
var CDATA_START = '<![CDATA[';
var CDATA_END = ']]>';
var COMMENT_END_CHAR = COMMENT_END.charAt(0);
var CDATA_END_CHAR = CDATA_END.charAt(0);
var COMMENT_START_LENGTH = COMMENT_START.length;
var COMMENT_END_LENGTH = COMMENT_END.length;
var CDATA_START_LENGTH = CDATA_START.length;
var CDATA_END_LENGTH = CDATA_END.length;

/*
 * Node types.
 */

var T_HORIZONTAL_RULE = 'horizontalRule';
var T_HTML = 'html';
var T_YAML = 'yaml';
var T_TABLE = 'table';
var T_TABLE_CELL = 'tableCell';
var T_TABLE_HEADER = 'tableHeader';
var T_TABLE_ROW = 'tableRow';
var T_PARAGRAPH = 'paragraph';
var T_TEXT = 'text';
var T_CODE = 'code';
var T_LIST = 'list';
var T_LIST_ITEM = 'listItem';
var T_DEFINITION = 'definition';
var T_FOOTNOTE_DEFINITION = 'footnoteDefinition';
var T_HEADING = 'heading';
var T_BLOCKQUOTE = 'blockquote';
var T_LINK = 'link';
var T_IMAGE = 'image';
var T_FOOTNOTE = 'footnote';
var T_STRONG = 'strong';
var T_EMPHASIS = 'emphasis';
var T_DELETE = 'delete';
var T_INLINE_CODE = 'inlineCode';
var T_BREAK = 'break';
var T_ROOT = 'root';

/*
 * Available table alignments.
 */

var TABLE_ALIGN_LEFT = 'left';
var TABLE_ALIGN_CENTER = 'center';
var TABLE_ALIGN_RIGHT = 'right';
var TABLE_ALIGN_NONE = null;

/*
 * Available reference types.
 */

var REFERENCE_TYPE_SHORTCUT = 'shortcut';
var REFERENCE_TYPE_COLLAPSED = 'collapsed';
var REFERENCE_TYPE_FULL = 'full';

/*
 * A map of characters, and their column length,
 * which can be used as indentation.
 */

var INDENTATION_CHARACTERS = {};

INDENTATION_CHARACTERS[C_SPACE] = SPACE_SIZE;
INDENTATION_CHARACTERS[C_TAB] = TAB_SIZE;

/*
 * A map of characters, which can be used to mark emphasis.
 */

var EMPHASIS_MARKERS = {};

EMPHASIS_MARKERS[C_ASTERISK] = true;
EMPHASIS_MARKERS[C_UNDERSCORE] = true;

/*
 * A map of characters, which can be used to mark rules.
 */

var RULE_MARKERS = {};

RULE_MARKERS[C_ASTERISK] = true;
RULE_MARKERS[C_UNDERSCORE] = true;
RULE_MARKERS[C_DASH] = true;

/*
 * A map of characters which can be used to mark
 * list-items.
 */

var LIST_UNORDERED_MARKERS = {};

LIST_UNORDERED_MARKERS[C_ASTERISK] = true;
LIST_UNORDERED_MARKERS[C_PLUS] = true;
LIST_UNORDERED_MARKERS[C_DASH] = true;

/*
 * A map of characters which can be used to mark
 * list-items after a digit.
 */

var LIST_ORDERED_MARKERS = {};

LIST_ORDERED_MARKERS[C_DOT] = true;

/*
 * A map of characters which can be used to mark
 * list-items after a digit.
 */

var LIST_ORDERED_COMMONMARK_MARKERS = {};

LIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;
LIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;

/*
 * A map of characters, which can be used to mark link
 * and image titles.
 */

var LINK_TITLE_MARKERS = {};

LINK_TITLE_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
LINK_TITLE_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;

/*
 * A map of characters, which can be used to mark link
 * and image titles in commonmark-mode.
 */

var COMMONMARK_LINK_TITLE_MARKERS = {};

COMMONMARK_LINK_TITLE_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;
COMMONMARK_LINK_TITLE_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;
COMMONMARK_LINK_TITLE_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;

/*
 * A map of characters which can be used to mark setext
 * headers, mapping to their corresponding depth.
 */

var SETEXT_MARKERS = {};

SETEXT_MARKERS[C_EQUALS] = 1;
SETEXT_MARKERS[C_DASH] = 2;

/*
 * A map of two functions which can create list items.
 */

var LIST_ITEM_MAP = {};

LIST_ITEM_MAP.true = renderPedanticListItem;
LIST_ITEM_MAP.false = renderNormalListItem;

/**
 * Check whether `character` is alphabetic.
 *
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` is
 *   alphabetic.
 */
function isAlphabetic(character) {
    var code = character.charCodeAt(0);

    return (code >= CC_A_LOWER && code <= CC_Z_LOWER) ||
        (code >= CC_A_UPPER && code <= CC_Z_UPPER);
}

/**
 * Check whether `character` is numeric.
 *
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` is
 *   numeric.
 */
function isNumeric(character) {
    var code = character.charCodeAt(0);

    return code >= CC_0 && code <= CC_9;
}

/**
 * Check whether `character` is a word character.
 *
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` is a
 *   word character.
 */
function isWordCharacter(character) {
    return character === C_UNDERSCORE ||
        isAlphabetic(character) ||
        isNumeric(character);
}

/**
 * Check whether `character` is white-space.
 *
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` is
 *   white-space.
 */
function isWhiteSpace(character) {
    return character === C_SPACE ||
        character === C_FORM_FEED ||
        character === C_NEWLINE ||
        character === C_CARRIAGE_RETURN ||
        character === C_TAB ||
        character === C_VERTICAL_TAB ||
        character === C_NO_BREAK_SPACE ||
        character === C_OGHAM_SPACE ||
        character === C_MONGOLIAN_VOWEL_SEPARATOR ||
        character === C_EN_QUAD ||
        character === C_EM_QUAD ||
        character === C_EN_SPACE ||
        character === C_EM_SPACE ||
        character === C_THREE_PER_EM_SPACE ||
        character === C_FOUR_PER_EM_SPACE ||
        character === C_SIX_PER_EM_SPACE ||
        character === C_FIGURE_SPACE ||
        character === C_PUNCTUATION_SPACE ||
        character === C_THIN_SPACE ||
        character === C_HAIR_SPACE ||
        character === C_LINE_SEPARATOR ||
        character === C_PARAGRAPH_SEPARATOR ||
        character === C_NARROW_NO_BREAK_SPACE ||
        character === C_IDEOGRAPHIC_SPACE ||
        character === C_ZERO_WIDTH_NO_BREAK_SPACE;
}

/**
 * Check whether `character` can be inside an unquoted
 * attribute value.
 *
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` can be
 *   inside an unquoted attribute value.
 */
function isUnquotedAttributeCharacter(character) {
    return character !== C_DOUBLE_QUOTE &&
        character !== C_SINGLE_QUOTE &&
        character !== C_EQUALS &&
        character !== C_LT &&
        character !== C_GT &&
        character !== C_TICK;
}

/**
 * Check whether `character` can be inside a double-quoted
 * attribute value.
 *
 * @property {string} delimiter - Closing delimiter.
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` can be
 *   inside a double-quoted attribute value.
 */
function isDoubleQuotedAttributeCharacter(character) {
    return character !== C_DOUBLE_QUOTE;
}

isDoubleQuotedAttributeCharacter.delimiter = C_DOUBLE_QUOTE;

/**
 * Check whether `character` can be inside a single-quoted
 * attribute value.
 *
 * @property {string} delimiter - Closing delimiter.
 * @param {string} character - Single character to check.
 * @return {boolean} - Whether or not `character` can be
 *   inside a single-quoted attribute value.
 */
function isSingleQuotedAttributeCharacter(character) {
    return character !== C_SINGLE_QUOTE;
}

isSingleQuotedAttributeCharacter.delimiter = C_SINGLE_QUOTE;

/**
 * Check whether `character` can be inside an enclosed
 * URI.
 *
 * @property {string} delimiter - Closing delimiter.
 * @param {string} character - Character to test.
 * @return {boolean} - Whether or not `character` can be
 *   inside an enclosed URI.
 */
function isEnclosedURLCharacter(character) {
    return character !== C_GT &&
        character !== C_BRACKET_OPEN &&
        character !== C_BRACKET_CLOSE;
}

isEnclosedURLCharacter.delimiter = C_GT;

/**
 * Check whether `character` can be inside an unclosed
 * URI.
 *
 * @param {string} character - Character to test.
 * @return {boolean} - Whether or not `character` can be
 *   inside an unclosed URI.
 */
function isUnclosedURLCharacter(character) {
    return character !== C_BRACKET_OPEN &&
        character !== C_BRACKET_CLOSE &&
        !isWhiteSpace(character);
}

/**
 * Factory to create an entity decoder.
 *
 * @param {Object} context - Context to attach to, e.g.,
 *   a parser.
 * @return {Function} - See `decode`.
 */
function decodeFactory(context) {
    /**
     * Normalize `position` to add an `indent`.
     *
     * @param {Position} position - Reference
     * @return {Position} - Augmented with `indent`.
     */
    function normalize(position) {
        return {
            'start': position,
            'indent': context.getIndent(position.line)
        };
    }

    /**
     * Handle a warning.
     *
     * @this {VFile} - Virtual file.
     * @param {string} reason - Reason for warning.
     * @param {Position} position - Place of warning.
     * @param {number} code - Code for warning.
     */
    function handleWarning(reason, position, code) {
        if (code === 3) {
            return;
        }

        context.file.warn(reason, position);
    }

    /**
     * Decode `value` (at `position`) into text-nodes.
     *
     * @param {string} value - Value to parse.
     * @param {Position} position - Position to start parsing at.
     * @param {Function} handler - Node handler.
     */
    function decoder(value, position, handler) {
        var hasPosition = context.options.position;

        decode(value, {
            'position': position && normalize(position),
            'warning': hasPosition && handleWarning,
            'text': handler,
            'reference': handler,
            'textContext': context,
            'referenceContext': context
        });
    }

    /**
     * Decode `value` (at `position`) into a string.
     *
     * @param {string} value - Value to parse.
     * @param {Position} position - Position to start
     *   parsing at.
     * @return {string} - Plain-text.
     */
    function decodeRaw(value, position) {
        return decode(value, {
            'position': position && normalize(position),
            'warning': context.options.position && handleWarning
        });
    }

    decoder.raw = decodeRaw;

    return decoder;
}

/**
 * Factory to de-escape a value, based on a list at `key`
 * in `scope`.
 *
 * @example
 *   var scope = {escape: ['a']}
 *   var descape = descapeFactory(scope, 'escape');
 *
 * @param {Object} scope - List of escapable characters.
 * @param {string} key - Key in `map` at which the list
 *   exists.
 * @return {function(string): string} - Function which
 *   takes a value and returns its unescaped version.
 */
function descapeFactory(scope, key) {
    /**
     * De-escape a string using the expression at `key`
     * in `scope`.
     *
     * @example
     *   var scope = {escape: ['a']}
     *   var descape = descapeFactory(scope, 'escape');
     *   descape('\a \b'); // 'a \b'
     *
     * @param {string} value - Escaped string.
     * @return {string} - Unescaped string.
     */
    function descape(value) {
        var prev = 0;
        var index = value.indexOf(C_BACKSLASH);
        var escape = scope[key];
        var queue = [];
        var character;

        while (index !== -1) {
            queue.push(value.slice(prev, index));
            prev = index + 1;
            character = value.charAt(prev);

            /*
             * If the following character is not a valid escape,
             * add the slash.
             */

            if (!character || escape.indexOf(character) === -1) {
                queue.push(C_BACKSLASH);
            }

            index = value.indexOf(C_BACKSLASH, prev);
        }

        queue.push(value.slice(prev));

        return queue.join(EMPTY);
    }

    return descape;
}

/**
 * Gets indentation information for a line.
 *
 * @example
 *   getIndent('  foo');
 *   // {indent: 2, stops: {1: 0, 2: 1}}
 *
 *   getIndent('\tfoo');
 *   // {indent: 4, stops: {4: 0}}
 *
 *   getIndent('  \tfoo');
 *   // {indent: 4, stops: {1: 0, 2: 1, 4: 2}}
 *
 *   getIndent('\t  foo')
 *   // {indent: 6, stops: {4: 0, 5: 1, 6: 2}}
 *
 * @param {string} value - Indented line.
 * @return {Object} - Indetation information.
 */
function getIndent(value) {
    var index = 0;
    var indent = 0;
    var character = value.charAt(index);
    var stops = {};
    var size;

    while (character in INDENTATION_CHARACTERS) {
        size = INDENTATION_CHARACTERS[character];

        indent += size;

        if (size > 1) {
            indent = Math.floor(indent / size) * size;
        }

        stops[indent] = index;

        character = value.charAt(++index);
    }

    return {
        'indent': indent,
        'stops': stops
    };
}

/**
 * Remove the minimum indent from every line in `value`.
 * Supports both tab, spaced, and mixed indentation (as
 * well as possible).
 *
 * @example
 *   removeIndentation('  foo'); // 'foo'
 *   removeIndentation('    foo', 2); // '  foo'
 *   removeIndentation('\tfoo', 2); // '  foo'
 *   removeIndentation('  foo\n bar'); // ' foo\n bar'
 *
 * @param {string} value - Value to trim.
 * @param {number?} [maximum] - Maximum indentation
 *   to remove.
 * @return {string} - Unindented `value`.
 */
function removeIndentation(value, maximum) {
    var values = value.split(C_NEWLINE);
    var position = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index;
    var indentation;
    var stops;
    var padding;

    values.unshift(repeat(C_SPACE, maximum) + C_EXCLAMATION_MARK);

    while (position--) {
        indentation = getIndent(values[position]);

        matrix[position] = indentation.stops;

        if (trim(values[position]).length === 0) {
            continue;
        }

        if (indentation.indent) {
            if (indentation.indent > 0 && indentation.indent < minIndent) {
                minIndent = indentation.indent;
            }
        } else {
            minIndent = Infinity;

            break;
        }
    }

    if (minIndent !== Infinity) {
        position = values.length;

        while (position--) {
            stops = matrix[position];
            index = minIndent;

            while (index && !(index in stops)) {
                index--;
            }

            if (
                trim(values[position]).length !== 0 &&
                minIndent &&
                index !== minIndent
            ) {
                padding = C_TAB;
            } else {
                padding = EMPTY;
            }

            values[position] = padding + values[position].slice(
                index in stops ? stops[index] + 1 : 0
            );
        }
    }

    values.shift();

    return values.join(C_NEWLINE);
}

/**
 * Tokenise a line.
 *
 * @example
 *   tokenizeNewline(eat, '\n\n');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {boolean?} - `true` when matching.
 */
function tokenizeNewline(eat, value, silent) {
    var character = value.charAt(0);
    var length;
    var subvalue;
    var queue;
    var index;

    if (character !== C_NEWLINE) {
        return;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    index = 1;
    length = value.length;
    subvalue = C_NEWLINE;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (!isWhiteSpace(character)) {
            break;
        }

        queue += character;

        if (character === C_NEWLINE) {
            subvalue += queue;
            queue = EMPTY;
        }

        index++;
    }

    eat(subvalue);
}

/**
 * Tokenise an indented code block.
 *
 * @example
 *   tokenizeCode(eat, '\tfoo');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `code` node.
 */
function tokenizeCode(eat, value, silent) {
    var self = this;
    var index = -1;
    var length = value.length;
    var character;
    var subvalue = EMPTY;
    var content = EMPTY;
    var subvalueQueue = EMPTY;
    var contentQueue = EMPTY;
    var blankQueue;
    var indent;

    while (++index < length) {
        character = value.charAt(index);

        if (indent) {
            indent = false;

            subvalue += subvalueQueue;
            content += contentQueue;
            subvalueQueue = contentQueue = EMPTY;

            if (character === C_NEWLINE) {
                subvalueQueue = contentQueue = character;
            } else {
                subvalue += character;
                content += character;

                while (++index < length) {
                    character = value.charAt(index);

                    if (!character || character === C_NEWLINE) {
                        contentQueue = subvalueQueue = character;
                        break;
                    }

                    subvalue += character;
                    content += character;
                }
            }
        } else if (
            character === C_SPACE &&
            value.charAt(index + 1) === C_SPACE &&
            value.charAt(index + 2) === C_SPACE &&
            value.charAt(index + 3) === C_SPACE
        ) {
            subvalueQueue += CODE_INDENT;
            index += 3;
            indent = true;
        } else if (character === C_TAB) {
            subvalueQueue += character;
            indent = true;
        } else {
            blankQueue = EMPTY;

            while (character === C_TAB || character === C_SPACE) {
                blankQueue += character;
                character = value.charAt(++index);
            }

            if (character !== C_NEWLINE) {
                break;
            }

            subvalueQueue += blankQueue + character;
            contentQueue += character;
        }
    }

    if (content) {
        if (silent) {
            return true;
        }

        return eat(subvalue)(self.renderCodeBlock(content));
    }
}

/**
 * Tokenise a fenced code block.
 *
 * @example
 *   tokenizeFences(eat, '```js\nfoo()\n```');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `code` node.
 */
function tokenizeFences(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var length = value.length + 1;
    var index = 0;
    var subvalue = EMPTY;
    var fenceCount;
    var marker;
    var character;
    var flag;
    var queue;
    var content;
    var exdentedContent;
    var closing;
    var exdentedClosing;
    var indent;
    var now;

    if (!settings.gfm) {
        return;
    }

    /*
     * Eat initial spacing.
     */

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            break;
        }

        subvalue += character;
        index++;
    }

    indent = index; // TODO: CHECK.

    /*
     * Eat the fence.
     */

    character = value.charAt(index);

    if (character !== C_TILDE && character !== C_TICK) {
        return;
    }

    index++;
    marker = character;
    fenceCount = 1;
    subvalue += character;

    while (index < length) {
        character = value.charAt(index);

        if (character !== marker) {
            break;
        }

        subvalue += character;
        fenceCount++;
        index++;
    }

    if (fenceCount < MIN_FENCE_COUNT) {
        return;
    }

    /*
     * Eat spacing before flag.
     */

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            break;
        }

        subvalue += character;
        index++;
    }

    /*
     * Eat flag.
     */

    flag = queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (
            character === C_NEWLINE ||
            character === C_TILDE ||
            character === C_TICK
        ) {
            break;
        }

        if (character === C_SPACE || character === C_TAB) {
            queue += character;
        } else {
            flag += queue + character;
            queue = EMPTY;
        }

        index++;
    }

    character = value.charAt(index);

    if (character && character !== C_NEWLINE) {
        return;
    }

    if (silent) {
        return true;
    }

    now = eat.now();
    now.column += subvalue.length;

    subvalue += flag;
    flag = self.decode.raw(self.descape(flag), now);

    if (queue) {
        subvalue += queue;
    }

    queue = closing = exdentedClosing = content = exdentedContent = EMPTY;

    /*
     * Eat content.
     */

    while (index < length) {
        character = value.charAt(index);
        content += closing;
        exdentedContent += exdentedClosing;
        closing = exdentedClosing = EMPTY;

        if (character !== C_NEWLINE) {
            content += character;
            exdentedClosing += character;
            index++;
            continue;
        }

        /*
         * Add the newline to `subvalue` if its the first
         * character. Otherwise, add it to the `closing`
         * queue.
         */

        if (!content) {
            subvalue += character;
        } else {
            closing += character;
            exdentedClosing += character;
        }

        queue = EMPTY;
        index++;

        while (index < length) {
            character = value.charAt(index);

            if (character !== C_SPACE) {
                break;
            }

            queue += character;
            index++;
        }

        closing += queue;
        exdentedClosing += queue.slice(indent);

        if (queue.length >= CODE_INDENT_LENGTH) {
            continue;
        }

        queue = EMPTY;

        while (index < length) {
            character = value.charAt(index);

            if (character !== marker) {
                break;
            }

            queue += character;
            index++;
        }

        closing += queue;
        exdentedClosing += queue;

        if (queue.length < fenceCount) {
            continue;
        }

        queue = EMPTY;

        while (index < length) {
            character = value.charAt(index);

            if (character !== C_SPACE && character !== C_TAB) {
                break;
            }

            closing += character;
            exdentedClosing += character;
            index++;
        }

        if (!character || character === C_NEWLINE) {
            break;
        }
    }

    subvalue += content + closing;

    return eat(subvalue)(self.renderCodeBlock(exdentedContent, flag));
}

/**
 * Tokenise an ATX-style heading.
 *
 * @example
 *   tokenizeHeading(eat, ' # foo');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `heading` node.
 */
function tokenizeHeading(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var length = value.length + 1;
    var index = -1;
    var now = eat.now();
    var subvalue = EMPTY;
    var content = EMPTY;
    var character;
    var queue;
    var depth;

    /*
     * Eat initial spacing.
     */

    while (++index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            index--;
            break;
        }

        subvalue += character;
    }

    /*
     * Eat hashes.
     */

    depth = 0;
    length = index + MAX_ATX_COUNT + 1;

    while (++index <= length) {
        character = value.charAt(index);

        if (character !== C_HASH) {
            index--;
            break;
        }

        subvalue += character;
        depth++;
    }

    if (
        !depth ||
        (!settings.pedantic && value.charAt(index + 1) === C_HASH)
    ) {
        return;
    }

    length = value.length + 1;

    /*
     * Eat intermediate white-space.
     */

    queue = EMPTY;

    while (++index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            index--;
            break;
        }

        queue += character;
    }

    /*
     * Exit when not in pedantic mode without spacing.
     */

    if (
        !settings.pedantic &&
        !queue.length &&
        character &&
        character !== C_NEWLINE
    ) {
        return;
    }

    if (silent) {
        return true;
    }

    /*
     * Eat content.
     */

    subvalue += queue;
    queue = content = EMPTY;

    while (++index < length) {
        character = value.charAt(index);

        if (!character || character === C_NEWLINE) {
            break;
        }

        if (
            character !== C_SPACE &&
            character !== C_TAB &&
            character !== C_HASH
        ) {
            content += queue + character;
            queue = EMPTY;
            continue;
        }

        while (character === C_SPACE || character === C_TAB) {
            queue += character;
            character = value.charAt(++index);
        }

        while (character === C_HASH) {
            queue += character;
            character = value.charAt(++index);
        }

        while (character === C_SPACE || character === C_TAB) {
            queue += character;
            character = value.charAt(++index);
        }

        index--;
    }

    now.column += subvalue.length;
    subvalue += content + queue;

    return eat(subvalue)(self.renderHeading(content, depth, now));
}

/**
 * Tokenise a Setext-style heading.
 *
 * @example
 *   tokenizeLineHeading(eat, 'foo\n===');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `heading` node.
 */
function tokenizeLineHeading(eat, value, silent) {
    var self = this;
    var now = eat.now();
    var length = value.length;
    var index = -1;
    var subvalue = EMPTY;
    var content;
    var queue;
    var character;
    var marker;
    var depth;

    /*
     * Eat initial indentation.
     */

    while (++index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE || index >= MAX_LINE_HEADING_INDENT) {
            index--;
            break;
        }

        subvalue += character;
    }

    /*
     * Eat content.
     */

    content = queue = EMPTY;

    while (++index < length) {
        character = value.charAt(index);

        if (character === C_NEWLINE) {
            index--;
            break;
        }

        if (character === C_SPACE || character === C_TAB) {
            queue += character;
        } else {
            content += queue + character;
            queue = EMPTY;
        }
    }

    now.column += subvalue.length;
    subvalue += content + queue;

    /*
     * Ensure the content is followed by a newline and a
     * valid marker.
     */

    character = value.charAt(++index);
    marker = value.charAt(++index);

    if (
        character !== C_NEWLINE ||
        !SETEXT_MARKERS[marker]
    ) {
        return;
    }

    if (silent) {
        return true;
    }

    subvalue += character;

    /*
     * Eat Setext-line.
     */

    queue = marker;
    depth = SETEXT_MARKERS[marker];

    while (++index < length) {
        character = value.charAt(index);

        if (character !== marker) {
            if (character !== C_NEWLINE) {
                return;
            }

            index--;
            break;
        }

        queue += character;
    }

    return eat(subvalue + queue)(self.renderHeading(content, depth, now));
}

/**
 * Tokenise a horizontal rule.
 *
 * @example
 *   tokenizeHorizontalRule(eat, '***');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `horizontalRule` node.
 */
function tokenizeHorizontalRule(eat, value, silent) {
    var self = this;
    var index = -1;
    var length = value.length + 1;
    var subvalue = EMPTY;
    var character;
    var marker;
    var markerCount;
    var queue;

    while (++index < length) {
        character = value.charAt(index);

        if (character !== C_TAB && character !== C_SPACE) {
            break;
        }

        subvalue += character;
    }

    if (RULE_MARKERS[character] !== true) {
        return;
    }

    marker = character;
    subvalue += character;
    markerCount = 1;
    queue = EMPTY;

    while (++index < length) {
        character = value.charAt(index);

        if (character === marker) {
            markerCount++;
            subvalue += queue + marker;
            queue = EMPTY;
        } else if (character === C_SPACE) {
            queue += character;
        } else if (
            markerCount >= HORIZONTAL_RULE_MARKER_COUNT &&
            (!character || character === C_NEWLINE)
        ) {
            subvalue += queue;

            if (silent) {
                return true;
            }

            return eat(subvalue)(self.renderVoid(T_HORIZONTAL_RULE));
        } else {
            return;
        }
    }
}

/**
 * Tokenise a blockquote.
 *
 * @example
 *   tokenizeBlockquote(eat, '> Foo');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `blockquote` node.
 */
function tokenizeBlockquote(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var now = eat.now();
    var indent = self.indent(now.line);
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var tokenizers;
    var index = 0;
    var character;
    var rest;
    var nextIndex;
    var content;
    var line;
    var startIndex;
    var prefixed;

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            break;
        }

        index++;
    }

    if (value.charAt(index) !== C_GT) {
        return;
    }

    if (silent) {
        return true;
    }

    tokenizers = self.blockTokenizers;
    index = 0;

    while (index < length) {
        nextIndex = value.indexOf(C_NEWLINE, index);
        startIndex = index;
        prefixed = false;

        if (nextIndex === -1) {
            nextIndex = length;
        }

        while (index < length) {
            character = value.charAt(index);

            if (character !== C_SPACE && character !== C_TAB) {
                break;
            }

            index++;
        }

        if (value.charAt(index) === C_GT) {
            index++;
            prefixed = true;

            if (value.charAt(index) === C_SPACE) {
                index++;
            }
        } else {
            index = startIndex;
        }

        content = value.slice(index, nextIndex);

        if (!prefixed && !trim(content)) {
            index = startIndex;
            break;
        }

        if (!prefixed) {
            rest = value.slice(index);

            if (
                commonmark &&
                (
                    tokenizers.code.call(self, eat, rest, true) ||
                    tokenizers.fences.call(self, eat, rest, true) ||
                    tokenizers.heading.call(self, eat, rest, true) ||
                    tokenizers.lineHeading.call(self, eat, rest, true) ||
                    tokenizers.horizontalRule.call(self, eat, rest, true) ||
                    tokenizers.html.call(self, eat, rest, true) ||
                    tokenizers.list.call(self, eat, rest, true)
                )
            ) {
                break;
            }

            if (
                !commonmark &&
                (
                    tokenizers.definition.call(self, eat, rest, true) ||
                    tokenizers.footnoteDefinition.call(self, eat, rest, true)
                )
            ) {
                break;
            }
        }

        line = startIndex === index ?
            content :
            value.slice(startIndex, nextIndex);

        indents.push(index - startIndex);
        values.push(line);
        contents.push(content);

        index = nextIndex + 1;
    }

    index = -1;
    length = indents.length;
    add = eat(values.join(C_NEWLINE));

    while (++index < length) {
        indent(indents[index]);
    }

    return add(self.renderBlockquote(contents.join(C_NEWLINE), now));
}

/**
 * Tokenise a list.
 *
 * @example
 *   tokenizeList(eat, '- Foo');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `list` node.
 */
function tokenizeList(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var pedantic = self.options.pedantic;
    var tokenizers = self.blockTokenizers;
    var markers;
    var index = 0;
    var length = value.length;
    var start = null;
    var queue;
    var ordered;
    var character;
    var marker;
    var nextIndex;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var prevEmpty;
    var empty;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var isLoose;
    var node;
    var now;
    var end;
    var indented;
    var size;

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            break;
        }

        index++;
    }

    character = value.charAt(index);

    markers = commonmark ?
        LIST_ORDERED_COMMONMARK_MARKERS :
        LIST_ORDERED_MARKERS;

    if (LIST_UNORDERED_MARKERS[character] === true) {
        marker = character;
        ordered = false;
    } else {
        ordered = true;
        queue = EMPTY;

        while (index < length) {
            character = value.charAt(index);

            if (!isNumeric(character)) {
                break;
            }

            queue += character;
            index++;
        }

        character = value.charAt(index);

        if (!queue || markers[character] !== true) {
            return;
        }

        start = parseInt(queue, 10);
        marker = character;
    }

    character = value.charAt(++index);

    if (character !== C_SPACE && character !== C_TAB) {
        return;
    }

    if (silent) {
        return true;
    }

    index = 0;
    items = [];
    allLines = [];
    emptyLines = [];

    while (index < length) {
        nextIndex = value.indexOf(C_NEWLINE, index);
        startIndex = index;
        prefixed = false;
        indented = false;

        if (nextIndex === -1) {
            nextIndex = length;
        }

        end = index + TAB_SIZE;
        size = 0;

        while (index < length) {
            character = value.charAt(index);

            if (character === C_TAB) {
                size += TAB_SIZE - size % TAB_SIZE;
            } else if (character === C_SPACE) {
                size++;
            } else {
                break;
            }

            index++;
        }

        if (size >= TAB_SIZE) {
            indented = true;
        }

        if (item && size >= item.indent) {
            indented = true;
        }

        character = value.charAt(index);
        currentMarker = null;

        if (!indented) {
            if (LIST_UNORDERED_MARKERS[character] === true) {
                currentMarker = character;
                index++;
                size++;
            } else {
                queue = EMPTY;

                while (index < length) {
                    character = value.charAt(index);

                    if (!isNumeric(character)) {
                        break;
                    }

                    queue += character;
                    index++;
                }

                character = value.charAt(index);
                index++;

                if (queue && markers[character] === true) {
                    currentMarker = character;
                    size += queue.length + 1;
                }
            }

            if (currentMarker) {
                character = value.charAt(index);

                if (character === C_TAB) {
                    size += TAB_SIZE - size % TAB_SIZE;
                    index++;
                } else if (character === C_SPACE) {
                    end = index + TAB_SIZE;

                    while (index < end) {
                        if (value.charAt(index) !== C_SPACE) {
                            break;
                        }

                        index++;
                        size++;
                    }

                    if (index === end && value.charAt(index) === C_SPACE) {
                        index -= TAB_SIZE - 1;
                        size -= TAB_SIZE - 1;
                    }
                } else if (
                    character !== C_NEWLINE &&
                    character !== EMPTY
                ) {
                    currentMarker = null;
                }
            }
        }

        if (currentMarker) {
            if (commonmark && marker !== currentMarker) {
                break;
            }

            prefixed = true;
        } else {
            if (
                !commonmark &&
                !indented &&
                value.charAt(startIndex) === C_SPACE
            ) {
                indented = true;
            } else if (
                commonmark &&
                item
            ) {
                indented = size >= item.indent || size > TAB_SIZE;
            }

            prefixed = false;
            index = startIndex;
        }

        line = value.slice(startIndex, nextIndex);
        content = startIndex === index ? line : value.slice(index, nextIndex);

        if (currentMarker && RULE_MARKERS[currentMarker] === true) {
            if (
                tokenizers.horizontalRule.call(self, eat, line, true)
            ) {
                break;
            }
        }

        prevEmpty = empty;
        empty = !trim(content).length;

        if (indented && item) {
            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (prefixed) {
            if (emptyLines.length) {
                item.value.push(EMPTY);
                item.trail = emptyLines.concat();
            }

            item = {
                // 'bullet': value.slice(startIndex, index),
                'value': [line],
                'indent': size,
                'trail': []
            };

            items.push(item);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        } else if (empty) {
            // TODO: disable when in pedantic-mode.
            if (prevEmpty) {
                break;
            }

            emptyLines.push(line);
        } else {
            if (prevEmpty) {
                break;
            }

            if (
                !pedantic &&
                tokenizers.horizontalRule.call(self, eat, line, true)
            ) {
                break;
            }

            if (!commonmark) {
                if (
                    tokenizers.definition.call(self, eat, line, true) ||
                    tokenizers.footnoteDefinition.call(self, eat, line, true)
                ) {
                    break;
                }
            }

            item.value = item.value.concat(emptyLines, line);
            allLines = allLines.concat(emptyLines, line);
            emptyLines = [];
        }

        index = nextIndex + 1;
    }

    node = eat(allLines.join(C_NEWLINE)).reset({
        'type': T_LIST,
        'ordered': ordered,
        'start': start,
        'loose': null,
        'children': []
    });

    enterTop = self.exitTop();
    exitBlockquote = self.enterBlockquote();
    isLoose = false;
    index = -1;
    length = items.length;

    while (++index < length) {
        item = items[index].value.join(C_NEWLINE);
        now = eat.now();

        item = eat(item)(self.renderListItem(item, now), node);

        if (item.loose) {
            isLoose = true;
        }

        item = items[index].trail.join(C_NEWLINE);

        if (index !== length - 1) {
            item += C_NEWLINE;
        }

        eat(item);
    }

    enterTop();
    exitBlockquote();

    node.loose = isLoose;

    return node;
}

/**
 * Try to match comment.
 *
 * @param {string} value - Value to parse.
 * @param {Object} settings - Configuration as available on
 *   a parser.
 * @return {string?} - When applicable, the comment at the
 *   start of `value`.
 */
function eatHTMLComment(value, settings) {
    var index = COMMENT_START_LENGTH;
    var queue = COMMENT_START;
    var length = value.length;
    var commonmark = settings.commonmark;
    var character;
    var hasNonDash;

    if (value.slice(0, index) === queue) {
        while (index < length) {
            character = value.charAt(index);

            if (
                character === COMMENT_END_CHAR &&
                value.slice(index, index + COMMENT_END_LENGTH) === COMMENT_END
            ) {
                return queue + COMMENT_END;
            }

            if (commonmark) {
                if (character === C_GT && !hasNonDash) {
                    return;
                }

                if (character === C_DASH) {
                    if (value.charAt(index + 1) === C_DASH) {
                        return;
                    }
                } else {
                    hasNonDash = true;
                }
            }

            queue += character;
            index++;
        }
    }
}

/**
 * Try to match CDATA.
 *
 * @param {string} value - Value to parse.
 * @return {string?} - When applicable, the CDATA at the
 *   start of `value`.
 */
function eatHTMLCDATA(value) {
    var index = CDATA_START_LENGTH;
    var queue = value.slice(0, index);
    var length = value.length;
    var character;

    if (queue.toUpperCase() === CDATA_START) {
        while (index < length) {
            character = value.charAt(index);

            if (
                character === CDATA_END_CHAR &&
                value.slice(index, index + CDATA_END_LENGTH) === CDATA_END
            ) {
                return queue + CDATA_END;
            }

            queue += character;
            index++;
        }
    }
}

/**
 * Try to match a processing instruction.
 *
 * @param {string} value - Value to parse.
 * @return {string?} - When applicable, the processing
 *   instruction at the start of `value`.
 */
function eatHTMLProcessingInstruction(value) {
    var index = 0;
    var queue = EMPTY;
    var length = value.length;
    var character;

    if (
        value.charAt(index) === C_LT &&
        value.charAt(++index) === C_QUESTION_MARK
    ) {
        queue = C_LT + C_QUESTION_MARK;
        index++;

        while (index < length) {
            character = value.charAt(index);

            if (
                character === C_QUESTION_MARK &&
                value.charAt(index + 1) === C_GT
            ) {
                return queue + character + C_GT;
            }

            queue += character;
            index++;
        }
    }
}

/**
 * Try to match a declaration.
 *
 * @param {string} value - Value to parse.
 * @return {string?} - When applicable, the declaration at
 *   the start of `value`.
 */
function eatHTMLDeclaration(value) {
    var index = 0;
    var length = value.length;
    var queue = EMPTY;
    var subqueue = EMPTY;
    var character;

    if (
        value.charAt(index) === C_LT &&
        value.charAt(++index) === C_EXCLAMATION_MARK
    ) {
        queue = C_LT + C_EXCLAMATION_MARK;
        index++;

        /*
         * Eat as many alphabetic characters as
         * possible.
         */

        while (index < length) {
            character = value.charAt(index);

            if (!isAlphabetic(character)) {
                break;
            }

            subqueue += character;
            index++;
        }

        character = value.charAt(index);

        if (!subqueue || !isWhiteSpace(character)) {
            return;
        }

        queue += subqueue + character;
        index++;

        while (index < length) {
            character = value.charAt(index);

            if (character === C_GT) {
                return queue;
            }

            queue += character;
            index++;
        }
    }
}

/**
 * Try to match a closing tag.
 *
 * @param {string} value - Value to parse.
 * @param {boolean?} [isBlock] - Whether the tag-name
 *   must be a known block-level node to match.
 * @return {string?} - When applicable, the closing tag at
 *   the start of `value`.
 */
function eatHTMLClosingTag(value, isBlock) {
    var index = 0;
    var length = value.length;
    var queue = EMPTY;
    var subqueue = EMPTY;
    var character;

    if (
        value.charAt(index) === C_LT &&
        value.charAt(++index) === C_SLASH
    ) {
        queue = C_LT + C_SLASH;
        subqueue = character = value.charAt(++index);

        if (!isAlphabetic(character)) {
            return;
        }

        index++;

        /*
         * Eat as many alphabetic characters as
         * possible.
         */

        while (index < length) {
            character = value.charAt(index);

            if (!isAlphabetic(character) && !isNumeric(character)) {
                break;
            }

            subqueue += character;
            index++;
        }

        if (isBlock && blockElements.indexOf(subqueue.toLowerCase()) === -1) {
            return;
        }

        queue += subqueue;

        /*
         * Eat white-space.
         */

        while (index < length) {
            character = value.charAt(index);

            if (!isWhiteSpace(character)) {
                break;
            }

            queue += character;
            index++;
        }

        if (value.charAt(index) === C_GT) {
            return queue + C_GT;
        }
    }
}

/**
 * Try to match an opening tag.
 *
 * @param {string} value - Value to parse.
 * @param {boolean?} [isBlock] - Whether the tag-name
 *   must be a known block-level node to match.
 * @return {string?} - When applicable, the opening tag at
 *   the start of `value`.
 */
function eatHTMLOpeningTag(value, isBlock) {
    var index = 0;
    var length = value.length;
    var queue = EMPTY;
    var subqueue = EMPTY;
    var character = value.charAt(index);
    var hasEquals;
    var test;

    if (character === C_LT) {
        queue = character;
        subqueue = character = value.charAt(++index);

        if (!isAlphabetic(character)) {
            return;
        }

        index++;

        /*
         * Eat as many alphabetic characters as
         * possible.
         */

        while (index < length) {
            character = value.charAt(index);

            if (!isAlphabetic(character) && !isNumeric(character)) {
                break;
            }

            subqueue += character;
            index++;
        }

        if (isBlock && blockElements.indexOf(subqueue.toLowerCase()) === -1) {
            return;
        }

        queue += subqueue;
        subqueue = EMPTY;

        /*
         * Find attributes.
         */

        while (index < length) {
            /*
             * Eat white-space.
             */

            while (index < length) {
                character = value.charAt(index);

                if (!isWhiteSpace(character)) {
                    break;
                }

                subqueue += character;
                index++;
            }

            if (!subqueue) {
                break;
            }

            /*
             * Eat an attribute name.
             */

            queue += subqueue;
            subqueue = EMPTY;
            character = value.charAt(index);

            if (
                isAlphabetic(character) ||
                character === C_UNDERSCORE ||
                character === C_COLON
            ) {
                subqueue = character;
                index++;

                while (index < length) {
                    character = value.charAt(index);

                    if (
                        !isAlphabetic(character) &&
                        !isNumeric(character) &&
                        character !== C_UNDERSCORE &&
                        character !== C_COLON &&
                        character !== C_DOT &&
                        character !== C_DASH
                    ) {
                        break;
                    }

                    subqueue += character;
                    index++;
                }
            }

            if (!subqueue) {
                break;
            }

            queue += subqueue;
            subqueue = EMPTY;
            hasEquals = false;

            /*
             * Eat zero or more white-space and one
             * equals sign.
             */

            while (index < length) {
                character = value.charAt(index);

                if (!isWhiteSpace(character)) {
                    if (!hasEquals && character === C_EQUALS) {
                        hasEquals = true;
                    } else {
                        break;
                    }
                }

                subqueue += character;
                index++;
            }

            queue += subqueue;
            subqueue = EMPTY;

            if (!hasEquals) {
                queue += subqueue;
            } else {
                character = value.charAt(index);
                queue += subqueue;

                if (character === C_DOUBLE_QUOTE) {
                    test = isDoubleQuotedAttributeCharacter;
                    subqueue = character;
                    index++;
                } else if (character === C_SINGLE_QUOTE) {
                    test = isSingleQuotedAttributeCharacter;
                    subqueue = character;
                    index++;
                } else {
                    test = isUnquotedAttributeCharacter;
                    subqueue = EMPTY;
                }

                while (index < length) {
                    character = value.charAt(index);

                    if (!test(character)) {
                        break;
                    }

                    subqueue += character;
                    index++;
                }

                character = value.charAt(index);
                index++;

                if (!test.delimiter) {
                    if (!subqueue.length) {
                        return;
                    }

                    index--;
                } else if (character === test.delimiter) {
                    subqueue += character;
                } else {
                    return;
                }

                queue += subqueue;
                subqueue = EMPTY;
            }
        }

        /*
         * More white-space is already eaten by the
         * attributes subroutine.
         */

        character = value.charAt(index);

        /*
         * Eat an optional backslash (for self-closing
         * tags).
         */

        if (character === C_SLASH) {
            queue += character;
            character = value.charAt(++index);
        }

        return character === C_GT ? queue + character : null;
    }
}

/**
 * Tokenise HTML.
 *
 * @example
 *   tokenizeHTML(eat, '<span>foo</span>');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `html` node.
 */
function tokenizeHTML(eat, value, silent) {
    var self = this;
    var index = 0;
    var length = value.length;
    var subvalue = EMPTY;
    var offset;
    var lineCount;
    var character;
    var queue;

    /*
     * Eat initial spacing.
     */

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_TAB && character !== C_SPACE) {
            break;
        }

        subvalue += character;
        index++;
    }

    offset = index;
    value = value.slice(offset);

    /*
     * Try to eat an HTML thing.
     */

    queue = eatHTMLComment(value, self.options) ||
        eatHTMLCDATA(value) ||
        eatHTMLProcessingInstruction(value) ||
        eatHTMLDeclaration(value) ||
        eatHTMLClosingTag(value, true) ||
        eatHTMLOpeningTag(value, true);

    if (!queue) {
        return;
    }

    if (silent) {
        return true;
    }

    subvalue += queue;
    index = subvalue.length - offset;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (character === C_NEWLINE) {
            queue += character;
            lineCount++;
        } else if (queue.length < MIN_CLOSING_HTML_NEWLINE_COUNT) {
            subvalue += queue + character;
            queue = EMPTY;
        } else {
            break;
        }

        index++;
    }

    return eat(subvalue)(self.renderRaw(T_HTML, subvalue));
}

/**
 * Tokenise a definition.
 *
 * @example
 *   var value = '[foo]: http://example.com "Example Domain"';
 *   tokenizeDefinition(eat, value);
 *
 * @property {boolean} onlyAtTop
 * @property {boolean} notInBlockquote
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `definition` node.
 */
function tokenizeDefinition(eat, value, silent) {
    var self = this;
    var commonmark = self.options.commonmark;
    var index = 0;
    var length = value.length;
    var subvalue = EMPTY;
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url;
    var title;

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_SPACE && character !== C_TAB) {
            break;
        }

        subvalue += character;
        index++;
    }

    character = value.charAt(index);

    if (character !== C_BRACKET_OPEN) {
        return;
    }

    index++;
    subvalue += character;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (character === C_BRACKET_CLOSE) {
            break;
        } else if (character === C_BACKSLASH) {
            queue += character;
            index++;
            character = value.charAt(index);
        }

        queue += character;
        index++;
    }

    if (
        !queue ||
        value.charAt(index) !== C_BRACKET_CLOSE ||
        value.charAt(index + 1) !== C_COLON
    ) {
        return;
    }

    identifier = queue;
    subvalue += queue + C_BRACKET_CLOSE + C_COLON;
    index = subvalue.length;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (
            character !== C_TAB &&
            character !== C_SPACE &&
            character !== C_NEWLINE
        ) {
            break;
        }

        subvalue += character;
        index++;
    }

    character = value.charAt(index);
    queue = EMPTY;
    beforeURL = subvalue;

    if (character === C_LT) {
        index++;

        while (index < length) {
            character = value.charAt(index);

            if (!isEnclosedURLCharacter(character)) {
                break;
            }

            queue += character;
            index++;
        }

        character = value.charAt(index);

        if (character !== isEnclosedURLCharacter.delimiter) {
            if (commonmark) {
                return;
            }

            index -= queue.length + 1;
            queue = EMPTY;
        } else {
            subvalue += C_LT + queue + character;
            index++;
        }
    }

    if (!queue) {
        while (index < length) {
            character = value.charAt(index);

            if (!isUnclosedURLCharacter(character)) {
                break;
            }

            queue += character;
            index++;
        }

        subvalue += queue;
    }

    if (!queue) {
        return;
    }

    url = queue;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (
            character !== C_TAB &&
            character !== C_SPACE &&
            character !== C_NEWLINE
        ) {
            break;
        }

        queue += character;
        index++;
    }

    character = value.charAt(index);
    test = null;

    if (character === C_DOUBLE_QUOTE) {
        test = C_DOUBLE_QUOTE;
    } else if (character === C_SINGLE_QUOTE) {
        test = C_SINGLE_QUOTE;
    } else if (character === C_PAREN_OPEN) {
        test = C_PAREN_CLOSE;
    }

    if (!test) {
        queue = EMPTY;
        index = subvalue.length;
    } else if (!queue) {
        return;
    } else {
        subvalue += queue + character;
        index = subvalue.length;
        queue = EMPTY;

        while (index < length) {
            character = value.charAt(index);

            if (character === test) {
                break;
            }

            if (character === C_NEWLINE) {
                index++;
                character = value.charAt(index);

                if (character === C_NEWLINE || character === test) {
                    return;
                }

                queue += C_NEWLINE;
            }

            queue += character;
            index++;
        }

        character = value.charAt(index);

        if (character !== test) {
            return;
        }

        beforeTitle = subvalue;
        subvalue += queue + character;
        index++;
        title = queue;
        queue = EMPTY;
    }

    while (index < length) {
        character = value.charAt(index);

        if (character !== C_TAB && character !== C_SPACE) {
            break;
        }

        subvalue += character;
        index++;
    }

    character = value.charAt(index);

    if (!character || character === C_NEWLINE) {
        if (silent) {
            return true;
        }

        beforeURL = eat(beforeURL).test().end;
        url = self.decode.raw(self.descape(url), beforeURL);

        if (title) {
            beforeTitle = eat(beforeTitle).test().end;
            title = self.decode.raw(self.descape(title), beforeTitle);
        }

        return eat(subvalue)({
            'type': T_DEFINITION,
            'identifier': normalize(identifier),
            'title': title || null,
            'link': url
        });
    }
}

tokenizeDefinition.onlyAtTop = true;
tokenizeDefinition.notInBlockquote = true;

/**
 * Tokenise YAML front matter.
 *
 * @example
 *   tokenizeYAMLFrontMatter(eat, '---\nfoo: bar\n---');
 *
 * @property {boolean} onlyAtStart
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `yaml` node.
 */
function tokenizeYAMLFrontMatter(eat, value, silent) {
    var self = this;
    var subvalue;
    var content;
    var index;
    var length;
    var character;
    var queue;

    if (
        !self.options.yaml ||
        value.charAt(0) !== C_DASH ||
        value.charAt(1) !== C_DASH ||
        value.charAt(2) !== C_DASH ||
        value.charAt(3) !== C_NEWLINE
    ) {
        return;
    }

    subvalue = YAML_FENCE + C_NEWLINE;
    content = queue = EMPTY;
    index = 3;
    length = value.length;

    while (++index < length) {
        character = value.charAt(index);

        if (
            character === C_DASH &&
            (queue || !content) &&
            value.charAt(index + 1) === C_DASH &&
            value.charAt(index + 2) === C_DASH
        ) {
            /* istanbul ignore if - never used (yet) */
            if (silent) {
                return true;
            }

            subvalue += queue + YAML_FENCE;

            return eat(subvalue)(self.renderRaw(T_YAML, content));
        }

        if (character === C_NEWLINE) {
            queue += character;
        } else {
            subvalue += queue + character;
            content += queue + character;
            queue = EMPTY;
        }
    }
}

tokenizeYAMLFrontMatter.onlyAtStart = true;

/**
 * Tokenise a footnote definition.
 *
 * @example
 *   tokenizeFootnoteDefinition(eat, '[^foo]: Bar.');
 *
 * @property {boolean} onlyAtTop
 * @property {boolean} notInBlockquote
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `footnoteDefinition` node.
 */
function tokenizeFootnoteDefinition(eat, value, silent) {
    var self = this;
    var index;
    var length;
    var subvalue;
    var now;
    var indent;
    var content;
    var queue;
    var subqueue;
    var character;
    var identifier;

    if (!self.options.footnotes) {
        return;
    }

    index = 0;
    length = value.length;
    subvalue = EMPTY;
    now = eat.now();
    indent = self.indent(now.line);

    while (index < length) {
        character = value.charAt(index);

        if (!isWhiteSpace(character)) {
            break;
        }

        subvalue += character;
        index++;
    }

    if (
        value.charAt(index) !== C_BRACKET_OPEN ||
        value.charAt(index + 1) !== C_CARET
    ) {
        return;
    }

    subvalue += C_BRACKET_OPEN + C_CARET;
    index = subvalue.length;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (character === C_BRACKET_CLOSE) {
            break;
        } else if (character === C_BACKSLASH) {
            queue += character;
            index++;
            character = value.charAt(index);
        }

        queue += character;
        index++;
    }

    if (
        !queue ||
        value.charAt(index) !== C_BRACKET_CLOSE ||
        value.charAt(index + 1) !== C_COLON
    ) {
        return;
    }

    if (silent) {
        return true;
    }

    identifier = normalize(queue);
    subvalue += queue + C_BRACKET_CLOSE + C_COLON;
    index = subvalue.length;

    while (index < length) {
        character = value.charAt(index);

        if (
            character !== C_TAB &&
            character !== C_SPACE
        ) {
            break;
        }

        subvalue += character;
        index++;
    }

    now.column += subvalue.length;
    queue = content = subqueue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (character === C_NEWLINE) {
            subqueue = character;
            index++;

            while (index < length) {
                character = value.charAt(index);

                if (character !== C_NEWLINE) {
                    break;
                }

                subqueue += character;
                index++;
            }

            queue += subqueue;
            subqueue = EMPTY;

            while (index < length) {
                character = value.charAt(index);

                if (character !== C_SPACE) {
                    break;
                }

                subqueue += character;
                index++;
            }

            if (!subqueue.length) {
                break;
            }

            queue += subqueue;
        }

        if (queue) {
            content += queue;
            queue = EMPTY;
        }

        content += character;
        index++;
    }

    subvalue += content;

    content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {
        indent(line.length);

        return EMPTY;
    });

    return eat(subvalue)(
        self.renderFootnoteDefinition(identifier, content, now)
    );
}

tokenizeFootnoteDefinition.onlyAtTop = true;
tokenizeFootnoteDefinition.notInBlockquote = true;

/**
 * Tokenise a table.
 *
 * @example
 *   tokenizeTable(eat, ' | foo |\n | --- |\n | bar |');
 *
 * @property {boolean} onlyAtTop
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `table` node.
 */
function tokenizeTable(eat, value, silent) {
    var self = this;
    var index;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var count;
    var opening;
    var now;
    var position;
    var lineCount;
    var line;
    var rows;
    var table;
    var lineIndex;
    var pipeIndex;
    var first;

    /*
     * Exit when not in gfm-mode.
     */

    if (!self.options.gfm) {
        return;
    }

    /*
     * Get the rows.
     * Detecting tables soon is hard, so there are some
     * checks for performance here, such as the minimum
     * number of rows, and allowed characters in the
     * alignment row.
     */

    index = lineCount = 0;
    length = value.length + 1;
    lines = [];

    while (index < length) {
        lineIndex = value.indexOf(C_NEWLINE, index);
        pipeIndex = value.indexOf(C_PIPE, index + 1);

        if (lineIndex === -1) {
            lineIndex = value.length;
        }

        if (
            pipeIndex === -1 ||
            pipeIndex > lineIndex
        ) {
            if (lineCount < MIN_TABLE_ROWS) {
                return;
            }

            break;
        }

        lines.push(value.slice(index, lineIndex));
        lineCount++;
        index = lineIndex + 1;
    }

    /*
     * Parse the alignment row.
     */

    subvalue = lines.join(C_NEWLINE);
    alignments = lines.splice(1, 1)[0];
    index = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];

    while (index < length) {
        character = alignments.charAt(index);

        if (character === C_PIPE) {
            hasDash = null;

            if (alignment === false) {
                if (first === false) {
                    return;
                }
            } else {
                align.push(alignment);
                alignment = false;
            }

            first = false;
        } else if (character === C_DASH) {
            hasDash = true;
            alignment = alignment || TABLE_ALIGN_NONE;
        } else if (character === C_COLON) {
            if (alignment === TABLE_ALIGN_LEFT) {
                alignment = TABLE_ALIGN_CENTER;
            } else if (hasDash && alignment === TABLE_ALIGN_NONE) {
                alignment = TABLE_ALIGN_RIGHT;
            } else {
                alignment = TABLE_ALIGN_LEFT;
            }
        } else if (!isWhiteSpace(character)) {
            return;
        }

        index++;
    }

    if (alignment !== false) {
        align.push(alignment);
    }

    /*
     * Exit when without enough columns.
     */

    if (align.length < MIN_TABLE_COLUMNS) {
        return;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    /*
     * Parse the rows.
     */

    position = -1;
    rows = [];

    table = eat(subvalue).reset({
        'type': T_TABLE,
        'align': align,
        'children': rows
    });

    while (++position < lineCount) {
        line = lines[position];
        row = self.renderParent(position ? T_TABLE_ROW : T_TABLE_HEADER, []);

        /*
         * Eat a newline character when this is not the
         * first row.
         */

        if (position) {
            eat(C_NEWLINE);
        }

        /*
         * Eat the row.
         */

        eat(line).reset(row, table);

        length = line.length + 1;
        index = 0;
        queue = EMPTY;
        cell = EMPTY;
        preamble = true;
        count = opening = null;

        while (index < length) {
            character = line.charAt(index);

            if (character === C_TAB || character === C_SPACE) {
                if (cell) {
                    queue += character;
                } else {
                    eat(character);
                }

                index++;
                continue;
            }

            if (character === EMPTY || character === C_PIPE) {
                if (preamble) {
                    eat(character);
                } else {
                    if (character && opening) {
                        queue += character;
                        index++;
                        continue;
                    }

                    if ((cell || character) && !preamble) {
                        subvalue = cell;

                        if (queue.length > 1) {
                            if (character) {
                                subvalue += queue.slice(0, queue.length - 1);
                                queue = queue.charAt(queue.length - 1);
                            } else {
                                subvalue += queue;
                                queue = EMPTY;
                            }
                        }

                        now = eat.now();

                        eat(subvalue)(
                            self.renderInline(T_TABLE_CELL, cell, now), row
                        );
                    }

                    eat(queue + character);

                    queue = EMPTY;
                    cell = EMPTY;
                }
            } else {
                if (queue) {
                    cell += queue;
                    queue = EMPTY;
                }

                cell += character;

                if (character === C_BACKSLASH && index !== length - 2) {
                    cell += line.charAt(index + 1);
                    index++;
                }

                if (character === C_TICK) {
                    count = 1;

                    while (line.charAt(index + 1) === character) {
                        cell += character;
                        index++;
                        count++;
                    }

                    if (!opening) {
                        opening = count;
                    } else if (count >= opening) {
                        opening = 0;
                    }
                }
            }

            preamble = false;
            index++;
        }

        /*
         * Eat the alignment row.
         */

        if (!position) {
            eat(C_NEWLINE + alignments);
        }
    }

    return table;
}

tokenizeTable.onlyAtTop = true;

/**
 * Tokenise a paragraph node.
 *
 * @example
 *   tokenizeParagraph(eat, 'Foo.');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `paragraph` node.
 */
function tokenizeParagraph(eat, value, silent) {
    var self = this;
    var settings = self.options;
    var commonmark = settings.commonmark;
    var gfm = settings.gfm;
    var tokenizers = self.blockTokenizers;
    var index = value.indexOf(C_NEWLINE);
    var length = value.length;
    var position;
    var subvalue;
    var character;
    var size;
    var now;

    while (index < length) {
        /*
         * Eat everything if theres no following newline.
         */

        if (index === -1) {
            index = length;
            break;
        }

        /*
         * Stop if the next character is NEWLINE.
         */

        if (value.charAt(index + 1) === C_NEWLINE) {
            break;
        }

        /*
         * In commonmark-mode, following indented lines
         * are part of the paragraph.
         */

        if (commonmark) {
            size = 0;
            position = index + 1;

            while (position < length) {
                character = value.charAt(position);

                if (character === C_TAB) {
                    size = TAB_SIZE;
                    break;
                } else if (character === C_SPACE) {
                    size++;
                } else {
                    break;
                }

                position++;
            }

            if (size >= TAB_SIZE) {
                index = value.indexOf(C_NEWLINE, index + 1);
                continue;
            }
        }

        /*
         * Check if the following code contains a possible
         * block.
         */

        subvalue = value.slice(index + 1);

        if (
            tokenizers.horizontalRule.call(self, eat, subvalue, true) ||
            tokenizers.heading.call(self, eat, subvalue, true) ||
            tokenizers.fences.call(self, eat, subvalue, true) ||
            tokenizers.blockquote.call(self, eat, subvalue, true) ||
            tokenizers.html.call(self, eat, subvalue, true)
        ) {
            break;
        }

        if (gfm && tokenizers.list.call(self, eat, subvalue, true)) {
            break;
        }

        if (
            !commonmark &&
            (
                tokenizers.lineHeading.call(self, eat, subvalue, true) ||
                tokenizers.definition.call(self, eat, subvalue, true) ||
                tokenizers.footnoteDefinition.call(self, eat, subvalue, true)
            )
        ) {
            break;
        }

        index = value.indexOf(C_NEWLINE, index + 1);
    }

    subvalue = value.slice(0, index);

    if (trim(subvalue) === EMPTY) {
        eat(subvalue);

        return null;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    now = eat.now();
    subvalue = trimTrailingLines(subvalue);

    return eat(subvalue)(self.renderInline(T_PARAGRAPH, subvalue, now));
}

/**
 * Tokenise a text node.
 *
 * @example
 *   tokenizeText(eat, 'foo');
 *
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `text` node.
 */
function tokenizeText(eat, value, silent) {
    var self = this;
    var methods;
    var tokenizers;
    var index;
    var length;
    var subvalue;
    var position;
    var tokenizer;
    var name;
    var min;
    var now;

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    methods = self.inlineMethods;
    length = methods.length;
    tokenizers = self.inlineTokenizers;
    index = -1;
    min = value.length;

    while (++index < length) {
        name = methods[index];

        if (name === 'inlineText' || !tokenizers[name]) {
            continue;
        }

        tokenizer = tokenizers[name].locator;

        if (!tokenizer) {
            eat.file.fail(ERR_MISSING_LOCATOR + C_TICK + name + C_TICK);
            continue;
        }

        position = tokenizer.call(self, value, 1);

        if (position !== -1 && position < min) {
            min = position;
        }
    }

    subvalue = value.slice(0, min);
    now = eat.now();

    self.decode(subvalue, now, function (content, position, source) {
        eat(source || content)(self.renderRaw(T_TEXT, content));
    });
}

/**
 * Create a code-block node.
 *
 * @example
 *   renderCodeBlock('foo()', 'js', now());
 *
 * @param {string?} [value] - Code.
 * @param {string?} [language] - Optional language flag.
 * @param {Function} eat - Eater.
 * @return {Object} - `code` node.
 */
function renderCodeBlock(value, language) {
    return {
        'type': T_CODE,
        'lang': language || null,
        'value': trimTrailingLines(value || EMPTY)
    };
}

/**
 * Create a list-item using overly simple mechanics.
 *
 * @example
 *   renderPedanticListItem('- _foo_', now());
 *
 * @param {string} value - List-item.
 * @param {Object} position - List-item location.
 * @return {string} - Cleaned `value`.
 */
function renderPedanticListItem(value, position) {
    var self = this;
    var indent = self.indent(position.line);

    /**
     * A simple replacer which removed all matches,
     * and adds their length to `offset`.
     *
     * @param {string} $0 - Indentation to subtract.
     * @return {string} - An empty string.
     */
    function replacer($0) {
        indent($0.length);

        return EMPTY;
    }

    /*
     * Remove the list-items bullet.
     */

    value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);

    /*
     * The initial line was also matched by the below, so
     * we reset the `line`.
     */

    indent = self.indent(position.line);

    return value.replace(EXPRESSION_INITIAL_INDENT, replacer);
}

/**
 * Create a list-item using sane mechanics.
 *
 * @example
 *   renderNormalListItem('- _foo_', now());
 *
 * @param {string} value - List-item.
 * @param {Object} position - List-item location.
 * @return {string} - Cleaned `value`.
 */
function renderNormalListItem(value, position) {
    var self = this;
    var indent = self.indent(position.line);
    var max;
    var bullet;
    var rest;
    var lines;
    var trimmedLines;
    var index;
    var length;

    /*
     * Remove the list-items bullet.
     */

    value = value.replace(EXPRESSION_BULLET, function ($0, $1, $2, $3, $4) {
        bullet = $1 + $2 + $3;
        rest = $4;

        /*
         * Make sure that the first nine numbered list items
         * can indent with an extra space.  That is, when
         * the bullet did not receive an extra final space.
         */

        if (Number($2) < 10 && bullet.length % 2 === 1) {
            $2 = C_SPACE + $2;
        }

        max = $1 + repeat(C_SPACE, $2.length) + $3;

        return max + rest;
    });

    lines = value.split(C_NEWLINE);

    trimmedLines = removeIndentation(
        value, getIndent(max).indent
    ).split(C_NEWLINE);

    /*
     * We replaced the initial bullet with something
     * else above, which was used to trick
     * `removeIndentation` into removing some more
     * characters when possible. However, that could
     * result in the initial line to be stripped more
     * than it should be.
     */

    trimmedLines[0] = rest;

    indent(bullet.length);

    index = 0;
    length = lines.length;

    while (++index < length) {
        indent(lines[index].length - trimmedLines[index].length);
    }

    return trimmedLines.join(C_NEWLINE);
}

/**
 * Create a list-item node.
 *
 * @example
 *   renderListItem('- _foo_', now());
 *
 * @param {Object} value - List-item.
 * @param {Object} position - List-item location.
 * @return {Object} - `listItem` node.
 */
function renderListItem(value, position) {
    var self = this;
    var checked = null;
    var node;
    var task;
    var indent;

    value = LIST_ITEM_MAP[self.options.pedantic].apply(self, arguments);

    if (self.options.gfm) {
        task = value.match(EXPRESSION_TASK_ITEM);

        if (task) {
            indent = task[0].length;
            checked = task[1].toLowerCase() === C_X_LOWER;

            self.indent(position.line)(indent);
            value = value.slice(indent);
        }
    }

    node = {
        'type': T_LIST_ITEM,
        'loose': EXPRESSION_LOOSE_LIST_ITEM.test(value) ||
            value.charAt(value.length - 1) === C_NEWLINE
    };

    if (self.options.gfm) {
        node.checked = checked;
    }

    node.children = self.tokenizeBlock(value, position);

    return node;
}

/**
 * Create a footnote-definition node.
 *
 * @example
 *   renderFootnoteDefinition('1', '_foo_', now());
 *
 * @param {string} identifier - Unique reference.
 * @param {string} value - Contents
 * @param {Object} position - Definition location.
 * @return {Object} - `footnoteDefinition` node.
 */
function renderFootnoteDefinition(identifier, value, position) {
    var self = this;
    var exitBlockquote = self.enterBlockquote();
    var node;

    node = {
        'type': T_FOOTNOTE_DEFINITION,
        'identifier': identifier,
        'children': self.tokenizeBlock(value, position)
    };

    exitBlockquote();

    return node;
}

/**
 * Create a heading node.
 *
 * @example
 *   renderHeading('_foo_', 1, now());
 *
 * @param {string} value - Content.
 * @param {number} depth - Heading depth.
 * @param {Object} position - Heading content location.
 * @return {Object} - `heading` node
 */
function renderHeading(value, depth, position) {
    return {
        'type': T_HEADING,
        'depth': depth,
        'children': this.tokenizeInline(value, position)
    };
}

/**
 * Create a blockquote node.
 *
 * @example
 *   renderBlockquote('_foo_', eat);
 *
 * @param {string} value - Content.
 * @param {Object} now - Position.
 * @return {Object} - `blockquote` node.
 */
function renderBlockquote(value, now) {
    var self = this;
    var exitBlockquote = self.enterBlockquote();
    var node = {
        'type': T_BLOCKQUOTE,
        'children': self.tokenizeBlock(value, now)
    };

    exitBlockquote();

    return node;
}

/**
 * Create a void node.
 *
 * @example
 *   renderVoid('horizontalRule');
 *
 * @param {string} type - Node type.
 * @return {Object} - Node of type `type`.
 */
function renderVoid(type) {
    return {
        'type': type
    };
}

/**
 * Create a parent.
 *
 * @example
 *   renderParent('paragraph', '_foo_');
 *
 * @param {string} type - Node type.
 * @param {Array.<Object>} children - Child nodes.
 * @return {Object} - Node of type `type`.
 */
function renderParent(type, children) {
    return {
        'type': type,
        'children': children
    };
}

/**
 * Create a raw node.
 *
 * @example
 *   renderRaw('inlineCode', 'foo()');
 *
 * @param {string} type - Node type.
 * @param {string} value - Contents.
 * @return {Object} - Node of type `type`.
 */
function renderRaw(type, value) {
    return {
        'type': type,
        'value': value
    };
}

/**
 * Create a link node.
 *
 * @example
 *   renderLink(true, 'example.com', 'example', 'Example Domain', now(), eat);
 *   renderLink(false, 'fav.ico', 'example', 'Example Domain', now(), eat);
 *
 * @param {boolean} isLink - Whether linking to a document
 *   or an image.
 * @param {string} href - URI reference.
 * @param {string} text - Content.
 * @param {string?} title - Title.
 * @param {Object} position - Location of link.
 * @return {Object} - `link` or `image` node.
 */
function renderLink(isLink, href, text, title, position) {
    var self = this;
    var exitLink = self.enterLink();
    var node;

    node = {
        'type': isLink ? T_LINK : T_IMAGE,
        'title': title || null
    };

    if (isLink) {
        node.href = href;
        node.children = self.tokenizeInline(text, position);
    } else {
        node.src = href;
        node.alt = text ?
            self.decode.raw(self.descape(text), position) :
            null;
    }

    exitLink();

    return node;
}

/**
 * Create a footnote node.
 *
 * @example
 *   renderFootnote('_foo_', now());
 *
 * @param {string} value - Contents.
 * @param {Object} position - Location of footnote.
 * @return {Object} - `footnote` node.
 */
function renderFootnote(value, position) {
    return this.renderInline(T_FOOTNOTE, value, position);
}

/**
 * Add a node with inline content.
 *
 * @example
 *   renderInline('strong', '_foo_', now());
 *
 * @param {string} type - Node type.
 * @param {string} value - Contents.
 * @param {Object} position - Location of node.
 * @return {Object} - Node of type `type`.
 */
function renderInline(type, value, position) {
    return this.renderParent(type, this.tokenizeInline(value, position));
}

/**
 * Add a node with block content.
 *
 * @example
 *   renderBlock('blockquote', 'Foo.', now());
 *
 * @param {string} type - Node type.
 * @param {string} value - Contents.
 * @param {Object} position - Location of node.
 * @return {Object} - Node of type `type`.
 */
function renderBlock(type, value, position) {
    return this.renderParent(type, this.tokenizeBlock(value, position));
}

/**
 * Find a possible escape sequence.
 *
 * @example
 *   locateEscape('foo \- bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible escape sequence.
 */
function locateEscape(value, fromIndex) {
    return value.indexOf(C_BACKSLASH, fromIndex);
}

/**
 * Tokenise an escape sequence.
 *
 * @example
 *   tokenizeEscape(eat, '\\a');
 *
 * @property {Function} locator - Escape locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `text` or `break` node.
 */
function tokenizeEscape(eat, value, silent) {
    var self = this;
    var character;

    if (value.charAt(0) === C_BACKSLASH) {
        character = value.charAt(1);

        if (self.escape.indexOf(character) !== -1) {
            /* istanbul ignore if - never used (yet) */
            if (silent) {
                return true;
            }

            return eat(C_BACKSLASH + character)(
                character === C_NEWLINE ?
                    self.renderVoid(T_BREAK) :
                    self.renderRaw(T_TEXT, character)
            );
        }
    }
}

tokenizeEscape.locator = locateEscape;

/**
 * Find a possible auto-link.
 *
 * @example
 *   locateAutoLink('foo <bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible auto-link.
 */
function locateAutoLink(value, fromIndex) {
    return value.indexOf(C_LT, fromIndex);
}

/**
 * Tokenise a URL in carets.
 *
 * @example
 *   tokenizeAutoLink(eat, '<http://foo.bar>');
 *
 * @property {boolean} notInLink
 * @property {Function} locator - Auto-link locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` node.
 */
function tokenizeAutoLink(eat, value, silent) {
    var self;
    var subvalue;
    var length;
    var index;
    var queue;
    var character;
    var hasAtCharacter;
    var link;
    var now;
    var content;
    var tokenize;
    var node;

    if (value.charAt(0) !== C_LT) {
        return;
    }

    self = this;
    subvalue = EMPTY;
    length = value.length;
    index = 0;
    queue = EMPTY;
    hasAtCharacter = false;
    link = EMPTY;

    index++;
    subvalue = C_LT;

    while (index < length) {
        character = value.charAt(index);

        if (
            character === C_SPACE ||
            character === C_GT ||
            character === C_AT_SIGN ||
            (character === C_COLON && value.charAt(index + 1) === C_SLASH)
        ) {
            break;
        }

        queue += character;
        index++;
    }

    if (!queue) {
        return;
    }

    link += queue;
    queue = EMPTY;

    character = value.charAt(index);
    link += character;
    index++;

    if (character === C_AT_SIGN) {
        hasAtCharacter = true;
    } else {
        if (
            character !== C_COLON ||
            value.charAt(index + 1) !== C_SLASH
        ) {
            return;
        }

        link += C_SLASH;
        index++;
    }

    while (index < length) {
        character = value.charAt(index);

        if (character === C_SPACE || character === C_GT) {
            break;
        }

        queue += character;
        index++;
    }

    character = value.charAt(index);

    if (!queue || character !== C_GT) {
        return;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    link += queue;
    content = link;
    subvalue += link + character;
    now = eat.now();
    now.column++;

    if (hasAtCharacter) {
        if (
            link.substr(0, MAILTO_PROTOCOL.length).toLowerCase() !==
            MAILTO_PROTOCOL
        ) {
            link = MAILTO_PROTOCOL + link;
        } else {
            content = content.substr(MAILTO_PROTOCOL.length);
            now.column += MAILTO_PROTOCOL.length;
        }
    }

    /*
     * Temporarily remove support for escapes in autolinks.
     */

    tokenize = self.inlineTokenizers.escape;
    self.inlineTokenizers.escape = null;

    node = eat(subvalue)(
        self.renderLink(true, decode(link), content, null, now, eat)
    );

    self.inlineTokenizers.escape = tokenize;

    return node;
}

tokenizeAutoLink.notInLink = true;
tokenizeAutoLink.locator = locateAutoLink;

/**
 * Find a possible URL.
 *
 * @example
 *   locateURL('foo http://bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible URL.
 */
function locateURL(value, fromIndex) {
    var index = -1;
    var min = -1;
    var position;

    if (!this.options.gfm) {
        return -1;
    }

    while (++index < PROTOCOLS_LENGTH) {
        position = value.indexOf(PROTOCOLS[index], fromIndex);

        if (position !== -1 && (position < min || min === -1)) {
            min = position;
        }
    }

    return min;
}

/**
 * Tokenise a URL in text.
 *
 * @example
 *   tokenizeURL(eat, 'http://foo.bar');
 *
 * @property {boolean} notInLink
 * @property {Function} locator - URL locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` node.
 */
function tokenizeURL(eat, value, silent) {
    var self = this;
    var subvalue;
    var content;
    var character;
    var index;
    var position;
    var protocol;
    var match;
    var length;
    var queue;
    var parenCount;
    var nextCharacter;
    var now;

    if (!self.options.gfm) {
        return;
    }

    subvalue = EMPTY;
    index = -1;
    length = PROTOCOLS_LENGTH;

    while (++index < length) {
        protocol = PROTOCOLS[index];
        match = value.slice(0, protocol.length);

        if (match.toLowerCase() === protocol) {
            subvalue = match;
            break;
        }
    }

    if (!subvalue) {
        return;
    }

    index = subvalue.length;
    length = value.length;
    queue = EMPTY;
    parenCount = 0;

    while (index < length) {
        character = value.charAt(index);

        if (isWhiteSpace(character) || character === C_LT) {
            break;
        }

        if (
            character === C_DOT ||
            character === C_COMMA ||
            character === C_COLON ||
            character === C_SEMI_COLON ||
            character === C_DOUBLE_QUOTE ||
            character === C_SINGLE_QUOTE ||
            character === C_PAREN_CLOSE ||
            character === C_BRACKET_CLOSE
        ) {
            nextCharacter = value.charAt(index + 1);

            if (
                !nextCharacter ||
                isWhiteSpace(nextCharacter)
            ) {
                break;
            }
        }

        if (
            character === C_PAREN_OPEN ||
            character === C_BRACKET_OPEN
        ) {
            parenCount++;
        }

        if (
            character === C_PAREN_CLOSE ||
            character === C_BRACKET_CLOSE
        ) {
            parenCount--;

            if (parenCount < 0) {
                break;
            }
        }

        queue += character;
        index++;
    }

    if (!queue) {
        return;
    }

    subvalue += queue;
    content = subvalue;

    if (protocol === MAILTO_PROTOCOL) {
        position = queue.indexOf(C_AT_SIGN);

        if (position === -1 || position === length - 1) {
            return;
        }

        content = content.substr(MAILTO_PROTOCOL.length);
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    now = eat.now();

    return eat(subvalue)(
        self.renderLink(true, decode(subvalue), content, null, now, eat)
    );
}

tokenizeURL.notInLink = true;
tokenizeURL.locator = locateURL;

/**
 * Find a possible tag.
 *
 * @example
 *   locateTag('foo <bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible tag.
 */
function locateTag(value, fromIndex) {
    return value.indexOf(C_LT, fromIndex);
}

/**
 * Tokenise an HTML tag.
 *
 * @example
 *   tokenizeTag(eat, '<span foo="bar">');
 *
 * @property {Function} locator - Tag locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `html` node.
 */
function tokenizeTag(eat, value, silent) {
    var self = this;
    var subvalue = eatHTMLComment(value, self.options) ||
        eatHTMLCDATA(value) ||
        eatHTMLProcessingInstruction(value) ||
        eatHTMLDeclaration(value) ||
        eatHTMLClosingTag(value) ||
        eatHTMLOpeningTag(value);

    if (!subvalue) {
        return;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {
        self.inLink = true;
    } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {
        self.inLink = false;
    }

    return eat(subvalue)(self.renderRaw(T_HTML, subvalue));
}

tokenizeTag.locator = locateTag;

/**
 * Find a possible link.
 *
 * @example
 *   locateLink('foo ![bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible link.
 */
function locateLink(value, fromIndex) {
    var link = value.indexOf(C_BRACKET_OPEN, fromIndex);
    var image = value.indexOf(C_EXCLAMATION_MARK + C_BRACKET_OPEN, fromIndex);

    if (image === -1) {
        return link;
    }

    /*
     * Link can never be `-1` if an image is found, so we dont need to
     * check for that :)
     */

    return link < image ? link : image;
}

/**
 * Tokenise a link.
 *
 * @example
 *   tokenizeLink(eat, '![foo](fav.ico "Favicon"));
 *
 * @property {Function} locator - Link locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` or `image` node.
 */
function tokenizeLink(eat, value, silent) {
    var self = this;
    var subvalue = EMPTY;
    var index = 0;
    var character = value.charAt(0);
    var beforeURL;
    var beforeTitle;
    var whiteSpaceQueue;
    var commonmark;
    var openCount;
    var hasMarker;
    var markers;
    var isImage;
    var content;
    var marker;
    var length;
    var title;
    var depth;
    var queue;
    var url;
    var now;

    /*
     * Detect whether this is an image.
     */

    if (character === C_EXCLAMATION_MARK) {
        isImage = true;
        subvalue = character;
        character = value.charAt(++index);
    }

    /*
     * Eat the opening.
     */

    if (character !== C_BRACKET_OPEN) {
        return;
    }

    /*
     * Exit when this is a link and were already inside
     * a link.
     */

    if (!isImage && self.inLink) {
        return;
    }

    subvalue += character;
    queue = EMPTY;
    index++;

    /*
     * Eat the content.
     */

    commonmark = self.options.commonmark;
    length = value.length;
    now = eat.now();
    depth = 0;

    now.column += index;

    while (index < length) {
        character = value.charAt(index);

        if (character === C_BRACKET_OPEN) {
            depth++;
        } else if (character === C_BRACKET_CLOSE) {
            /*
             * Allow a single closing bracket when not in
             * commonmark-mode.
             */

            if (!commonmark && !depth) {
                if (value.charAt(index + 1) === C_PAREN_OPEN) {
                    break;
                }

                depth++;
            }

            if (depth === 0) {
                break;
            }

            depth--;
        }

        queue += character;
        index++;
    }

    /*
     * Eat the content closing.
     */

    if (
        value.charAt(index) !== C_BRACKET_CLOSE ||
        value.charAt(++index) !== C_PAREN_OPEN
    ) {
        return;
    }

    subvalue += queue + C_BRACKET_CLOSE + C_PAREN_OPEN;
    index++;
    content = queue;

    /*
     * Eat white-space.
     */

    while (index < length) {
        character = value.charAt(index);

        if (!isWhiteSpace(character)) {
            break;
        }

        subvalue += character;
        index++;
    }

    /*
     * Eat the URL.
     */

    character = value.charAt(index);
    markers = commonmark ? COMMONMARK_LINK_TITLE_MARKERS : LINK_TITLE_MARKERS;
    openCount = 0;
    queue = EMPTY;
    beforeURL = subvalue;

    if (character === C_LT) {
        index++;
        beforeURL += C_LT;

        while (index < length) {
            character = value.charAt(index);

            if (character === C_GT) {
                break;
            }

            if (commonmark && character === C_NEWLINE) {
                return;
            }

            queue += character;
            index++;
        }

        if (value.charAt(index) !== C_GT) {
            return;
        }

        subvalue += C_LT + queue + C_GT;
        url = queue;
        index++;
    } else {
        character = null;
        whiteSpaceQueue = EMPTY;

        while (index < length) {
            character = value.charAt(index);

            if (whiteSpaceQueue && has.call(markers, character)) {
                break;
            }

            if (isWhiteSpace(character)) {
                if (commonmark) {
                    break;
                }

                whiteSpaceQueue += character;
            } else {
                if (character === C_PAREN_OPEN) {
                    depth++;
                    openCount++;
                } else if (character === C_PAREN_CLOSE) {
                    if (depth === 0) {
                        break;
                    }

                    depth--;
                }

                queue += whiteSpaceQueue;
                whiteSpaceQueue = EMPTY;

                if (character === C_BACKSLASH) {
                    queue += C_BACKSLASH;
                    character = value.charAt(++index);
                }

                queue += character;
            }

            index++;
        }

        queue = queue;
        subvalue += queue;
        url = queue;
        index = subvalue.length;
    }

    /*
     * Eat white-space.
     */

    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (!isWhiteSpace(character)) {
            break;
        }

        queue += character;
        index++;
    }

    character = value.charAt(index);
    subvalue += queue;

    /*
     * Eat the title.
     */

    if (queue && has.call(markers, character)) {
        index++;
        subvalue += character;
        queue = EMPTY;
        marker = markers[character];
        beforeTitle = subvalue;

        /*
         * In commonmark-mode, things are pretty easy: the
         * marker cannot occur inside the title.
         *
         * Non-commonmark does, however, support nested
         * delimiters.
         */

        if (commonmark) {
            while (index < length) {
                character = value.charAt(index);

                if (character === marker) {
                    break;
                }

                if (character === C_BACKSLASH) {
                    queue += C_BACKSLASH;
                    character = value.charAt(++index);
                }

                index++;
                queue += character;
            }

            character = value.charAt(index);

            if (character !== marker) {
                return;
            }

            title = queue;
            subvalue += queue + character;
            index++;

            while (index < length) {
                character = value.charAt(index);

                if (!isWhiteSpace(character)) {
                    break;
                }

                subvalue += character;
                index++;
            }
        } else {
            whiteSpaceQueue = EMPTY;

            while (index < length) {
                character = value.charAt(index);

                if (character === marker) {
                    if (hasMarker) {
                        queue += marker + whiteSpaceQueue;
                        whiteSpaceQueue = EMPTY;
                    }

                    hasMarker = true;
                } else if (!hasMarker) {
                    queue += character;
                } else if (character === C_PAREN_CLOSE) {
                    subvalue += queue + marker + whiteSpaceQueue;
                    title = queue;
                    break;
                } else if (isWhiteSpace(character)) {
                    whiteSpaceQueue += character;
                } else {
                    queue += marker + whiteSpaceQueue + character;
                    whiteSpaceQueue = EMPTY;
                    hasMarker = false;
                }

                index++;
            }
        }
    }

    if (value.charAt(index) !== C_PAREN_CLOSE) {
        return;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    subvalue += C_PAREN_CLOSE;

    url = self.decode.raw(self.descape(url), eat(beforeURL).test().end);

    if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self.decode.raw(self.descape(title), beforeTitle);
    }

    return eat(subvalue)(
        self.renderLink(!isImage, url, content, title, now, eat)
    );
}

tokenizeLink.locator = locateLink;

/**
 * Tokenise a reference link, image, or footnote;
 * shortcut reference link, or footnote.
 *
 * @example
 *   tokenizeReference(eat, '[foo]');
 *   tokenizeReference(eat, '[foo][]');
 *   tokenizeReference(eat, '[foo][bar]');
 *
 * @property {Function} locator - Reference locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - Reference node.
 */
function tokenizeReference(eat, value, silent) {
    var self = this;
    var character = value.charAt(0);
    var index = 0;
    var length = value.length;
    var subvalue = EMPTY;
    var intro = EMPTY;
    var type = T_LINK;
    var referenceType = REFERENCE_TYPE_SHORTCUT;
    var text;
    var identifier;
    var now;
    var node;
    var exitLink;
    var queue;
    var bracketed;
    var depth;

    /*
     * Check whether were eating an image.
     */

    if (character === C_EXCLAMATION_MARK) {
        type = T_IMAGE;
        intro = character;
        character = value.charAt(++index);
    }

    if (character !== C_BRACKET_OPEN) {
        return;
    }

    index++;
    intro += character;
    queue = EMPTY;

    /*
     * Check whether were eating a footnote.
     */

    if (
        self.options.footnotes &&
        type === T_LINK &&
        value.charAt(index) === C_CARET
    ) {
        intro += C_CARET;
        index++;
        type = T_FOOTNOTE;
    }

    /*
     * Eat the text.
     */

    depth = 0;

    while (index < length) {
        character = value.charAt(index);

        if (character === C_BRACKET_OPEN) {
            bracketed = true;
            depth++;
        } else if (character === C_BRACKET_CLOSE) {
            if (!depth) {
                break;
            }

            depth--;
        }

        if (character === C_BACKSLASH) {
            queue += C_BACKSLASH;
            character = value.charAt(++index);
        }

        queue += character;
        index++;
    }

    subvalue = text = queue;
    character = value.charAt(index);

    if (character !== C_BRACKET_CLOSE) {
        return;
    }

    index++;
    subvalue += character;
    queue = EMPTY;

    while (index < length) {
        character = value.charAt(index);

        if (!isWhiteSpace(character)) {
            break;
        }

        queue += character;
        index++;
    }

    character = value.charAt(index);

    if (character !== C_BRACKET_OPEN) {
        if (!text) {
            return;
        }

        identifier = text;
    } else {
        identifier = EMPTY;
        queue += character;
        index++;

        while (index < length) {
            character = value.charAt(index);

            if (
                character === C_BRACKET_OPEN ||
                character === C_BRACKET_CLOSE
            ) {
                break;
            }

            if (character === C_BACKSLASH) {
                identifier += C_BACKSLASH;
                character = value.charAt(++index);
            }

            identifier += character;
            index++;
        }

        character = value.charAt(index);

        if (character === C_BRACKET_CLOSE) {
            queue += identifier + character;
            index++;

            referenceType = identifier ?
                REFERENCE_TYPE_FULL :
                REFERENCE_TYPE_COLLAPSED;
        } else {
            identifier = EMPTY;
        }

        subvalue += queue;
        queue = EMPTY;
    }

    /*
     * Brackets cannot be inside the identifier.
     */

    if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {
        return;
    }

    /*
     * Inline footnotes cannot have an identifier.
     */

    if (type === T_FOOTNOTE && referenceType !== REFERENCE_TYPE_SHORTCUT) {
        type = T_LINK;
        intro = C_BRACKET_OPEN + C_CARET;
        text = C_CARET + text;
    }

    subvalue = intro + subvalue;

    if (type === T_LINK && self.inLink) {
        return null;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    if (type === T_FOOTNOTE && text.indexOf(C_SPACE) !== -1) {
        return eat(subvalue)(self.renderFootnote(text, eat.now()));
    }

    now = eat.now();
    now.column += intro.length;
    identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : text;

    node = {
        'type': type + 'Reference',
        'identifier': normalize(identifier)
    };

    if (type === T_LINK || type === T_IMAGE) {
        node.referenceType = referenceType;
    }

    if (type === T_LINK) {
        exitLink = self.enterLink();
        node.children = self.tokenizeInline(text, now);
        exitLink();
    } else if (type === T_IMAGE) {
        node.alt = self.decode.raw(self.descape(text), now) || null;
    }

    return eat(subvalue)(node);
}

tokenizeReference.locator = locateLink;

/**
 * Find a possible strong emphasis.
 *
 * @example
 *   locateStrong('foo **bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible strong emphasis.
 */
function locateStrong(value, fromIndex) {
    var asterisk = value.indexOf(C_ASTERISK + C_ASTERISK, fromIndex);
    var underscore = value.indexOf(C_UNDERSCORE + C_UNDERSCORE, fromIndex);

    if (underscore === -1) {
        return asterisk;
    }

    if (asterisk === -1) {
        return underscore;
    }

    return underscore < asterisk ? underscore : asterisk;
}

/**
 * Tokenise strong emphasis.
 *
 * @example
 *   tokenizeStrong(eat, '**foo**');
 *   tokenizeStrong(eat, '__foo__');
 *
 * @property {Function} locator - Strong emphasis locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `strong` node.
 */
function tokenizeStrong(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var prev;

    if (
        EMPHASIS_MARKERS[character] !== true ||
        value.charAt(++index) !== character
    ) {
        return;
    }

    pedantic = self.options.pedantic;
    marker = character;
    subvalue = marker + marker;
    length = value.length;
    index++;
    queue = character = EMPTY;

    if (pedantic && isWhiteSpace(value.charAt(index))) {
        return;
    }

    while (index < length) {
        prev = character;
        character = value.charAt(index);

        if (
            character === marker &&
            value.charAt(index + 1) === marker &&
            (!pedantic || !isWhiteSpace(prev))
        ) {
            character = value.charAt(index + 2);

            if (character !== marker) {
                if (!trim(queue)) {
                    return;
                }

                /* istanbul ignore if - never used (yet) */
                if (silent) {
                    return true;
                }

                now = eat.now();
                now.column += 2;

                return eat(subvalue + queue + subvalue)(
                    self.renderInline(T_STRONG, queue, now)
                );
            }
        }

        if (!pedantic && character === C_BACKSLASH) {
            queue += character;
            character = value.charAt(++index);
        }

        queue += character;
        index++;
    }
}

tokenizeStrong.locator = locateStrong;

/**
 * Find possible slight emphasis.
 *
 * @example
 *   locateEmphasis('foo *bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible slight emphasis.
 */
function locateEmphasis(value, fromIndex) {
    var asterisk = value.indexOf(C_ASTERISK, fromIndex);
    var underscore = value.indexOf(C_UNDERSCORE, fromIndex);

    if (underscore === -1) {
        return asterisk;
    }

    if (asterisk === -1) {
        return underscore;
    }

    return underscore < asterisk ? underscore : asterisk;
}

/**
 * Tokenise slight emphasis.
 *
 * @example
 *   tokenizeEmphasis(eat, '*foo*');
 *   tokenizeEmphasis(eat, '_foo_');
 *
 * @property {Function} locator - Slight emphasis locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `emphasis` node.
 */
function tokenizeEmphasis(eat, value, silent) {
    var self = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var prev;

    if (EMPHASIS_MARKERS[character] !== true) {
        return;
    }

    pedantic = self.options.pedantic;
    subvalue = marker = character;
    length = value.length;
    index++;
    queue = character = EMPTY;

    if (pedantic && isWhiteSpace(value.charAt(index))) {
        return;
    }

    while (index < length) {
        prev = character;
        character = value.charAt(index);

        if (
            character === marker &&
            (!pedantic || !isWhiteSpace(prev))
        ) {
            character = value.charAt(++index);

            if (character !== marker) {
                if (!trim(queue) || prev === marker) {
                    return;
                }

                if (
                    pedantic ||
                    marker !== C_UNDERSCORE ||
                    !isWordCharacter(character)
                ) {
                    /* istanbul ignore if - never used (yet) */
                    if (silent) {
                        return true;
                    }

                    now = eat.now();
                    now.column++;

                    return eat(subvalue + queue + marker)(
                        self.renderInline(T_EMPHASIS, queue, now)
                    );
                }
            }

            queue += marker;
        }

        if (!pedantic && character === C_BACKSLASH) {
            queue += character;
            character = value.charAt(++index);
        }

        queue += character;
        index++;
    }
}

tokenizeEmphasis.locator = locateEmphasis;

/**
 * Find a possible deletion.
 *
 * @example
 *   locateDeletion('foo ~~bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible deletion.
 */
function locateDeletion(value, fromIndex) {
    return value.indexOf(C_TILDE + C_TILDE, fromIndex);
}

/**
 * Tokenise a deletion.
 *
 * @example
 *   tokenizeDeletion(eat, '~~foo~~');
 *
 * @property {Function} locator - Deletion locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `delete` node.
 */
function tokenizeDeletion(eat, value, silent) {
    var self = this;
    var character = EMPTY;
    var previous = EMPTY;
    var preceding = EMPTY;
    var subvalue = EMPTY;
    var index;
    var length;
    var now;

    if (
        !self.options.gfm ||
        value.charAt(0) !== C_TILDE ||
        value.charAt(1) !== C_TILDE ||
        isWhiteSpace(value.charAt(2))
    ) {
        return;
    }

    index = 1;
    length = value.length;
    now = eat.now();
    now.column += 2;

    while (++index < length) {
        character = value.charAt(index);

        if (
            character === C_TILDE &&
            previous === C_TILDE &&
            (!preceding || !isWhiteSpace(preceding))
        ) {
            /* istanbul ignore if - never used (yet) */
            if (silent) {
                return true;
            }

            return eat(C_TILDE + C_TILDE + subvalue + C_TILDE + C_TILDE)(
                self.renderInline(T_DELETE, subvalue, now)
            );
        }

        subvalue += previous;
        preceding = previous;
        previous = character;
    }
}

tokenizeDeletion.locator = locateDeletion;

/**
 * Find possible inline code.
 *
 * @example
 *   locateInlineCode('foo `bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible inline code.
 */
function locateInlineCode(value, fromIndex) {
    return value.indexOf(C_TICK, fromIndex);
}

/**
 * Tokenise inline code.
 *
 * @example
 *   tokenizeInlineCode(eat, '`foo()`');
 *
 * @property {Function} locator - Inline code locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `inlineCode` node.
 */
function tokenizeInlineCode(eat, value, silent) {
    var self = this;
    var length = value.length;
    var index = 0;
    var queue = EMPTY;
    var tickQueue = EMPTY;
    var contentQueue;
    var whiteSpaceQueue;
    var count;
    var openingCount;
    var subvalue;
    var character;
    var found;
    var next;

    while (index < length) {
        if (value.charAt(index) !== C_TICK) {
            break;
        }

        queue += C_TICK;
        index++;
    }

    if (!queue) {
        return;
    }

    subvalue = queue;
    openingCount = index;
    queue = EMPTY;
    next = value.charAt(index);
    count = 0;

    while (index < length) {
        character = next;
        next = value.charAt(index + 1);

        if (character === C_TICK) {
            count++;
            tickQueue += character;
        } else {
            count = 0;
            queue += character;
        }

        if (count && next !== C_TICK) {
            if (count === openingCount) {
                subvalue += queue + tickQueue;
                found = true;
                break;
            }

            queue += tickQueue;
            tickQueue = EMPTY;
        }

        index++;
    }

    if (!found) {
        if (openingCount % 2 !== 0) {
            return;
        }

        queue = EMPTY;
    }

    /* istanbul ignore if - never used (yet) */
    if (silent) {
        return true;
    }

    contentQueue = whiteSpaceQueue = EMPTY;
    length = queue.length;
    index = -1;

    while (++index < length) {
        character = queue.charAt(index);

        if (isWhiteSpace(character)) {
            whiteSpaceQueue += character;
            continue;
        }

        if (whiteSpaceQueue) {
            if (contentQueue) {
                contentQueue += whiteSpaceQueue;
            }

            whiteSpaceQueue = EMPTY;
        }

        contentQueue += character;
    }

    return eat(subvalue)(self.renderRaw(T_INLINE_CODE, contentQueue));
}

tokenizeInlineCode.locator = locateInlineCode;

/**
 * Find a possible break.
 *
 * @example
 *   locateBreak('foo   \nbar'); // 3
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible break.
 */
function locateBreak(value, fromIndex) {
    var index = value.indexOf(C_NEWLINE, fromIndex);

    while (index > fromIndex) {
        if (value.charAt(index - 1) !== C_SPACE) {
            break;
        }

        index--;
    }

    return index;
}

/**
 * Tokenise a break.
 *
 * @example
 *   tokenizeBreak(eat, '  \n');
 *
 * @property {Function} locator - Break locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `break` node.
 */
function tokenizeBreak(eat, value, silent) {
    var self = this;
    var breaks = self.options.breaks;
    var length = value.length;
    var index = -1;
    var queue = EMPTY;
    var character;

    while (++index < length) {
        character = value.charAt(index);

        if (character === C_NEWLINE) {
            if (!breaks && index < MIN_BREAK_LENGTH) {
                return;
            }

            /* istanbul ignore if - never used (yet) */
            if (silent) {
                return true;
            }

            queue += character;
            return eat(queue)(self.renderVoid(T_BREAK));
        }

        if (character !== C_SPACE) {
            return;
        }

        queue += character;
    }
}

tokenizeBreak.locator = locateBreak;

/**
 * Construct a new parser.
 *
 * @example
 *   var parser = new Parser(new VFile('Foo'));
 *
 * @constructor
 * @class {Parser}
 * @param {VFile} file - File to parse.
 * @param {Object?} [options] - Passed to
 *   `Parser#setOptions()`.
 */
function Parser(file, options, processor) {
    var self = this;

    self.file = file;
    self.inLink = false;
    self.atTop = true;
    self.atStart = true;
    self.inBlockquote = false;
    self.data = processor.data;

    self.descape = descapeFactory(self, 'escape');
    self.decode = decodeFactory(self);

    self.options = extend({}, self.options);

    self.setOptions(options);
}

/**
 * Set options.  Does not overwrite previously set
 * options.
 *
 * @example
 *   var parser = new Parser();
 *   parser.setOptions({gfm: true});
 *
 * @this {Parser}
 * @throws {Error} - When an option is invalid.
 * @param {Object?} [options] - Parse settings.
 * @return {Parser} - `self`.
 */
Parser.prototype.setOptions = function (options) {
    var self = this;
    var escape = self.data.escape;
    var current = self.options;
    var key;

    if (options === null || options === undefined) {
        options = {};
    } else if (typeof options === 'object') {
        options = extend({}, options);
    } else {
        raise(options, 'options');
    }

    for (key in defaultOptions) {
        validate.boolean(options, key, current[key]);
    }

    self.options = options;

    if (options.commonmark) {
        self.escape = escape.commonmark;
    } else if (options.gfm) {
        self.escape = escape.gfm;
    } else {
        self.escape = escape.default;
    }

    return self;
};

/*
 * Expose `defaults`.
 */

Parser.prototype.options = defaultOptions;

/**
 * Factory to track indentation for each line corresponding
 * to the given `start` and the number of invocations.
 *
 * @param {number} start - Starting line.
 * @return {function(offset)} - Indenter.
 */
Parser.prototype.indent = function (start) {
    var self = this;
    var line = start;

    /**
     * Intender which increments the global offset,
     * starting at the bound line, and further incrementing
     * each line for each invocation.
     *
     * @example
     *   indenter(2);
     *
     * @param {number} offset - Number to increment the
     *   offset.
     */
    function indenter(offset) {
        self.offset[line] = (self.offset[line] || 0) + offset;

        line++;
    }

    return indenter;
};

/**
 * Get found offsets starting at `start`.
 *
 * @param {number} start - Starting line.
 * @return {Array.<number>} - Offsets starting at `start`.
 */
Parser.prototype.getIndent = function (start) {
    var offset = this.offset;
    var result = [];

    while (++start) {
        if (!(start in offset)) {
            break;
        }

        result.push((offset[start] || 0) + 1);
    }

    return result;
};

/**
 * Parse the bound file.
 *
 * @example
 *   new Parser(new File('_Foo_.')).parse();
 *
 * @this {Parser}
 * @return {Object} - `root` node.
 */
Parser.prototype.parse = function () {
    var self = this;
    var value = clean(String(self.file));
    var node;

    /*
     * Add an `offset` matrix, used to keep track of
     * syntax and white space indentation per line.
     */

    self.offset = {};

    node = self.renderBlock(T_ROOT, value);

    if (self.options.position) {
        node.position = {
            'start': {
                'line': 1,
                'column': 1
            }
        };

        node.position.end = self.eof || node.position.start;
    }

    return node;
};

/*
 * Enter and exit helpers.
 */

Parser.prototype.enterLink = stateToggler('inLink', false);
Parser.prototype.exitTop = stateToggler('atTop', true);
Parser.prototype.exitStart = stateToggler('atStart', true);
Parser.prototype.enterBlockquote = stateToggler('inBlockquote', false);

/*
 * Expose helpers
 */

Parser.prototype.renderRaw = renderRaw;
Parser.prototype.renderVoid = renderVoid;
Parser.prototype.renderParent = renderParent;
Parser.prototype.renderInline = renderInline;
Parser.prototype.renderBlock = renderBlock;

Parser.prototype.renderLink = renderLink;
Parser.prototype.renderCodeBlock = renderCodeBlock;
Parser.prototype.renderBlockquote = renderBlockquote;
Parser.prototype.renderListItem = renderListItem;
Parser.prototype.renderFootnoteDefinition = renderFootnoteDefinition;
Parser.prototype.renderHeading = renderHeading;
Parser.prototype.renderFootnote = renderFootnote;

/**
 * Construct a tokenizer.  This creates both
 * `tokenizeInline` and `tokenizeBlock`.
 *
 * @example
 *   Parser.prototype.tokenizeInline = tokenizeFactory('inline');
 *
 * @param {string} type - Name of parser, used to find
 *   its expressions (`%sMethods`) and tokenizers
 *   (`%Tokenizers`).
 * @return {Function} - Tokenizer.
 */
function tokenizeFactory(type) {
    /**
     * Tokenizer for a bound `type`
     *
     * @example
     *   parser = new Parser();
     *   parser.tokenizeInline('_foo_');
     *
     * @param {string} value - Content.
     * @param {Object?} [location] - Offset at which `value`
     *   starts.
     * @return {Array.<Object>} - Nodes.
     */
    function tokenize(value, location) {
        var self = this;
        var offset = self.offset;
        var tokens = [];
        var methods = self[type + 'Methods'];
        var tokenizers = self[type + 'Tokenizers'];
        var line = location ? location.line : 1;
        var column = location ? location.column : 1;
        var patchPosition = self.options.position;
        var add;
        var index;
        var length;
        var method;
        var name;
        var matched;
        var valueLength;
        var eater;

        /*
         * Trim white space only lines.
         */

        if (!value) {
            return tokens;
        }

        /**
         * Update line and column based on `value`.
         *
         * @example
         *   updatePosition('foo');
         *
         * @param {string} subvalue - Subvalue to eat.
         */
        function updatePosition(subvalue) {
            var lastIndex = -1;
            var index = subvalue.indexOf(C_NEWLINE);

            while (index !== -1) {
                line++;
                lastIndex = index;
                index = subvalue.indexOf(C_NEWLINE, index + 1);
            }

            if (lastIndex === -1) {
                column = column + subvalue.length;
            } else {
                column = subvalue.length - lastIndex;
            }

            if (line in offset) {
                if (lastIndex !== -1) {
                    column += offset[line];
                } else if (column <= offset[line]) {
                    column = offset[line] + 1;
                }
            }
        }

        /**
         * Get offset. Called before the first character is
         * eaten to retrieve the range's offsets.
         *
         * @return {Function} - `done`, to be called when
         *   the last character is eaten.
         */
        function getOffset() {
            var indentation = [];
            var pos = line + 1;

            /**
             * Done. Called when the last character is
             * eaten to retrieve the ranges offsets.
             *
             * @return {Array.<number>} - Offset.
             */
            function done() {
                var last = line + 1;

                while (pos < last) {
                    indentation.push((offset[pos] || 0) + 1);

                    pos++;
                }

                return indentation;
            }

            return done;
        }

        /**
         * Get the current position.
         *
         * @example
         *   position = now(); // {line: 1, column: 1}
         *
         * @return {Object} - Current Position.
         */
        function now() {
            return {
                'line': line,
                'column': column
            };
        }

        /**
         * Store position information for a node.
         *
         * @example
         *   start = now();
         *   updatePosition('foo');
         *   location = new Position(start);
         *   // {start: {line: 1, column: 1}, end: {line: 1, column: 3}}
         *
         * @param {Object} start - Starting position.
         */
        function Position(start) {
            this.start = start;
            this.end = now();
        }

        /**
         * Throw when a value is incorrectly eaten.
         * This shouldnt happen but will throw on new,
         * incorrect rules.
         *
         * @example
         *   // When the current value is set to `foo bar`.
         *   validateEat('foo');
         *   eat('foo');
         *
         *   validateEat('bar');
         *   // throws, because the space is not eaten.
         *
         * @param {string} subvalue - Value to be eaten.
         * @throws {Error} - When `subvalue` cannot be eaten.
         */
        function validateEat(subvalue) {
            /* istanbul ignore if */
            if (value.substring(0, subvalue.length) !== subvalue) {
                self.file.fail(ERR_INCORRECTLY_EATEN, now());
            }
        }

        /**
         * Mark position and patch `node.position`.
         *
         * @example
         *   var update = position();
         *   updatePosition('foo');
         *   update({});
         *   // {
         *   //   position: {
         *   //     start: {line: 1, column: 1}
         *   //     end: {line: 1, column: 3}
         *   //   }
         *   // }
         *
         * @returns {Function} - Updater.
         */
        function position() {
            var before = now();

            /**
             * Add the position to a node.
             *
             * @example
             *   update({type: 'text', value: 'foo'});
             *
             * @param {Node} node - Node to attach position
             *   on.
             * @param {Array} [indent] - Indentation for
             *   `node`.
             * @return {Node} - `node`.
             */
            function update(node, indent) {
                var prev = node.position;
                var start = prev ? prev.start : before;
                var combined = [];
                var n = prev && prev.end.line;
                var l = before.line;

                node.position = new Position(start);

                /*
                 * If there was already a `position`, this
                 * node was merged.  Fixing `start` wasnt
                 * hard, but the indent is different.
                 * Especially because some information, the
                 * indent between `n` and `l` wasnt
                 * tracked.  Luckily, that space is
                 * (should be?) empty, so we can safely
                 * check for it now.
                 */

                if (prev && indent && prev.indent) {
                    combined = prev.indent;

                    if (n < l) {
                        while (++n < l) {
                            combined.push((offset[n] || 0) + 1);
                        }

                        combined.push(before.column);
                    }

                    indent = combined.concat(indent);
                }

                node.position.indent = indent || [];

                return node;
            }

            return update;
        }

        /**
         * Add `node` to `parent`s children or to `tokens`.
         * Performs merges where possible.
         *
         * @example
         *   add({});
         *
         *   add({}, {children: []});
         *
         * @param {Object} node - Node to add.
         * @param {Object} [parent] - Parent to insert into.
         * @return {Object} - Added or merged into node.
         */
        add = function (node, parent) {
            var prev;
            var children;

            if (!parent) {
                children = tokens;
            } else {
                children = parent.children;
            }

            prev = children[children.length - 1];

            if (
                prev &&
                node.type === prev.type &&
                node.type in MERGEABLE_NODES &&
                mergeable(prev) &&
                mergeable(node)
            ) {
                node = MERGEABLE_NODES[node.type].call(
                    self, prev, node
                );
            }

            if (node !== prev) {
                children.push(node);
            }

            if (self.atStart && tokens.length) {
                self.exitStart();
            }

            return node;
        };

        /**
         * Remove `subvalue` from `value`.
         * Expects `subvalue` to be at the start from
         * `value`, and applies no validation.
         *
         * @example
         *   eat('foo')({type: 'text', value: 'foo'});
         *
         * @param {string} subvalue - Removed from `value`,
         *   and passed to `updatePosition`.
         * @return {Function} - Wrapper around `add`, which
         *   also adds `position` to node.
         */
        function eat(subvalue) {
            var indent = getOffset();
            var pos = position();
            var current = now();

            validateEat(subvalue);

            /**
             * Add the given arguments, add `position` to
             * the returned node, and return the node.
             *
             * @param {Object} node - Node to add.
             * @param {Object} [parent] - Node to insert into.
             * @return {Node} - Added node.
             */
            function apply(node, parent) {
                return pos(add(pos(node), parent), indent);
            }

            /**
             * Functions just like apply, but resets the
             * content:  the line and column are reversed,
             * and the eaten value is re-added.
             *
             * This is useful for nodes with a single
             * type of content, such as lists and tables.
             *
             * See `apply` above for what parameters are
             * expected.
             *
             * @return {Node} - Added node.
             */
            function reset() {
                var node = apply.apply(null, arguments);

                line = current.line;
                column = current.column;
                value = subvalue + value;

                return node;
            }

            /**
             * Test the position, after eating, and reverse
             * to a not-eaten state.
             *
             * @return {Position} - Position after eating `subvalue`.
             */
            function test() {
                var result = pos({});

                line = current.line;
                column = current.column;
                value = subvalue + value;

                return result.position;
            }

            apply.reset = reset;
            apply.test = reset.test = test;

            value = value.substring(subvalue.length);

            updatePosition(subvalue);

            indent = indent();

            return apply;
        }

        /**
         * Same as `eat` above, but will not add positional
         * information to nodes.
         *
         * @example
         *   noEat('foo')({type: 'text', value: 'foo'});
         *
         * @param {string} subvalue - Removed from `value`.
         * @return {Function} - Wrapper around `add`.
         */
        function noEat(subvalue) {
            validateEat(subvalue);

            /**
             * Add the given arguments, and return the
             * node.
             *
             * @return {Node} - Added node.
             */
            function apply() {
                return add.apply(null, arguments);
            }

            /**
             * Functions just like apply, but resets the
             * content: the eaten value is re-added.
             *
             * @return {Node} - Added node.
             */
            function reset() {
                var node = apply.apply(null, arguments);

                value = subvalue + value;

                return node;
            }

            /**
             * Test the position, which in this mode is an
             * empty object.
             *
             * @return {Object} - Empty position object.
             */
            function test() {
                value = subvalue + value;

                return {};
            }

            apply.reset = reset;
            apply.test = reset.test = test;

            value = value.substring(subvalue.length);

            return apply;
        }

        /*
         * Expose the eater, depending on if `position`s
         * should be patched on nodes.
         */

        eater = patchPosition ? eat : noEat;

        /*
         * Expose `now` on `eater`.
         */

        eater.now = now;

        /*
         * Expose `file` on `eater`.
         */

        eater.file = self.file;

        /*
         * Sync initial offset.
         */

        updatePosition(EMPTY);

        /*
         * Iterate over `value`, and iterate over all
         * tokenizers.  When one eats something, re-iterate
         * with the remaining value.  If no tokenizer eats,
         * something failed (should not happen) and an
         * exception is thrown.
         */

        while (value) {
            index = -1;
            length = methods.length;
            matched = false;

            while (++index < length) {
                name = methods[index];
                method = tokenizers[name];

                if (
                    method &&
                    (!method.onlyAtStart || self.atStart) &&
                    (!method.onlyAtTop || self.atTop) &&
                    (!method.notInBlockquote || !self.inBlockquote) &&
                    (!method.notInLink || !self.inLink)
                ) {
                    valueLength = value.length;

                    method.apply(self, [eater, value]);

                    matched = valueLength !== value.length;

                    if (matched) {
                        break;
                    }
                }
            }

            /* istanbul ignore if */
            if (!matched) {
                self.file.fail(ERR_INFINITE_LOOP, eater.now());

                /*
                 * Errors are not thrown on `File#fail`
                 * when `quiet: true`.
                 */

                break;
            }
        }

        self.eof = now();

        return tokens;
    }

    return tokenize;
}

/*
 * Expose tokenizers for block-level nodes.
 */

Parser.prototype.blockTokenizers = {
    'yamlFrontMatter': tokenizeYAMLFrontMatter,
    'newline': tokenizeNewline,
    'code': tokenizeCode,
    'fences': tokenizeFences,
    'heading': tokenizeHeading,
    'lineHeading': tokenizeLineHeading,
    'horizontalRule': tokenizeHorizontalRule,
    'blockquote': tokenizeBlockquote,
    'list': tokenizeList,
    'html': tokenizeHTML,
    'definition': tokenizeDefinition,
    'footnoteDefinition': tokenizeFootnoteDefinition,
    'table': tokenizeTable,
    'paragraph': tokenizeParagraph
};

/*
 * Expose order in which to parse block-level nodes.
 */

Parser.prototype.blockMethods = [
    'yamlFrontMatter',
    'newline',
    'code',
    'fences',
    'blockquote',
    'heading',
    'horizontalRule',
    'list',
    'lineHeading',
    'html',
    'footnoteDefinition',
    'definition',
    'looseTable',
    'table',
    'paragraph'
];

/**
 * Block tokenizer.
 *
 * @example
 *   var parser = new Parser();
 *   parser.tokenizeBlock('> foo.');
 *
 * @param {string} value - Content.
 * @return {Array.<Object>} - Nodes.
 */

Parser.prototype.tokenizeBlock = tokenizeFactory(BLOCK);

/*
 * Expose tokenizers for inline-level nodes.
 */

Parser.prototype.inlineTokenizers = {
    'escape': tokenizeEscape,
    'autoLink': tokenizeAutoLink,
    'url': tokenizeURL,
    'tag': tokenizeTag,
    'link': tokenizeLink,
    'reference': tokenizeReference,
    'strong': tokenizeStrong,
    'emphasis': tokenizeEmphasis,
    'deletion': tokenizeDeletion,
    'inlineCode': tokenizeInlineCode,
    'break': tokenizeBreak,
    'inlineText': tokenizeText
};

/*
 * Expose order in which to parse inline-level nodes.
 */

Parser.prototype.inlineMethods = [
    'escape',
    'autoLink',
    'url',
    'tag',
    'link',
    'reference',
    'shortcutReference',
    'strong',
    'emphasis',
    'deletion',
    'inlineCode',
    'break',
    'inlineText'
];

/**
 * Inline tokenizer.
 *
 * @example
 *   var parser = new Parser();
 *   parser.tokenizeInline('_foo_');
 *
 * @param {string} value - Content.
 * @return {Array.<Object>} - Nodes.
 */

Parser.prototype.tokenizeInline = tokenizeFactory(INLINE);

/*
 * Expose `tokenizeFactory` so dependencies could create
 * their own tokenizers.
 */

Parser.prototype.tokenizeFactory = tokenizeFactory;

/*
 * Expose `parse` on `module.exports`.
 */

module.exports = Parser;

},
"iyZIQa9fpAJWi1LGhuCZRH4TMZQVAG3AAUfP4A6xmRM=":
function (require, module, exports, __dirname, __filename) {
var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},
"j1iN1Piliy2Kq5ORPhCwG4YM8nGvW3dmRrITB22TfPo=":
function (require, module, exports, __dirname, __filename) {
var EventEmitter = require('events')
var u            = require('./util')
var Hookable     = require('hoox')

function isFunction (f) {
  return 'function' === typeof f
}

function merge (a, b, mapper) {

  for(var k in b) {
    if(b[k] && 'object' === typeof b[k] && !Buffer.isBuffer(b[k]))
      merge(a[k] = {}, b[k], mapper)
    else
      a[k] = mapper(b[k], k)
  }

  return a
}

module.exports = function (plugins) {

  function create (opts) {
    //change event emitter to something with more rigorous security?
    var api = new EventEmitter()
    create.plugins.forEach(function (plug) {
      var _api = plug.init.call({createClient: create.createClient}, api, opts)
      if(plug.name) {
        var o = {}; o[plug.name] = _api; _api = o
      }
      api = merge(api, _api, function (v, k) {
        if ('function' === typeof v) {
          v = Hookable(v)
          if (plug.manifest && plug.manifest[k] === 'sync') {
            u.hookOptionalCB(v)
          }
        }
        return v
      })
    })

    return api
  }

  create.plugins = []
  create.manifest = {}
  create.permissions = {}

  create.use = function (plug) {
    if(isFunction(plug))
      return create.plugins.push({init: plug}), create

    if(!plug.init)
      throw new Error('plugins *must* have "init" method')

    var name = plug.name
    if(plug.manifest)
      create.manifest =
        u.merge.manifest(create.manifest, plug.manifest, name)
    if(plug.permissions)
      create.permissions =
        u.merge.permissions(create.permissions, plug.permissions, name)
    create.plugins.push(plug)

    return create
  }

  ;[].concat(plugins).filter(Boolean).forEach(create.use)

  return create
}

},
"j6aP6LD2tdvlAd5NtAw/vSzcYqhGdFQxdP6xrfT00i4=":
function (require, module, exports, __dirname, __filename) {
exports.AbstractLevelDOWN    = require('./abstract-leveldown')
exports.AbstractIterator     = require('./abstract-iterator')
exports.AbstractChainedBatch = require('./abstract-chained-batch')
exports.isLevelDOWN          = require('./is-leveldown')

},
"jEVc+z0ZgqBUBZ96CTIjnGzsTmnKS5WkAzgSIBxk01g=":
function (require, module, exports, __dirname, __filename) {
'use strict';

var hash = require('ssb-keys').hash

// make a validation stream?
// read the latest record in the database
// check it against the incoming data,
// and then read through

function isString (s) {
  return 'string' === typeof s
}

function isInteger (n) {
  return ~~n === n
}

function isObject (o) {
  return o && 'object' === typeof o
}

var util = require('./util')
var encode = util.encode

module.exports = function (ssb) {

  var write = util.BatchQueue(ssb)

  function getLatest (id, cb) {
    ssb.getLatest(id, function (err, data) {
      if(err) return cb(null, {key: null, value: null, type: 'put', public: null, ready: true})
      cb(null, {
        key: data.key, value: data.value, type: 'put',
        public: data.value && data.value.author, ready: true
      })
    })
  }

  var latest = {}

  function setLatest(id) {
    if(latest[id].ready)
      throw new Error('setLatest should only be called once')
    ssb.getLatest(id, function (err, data) {
      latest[id].ready = true
      if(data) {
        latest[id].key = data.key
        latest[id].value = data.value
      }
      validate(id)
    })
  }

  function validate(id) {
    var feed = latest[id]
    if(!feed.queue.length) return
    if(!feed.ready) return

    while(feed.queue.length) {
      var op = feed.queue.shift()


      if('function' == typeof op.create) {
        op.value = op.create(feed.key, feed.value)
        op.key = '%'+hash(encode(op.value))
      }

      var err =
        util.isInvalidShape(op.value) ||
        util.isInvalid(id, op.value, feed)

      if(err)
        op.cb(err)
      else {
        feed.key = op.key
        feed.value = op.value
        feed.ts = Date.now()
        write(op)
      }
    }
  }

  function queue (id, job) {
    if(!latest[id]) {
      latest[id] = {
        key:null, value: null,
        ready: false, queue: [],
        ts: Date.now()
      }
      latest[id].queue.push(job)
      setLatest(id)
    }
    else
      latest[id].queue.push(job)

    validate(id)
  }

  function add (msg, cb) {
    var err = util.isInvalidShape(msg)
    if(err) return cb(err)

    queue(msg.author, {
        key: '%'+hash(encode(msg)),
        value: msg, cb: cb,
        create: null
      })
  }

  add.queue = function (id, create, cb) {
    queue(id, {
        key: null, value: null,
        create: create, cb: cb
      })

  }

  return add
}

},
"jV3jk5AWI4ZrZK+xzgRd3HaURfDqGWeTbcsJiv/G7ag=":
function (require, module, exports, __dirname, __filename) {
module.exports = require('level-packager')(require('leveldown'))
},
"jkPNb0YPMe0O38zouSK6lxbIYWStTMM7GQTKnLrKdgA=":
function (require, module, exports, __dirname, __filename) {
var ltgt = require('ltgt')
var pull = require('pull-stream')
var BSS = require('binary-sorted-set')
var util = require('../util')

var LO = null
var HI = undefined

module.exports = function (path) {

  util.assertDepth(path, 'createMemIndex')

  var table = BSS()
  var index = {
    path: path,
    since: 0,
    mem: true,
    table: table,
    read: function (opts) {
      opts = ltgt.toLtgt(opts, opts, function (value, isUpper) {
        var bound = isUpper ? HI : LO
        return [value, bound]
      })
      return pull.values(
        table.range(opts)
        .map(function (key) { return key[1] })
      )
    },

    // the data is already written. mutate the index.
    // this should be a sync function,
    // that mutates the indexes actual data.

    post: function (data) {
      util.eachpath(path, data.value)
      .forEach(function (value) {
        table.add([value, data.key])
      })
    }
  }

  return index
}

},
"kHUk1iAy7Qi9Sc5XNIJ3nVD9jg1u0R2WIKJwmZF1au0=":
function (require, module, exports, __dirname, __filename) {
var bytewise = require('bytewise')

module.exports = {
  encode: bytewise.encode,
  decode: bytewise.decode,
  lowerBound: null,
  upperBound: undefined,
  buffer: true
}

},
"kK+TXeMaBMqopUbJj5bVbF44Tt2B0dVdk3RTWVAsurs=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var sodium = require('chloride')
var Reader = require('pull-reader')
var increment = require('increment-buffer')
var through = require('pull-through')
var split = require('split-buffer')

var isBuffer = Buffer.isBuffer
var concat = Buffer.concat

var box = sodium.crypto_secretbox_easy
var unbox = sodium.crypto_secretbox_open_easy  

function unbox_detached (mac, boxed, nonce, key) {
  return sodium.crypto_secretbox_open_easy(concat([mac, boxed]), nonce, key)
}

var max = 1024*4

var NONCE_LEN = 24
var HEADER_LEN = 2+16+16

function isZeros(b) {
  for(var i = 0; i < b.length; i++)
    if(b[i] !== 0) return false
  return true
}

function randomSecret(n) {
  var rand = new Buffer(n)
  sodium.randombytes(rand)
  return rand
}

function copy (a) {
  var b = new Buffer(a.length)
  a.copy(b, 0, 0, a.length)
  return b
}

exports.createBoxStream =
exports.createEncryptStream = function (key, init_nonce) {

  if(key.length === 56) {
    init_nonce = key.slice(32, 56)
    key = key.slice(0, 32)
  }
  else if(!(key.length === 32 && init_nonce.length === 24))
    throw new Error('nonce must be 24 bytes')

  // we need two nonces because increment mutates,
  // and we need the next for the header,
  // and the next next nonce for the packet
  var nonce1 = copy(init_nonce), nonce2 = copy(init_nonce)
  var head = new Buffer(18)

  return through(function (data) {

    if('string' === typeof data)
      data = new Buffer(data, 'utf8')
    else if(!isBuffer(data))
      return this.emit('error', new Error('must be buffer'))

    if(data.length === 0) return

    var input = split(data, max)

    for(var i = 0; i < input.length; i++) {
      head.writeUInt16BE(input[i].length, 0)
      var boxed = box(input[i], increment(nonce2), key)
      //write the mac into the header.
      boxed.copy(head, 2, 0, 16)

      this.queue(box(head, nonce1, key))
      this.queue(boxed.slice(16, 16 + input[i].length))

      increment(increment(nonce1)); increment(nonce2)
    }
  }, function (err) {
    if(err) return this.queue(null)

    //handle special-case of empty session
    //final header is same length as header except all zeros (inside box)
    var final = new Buffer(2+16); final.fill(0)
    this.queue(box(final, nonce1, key))
    this.queue(null)
  })

}
exports.createUnboxStream =
exports.createDecryptStream = function (key, nonce) {


  if(key.length == 56) {
    nonce = key.slice(32, 56)
    key = key.slice(0, 32)
  }
  else if(!(key.length === 32 && nonce.length === 24))
    throw new Error('nonce must be 24 bytes')

  var reader = Reader(), first = true,  ended
  var first = true

  return function (read) {
    reader(read)
    return function (end, cb) {
      if(end) return reader.abort(end, cb)
      //use abort when the input was invalid,
      //but the source hasn't actually ended yet.
      function abort(err) {
        reader.abort(ended = err || true, cb)
      }

      if(ended) return cb(ended)
      reader.read(HEADER_LEN, function (err, cipherheader) {
        if(err === true) return cb(ended = new Error('unexpected hangup'))
        if(err) return cb(ended = err)

        var header = unbox(cipherheader, nonce, key)

        if(!header)
          return abort(new Error('invalid header'))

        //valid end of stream
        if(isZeros(header))
          return cb(ended = true)

        var length = header.readUInt16BE(0)
        var mac = header.slice(2, 34)

        reader.read(length, function (err, cipherpacket) {
          if(err) return cb(ended = err)
          //recreate a valid packet
          //TODO: PR to sodium bindings for detached box/open
          var plainpacket = unbox_detached(mac, cipherpacket, increment(nonce), key)
          if(!plainpacket)
            return abort(new Error('invalid packet'))

          increment(nonce)
          cb(null, plainpacket)
        })
      })
    }
  }
}

},
"kK78KFK65pX98WPrreowhFqTeeX4ddqsf0xpMnhGAtc=":
function (require, module, exports, __dirname, __filename) {
'use strict';

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {/**/}

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						target[name] = copy;
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},
"kMWctOiqLccORn8/pujjHJQiVNhIlqNemBGzyI0oCpg=":
function (require, module, exports, __dirname, __filename) {

//only exports browser api. use chloride module
//to get automatic fallbacks!
module.exports = require('./browser')

},
"kRrAQeGOddupYmHHuAn1pFnw/kVrUzHbgZXAlM1B6kY=":
function (require, module, exports, __dirname, __filename) {
'use strict';
//
// Algorithms
//

// probably move these to another file when there get to be lots of them.

function count(obj) {
  var c = 0
  for(var k in obj) c++
  return c
}

function widthTraverse (graph, reachable, start, depth, hops, max, iter) {
  if(!start)
    throw new Error('Graphmitter#traverse: start must be provided')

  var nodes = 1

  reachable[start] = reachable[start] == null ? 0 : reachable[start]

  var queue = [{key: start, hops: depth}]
  iter = iter || function () {}
  var abort = false
  while(queue.length && (!max || nodes < max) && !abort) {
    var o = queue.shift()
    var h = o.hops
    var n = graph.nodes[o.key]
    if(n && (!hops || (h + 1 <= hops)))
      for(var k in n.edges) {
        // If we have already been to this node by a shorter path,
        // then skip this node (this only happens when processing
        // a realtime edge)
        if(!(reachable[k] != null && reachable[k] < h + 1)) {
          if(false === iter(o.key, k, h + 1, reachable[k]))
            return reachable

          reachable[k] = h + 1
          nodes ++
          queue.push({key: k, hops: h + 1})
        }
    }
  }

  return reachable
}

exports.traverse = function (opts, onEach) {
  var self = this
  var maxHops = opts.hops || 3
  var maxNodes = opts.max || 150
  var reachable = {}
  opts.each = onEach = onEach || opts.each

  widthTraverse(
    this, reachable,
    opts.start,
    0,             //initial hops
    opts.hops,     //max hops
    opts.max,      //max nodes
    opts.old !== false && onEach
  )

  if(!onEach || opts.live === false) return reachable

  function onEdge (from, to) {
    //if this edge is part of the initial setd
    if(reachable[from] != null && reachable[from] < maxHops) {
      //edges to new nodes.
      var h = reachable[from] + 1
      var _h = reachable[to]
      if(_h == null)
        onEach(from, to, reachable[to] = h, _h)
      else if(Math.min(h, _h) != _h)
        onEach(from, to, reachable[to] = Math.min(h, _h), _h)

      if(h <= maxHops && h != _h) {
        //also add other nodes that are now reachable.
        widthTraverse(self, reachable, to, h, maxHops, maxNodes, onEach)

      }
    }
  }

  this.on('edge', onEdge)

  return function () {
    self.removeListener('edge', onEdge)
  }
}

// page rank. I adapted the algorithm to use
// forward links instead of backward links which means
// we only have to traverse the graph one time.

exports.rank = function (opts) {
  opts = opts || {}

  var ranks = {}, links = {}, _ranks = {}
  var N = count(this.nodes)
  var iterations = opts.iterations || 1
  var damping = opts.damping || 0.85
  var init = (1 - damping) / N

  //initialize
  this.each(function (k, n) {
    ranks[k] = 1/N; _ranks[k] = init
    links[k] = count(n.edges)
  })

  while(iterations --> 0) {

    //iteration
    this.each(function (j, n) {
      var r = damping*(ranks[j]/links[j])
      n.each(function (k) { _ranks[k] += r })
    })

    //reset
    for(var k in ranks)
      ranks[k] = init

    var __ranks = ranks
    ranks = _ranks
    _ranks = __ranks
  }
  return ranks
}

//find the shortest path between two nodes.
//if there was no path within max hops, return null.

//convert a spanning tree to an array.
function toArray (span, root) {
  if(!span[root]) return null
  var a = [root]
  while(span[root])
    a.push(root = span[root])
  return a.reverse()
}

exports.path = function (opts) {
  var reverse = {}
  if(opts.source == opts.dest)
    return [opts.source]

  opts.start = opts.source
  opts.live = false
  opts.each = function (f, t, h) {
    reverse[t] = f
  }

  this.traverse(opts)
  return toArray(reverse, opts.dest)
}



},
"kiKgwhC4zhbntG5eh1zfswPH1Bd6S7mVhx2GTYogAcE=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer. All rights reserved.
 * @module bail
 * @fileoverview Throw a given error.
 */

'use strict';

/**
 * Throw a given error.
 *
 * @example
 *   bail();
 *
 * @example
 *   bail(new Error('failure'));
 *   // Error: failure
 *   //     at repl:1:6
 *   //     at REPLServer.defaultEval (repl.js:154:27)
 *   //     ...
 *
 * @param {Error?} [err] - Optional error.
 * @throws {Error} - `err`, when given.
 */
function bail(err) {
    if (err) {
        throw err;
    }
}

/*
 * Expose.
 */

module.exports = bail;

},
"kjwiLuBIqcfA8RLq2UMSLPUO0lKtt3Z5eU95+NY5wlM=":
function (require, module, exports, __dirname, __filename) {
module.exports = require('./base')

},
"kpQf5YlD36spS2U7D4cMcVawxfNmToheCTJwTjgKre8=":
function (require, module, exports, __dirname, __filename) {



var fs           = require('fs')
var path         = require('path')
var pull         = require('pull-stream')
var toPull       = require('stream-to-pull-stream')
var explain      = require('explain-error')
var ssbKeys      = require('ssb-keys')
var stringify    = require('pull-stringify')
var createHash   = require('multiblob/util').createHash
var config       = require('ssb-config/inject')(process.env.ssb_appname)
var muxrpcli     = require('muxrpcli')
var cmdAliases   = require('./lib/cli-cmd-aliases')

var keys = ssbKeys.loadOrCreateSync(path.join(config.path, 'secret'))
if(keys.curve === 'k256')
  throw new Error('k256 curves are no longer supported,'+
                  'please delete' + path.join(config.path, 'secret'))

var manifestFile = path.join(config.path, 'manifest.json')

if (process.argv[2] == 'server') {

  // special server command:
  // import sbot and start the server

  var createSbot = require('./')
    .use(require('./plugins/master'))
    .use(require('./plugins/gossip'))
    .use(require('./plugins/friends'))
    .use(require('./plugins/replicate'))
    .use(require('./plugins/blobs'))
    .use(require('./plugins/invite'))
    .use(require('./plugins/block'))
    .use(require('./plugins/local'))
    .use(require('./plugins/logging'))
    .use(require('./plugins/private'))

  // start server

  config.keys = keys
  var server = createSbot(config)

  // write RPC manifest to ~/.ssb/manifest.json
  fs.writeFileSync(manifestFile, JSON.stringify(server.getManifest(), null, 2))
} else {

  // normal command:
  // create a client connection to the server

  // read manifest.json
  var manifest
  try {
    manifest = JSON.parse(fs.readFileSync(manifestFile))
  } catch (err) {
    throw explain(err,
      'no manifest file'
      + '- should be generated first time server is run'
    )
  }

  // connect
  require('ssb-client')(keys, {
    manifest: manifest,
    port: config.port,
    host: config.host||'localhost',
    key: keys.id
  }, function (err, rpc) {
    if(err) {
      if (/could not connect/.test(err.message)) {
        console.log('Error: Could not connect to the scuttlebot server.')
        console.log('Use the "server" command to start it.')
        process.exit(1)
      }
      throw err
    }

    // add aliases
    for (var k in cmdAliases) {
      rpc[k] = rpc[cmdAliases[k]]
      manifest[k] = manifest[cmdAliases[k]]
    }

    // add some extra commands
    manifest.version = 'async'
    manifest.config = 'sync'
    rpc.version = function (cb) {
      console.log(require('./package.json').version)
      cb()
    }
    rpc.config = function (cb) {
      console.log(JSON.stringify(config, null, 2))
      cb()
    }

    // HACK
    // we need to output the hash of blobs that are added via blobs.add
    // because muxrpc doesnt support the `sink` callback yet, we need this manual override:
    if (process.argv[2] === 'blobs.add')
      return blobsAddOverride(rpc)

    // run commandline flow
    muxrpcli(process.argv.slice(2), manifest, rpc)
  })
}

// HACK helper
// runs stdin through the hasher, then on to sbot for adding, then outputs the hash on success
var createHash = require('multiblob/util').createHash
function blobsAddOverride (rpc) {
  var hasher = createHash('sha256')
  pull(
    toPull.source(process.stdin),
    hasher,
    rpc.blobs.add(function (err) {
      if (err) 
        throw err
      console.log('&'+hasher.digest)
      process.exit()
    })
  )
}


},
"kyqeUFNTWjvVxavKOw5LOdz8g5QWMXv3p8S6xZS7cTo=":
function (require, module, exports, __dirname, __filename) {
var collation = require('./collation')

//
// base type system
//
var base = {}

//
// helper utilities
//

function _valueOf(instance) {
  return instance == null ? instance : instance.valueOf()
}

var _toString = Object.prototype.toString

function _isObject(instance) {
  return instance && _toString.call(instance) === '[object Object]'
}

//
// base typewise compare implementation
//
base.compare = function (a, b) {
  //
  // test for invalid values
  //
  if (base.invalid(a, b))
    return NaN

  //
  // short circuit for identical objects
  //
  if (a === b)
    return 0

  //
  // short circuit for base bound types
  //
  var result = base.bound.compare(a, b)
  if (result !== undefined)
    return result

  //
  // cache typeof and valueOf for both values
  //
  var aTypeOf = typeof a
  var bTypeOf = typeof b
  var aValueOf = _valueOf(a)
  var bValueOf = _valueOf(b)

  //
  // loop over type tags and attempt compare
  //
  var order = base.order
  var sorts = base.sorts
  var sort
  for (var i = 0, length = order.length; i < length; ++i) {
    sort = sorts[order[i]]

    //
    // if first arg is a member of this sort we have an answer
    //
    if (sort.is(a, aTypeOf))
      //
      // if b is the same as a then defer to sort's comparator, else a comes first
      //
      return sort.is(b, bTypeOf) ? sort.compare(aValueOf, bValueOf) : -1

    //
    // if b is this type but not a then b comes first
    //
    if (sort.is(b, bTypeOf))
      return 1
  }

  //
  // values are incomparable as they didn't match against any registered types
  //
  return NaN
}

//
// sort equality test
//
base.equal = function(a, b) {
  return base.compare(a, b) === 0
}

//
// test for top-level incomparability using invalid sort definitions
//
base.invalid = function (a, b) {
  var types = base.invalid
  for (var key in types) {
    var type = types[key]
    if (type && type.is && (type.is(a) || type.is(b)))
      return true
  }
  return false
}

//
// definitions for explicitly invalid/incomparable types
//

base.invalid.NAN = {
  is: function (instance) {
    var valueOf = _valueOf(instance)
    return valueOf !== valueOf
  }
}

base.invalid.ERROR = {
  is: function (instance) {
    return instance && instance instanceof Error
  }
}

//
// definitions for boundary types, unserializable as values
//

function BoundedKey(bound, upper, prefix) {
  this.bound = bound
  this.upper = !!upper
  this.prefix = prefix
}

function Boundary(sort) {
  this.sort = sort
}

Boundary.prototype.lower = function (prefix) {
  return new BoundedKey(this, false, prefix)
}

Boundary.prototype.upper = function (prefix) {
  return new BoundedKey(this, true, prefix)
}

Boundary.prototype.is = function (source) {
  return source instanceof BoundedKey && source.sort === this.sort
}

Boundary.add = function (sort) {
  sort.bound = new Boundary(sort)
}

Boundary.add(base)

base.bound.getBoundary = function (source) {
  return source instanceof BoundedKey && source.bound
}

//
// compare a values against top level bounds (assumes first arg is an instance)
//
base.bound.compare = function (a, b) {
  var aBound = base.bound.is(a)
  var bBound = base.bound.is(b)
  if (aBound) {
    if (bBound && !a.upper === !b.upper)
      return 0
    return a.upper ? 1 : -1
  }

  if (bBound)
    return -base.bound.compare(b, a)
}

//
// helper to register fixed (nullary) types
//
function fixed(value) {
  return {
    is: function (instance) {
      return instance === value
    },
    value: value
  }
}

//
// value types defined as ordered map of "sorts"
//
var sorts = base.sorts = {}

sorts.void = fixed(void 0)
sorts.void.compare = collation.inequality

sorts.null = fixed(null)
sorts.null.compare = collation.inequality

var BOOLEAN = sorts.boolean = {}
BOOLEAN.compare = collation.inequality
BOOLEAN.is = function (instance, typeOf) {
  return (typeOf || typeof instance) === 'boolean'
}

BOOLEAN.sorts = {}
BOOLEAN.sorts.true = fixed(true)
BOOLEAN.sorts.false = fixed(false)

Boundary.add(BOOLEAN)


var NUMBER = sorts.number = {}
NUMBER.compare = collation.difference
NUMBER.is = function (instance, typeOf) {
  return (typeOf || typeof instance) === 'number'
}

NUMBER.sorts = {}
NUMBER.sorts.max = fixed(Number.POSITIVE_INFINITY)
NUMBER.sorts.min = fixed(Number.NEGATIVE_INFINITY)

NUMBER.sorts.positive = {}
NUMBER.sorts.positive.is = function (instance) {
  return instance >= 0
}

NUMBER.sorts.negative = {}
NUMBER.sorts.negative.is = function (instance) {
  return instance < 0
}

Boundary.add(NUMBER)


var DATE = sorts.date = {}
DATE.compare = collation.difference
DATE.is = function (instance) {
  return instance instanceof Date && instance.valueOf() === instance.valueOf()
}

DATE.sorts = {}
DATE.sorts.positive = {}
DATE.sorts.positive.is = function (instance) {
  return instance.valueOf() >= 0
}

DATE.sorts.negative = {}
DATE.sorts.negative.is = function (instance) {
  return instance.valueOf() < 0
}

Boundary.add(DATE)


var BINARY = sorts.binary = {}
BINARY.empty = new Buffer([])
BINARY.compare = collation.bitwise
BINARY.is = Buffer.isBuffer

Boundary.add(BINARY)


var STRING = sorts.string = {}
STRING.empty = ''
STRING.compare = collation.inequality
STRING.is = function (instance, typeOf) {
  return (typeOf || typeof instance) === 'string'
}

Boundary.add(STRING)


var ARRAY = sorts.array = {}
ARRAY.empty = []
ARRAY.compare = collation.recursive.elementwise(base.compare)
ARRAY.is = Array.isArray

Boundary.add(ARRAY)


// var OBJECT = sorts.object = {}
// OBJECT.empty = {}
// OBJECT.compare = collation.recursive.fieldwise(base.compare)
// OBJECT.is = _isObject

// Boundary.add(OBJECT)

//
// default order for instance checking in compare operations
//
base.order = []
for (var key in sorts) {
  base.order.push(key)
}

module.exports = base

},
"lKhJ5Mmc+x+PNwTHz0XD/JoAgiZhX9ZDmte/WKmaSOY=":
function (require, module, exports, __dirname, __filename) {
'use strict'

function id (item) { return item }

function prop (key) {
  return (
    'string' == typeof key
    ? function (data) { return data[key] }
    : key && 'object' === typeof key && 'function' === typeof key.exec //regexp
    ? function (data) { var v = map.exec(data); return v && v[0] }
    : key || id
  )
}


var drain = exports.drain = function (op, done) {
  var read, abort

  function sink (_read) {
    read = _read
    if(abort) return sink.abort()
    //this function is much simpler to write if you
    //just use recursion, but by using a while loop
    //we do not blow the stack if the stream happens to be sync.
    ;(function next() {
        var loop = true, cbed = false
        while(loop) {
          cbed = false
          read(null, function (end, data) {
            cbed = true
            if(end = end || abort) {
              loop = false
              if(done) done(end === true ? null : end)
              else if(end && end !== true)
                throw end
            }
            else if(op && false === op(data) || abort) {
              loop = false
              read(abort || true, done || function () {})
            }
            else if(!loop){
              next()
            }
          })
          if(!cbed) {
            loop = false
            return
          }
        }
      })()
  }

  sink.abort = function (err, cb) {
    if('function' == typeof err)
      cb = err, err = true
    abort = err || true
    if(read) return read(abort, cb || function () {})
  }

  return sink
}

var onEnd = exports.onEnd = function (done) {
  return drain(null, done)
}

var log = exports.log = function (done) {
  return drain(function (data) {
    console.log(data)
  }, done)
}

var find =
exports.find = function (test, cb) {
  var ended = false
  if(!cb)
    cb = test, test = id
  else
    test = prop(test) || id

  return drain(function (data) {
    if(test(data)) {
      ended = true
      cb(null, data)
    return false
    }
  }, function (err) {
    if(ended) return //already called back
    cb(err === true ? null : err, null)
  })
}

var reduce = exports.reduce = function (reduce, acc, cb) {

  return drain(function (data) {
    acc = reduce(acc, data)
  }, function (err) {
    cb(err, acc)
  })

}

var collect = exports.collect =
function (cb) {
  return reduce(function (arr, item) {
    arr.push(item)
    return arr
  }, [], cb)
}

var concat = exports.concat =
function (cb) {
  return reduce(function (a, b) {
    return a + b
  }, '', cb)
}






},
"lMswXBQii9P/pfGzapgmMzlnSatBGkUCqq/dH5aFfr0=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module attach-ware
 * @fileoverview Middleware with configuration.
 * @example
 *   var ware = require('attach-ware')(require('ware'));
 *
 *   var middleware = ware()
 *     .use(function (context, options) {
 *         if (!options.condition) return;
 *
 *         return function (req, res, next) {
 *           res.x = 'hello';
 *           next();
 *         };
 *     }, {
 *         'condition': true
 *     })
 *     .use(function (context, options) {
 *         if (!options.condition) return;
 *
 *         return function (req, res, next) {
 *           res.y = 'world';
 *           next();
 *         };
 *     }, {
 *         'condition': false
 *     });
 *
 *   middleware.run({}, {}, function (err, req, res) {
 *     res.x; // "hello"
 *     res.y; // undefined
 *   });
 */

'use strict';

/* eslint-env commonjs */

var slice = [].slice;
var unherit = require('unherit');

/**
 * Clone `Ware` without affecting the super-class and
 * turn it into configurable middleware.
 *
 * @param {Function} Ware - Ware-like constructor.
 * @return {Function} AttachWare - Configurable middleware.
 */
function patch(Ware) {
    /*
     * Methods.
     */

    var useFn = Ware.prototype.use;

    /**
     * @constructor
     * @class {AttachWare}
     */
    var AttachWare = unherit(Ware);

    AttachWare.prototype.foo = true;

    /**
     * Attach configurable middleware.
     *
     * @memberof {AttachWare}
     * @this {AttachWare}
     * @param {Function} attach - Attacher.
     * @return {AttachWare} - `this`.
     */
    function use(attach) {
        var self = this;
        var params = slice.call(arguments, 1);
        var index;
        var length;
        var fn;

        /*
         * Accept other `AttachWare`.
         */

        if (attach instanceof AttachWare) {
            if (attach.attachers) {
                return self.use(attach.attachers);
            }

            return self;
        }

        /*
         * Accept normal ware.
         */

        if (attach instanceof Ware) {
            self.fns = self.fns.concat(attach.fns);
            return self;
        }

        /*
         * Multiple attachers.
         */

        if ('length' in attach && typeof attach !== 'function') {
            index = -1;
            length = attach.length;

            while (++index < length) {
                self.use.apply(self, [attach[index]].concat(params));
            }

            return self;
        }

        /*
         * Single attacher.
         */

        fn = attach.apply(null, [self.context || self].concat(params));

        /*
         * Store the attacher to not break `new Ware(otherWare)`
         * functionality.
         */

        if (!self.attachers) {
            self.attachers = [];
        }

        self.attachers.push(attach);

        /*
         * Pass `fn` to the original `Ware#use()`.
         */

        if (fn) {
            useFn.call(self, fn);
        }

        return self;
    }

    AttachWare.prototype.use = use;

    return function (fn) {
        return new AttachWare(fn);
    };
}

module.exports = patch;

},
"lnFYescKStjZ7BMzbQUuwmNMK7HQr3MAa1kNYcckMv4=":
function (require, module, exports, __dirname, __filename) {
'use strict';

/*
 * Constants.
 */

var WHITE_SPACE_COLLAPSABLE_LINE = /[ \t]*\n+[ \t]*/g;
var LINE = '\n';

/**
 * Remove initial and final spaces and tabs at the
 * line breaks in `value`. Does not trim initial and
 * final spaces and tabs of the value itself.
 *
 * @example
 *   trimLines(' foo\t\n\n bar \n\tbaz '); // ' foo\nbar\nbaz '
 *
 * @param {string} value - Value with untrimmed line breaks,
 *   coerced to string.
 * @return {string} - Value with trimmed line breaks.
 */
function trimLines(value) {
    return String(value).replace(WHITE_SPACE_COLLAPSABLE_LINE, LINE);
}

/*
 * Expose.
 */

module.exports = trimLines;

},
"loiUibNk8UcRLZ2jBFreyhfHe95Yz7IdjF8MPfoXuH8=":
function (require, module, exports, __dirname, __filename) {
var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      child = new Buffer(parent.length);
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
};
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
};
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
};
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
};
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

},
"m4xpE3KALaeIycX04covHtC4irhyIXbCrqFeOOyG0kk=":
function (require, module, exports, __dirname, __filename) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},
"m6AS/RrVbNagk0yZ7VYepMxyzuqC7CquDGee4lQfXkc=":
function (require, module, exports, __dirname, __filename) {
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events');

/*<replacement>*/
var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = undefined;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
},
"mJ1Mb97wyF/JYKHtacPJzv4XFtJkBvQS68qNva21Y08=":
function (require, module, exports, __dirname, __filename) {
var sleepCheckInterval
var lastSleepCheck = false
var SLEEP_CHECK_INTERVAL = 10e3
var NUM_MISSABLE_INTERVALS = 3
var EE = require('events')
var emitter = new EE()

module.exports = function (cb) {
  emitter.on('wakeup', cb)

  if (!sleepCheckInterval) {
    // setup interval
    sleepCheckInterval = setInterval(function () {
      var t = Date.now()
      if (lastSleepCheck && (t - lastSleepCheck) > SLEEP_CHECK_INTERVAL*NUM_MISSABLE_INTERVALS)
        emitter.emit('wakeup') // missed NUM_MISSABLE_INTERVALS checks, let's run the callbacks 
      lastSleepCheck = t
    }, SLEEP_CHECK_INTERVAL)
  }
  
  // unreference the timer so that the program can close
  if (sleepCheckInterval.unref)
    sleepCheckInterval.unref()

  return sleepCheckInterval
}

},
"mNQ0wNGLNSTSSsnIjBK2KJx9b/AAUfjQRmbBY9WfzcM=":
function (require, module, exports, __dirname, __filename) {

var Observ = require('observ')

module.exports = function (delay) {

  delay = delay || 200
  var o = Observ(),  set = o.set, ts = 0, timer, v

  o.set = function (v) {
    value = v
    var next = (ts + delay) - Date.now()
    if(next >= 0) {
      if(!timer)
        timer = setTimeout(function () {
          timer = null
          ts = Date.now()
          set(value)
        }, next)
      return
    }

    ts = Date.now()
    set(v)
  }

  o.immediate = function (v) {
    ts = 0
    clearTimeout(timer)
    return o.set(v)
  }

  return o
}

},
"mRlJcCnoEOlbSJXF9YOZpWm2s0wNMfmSY7VJqbq4++Y=":
function (require, module, exports, __dirname, __filename) {
module.exports = copy

function copy(source, target, target_start, source_start, source_end) {
  return source.copy(target, target_start, source_start, source_end)
}

},
"mSQ4yRnbqMg10zcg6EFgoql4VwcYGFxzLWHL5tTOgnA=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "_args": [
    [
      "levelup@~0.19.0",
      "/home/dominic/c/scuttlebot/node_modules/level-sublevel"
    ]
  ],
  "_from": "levelup@>=0.19.0 <0.20.0",
  "_id": "levelup@0.19.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/levelup",
  "_nodeVersion": "5.5.0",
  "_npmUser": {
    "email": "ralphtheninja@riseup.net",
    "name": "ralphtheninja"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "levelup",
    "raw": "levelup@~0.19.0",
    "rawSpec": "~0.19.0",
    "scope": null,
    "spec": ">=0.19.0 <0.20.0",
    "type": "range"
  },
  "_requiredBy": [
    "/level-sublevel",
    "/secure-scuttlebutt/level-sublevel"
  ],
  "_resolved": "https://registry.npmjs.org/levelup/-/levelup-0.19.1.tgz",
  "_shasum": "f3a6a7205272c4b5f35e412ff004a03a0aedf50b",
  "_shrinkwrap": null,
  "_spec": "levelup@~0.19.0",
  "_where": "/home/dominic/c/scuttlebot/node_modules/level-sublevel",
  "browser": {
    "leveldown": false,
    "leveldown/package": false,
    "semver": false
  },
  "bugs": {
    "url": "https://github.com/rvagg/node-levelup/issues"
  },
  "contributors": [
    {
      "name": "David Bjrklund",
      "email": "david.bjorklund@gmail.com",
      "url": "https://github.com/kesla"
    },
    {
      "name": "Rod Vagg",
      "email": "r@va.gg",
      "url": "https://github.com/rvagg"
    },
    {
      "name": "Jake Verbaten",
      "email": "raynos2@gmail.com",
      "url": "https://github.com/raynos"
    },
    {
      "name": "Dominic Tarr",
      "email": "dominic.tarr@gmail.com",
      "url": "https://github.com/dominictarr"
    },
    {
      "name": "Max Ogden",
      "email": "max@maxogden.com",
      "url": "https://github.com/maxogden"
    },
    {
      "name": "Lars-Magnus Skog",
      "email": "lars.magnus.skog@gmail.com",
      "url": "https://github.com/ralphtheninja"
    },
    {
      "name": "John Chesley",
      "email": "john@chesl.es",
      "url": "https://github.com/chesles/"
    },
    {
      "name": "Julian Gruber",
      "email": "julian@juliangruber.com",
      "url": "https://github.com/juliangruber"
    },
    {
      "name": "Paolo Fragomeni",
      "email": "paolo@async.ly",
      "url": "https://github.com/hij1nx"
    },
    {
      "name": "Anton Whalley",
      "email": "anton.whalley@nearform.com",
      "url": "https://github.com/No9"
    },
    {
      "name": "Matteo Collina",
      "email": "matteo.collina@gmail.com",
      "url": "https://github.com/mcollina"
    },
    {
      "name": "Pedro Teixeira",
      "email": "pedro.teixeira@gmail.com",
      "url": "https://github.com/pgte"
    },
    {
      "name": "James Halliday",
      "email": "mail@substack.net",
      "url": "https://github.com/substack"
    }
  ],
  "dependencies": {
    "bl": "~0.8.1",
    "deferred-leveldown": "~0.2.0",
    "errno": "~0.1.1",
    "prr": "~0.0.0",
    "readable-stream": "~1.0.26",
    "semver": "~5.1.0",
    "xtend": "~3.0.0"
  },
  "description": "Fast & simple storage - a Node.js-style LevelDB wrapper",
  "devDependencies": {
    "async": "*",
    "boganipsum": "*",
    "bustermove": "~1.0.1",
    "delayed": "*",
    "du": "*",
    "fstream": "*",
    "leveldown": "~0.10.0",
    "memdown": "^0.11.0",
    "mkfiletree": "*",
    "msgpack-js": "*",
    "readfiletree": "*",
    "referee": "*",
    "rimraf": "*",
    "slow-stream": ">=0.0.4",
    "tap": "2.x.x",
    "tape": "4.x.x",
    "tar": "*"
  },
  "directories": {},
  "dist": {
    "shasum": "f3a6a7205272c4b5f35e412ff004a03a0aedf50b",
    "tarball": "https://registry.npmjs.org/levelup/-/levelup-0.19.1.tgz"
  },
  "gitHead": "2847795d54c6eceb865e2c6b5157bccf68132c55",
  "homepage": "https://github.com/rvagg/node-levelup",
  "keywords": [
    "database",
    "db",
    "json",
    "leveldb",
    "storage",
    "store",
    "stream"
  ],
  "license": "MIT",
  "main": "lib/levelup.js",
  "maintainers": [
    {
      "name": "rvagg",
      "email": "rod@vagg.org"
    },
    {
      "name": "ralphtheninja",
      "email": "ralphtheninja@riseup.net"
    },
    {
      "name": "juliangruber",
      "email": "julian@juliangruber.com"
    }
  ],
  "name": "levelup",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/rvagg/node-levelup.git"
  },
  "scripts": {
    "alltests": "npm test && npm run-script functionaltests",
    "functionaltests": "node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js",
    "test": "tap test/*-test.js"
  },
  "version": "0.19.1"
}

},
"mcGty7pSW6D6LnUrqJfOtYJxrh8HUx22eQtt/rXYgEY=":
function (require, module, exports, __dirname, __filename) {
var base = require('typewise-core/base')
var codecs = require('./codecs')
var util = require('./util')

//
// extend core sorts defined by typewise with bytewise-specific functionality
//

// byte represents byte tag prefix in encoded form, enforcing binary total order
// type tag is 1 byte, which gives us plenty of room to grow

//
// boundary types
//
base.bound.encode = util.encodeBaseBound

//
// value types
//
var sorts = base.sorts

sorts.void.byte = 0xf0

sorts.null.byte = 0x10


var BOOLEAN = sorts.boolean
BOOLEAN.sorts.false.byte = 0x20
BOOLEAN.sorts.true.byte = 0x21
BOOLEAN.bound.encode = util.encodeBound


var NUMBER = sorts.number
NUMBER.sorts.min.byte = 0x40
NUMBER.sorts.negative.byte = 0x41
NUMBER.sorts.positive.byte = 0x42
NUMBER.sorts.max.byte = 0x43
NUMBER.sorts.negative.codec = codecs.NEGATIVE_FLOAT
NUMBER.sorts.positive.codec = codecs.POSITIVE_FLOAT
NUMBER.bound.encode = util.encodeBound


var DATE = sorts.date
DATE.sorts.negative.byte = 0x51
DATE.sorts.positive.byte = 0x52
DATE.sorts.negative.codec = codecs.PRE_EPOCH_DATE
DATE.sorts.positive.codec = codecs.POST_EPOCH_DATE
DATE.bound.encode = util.encodeBound


var BINARY = sorts.binary
BINARY.byte = 0x60
BINARY.codec = codecs.UINT8
BINARY.bound.encode = util.encodeBound


var STRING = sorts.string
STRING.byte = 0x70
STRING.codec = codecs.UTF8
STRING.bound.encode = util.encodeBound


var ARRAY = sorts.array
ARRAY.byte = 0xa0
ARRAY.codec = codecs.LIST
ARRAY.bound.encode = util.encodeListBound


// var OBJECT = sorts.object
// OBJECT.byte = 0xb0
// OBJECT.codec = codecs.HASH
// OBJECT.bound.encode = util.encodeListBound

module.exports = base

},
"mmieKglJNpsadwM4iSgXEayIyhxEIUwZxPXDnDXg6zQ=":
function (require, module, exports, __dirname, __filename) {

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},
"moain6NKmbhh5wc0X7HR4uVabCPtuPmSvtV8xgf0LY4=":
function (require, module, exports, __dirname, __filename) {

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = require('util').deprecate;

},
"mvnAF7M3/57EHitgTGHw2KPxotIOMvGBq3qiEBTTu8U=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  feed: 'createFeedStream',
  history: 'createHistoryStream',
  hist: 'createHistoryStream',
  public: 'getPublicKey',
  pub: 'getPublicKey',
  log: 'createLogStream',
  logt: 'messagesByType',
  conf: 'config'
}
},
"my3Mtk8msQFkFs5faZG4tS0EjwmtODFORzhSxcgleDM=":
function (require, module, exports, __dirname, __filename) {
var cont = require('continuable')

exports = module.exports = function (fun) {
  return cont.to(fun)
}

for(var k in cont)
  exports[k] = cont[k]

exports.para = require('continuable-para')
exports.series = require('continuable-series')

},
"myVBC8npQvqz1ryIXXUrqfJZ1qY6+Q5EhZ7+1W43LBo=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module character-reference-invalid
 * @fileoverview HTML invalid numeric character reference information.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Expose.
 */

module.exports = require('./index.json');

},
"n0vDNDOSZ6aL2orzwLIfZWWDdKmybPF++mfkW0Z6y4o=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var zeroBuffer = new Buffer(128)
zeroBuffer.fill(0)

module.exports = Hmac

function Hmac (createHash, blocksize, key) {
  if(!(this instanceof Hmac)) return new Hmac(createHash, blocksize, key)

  this._opad = opad
  this._createHash = createHash

  if(blocksize !== 128 && blocksize !== 64)
    throw new Error('blocksize must be either 64 for or 128 , but was:'+blocksize)

  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

  if(key.length > blocksize) {
    key = this._createHash().update(key).digest()
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = this._createHash().update(ipad)
}

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)
  return this
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()
  return this._createHash().update(this._opad).update(h).digest(enc)
}



},
"nBwtMvs4nZJN90rnUYQJEZmjs/XZdFEHFFFa3bbP8+8=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015-2016 Titus Wormer
 * @license MIT
 * @module remark
 * @version 3.2.2
 * @fileoverview Markdown processor powered by plugins.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var unified = require('unified');
var Parser = require('./lib/parse.js');
var Compiler = require('./lib/stringify.js');
var escape = require('./lib/escape.json');

/*
 * Exports.
 */

module.exports = unified({
    'name': 'mdast',
    'Parser': Parser,
    'Compiler': Compiler,
    'data': {
        'escape': escape
    }
});

},
"nE3FfVy09zeoqtOb2QPPhqMDmYweZPnssE1SJZU42xk=":
function (require, module, exports, __dirname, __filename) {
var looper = require('looper')

module.exports = function (writer, ender) {
  return function (read) {
    var queue = [], ended, error

    function enqueue (data) {
      queue.push(data)
    }

    writer = writer || function (data) {
      this.queue(data)
    }

    ender = ender || function () {
      this.queue(null)
    }

    var emitter = {
      emit: function (event, data) {
        if(event == 'data') enqueue(data)
        if(event == 'end')  ended = true, enqueue(null)
        if(event == 'error') error = data
      },
      queue: enqueue
    }
    var _cb
    return function (end, cb) {
      ended = ended || end
      if(end)
        return read(end, function () {
          if(_cb) {
            var t = _cb; _cb = null; t(end)
          }
          cb(end)
        })

      _cb = cb
      looper(function pull (next) {
        //if it's an error
        if(!_cb) return
        cb = _cb
        if(error) _cb = null, cb(error)
        else if(queue.length) {
          var data = queue.shift()
          _cb = null,cb(data === null, data)
        }
        else {
          read(ended, function (end, data) {
             //null has no special meaning for pull-stream
            if(end && end !== true) {
              error = end; return next()
            }
            if(ended = ended || end)  ender.call(emitter)
            else if(data !== null) {
              writer.call(emitter, data)
              if(error || ended)
                return read(error || ended, function () {
                  _cb = null; cb(error || ended)
                })
            }
            next(pull)
          })
        }
      })
    }
  }
}


},
"nJfRXfWgSTdls0FUO3x9xt3zlb50ClqCtlApOsTWlOk=":
function (require, module, exports, __dirname, __filename) {
var ssbKeys = require('ssb-keys')
var timestamp = require('monotonic-timestamp')
var isRef = require('ssb-ref')
var isHash = isRef.isHash
var isFeedId = isRef.isFeedId

var encode = exports.encode = function (obj) {
  return JSON.stringify(obj, null, 2)
}

function isString (s) {
  return 'string' === typeof s
}

function isInteger (n) {
  return ~~n === n
}

function isObject (o) {
  return o && 'object' === typeof o
}

function clone (obj) {
  var o = {}
  for(var k in obj) o[k] = obj[k];
  return o
}

function isEncrypted (str) {
  return isString(str) && /^[0-9A-Za-z\/+]+={0,2}\.box/.test(str)
}

exports.BatchQueue = function BatchQueue (db) {

  var batch = [], writing = false

  function drain () {
    writing = true
    var _batch = batch
    batch = []

    db.batch(_batch, function () {
      writing = false
      write.size = batch.length
      if(batch.length) drain()
      _batch.forEach(function (op) {
        op.cb(null, {key:op.key, value: op.value})
      })
    })
  }

  function write (op) {
    batch.push(op)
    write.size = batch.length
    if(!writing) drain()
  }

  write.size = 0

  return write
}

exports.create = function (keys, type, content, prev, prev_key) {

  //this noise is to handle things calling this with legacy api.
  if(isString(type) && (Buffer.isBuffer(content) || isString(content)))
    content = {type: type, value: content}
  if(isObject(content))
    content.type = content.type || type
  //noise end

  prev_key = !prev_key && prev ? ('%'+ssbKeys.hash(encode(prev))) : prev_key || null

  return ssbKeys.signObj(keys, {
    previous: prev_key,
    author: keys.id,
    sequence: prev ? prev.sequence + 1 : 1,
    timestamp: timestamp(),
    hash: 'sha256',
    content: content,
  })
}

var isInvalidContent = exports.isInvalidContent = function (content) {
  if(!isEncrypted(content)) {

    type = content.type

    if (!(isString(type) && type.length <= 52 && type.length >= 3)) {
      return new Error('type must be a string' +
        '3 <= type.length < 52, was:' + type
      )
    }
  }
  return false
}

exports.isInvalidShape = function (msg) {
  if(
    !isObject(msg) ||
    !isInteger(msg.sequence) ||
    !isFeedId(msg.author) ||
    !(isObject(msg.content) || isEncrypted(msg.content))
  )
    return new Error('message has invalid properties')

  //allow encrypted messages, where content is a base64 string.

  var asJson = encode(msg)
  if (asJson.length > 8192) // 8kb
    return new Error( 'encoded message must not be larger than 8192 bytes')

  return isInvalidContent(msg.content)
}

exports.isInvalid = function validateSync (pub, msg, previous) {
  // :TODO: is there a faster way to measure the size of this message?

  var key = previous.key
  var prev = previous.value

  if(prev) {
    if(msg.previous !== key)
      return new Error(
          'expected previous: '
        + key
        + 'but found:' + msg.previous
      )

    if(msg.sequence !== prev.sequence + 1
     || msg.timestamp <= prev.timestamp)
        return new Error('out of order')
  }
  else {
    if(!(msg.previous == null
      && msg.sequence === 1 && msg.timestamp > 0))
        return new Error('expected initial message')
  }

  if(msg.author !== pub) {

    return new Error(
        'expected different author:'
      + hash(pub.public || pub).toString('base64')
      + 'but found:' + msg.author.toString('base64')
    )
  }

  if(!ssbKeys.verifyObj(pub, msg))
    return new Error('signature was invalid')

  return false
}


},
"nUxnF57qemY+Mdk07TDCLZixJU+ZvZEq59JlwazRQYY=":
function (require, module, exports, __dirname, __filename) {
var Buffer = require('buffer').Buffer; // for use with browserify

module.exports = function (a, b) {
    if (!Buffer.isBuffer(a)) return undefined;
    if (!Buffer.isBuffer(b)) return undefined;
    if (typeof a.equals === 'function') return a.equals(b);
    if (a.length !== b.length) return false;
    
    for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
    }
    
    return true;
};

},
"ndz8xysNLoh8RKpifx147rp7hLl4ISMEYRchRAY8Hq4=":
function (require, module, exports, __dirname, __filename) {

exports.compare = function (a, b) {

  if(Buffer.isBuffer(a)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var cmp = a[i] - b[i]
      if(cmp) return cmp
    }
    return a.length - b.length
  }

  return a < b ? -1 : a > b ? 1 : 0
}

function has(obj, key) {
  return Object.hasOwnProperty.call(obj, key)
}

// to be compatible with the current abstract-leveldown tests
// nullish or empty strings.
// I could use !!val but I want to permit numbers and booleans,
// if possible.

function isDef (val) {
  return val !== undefined && val !== ''
}

function has (range, name) {
  return Object.hasOwnProperty.call(range, name)
}

function hasKey(range, name) {
  return Object.hasOwnProperty.call(range, name) && name
}

var lowerBoundKey = exports.lowerBoundKey = function (range) {
    return (
       hasKey(range, 'gt')
    || hasKey(range, 'gte')
    || hasKey(range, 'min')
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))
    || undefined
    )
}

var lowerBound = exports.lowerBound = function (range) {
  var k = lowerBoundKey(range)
  return k && range[k]
}

exports.lowerBoundInclusive = function (range) {
  return has(range, 'gt') ? false : true
}

exports.upperBoundInclusive =
  function (range) {
    return has(range, 'lt') || !range.minEx ? false : true
  }

var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
    return has(range, 'gt') || range.minEx ? true : false
  }

var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
    return has(range, 'lt') ? true : false
  }

var upperBoundKey = exports.upperBoundKey = function (range) {
    return (
       hasKey(range, 'lt')
    || hasKey(range, 'lte')
    || hasKey(range, 'max')
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))
    || undefined
    )
}

var upperBound = exports.upperBound = function (range) {
  var k = upperBoundKey(range)
  return k && range[k]
}

function id (e) { return e }

exports.toLtgt = function (range, _range, map, lower, upper) {
  _range = _range || {}
  map = map || id
  var defaults = arguments.length > 3
  var lb = exports.lowerBoundKey(range)
  var ub = exports.upperBoundKey(range)
  if(lb) {
    if(lb === 'gt') _range.gt = map(range.gt, false)
    else            _range.gte = map(range[lb], false)
  }
  else if(defaults)
    _range.gte = map(lower, false)

  if(ub) {
    if(ub === 'lt') _range.lt = map(range.lt, true)
    else            _range.lte = map(range[ub], true)
  }
  else if(defaults)
    _range.lte = map(upper, true)

  if(range.reverse != null)
    _range.reverse = !!range.reverse

  //if range was used mutably
  //(in level-sublevel it's part of an options object
  //that has more properties on it.)
  if(has(_range, 'max'))   delete _range.max
  if(has(_range, 'min'))   delete _range.min
  if(has(_range, 'start')) delete _range.start
  if(has(_range, 'end'))   delete _range.end

  return _range
}

exports.contains = function (range, key, compare) {
  compare = compare || exports.compare

  var lb = lowerBound(range)
  if(isDef(lb)) {
    var cmp = compare(key, lb)
    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
      return false
  }

  var ub = upperBound(range)
  if(isDef(ub)) {
    var cmp = compare(key, ub)
    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
      return false
  }

  return true
}

exports.filter = function (range, compare) {
  return function (key) {
    return exports.contains(range, key, compare)
  }
}

},
"nyacTWgKKqZ1xKyMnxonZfo2TAyqiZGZntieAhdElXY=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var u = require('./util')

var isArray = Array.isArray

function isFunction (f) {
  return 'function' === typeof f
}

function join (str) {
  return Array.isArray(str) ? str.join('.') : str
}

function toArray(str) {
  return isArray(str) ? str : str.split('.')
}

function isPerms (p) {
  return (
    p &&
    isFunction(p.pre) &&
    isFunction(p.test) &&
    isFunction(p.post)
  )
}

/*

perms:

a given capability may be permitted to call a particular api.
but only if a perms function returns true for the arguments
it passes.

suppose, an app may be given access, but may only create functions
with it's own properties.

create perms:
  {
    allow: ['add', 'query'], deny: [...],
    rules: {
      add: {
        call: function (value) {
          return (value.type === 'task' || value.type === '_task')
        },
      query: {
        call: function (value) {
          safe.contains(value, {path: ['content', 'type'], eq: 'task'}) ||
          safe.contains(value, {path: ['content', 'type'], eq: '_task'})
        },
        filter: function (value) {
          return (value.type === 'task' || value.type === '_task')
        }
      }
    }
  }
*/

module.exports = function (opts) {
  if(isPerms(opts)) return opts
  if(isFunction(opts)) return {pre: opts}
  var allow = null
  var deny = {}

  function perms (opts) {
    if(opts.allow) {
      allow = {}
      opts.allow.forEach(function (path) {
        u.set(allow, toArray(path), true)
      })
    }
    else allow = null

    if(opts.deny)
      opts.deny.forEach(function (path) {
        u.set(deny, toArray(path), true)
      })
    else deny = {}

    return this
  }

  if(opts) perms(opts)

  perms.pre = function (name, args) {
    name = isArray(name) ? name : [name]
    if(allow && !u.prefix(allow, name))
      return new Error('method:'+name + ' is not on whitelist')

    if(deny && u.prefix(deny, name))
      return new Error('method:'+name + ' is on blacklist')
  }

  perms.post = function (err, value) {
    //TODO
  }

  //alias for pre, used in tests.
  perms.test = function (name, args) {
    return perms.pre(name, args)
  }

  perms.get = function () {
    return {allow: allow, deny: deny}
  }

  return perms
}



},
"o5GlwujrnSLBqr/E1nzhxZiDaueCM5Clg2I7lg6QaHc=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var pull = require('pull-stream')
var Notify = require('pull-notify')
var toAddress = require('../../lib/util').toAddress
var mdm = require('mdmanifest')
var valid = require('../../lib/validators')
var apidoc = require('../../lib/apidocs').gossip
var u = require('../../lib/util')
var ping = require('pull-ping')
var Stats = require('statistics')
var isArray = Array.isArray
var Schedule = require('./schedule')
var Init = require('./init')

function isFunction (f) {
  return 'function' === typeof f
}

/*
Peers : [{
  key: id,
  host: ip,
  port: int,
  //to be backwards compatible with patchwork...
  announcers: {length: int}
  source: 'pub'|'manual'|'local'
}]
*/


module.exports = {
  name: 'gossip',
  version: '1.0.0',
  manifest: mdm.manifest(apidoc),
  permissions: {
    anonymous: {allow: ['ping']}
  },
  init: function (server, config) {
    var notify = Notify()
    var conf = config.gossip || {}
    var home = u.toAddress(server.getAddress())

    //Known Peers
    var peers = []

    function getPeer(id) {
      return u.find(peers, function (e) {
        return e && e.key === id
      })
    }

    var timer_ping = 5*6e4

    var gossip = {
      peers: function () {
        return peers
      },
      get: function (addr) {
        addr = u.toAddress(addr)
        return u.find(peers, function (a) {
          return (
            addr.port === a.port
            && addr.host === a.host
            && addr.key === a.key
          )
        })
      },
      connect: valid.async(function (addr, cb) {
        addr = u.toAddress(addr)
        if (!addr || typeof addr != 'object')
          return cb(new Error('first param must be an address'))

        if(!addr.key) return cb(new Error('address must have ed25519 key'))
        // add peer to the table, incase it isn't already.
        gossip.add(addr, 'manual')
        var p = gossip.get(addr)
        if(!p) return cb()

        p.stateChange = Date.now()
        p.state = 'connecting'
        server.connect(p, function (err, rpc) {
          if (err) {
            p.state = undefined
            p.failure = (p.failure || 0) + 1
            p.stateChange = Date.now()
            notify({ type: 'connect-failure', peer: p })
            server.emit('log:info', ['SBOT', p.host+':'+p.port+p.key, 'connection failed', err.message || err])
            p.duration.value(0)
            return (cb && cb(err))
          }
          else {
            p.state = 'connected'
            p.failure = 0
          }
          cb && cb(null, rpc)
        })

      }, 'string|object'),

      disconnect: valid.async(function (addr, cb) {
        var peer = this.get(addr)

        peer.state = 'disconnecting'
        peer.stateChange = Date.now()
        if(!peer || !peer.disconnect) cb && cb()
        else peer.disconnect(true, function (err) {
          peer.stateChange = Date.now()
        })

      }, 'string|object'),

      changes: function () {
        return notify.listen()
      },
      //add an address to the peer table.
      add: valid.sync(function (addr, source) {
        addr = u.toAddress(addr)
        if(!u.isAddress(addr))
          throw new Error('not a valid address:' + JSON.stringify(addr))
        // check that this is a valid address, and not pointing at self.

        if(addr.key === home.key) return
        if(addr.host === home.host && addr.port === home.port) return

        var f = gossip.get(addr)

        if(!f) {
          // new peer
          addr.source = source
          addr.announcers = 1
          addr.duration = Stats()
          peers.push(addr)
          notify({ type: 'discover', peer: addr, source: source || 'manual' })
          return addr
        }
        //don't count local over and over
        else if(f.source != 'local')
          f.announcers ++

        return f
      }, 'string|object', 'string?'),
      ping: function (opts) {
        var timeout = config.timers && config.timers.ping || 5*60e3
        //between 10 seconds and 30 minutes, default 5 min
        timeout = Math.max(10e3, Math.min(timeout, 30*60e3))
        return ping({timeout: timeout})
      }
    }

    Schedule (gossip, config, server)
    Init (gossip, config, server)
    //get current state

    server.on('rpc:connect', function (rpc, isClient) {
      var peer = getPeer(rpc.id)
      //don't track clients that connect, but arn't considered peers.
      //maybe we should though?
      if(!peer) return
      console.log('+connected', u.stringifyAddress(peer))
      //means that we have created this connection, not received it.
      peer.client = !!isClient
      peer.state = 'connected'
      peer.stateChange = Date.now()
      peer.disconnect = function (err, cb) {
        if(isFunction(err)) cb = err, err = null
        rpc.close(err, cb)
      }

      if(isClient) {
        //default ping is 5 minutes...
        var pp = ping({serve: true, timeout: timer_ping}, function (_) {})
        peer.ping = {rtt: pp.rtt, skew: pp.skew}
        pull(
          pp,
          rpc.gossip.ping({timeout: timer_ping}, function (err) {
            if(err.name === 'TypeError') peer.ping.fail = true
          }),
          pp
        )
      }

      rpc.on('closed', function () {
        console.log('-disconnected', u.stringifyAddress(peer))
        //track whether we have successfully connected.
        //or how many failures there have been.
        var since = peer.stateChange
        peer.stateChange = Date.now()
        if(peer.state === 'connected') //may be "disconnecting"
          peer.duration.value(peer.stateChange - since)
        peer.state = undefined
        notify({ type: 'disconnect', peer: peer })
        server.emit('log:info', ['SBOT', rpc.id, 'disconnect'])
      })

      notify({ type: 'connect', peer: peer })
    })

    return gossip
  }
}

















},
"oANZggQag1BRYauWPN7sm0lFM6yYAjlxqO30C0yFMG8=":
function (require, module, exports, __dirname, __filename) {

var Permissions  = require('./permissions')
var u            = require('./util')

module.exports = 

function createLocalCall(local, localApi, perms) {
  perms = Permissions(perms)

  function has(type, name) {
    return type === u.get(localApi, name)
  }

  function localCall(type, name, args) {

    if(name === 'emit')
      throw new Error('emit has been removed')

    //is there a way to know whether it's sync or async?
    if(type === 'async')
      if(has('sync', name)) {
        var cb = args.pop(), value
        try { value = u.get(local, name).apply(this, args) }
        catch (err) { return cb(err) }
        return cb(null, value)
      }

    if (!has(type, name))
      throw new Error('no '+type+':'+name)

    return u.get(local, name).apply(this, args)
  }

  return function (type, name, args) {
    var err = perms.pre(name, args)
    if(err) throw err
    return localCall.call(this, type, name, args)
  }
}



},
"oHkDWghwnaZ/de95LP9aOHd5b0YNSmYLTmHW5w+ANwE=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},
"oM8s3lAcPjewxN2ZNNDdK+k0CU4Pwi+98q5KWPxco68=":
function (require, module, exports, __dirname, __filename) {
var prr = require('prr')

function init (type, message, cause) {
  prr(this, {
      type    : type
    , name    : type
      // can be passed just a 'cause'
    , cause   : typeof message != 'string' ? message : cause
    , message : !!message && typeof message != 'string' ? message.message : message

  }, 'ewr')
}

// generic prototype, not intended to be actually used - helpful for `instanceof`
function CustomError (message, cause) {
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
  init.call(this, 'CustomError', message, cause)
}

CustomError.prototype = new Error()

function createError (errno, type, proto) {
  var err = function (message, cause) {
    init.call(this, type, message, cause)
    //TODO: the specificity here is stupid, errno should be available everywhere
    if (type == 'FilesystemError') {
      this.code    = this.cause.code
      this.path    = this.cause.path
      this.errno   = this.cause.errno
      this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message)
        + (this.cause.path ? ' [' + this.cause.path + ']' : '')
    }
    Error.call(this)
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, arguments.callee)
  }
  err.prototype = !!proto ? new proto() : new CustomError()
  return err
}

module.exports = function (errno) {
  var ce = function (type, proto) {
    return createError(errno, type, proto)
  }
  return {
      CustomError     : CustomError
    , FilesystemError : ce('FilesystemError')
    , createError     : ce
  }
}

},
"otM8QvULyYVzMFI9XM23DlX6C90Foz3Pk5mLi1pqvLc=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module stringify-entities
 * @fileoverview Encode HTML character references and character entities.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var entities = require('character-entities-html4');
var EXPRESSION_NAMED = require('./lib/expression.js');

/*
 * Methods.
 */

var has = {}.hasOwnProperty;

/*
 * List of enforced escapes.
 */

var escapes = ['"', '\'', '<', '>', '&', '`'];

/*
 * Map of characters to names.
 */

var characters = {};

(function () {
    var name;

    for (name in entities) {
        characters[entities[name]] = name;
    }
})();

/*
 * Regular expressions.
 */

var EXPRESSION_ESCAPE = new RegExp('[' + escapes.join('') + ']', 'g');
var EXPRESSION_SURROGATE_PAIR = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var EXPRESSION_BMP = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

/**
 * Transform `code` into a hexadecimal character reference.
 *
 * @param {number} code - Number to encode.
 * @return {string} - `code` encoded as hexadecimal.
 */
function characterCodeToHexadecimalReference(code) {
    return '&#x' + code.toString(16).toUpperCase() + ';';
}

/**
 * Transform `character` into a hexadecimal character
 * reference.
 *
 * @param {string} character - Character to encode.
 * @return {string} - `character` encoded as hexadecimal.
 */
function characterToHexadecimalReference(character) {
    return characterCodeToHexadecimalReference(character.charCodeAt(0));
}

/**
 * Transform `code` into an entity.
 *
 * @param {string} name - Name to wrap.
 * @return {string} - `name` encoded as hexadecimal.
 */
function toNamedEntity(name) {
    return '&' + name + ';';
}

/**
 * Transform `code` into an entity.
 *
 * @param {string} character - Character to encode.
 * @return {string} - `name` encoded as hexadecimal.
 */
function characterToNamedEntity(character) {
    return toNamedEntity(characters[character]);
}

/**
 * Encode special characters in `value`.
 *
 * @param {string} value - Value to encode.
 * @param {Object?} [options] - Configuration.
 * @param {boolean?} [options.escapeOnly=false]
 *   - Whether to only escape required characters.
 * @param {boolean?} [options.useNamedReferences=false]
 *   - Whether to use entities where possible.
 * @return {string} - Encoded `value`.
 */
function encode(value, options) {
    var settings = options || {};
    var escapeOnly = settings.escapeOnly;
    var named = settings.useNamedReferences;
    var map = named ? characters : null;

    value = value.replace(EXPRESSION_ESCAPE, function (character) {
        return map && has.call(map, character) ?
            toNamedEntity(map[character]) :
            characterToHexadecimalReference(character);
    });

    if (escapeOnly) {
        return value;
    }

    if (named) {
        value = value.replace(EXPRESSION_NAMED, characterToNamedEntity);
    }

    return value
        .replace(EXPRESSION_SURROGATE_PAIR, function (pair) {
            return characterCodeToHexadecimalReference(
                (pair.charCodeAt(0) - 0xD800) * 0x400 +
                pair.charCodeAt(1) - 0xDC00 + 0x10000
            );
        })
        .replace(EXPRESSION_BMP, characterToHexadecimalReference);
}

/**
 * Shortcut to escape special characters in HTML.
 *
 * @param {string} value - Value to encode.
 * @return {string} - Encoded `value`.
 */
function escape(value) {
    return encode(value, {
        'escapeOnly': true,
        'useNamedReferences': true
    });
}

encode.escape = escape;

/*
 * Expose.
 */

module.exports = encode;

},
"p1ZmNIwXcmirDM5E1sjRaey+BX6wKdjHWAQ0TmZU7fw=":
function (require, module, exports, __dirname, __filename) {

exports.compare = function (a, b) {

  if(Buffer.isBuffer(a)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var cmp = a[i] - b[i]
      if(cmp) return cmp
    }
    return a.length - b.length
  }

  return a < b ? -1 : a > b ? 1 : 0
}

function has(obj, key) {
  return Object.hasOwnProperty.call(obj, key)
}

// to be compatible with the current abstract-leveldown tests
// nullish or empty strings.
// I could use !!val but I want to permit numbers and booleans,
// if possible.

function isDef (val) {
  return val !== undefined && val !== ''
}

function has (range, name) {
  return Object.hasOwnProperty.call(range, name)
}

function hasKey(range, name) {
  return Object.hasOwnProperty.call(range, name) && name
}

var lowerBoundKey = exports.lowerBoundKey = function (range) {
    return (
       hasKey(range, 'gt')
    || hasKey(range, 'gte')
    || hasKey(range, 'min')
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))
    || undefined
    )
}

var lowerBound = exports.lowerBound = function (range) {
  var k = lowerBoundKey(range)
  return k && range[k]
  return (
      has(range, 'gt')                      ? range.gt
    : has(range, 'gte')                     ? range.gte
    : has(range, 'min')                     ? range.min
    : has(range, 'start') && !range.reverse ? range.start
    : has(range, 'end')   && range.reverse  ? range.end
    :                                         undefined
  )
}

exports.lowerBoundInclusive = function (range) {
  return has(range, 'gt') ? false : true
}

exports.upperBoundInclusive =
  function (range) {
    return has(range, 'lt') || !range.minEx ? false : true
  }

var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
    return has(range, 'gt') || range.minEx ? true : false
  }

var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
    return has(range, 'lt') ? true : false
  }

var upperBoundKey = exports.upperBoundKey = function (range) {
    return (
       hasKey(range, 'lt')
    || hasKey(range, 'lte')
    || hasKey(range, 'max')
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))
    || undefined
    )
}

var upperBound = exports.upperBound = function (range) {
  var k = upperBoundKey(range)
  return k && range[k]
}

function id (e) { return e }

exports.toLtgt = function (range, _range, map, lower, upper) {
  _range = _range || {}
  map = map || id
  var defaults = arguments.length > 3
  var lb = exports.lowerBoundKey(range)
  var ub = exports.upperBoundKey(range)
  if(lb) {
    if(lb === 'gt') _range.gt = map(range.gt)
    else            _range.gte = map(range[lb])
  }
  else if(defaults)
    _range.gte = map(lower)

  if(ub) {
    if(ub === 'lt') _range.lt = map(range.lt)
    else            _range.lte = map(range[ub])
  }
  else if(defaults)
    _range.lte = map(upper)

  if(range.reverse != null)
    _range.reverse = !!range.reverse

  return _range
}

exports.contains = function (range, key, compare) {
  compare = compare || exports.compare

  var lb = lowerBound(range)
  if(isDef(lb)) {
    var cmp = compare(key, lb)
    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
      return false
  }

  var ub = upperBound(range)
  if(isDef(ub)) {
    var cmp = compare(key, ub)
    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
      return false
  }

  return true
}

exports.filter = function (range, compare) {
  return function (key) {
    return exports.contains(range, key, compare)
  }
}

},
"p7QKOhmTGfBiDlhaPpzaNJvNy31EUOIzmap7gRRyYo0=":
function (require, module, exports, __dirname, __filename) {
var isArray = Array.isArray
var pull = require('pull-stream')

module.exports = function (gossip, config, server) {

  // populate peertable with configured seeds (mainly used in testing)
  var seeds = config.seeds

  ;(isArray(seeds)  ? seeds : [seeds]).filter(Boolean)
  .forEach(function (addr) { gossip.add(addr, 'seed') })

  // populate peertable with pub announcements on the feed
  pull(
    server.messagesByType({
      type: 'pub', live: true, keys: false
    }),
    pull.drain(function (msg) {
      if(!msg.content.address) return
      gossip.add(msg.content.address, 'pub')
    })
  )

  // populate peertable with announcements on the LAN multicast
  server.on('local', function (_peer) {
    gossip.add(_peer, 'local')
  })

}




},
"pN128HmfxJd3AhJuZ6vuPPgWw3XLAKVTqj/gX8bFlno=":
function (require, module, exports, __dirname, __filename) {
var slice = Array.prototype.slice

/* Given a function that takes n arguments and returns a continuable
    return a function that takes n arguments and maybe a n+1th argument
    which is a callback or takes n arguments and returns a continuable

This basically means that you can do this:

```js
var readFile = maybeCallback(function (uri) {
    return function (cb) { fs.readFile(uri, cb) }
})

readFile("./foo")(cb)
readFile("./foo", cb)
```

Be warned this breaks if the last argument is a function

*/
module.exports = maybeCallback

//  maybeCallback := (fn: (Any, ...) => Continuable<T>) =>
//      (Any, ..., Callback<T>?) => Continuable<T>
function maybeCallback(fn) {
    return function maybeContinuable() {
        var args = slice.call(arguments)
        var callback = args[args.length - 1]

        if (typeof callback === "function") {
            args.pop()
        }

        var continuable = fn.apply(null, args)

        if (typeof callback === "function") {
            continuable(callback)
        } else {
            return continuable
        }
    }
}

},
"pq9tHWt9lgwKW6IMcb/tWbAOxzeLT9AXi/Ih8FRq/P0=":
function (require, module, exports, __dirname, __filename) {
const util                 = require('util')
    , AbstractChainedBatch = require('abstract-leveldown').AbstractChainedBatch


function ChainedBatch (db) {
  AbstractChainedBatch.call(this, db)
  this.binding = db.binding.batch()
}


ChainedBatch.prototype._put = function (key, value) {
  this.binding.put(key, value)
}


ChainedBatch.prototype._del = function (key) {
  this.binding.del(key)
}


ChainedBatch.prototype._clear = function (key) {
  this.binding.clear(key)
}


ChainedBatch.prototype._write = function (options, callback) {
  this.binding.write(options, callback)
}

util.inherits(ChainedBatch, AbstractChainedBatch)


module.exports = ChainedBatch
},
"qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=":
function (require, module, exports, __dirname, __filename) {
var sources  = require('./sources')
var sinks    = require('./sinks')
var throughs = require('./throughs')
var u        = require('pull-core')

function isFunction (fun) {
  return 'function' === typeof fun
}

function isReader (fun) {
  return fun && (fun.type === "Through" || fun.length === 1)
}
var exports = module.exports = function pull () {
  var args = [].slice.call(arguments)

  if(isReader(args[0]))
    return function (read) {
      args.unshift(read)
      return pull.apply(null, args)
    }

  var read = args.shift()

  //if the first function is a duplex stream,
  //pipe from the source.
  if(isFunction(read.source))
    read = read.source

  function next () {
    var s = args.shift()

    if(null == s)
      return next()

    if(isFunction(s)) return s

    return function (read) {
      s.sink(read)
      //this supports pipeing through a duplex stream
      //pull(a, b, a) "telephone style".
      //if this stream is in the a (first & last position)
      //s.source will have already been used, but this should never be called
      //so that is okay.
      return s.source
    }
  }

  while(args.length)
    read = next() (read)

  return read
}


for(var k in sources)
  exports[k] = u.Source(sources[k])

for(var k in throughs)
  exports[k] = u.Through(throughs[k])

for(var k in sinks)
  exports[k] = u.Sink(sinks[k])

var maybe = require('./maybe')(exports)

for(var k in maybe)
  exports[k] = maybe[k]

exports.Duplex  = 
exports.Through = exports.pipeable       = u.Through
exports.Source  = exports.pipeableSource = u.Source
exports.Sink    = exports.pipeableSink   = u.Sink



},
"qdzmw1u79vk3uHg1fctAnXUBDtlOHUz/rw2Lildcq0E=":
function (require, module, exports, __dirname, __filename) {
var ltgt = require('ltgt')

//compare two array items
function isArrayLike (a) {
  return Array.isArray(a) || Buffer.isBuffer(a)
}

function isPrimitive (a) {
  return 'string' === typeof a || 'number' === typeof a
}

function has(o, k) {
  return Object.hasOwnProperty.call(o, k)
}

function compare (a, b) {
  if(isArrayLike(a) && isArrayLike(b)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var c = compare(a[i], b[i])
      if(c) return c
    }
    return a.length - b.length
  }
  if(isPrimitive(a) && isPrimitive(b))
    return a < b ? -1 : a > b ? 1 : 0

  throw new Error('items not comparable:'
    + JSON.stringify(a) + ' ' + JSON.stringify(b))
}

//this assumes that the prefix is of the form:
// [Array, string]

function prefix (a, b) {
  if(a.length > b.length) return false
  var l = a.length - 1
  var lastA = a[l]
  var lastB = b[l]

  if(typeof lastA !== typeof lastB)
    return false

  if('string' == typeof lastA
    && 0 != lastB.indexOf(lastA))
      return false
  
  //handle cas where there is no key prefix
  //(a hook on an entire sublevel)
  if(a.length == 1 && isArrayLike(lastA)) l ++
  
  while(l--) {
    if(compare(a[l], b[l])) return false
  }
  return true
}

exports = module.exports = function (range, key, _compare) {
  _compare = _compare || compare
  //handle prefix specially,
  //check that everything up to the last item is equal
  //then check the last item starts with
  if(isArrayLike(range)) return prefix(range, key)

  return ltgt.contains(range, key, _compare)
}

function addPrefix(prefix, range) {
  var o = ltgt.toLtgt(range, null, function (key) {
    return [prefix, key]
  })

  //if there where no ranges, then then just use a prefix.
  if(!has(o, 'gte') && !has(o, 'lte')) return [prefix]

  return o
}

exports.compare = compare
exports.prefix = prefix
exports.addPrefix = addPrefix

},
"qisTu/X0dmzjf7wjUr2/duoiq/mlHB/SLJ0gZmmRlUk=":
function (require, module, exports, __dirname, __filename) {
module.exports = create

var Buffer = require('buffer').Buffer

function create(size) {
  return new Buffer(size)
}

},
"qredUlYsK1dX/qhYl1PuZ7TmndbtJuvjGBIS9b5kJfA=":
function (require, module, exports, __dirname, __filename) {
var EventEmitter = require('events').EventEmitter
var addpre = require('./range').addPrefix

var errors = require('levelup/lib/errors')

function isFunction (f) {
  return 'function' === typeof f
}

function isString (s) {
  return 'string' === typeof s
}

function isObject (o) {
  return o && 'object' === typeof o
}

var version = require('./package.json').version

var sublevel = module.exports = function (nut, prefix, createStream, options) {
  var emitter = new EventEmitter()
  emitter.sublevels = {}
  emitter.options = options

  emitter.version = version

  emitter.methods = {}
  prefix = prefix || []

  function errback (err) { if (err) emitter.emit('error', err) }

  createStream = createStream || function (e) { return e }

  function mergeOpts(opts) {
    var o = {}
    if(options)
      for(var k in options)
        if(options[k] != undefined)o[k] = options[k]
    if(opts)
      for(var k in opts)
        if(opts[k] != undefined) o[k] = opts[k]
    return o
  }

  emitter.put = function (key, value, opts, cb) {
    if('function' === typeof opts) cb = opts, opts = {}
    if(!cb) cb = errback

    nut.apply([{
      key: key, value: value,
      prefix: prefix.slice(), type: 'put'
    }], mergeOpts(opts), function (err) {
      if(!err) { emitter.emit('put', key, value); cb(null) }
      if(err) return cb(err)
    })
  }

  emitter.prefix = function () {
    return prefix.slice()
  }

  emitter.del = function (key, opts, cb) {
    if('function' === typeof opts) cb = opts, opts = {}
    if(!cb) cb = errback

    nut.apply([{
      key: key,
      prefix: prefix.slice(), type: 'del'
    }], mergeOpts(opts), function (err) {
      if(!err) { emitter.emit('del', key); cb(null) }
      if(err) return cb(err)
    })
  }

  emitter.batch = function (ops, opts, cb) {
    if('function' === typeof opts)
      cb = opts, opts = {}
    if(!cb) cb = errback

    ops = ops.map(function (op) {
      return {
        key:           op.key,
        value:         op.value,
        prefix:        op.prefix || prefix,
        keyEncoding:   op.keyEncoding,    // *
        valueEncoding: op.valueEncoding,  // * (TODO: encodings on sublevel)
        type:          op.type
      }
    })

    nut.apply(ops, mergeOpts(opts), function (err) {
      if(!err) { emitter.emit('batch', ops); cb(null) }
      if(err) return cb(err)
    })
  }

  emitter.get = function (key, opts, cb) {
    if('function' === typeof opts)
      cb = opts, opts = {}
    nut.get(key, prefix, mergeOpts(opts), function (err, value) {
      if(err) cb(new errors.NotFoundError('Key not found in database', err))
      else cb(null, value)
    })
  }

  emitter.clone = function(opts) {
    return sublevel(nut, prefix, createStream, mergeOpts(opts))
  }

  emitter.sublevel = function (name, opts) {
    return emitter.sublevels[name] =
      emitter.sublevels[name] || sublevel(nut, prefix.concat(name), createStream, mergeOpts(opts))
  }

  emitter.pre = function (key, hook) {
    if(isFunction(key)) return nut.pre([prefix], key)
    if(isString(key)) return nut.pre([prefix, key], hook)
    if(isObject(key)) return nut.pre(addpre(prefix, key), hook)

    throw new Error('not implemented yet')
  }

  emitter.post = function (key, hook) {
    if(isFunction(key)) return nut.post([prefix], key)
    if(isString(key))   return nut.post([prefix, key], hook)
    if(isObject(key))   return nut.post(addpre(prefix, key), hook)

    //TODO: handle ranges, needed for level-live-stream, etc.
    throw new Error('not implemented yet')
  }

  emitter.readStream =
  emitter.createReadStream = function (opts) {
    opts = mergeOpts(opts)
    opts.prefix = prefix
    var stream
    var it = nut.iterator(opts, function (err, it) {
      stream.setIterator(it)
    })

    stream = createStream(opts, nut.createDecoder(opts))
    if(it) stream.setIterator(it)

    return stream
  }

  emitter.valueStream =
  emitter.createValueStream = function (opts) {
    opts = opts || {}
    opts.values = true
    opts.keys = false
    return emitter.createReadStream(opts)
  }

  emitter.keyStream =
  emitter.createKeyStream = function (opts) {
    opts = opts || {}
    opts.values = false
    opts.keys = true
    return emitter.createReadStream(opts)
  }

  emitter.close = function (cb) {
    //TODO: deregister all hooks
    cb = cb || function () {}
    if (!prefix.length) nut.close(cb)
    else process.nextTick(cb)
  }

  emitter.isOpen = nut.isOpen
  emitter.isClosed = nut.isClosed

  return emitter
}

},
"quxwChILv3+jFc11isLbWrWFYjcxftef8FE6U6bZg7o=":
function (require, module, exports, __dirname, __filename) {
module.exports = function(haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low < 0 || low >= haystack.length)
      throw new RangeError("invalid lower bound");
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high < low || high >= haystack.length)
      throw new RangeError("invalid upper bound");
  }

  while(low <= high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    /* Too low. */
    if(cmp < 0.0) 
      low  = mid + 1;

    /* Too high. */
    else if(cmp > 0.0)
      high = mid - 1;
    
    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}

},
"rC98x2QltpxXInWZPxaa9LZrWailB5Cjw3C/6pRatKA=":
function (require, module, exports, __dirname, __filename) {
var EventEmitter = require('events').EventEmitter
var addpre = require('./range').addPrefix

var errors = require('levelup/lib/errors')

function isFunction (f) {
  return 'function' === typeof f
}

function isString (s) {
  return 'string' === typeof s
}

function isObject (o) {
  return o && 'object' === typeof o
}

var version = require('./package.json').version

var sublevel = module.exports = function (nut, prefix, createStream, options) {
  var emitter = new EventEmitter()
  emitter.sublevels = {}
  emitter.options = options

  emitter.version = version

  emitter.methods = {}
  prefix = prefix || []

  function errback (err) { if (err) emitter.emit('error', err) }

  createStream = createStream || function (e) { return e }

  function mergeOpts(opts) {
    var o = {}
    if(options)
      for(var k in options)
        if(options[k] != undefined)o[k] = options[k]
    if(opts)
      for(var k in opts)
        if(opts[k] != undefined) o[k] = opts[k]
    return o
  }

  emitter.put = function (key, value, opts, cb) {
    if('function' === typeof opts) cb = opts, opts = {}
    if(!cb) cb = errback

    nut.apply([{
      key: key, value: value,
      prefix: prefix.slice(), type: 'put'
    }], mergeOpts(opts), function (err) {
      if(!err) { emitter.emit('put', key, value); cb(null) }
      if(err) return cb(err)
    })
  }

  emitter.prefix = function () {
    return prefix.slice()
  }

  emitter.del = function (key, opts, cb) {
    if('function' === typeof opts) cb = opts, opts = {}
    if(!cb) cb = errback

    nut.apply([{
      key: key,
      prefix: prefix.slice(), type: 'del'
    }], mergeOpts(opts), function (err) {
      if(!err) { emitter.emit('del', key); cb(null) }
      if(err) return cb(err)
    })
  }

  emitter.batch = function (ops, opts, cb) {
    if('function' === typeof opts)
      cb = opts, opts = {}
    if(!cb) cb = errback

    ops = ops.map(function (op) {
      return {
        key:           op.key,
        value:         op.value,
        prefix:        op.prefix || prefix,
        keyEncoding:   op.keyEncoding,    // *
        valueEncoding: op.valueEncoding,  // * (TODO: encodings on sublevel)
        type:          op.type
      }
    })

    nut.apply(ops, mergeOpts(opts), function (err) {
      if(!err) { emitter.emit('batch', ops); cb(null) }
      if(err) return cb(err)
    })
  }

  emitter.get = function (key, opts, cb) {
    if('function' === typeof opts)
      cb = opts, opts = {}
    nut.get(key, prefix, mergeOpts(opts), function (err, value) {
      if(err) cb(new errors.NotFoundError('Key not found in database', err))
      else cb(null, value)
    })
  }

  emitter.clone = function(opts) {
    return sublevel(nut, prefix, createStream, mergeOpts(opts))
  }

  emitter.sublevel = function (name, opts) {
    return emitter.sublevels[name] =
      emitter.sublevels[name] || sublevel(nut, prefix.concat(name), createStream, mergeOpts(opts))
  }

  emitter.pre = function (key, hook) {
    if(isFunction(key)) return nut.pre([prefix], key)
    if(isString(key)) return nut.pre([prefix, key], hook)
    if(isObject(key)) return nut.pre(addpre(prefix, key), hook)

    throw new Error('not implemented yet')
  }

  emitter.post = function (key, hook) {
    if(isFunction(key)) return nut.post([prefix], key)
    if(isString(key))   return nut.post([prefix, key], hook)
    if(isObject(key))   return nut.post(addpre(prefix, key), hook)

    //TODO: handle ranges, needed for level-live-stream, etc.
    throw new Error('not implemented yet')
  }

  emitter.createReadStream = function (opts) {
    opts = mergeOpts(opts)
    opts.prefix = prefix
    var stream
    var it = nut.iterator(opts, function (err, it) {
      stream.setIterator(it)
    })

    stream = createStream(opts, nut.createDecoder(opts))
    if(it) stream.setIterator(it)

    return stream
  }

  emitter.createValueStream = function (opts) {
    opts = opts || {}
    opts.values = true
    opts.keys = false
    return emitter.createReadStream(opts)
  }

  emitter.createKeyStream = function (opts) {
    opts = opts || {}
    opts.values = false
    opts.keys = true
    return emitter.createReadStream(opts)
  }

  emitter.close = function (cb) {
    //TODO: deregister all hooks
    process.nextTick(cb || function () {})
  }

  return emitter
}

},
"rFQTFWgU44ZunWD7LzMCjKPOqfvxcsYimn3q41vQzEE=":
function (require, module, exports, __dirname, __filename) {
var util = require('./util')

var FLOAT_LENGTH = 8

function identity(value) {
  return value
}

function shortlexEncode(codec) {
  return function (source, base) {
    // stupid lazy implementation
    // TODO: allow length getter to be provided
    var length = util.encodeFloat(source.length)
    var body = codec.encode(source, base)
    return Buffer.concat([ length, body ])
  }
}

function shortlexDecode(codec) {
  return function (buffer) {
    // stupid lazy implementation
    return codec.decode(this, buffer.slice(FLOAT_LENGTH))
  }
}

function shortlexParse(codec) {
  // TODO
  return function (buffer, base) {
    throw new Error('NYI')
  }
}

function shortlex(codec) {
  return {
    encode: shortlexEncode(codec),
    decode: shortlexDecode(codec),
    parse: shortlexParse(codec)
  }
}

//
// pairs of encode/decode functions
//
var codecs = exports

codecs.HEX = {
  encode: function (source) {
    return new Buffer(source, 'hex')
  },
  decode: function (buffer) {
    return buffer.toString('hex')
  }
}

codecs.UINT8 = {
  encode: identity,
  decode: identity,
  escape: util.escapeFlat,
  unescape: util.unescapeFlat
}

codecs.UINT8_SHORTLEX = shortlex(codecs.UINT8)

codecs.UTF8 = {
  encode: function (source) {
    return new Buffer(source, 'utf8')
  },
  decode: function (buffer) {
    return buffer.toString('utf8')
  },
  escape: util.escapeFlatLow,
  unescape: util.unescapeFlatLow
}

codecs.UTF8_SHORTLEX = shortlex(codecs.UTF8)

codecs.POSITIVE_FLOAT = {
  length: FLOAT_LENGTH,
  encode: util.encodeFloat,
  decode: util.decodeFloat
}

codecs.NEGATIVE_FLOAT = {
  length: FLOAT_LENGTH,
  encode: util.encodeFloat,
  decode: function (buffer) {
    return util.decodeFloat(buffer, null, true)
  }
}

codecs.POST_EPOCH_DATE = {
  length: FLOAT_LENGTH,
  encode: util.encodeFloat,
  decode: function (buffer) {
    return new Date(util.decodeFloat(buffer))
  }
}

codecs.PRE_EPOCH_DATE = {
  length: FLOAT_LENGTH,
  encode: util.encodeFloat,
  decode: function (buffer) {
    return new Date(util.decodeFloat(buffer, null, true))
  }
}

//
// base encoding for complex structures
//
codecs.LIST = {
  encode: util.encodeList,
  decode: util.decodeList
}

codecs.TUPLE = shortlex(codecs.LIST)

//
// member order is preserved and accounted for in sort (except for number keys)
//
codecs.HASH = {
  // TODO
  // encode: util.encodeHash,
  // decode: util.decodeHash
}

codecs.RECORD = shortlex(codecs.HASH)

},
"rXXYA2x9VEX66QDVrxljCKnFWifeueQAQojoYzUD3zI=":
function (require, module, exports, __dirname, __filename) {
var util = exports

//
// buffer compare
//
util.compare = require('typewise-core/collation').bitwise

//
// buffer equality
//
util.equal = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    return

  if (a === b)
    return true

  if (typeof a.equals === 'function')
    return a.equals(b)

  return util.compare(a, b) === 0
}

var assert = util.assert = function (test, message) {
  if (!test)
    throw new TypeError(message)
}

var FLOAT_LENGTH = 8

util.invertBytes = function (buffer) {
  var bytes = []
  for (var i = 0, end = buffer.length; i < end; ++i) {
    bytes.push(~buffer[i])
  }

  return new Buffer(bytes)
}

util.encodeFloat = function (value) {
  var buffer = new Buffer(FLOAT_LENGTH)
  if (value < 0) {
    //
    // write negative numbers as negated positive values to invert bytes
    //
    buffer.writeDoubleBE(-value.valueOf(), 0)
    return util.invertBytes(buffer)
  }

  //
  // normalize -0 values to 0
  //
  buffer.writeDoubleBE(value.valueOf() || 0, 0)
  return buffer
}

util.decodeFloat = function (buffer, base, negative) {
  assert(buffer.length === FLOAT_LENGTH, 'Invalid float encoding length')

  if (negative)
    buffer = util.invertBytes(buffer)

  var value = buffer.readDoubleBE(0)
  return negative ? -value : value
}

//
// sigil for controlling the escapement functions (TODO: clean this up)
//
var SKIP_HIGH_BYTES = {}

util.escapeFlat = function (buffer, options) {
  //
  // escape high and low bytes 0x00 and 0xff (and by necessity, 0x01 and 0xfe)
  //
  var b, bytes = []
  for (var i = 0, end = buffer.length; i < end; ++i) {
    b = buffer[i]

    //
    // escape low bytes with 0x01 and by adding 1
    //
    if (b === 0x01 || b === 0x00)
      bytes.push(0x01, b + 1)

    //
    // escape high bytes with 0xfe and by subtracting 1
    //
    else if (options !== SKIP_HIGH_BYTES && (b === 0xfe || b === 0xff))
      bytes.push(0xfe, b - 1)

    //
    // no escapement needed
    //
    else
      bytes.push(b)
  }

  return new Buffer(bytes)
}

util.unescapeFlat = function (buffer, options) {
  var b, bytes = []
  //
  // don't escape last byte
  //
  for (var i = 0, end = buffer.length; i < end; ++i) {
    b = buffer[i]

    //
    // if low-byte escape tag use the following byte minus 1
    //
    if (b === 0x01)
      bytes.push(buffer[++i] - 1)

    //
    // if high-byte escape tag use the following byte plus 1
    //
    else if (options !== SKIP_HIGH_BYTES && b === 0xfe)
      bytes.push(buffer[++i] + 1)

    //
    // no unescapement needed
    //
    else
      bytes.push(b)
  }
  return new Buffer(bytes)
}

util.escapeFlatLow = function (buffer) {
  return util.escapeFlat(buffer, SKIP_HIGH_BYTES)
}

util.unescapeFlatLow = function (buffer) {
  return util.unescapeFlat(buffer, SKIP_HIGH_BYTES)
}

util.encodeList = function (source, base) {
  // TODO: cycle detection
  var buffers = []
  var undecodable

  for (var i = 0, end = source.length; i < end; ++i) {
    var buffer = base.encode(source[i], null)

    //
    // bypass assertions for undecodable types (i.e. range bounds)
    //
    undecodable || (undecodable = buffer.undecodable)
    if (undecodable) {
      buffers.push(buffer)
      continue
    }

    var sort = base.getType(buffer[0])
    assert(sort, 'List encoding failure: ' + buffer)

    //
    // escape sorts if it requires it and add closing byte for element
    //
    if (sort.codec && sort.codec.escape)
      buffers.push(sort.codec.escape(buffer), new Buffer([ 0x00 ]))

    else
      buffers.push(buffer)
  }

  //
  // close the list with an end byte
  //
  buffers.push(new Buffer([ 0x00 ]))
  buffer = Buffer.concat(buffers)

  //
  // propagate undecoable bit if set
  //
  undecodable && (buffer.undecodable = undecodable)
  return buffer
}

util.decodeList = function (buffer, base) {
  var result = util.parse(buffer, base)

  assert(result[1] === buffer.length, 'Invalid encoding')
  return result[0]
}

util.encodeHash = function (source, base) {
  //
  // packs hash into an array, e.g. `[ k1, v1, k2, v2, ... ]`
  //
  var list = []
  Object.keys(source).forEach(function(key) {
    list.push(key)
    list.push(source[key])
  })
  return util.encodeList(list, base)
}

util.decodeHash = function (buffer, base) {
  var list = util.decodeList(buffer, base)
  var hash = Object.create(null)

  for (var i = 0, end = list.length; i < end; ++i) {
    hash[list[i]] = list[++i]
  }

  return hash
}

//
// base parser for nested/recursive sorts
//
util.parse = function (buffer, base, sort) {
  //
  // parses and returns the first sort on the buffer and total bytes consumed
  //
  var codec = sort && sort.codec
  var index, end

  //
  // nullary
  //
  if (sort && !codec)
    return [ base.decode(new Buffer([ sort.byte ]), null), 0 ]

  //
  // custom parse implementation provided by sort
  //
  if (codec && codec.parse)
    return codec.parse(buffer, base, sort)

  //
  // fixed length sort, decode fixed bytes
  //
  var length = codec && codec.length
  if (typeof length === 'number')
    return [ codec.decode(buffer.slice(0, length)), length ]

  //
  // escaped sort, seek to end byte and unescape
  //
  if (codec && codec.unescape) {
    for (index = 0, end = buffer.length; index < end; ++index) {
      if (buffer[index] === 0x00)
        break
    }

    assert(index < buffer.length, 'No closing byte found for sequence')
    var unescaped = codec.unescape(buffer.slice(0, index))

    //
    // add 1 to index to account for closing tag byte
    //
    return [ codec.decode(unescaped), index + 1 ]
  }

  //
  // recursive sort, resolve each item iteratively
  //
  index = 0
  var list = []
  var next
  while ((next = buffer[index]) !== 0x00) {
    sort = base.getType(next)
    var result = util.parse(buffer.slice(index + 1), base, sort)
    list.push(result[0])

    //
    // offset current index by bytes consumed (plus a byte for the sort tag)
    //
    index += result[1] + 1
    assert(index < buffer.length, 'No closing byte found for nested sequence')
  }

  //
  // return parsed list and bytes consumed (plus a byte for the closing tag)
  //
  return [ list, index + 1 ]
}

//
// helpers for encoding boundary types
//
function encodeBound(data, base) {
  var prefix = data.prefix
  var buffer = prefix ? base.encode(prefix, null) : new Buffer([ data.byte ])

  if (data.upper)
    buffer = Buffer.concat([ buffer, new Buffer([ 0xff ]) ])

  return util.encodedBound(data, buffer)
}

util.encodeBound = function (data, base) {
  return util.encodedBound(data, encodeBound(data, base))
}

util.encodeBaseBound = function (data, base) {
  return util.encodedBound(data, new Buffer([ data.upper ? 0xff : 0x00 ]))
}

util.encodeListBound = function (data, base) {
  var buffer = encodeBound(data, base)

  if (data.prefix) {
    //
    // trim off end byte if a prefix, and do some hackery if an upper bound
    //
    var endByte = buffer[buffer.length - 1]
    buffer = buffer.slice(0, -1)
    if (data.upper)
      buffer[buffer.length - 1] = endByte
  }

  return util.encodedBound(data, buffer)
}

//
// add some metadata to generated buffer instance
//
util.encodedBound = function (data, buffer) {
  buffer.undecodable = true
  return buffer
}

},
"reioqDzeG703e/zvg4J/MTLRGdlLnppYfOQTf+IfSCw=":
function (require, module, exports, __dirname, __filename) {
module.exports = function(source, encoding) {
  return source.toString(encoding)
}

},
"rkQ8ddGWXPYKU9rtSJEjLGMvOI45KX32dWOPe6Q0Hz4=":
function (require, module, exports, __dirname, __filename) {

var keys = exports.keys =
function (object) {
  return values(Object.keys(object))
}

function abortCb(cb, abort, onAbort) {
  cb(abort)
  onAbort && onAbort(abort === true ? null: abort)
  return
}

var once = exports.once =
function (value, onAbort) {
  return function (abort, cb) {
    if(abort)
      return abortCb(cb, abort, onAbort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}

var values = exports.values = exports.readArray =
function (array, onAbort) {
  if(!array)
    return function (abort, cb) {
      if(abort) return abortCb(cb, abort, onAbort)
      return cb(true)
    }
  if(!Array.isArray(array))
    array = Object.keys(array).map(function (k) {
      return array[k]
    })
  var i = 0
  return function (abort, cb) {
    if(abort)
      return abortCb(cb, abort, onAbort)
    cb(i >= array.length || null, array[i++])
  }
}


var count = exports.count =
function (max) {
  var i = 0; max = max || Infinity
  return function (end, cb) {
    if(end) return cb && cb(end)
    if(i > max)
      return cb(true)
    cb(null, i++)
  }
}

var infinite = exports.infinite =
function (generate) {
  generate = generate || Math.random
  return function (end, cb) {
    if(end) return cb && cb(end)
    return cb(null, generate())
  }
}

//a stream that ends immediately.
var empty = exports.empty = function () {
  return function (abort, cb) {
    cb(true)
  }
}

//a stream that errors immediately.
var error = exports.error = function (err) {
  return function (abort, cb) {
    cb(err)
  }
}


},
"rrxGe8mGpBGFX5t7qxsIqkWpsh36MqWqwkXb1AuygB4=":
function (require, module, exports, __dirname, __filename) {
var Buffer = require('buffer').Buffer

module.exports = function(targets, hint) {
  return hint !== undefined ?
    Buffer.concat(targets, hint) :
    Buffer.concat(targets)
}

},
"rw6wQdeShnSEjU8e/YNtOxUjBtvczz3KxnDJvn1GGAY=":
function (require, module, exports, __dirname, __filename) {
function wrap (fn, hook) {
  return function () {
    return hook.call(this, fn, [].slice.call(arguments))
  }
}

module.exports = function hookable(fn) {

  function hooked () {
    return fn.apply(this, [].slice.call(arguments))
  }

  hooked.hook = function (hook) {
    fn = wrap(fn, hook)
    return this
  }

  return hooked
}

},
"sXcqHGGdcqeUvIykBuV04nx7TY7lIdjbV9lu4Tav99o=":
function (require, module, exports, __dirname, __filename) {

var sources  = require('./sources')
var sinks    = require('./sinks')
var throughs = require('./throughs')
var u        = require('pull-core')

for(var k in sources)
  exports[k] = u.Source(sources[k])

for(var k in throughs)
  exports[k] = u.Through(throughs[k])

for(var k in sinks)
  exports[k] = u.Sink(sinks[k])

var maybe = require('./maybe')(exports)

for(var k in maybe)
  exports[k] = maybe[k]

exports.Duplex  = 
exports.Through = exports.pipeable       = u.Through
exports.Source  = exports.pipeableSource = u.Source
exports.Sink    = exports.pipeableSink   = u.Sink



},
"sYYh8iTlgmQnvaj5q28F3GpYLhBlvNuOJCz1FSRsRL8=":
function (require, module, exports, __dirname, __filename) {
// Queue
// returns a function which...
// - only acts if not already acting
// - automatically requeues if the task is not yet done
// - `delay`: ms, amount of time to wait before calling again
// - `n`: number, amount of simultaneous calls allowed
// - `label`: string, name of the task (for logging)
// - `fun`: function(cb(done?)), calls cb(true) when done, cb(false) when needs to requeue

function isFunction (f) {
  return 'function' === typeof f
}

function Work(avgWait, n, label, fun) {
  n  = 1
  var doing = 0, timeout

  var timers = []

  function clear (timer) {
    var i = timers.indexOf(timer)
    clearTimeout(timer[i])
    times.splice(i, 1)
  }

  function delay (job, d) {
    var i
    var timer = setTimeout(function () {
      timers.splice(timers.indexOf(timer), 1); job()
    }, d)
    timer.unref()
    timers.push(timer)

    return timer
  }

  function job () {
    // abort if already doing too many

    if(doing >= n) return
    doing++

    // run the behavior
    fun(function (done) {
      doing--
      if(done) {
        // we're done, dont requeue
        return
      }

      // requeue after a delay
      var wait = ~~(avgWait/2 + avgWait*Math.random())
      delay(job, wait)
    })
  }

  job.abort = function () {
    timers.forEach(clear)
  }

  return job
}

function find (jobs, test) {
  for(var k in jobs)
    if(test(jobs[k])) return k
  return -1
}

function max (jobs, test) {
  var M = -Infinity, i = -1
  for(var k in jobs) {
    var m = test(jobs[k], k, jobs)
    if(m > M) {
      M = m
      i = k
    }
  }
  return k
}

module.exports = function (work) {

  var jobs = []

  var queue = {
    push: function (job) {
      jobs.push(job)
    },

    pull: function (id) {
      var test = isFunction(id) ? id : function (e) { return e.id === id }
      if(!this.length()) return
      if(!id)
        return jobs.shift()
      else {
        var index = find(jobs, test)
        if(~index) return jobs.splice(index, 1)[0]
      }
    },

    each: function (iter) {
      jobs.forEach(iter)
    },

    length: function () {
      return jobs.length
    },

    toJSON: function () {
      return jobs.slice()
    }
  }

  Work(100, 2, null, function (done) {
    if(!queue.length()) return done()
    work(queue, done)
  }) ()

  return queue
}








},
"sgrUsQaJii/+fVMF8OmANMsLjyzvxtngBdS2/y/fIUg=":
function (require, module, exports, __dirname, __filename) {
var AbstractLevelDOWN = require('./abstract-leveldown')

function isLevelDOWN (db) {
  if (!db || typeof db !== 'object')
    return false
  return Object.keys(AbstractLevelDOWN.prototype).filter(function (name) {
    // TODO remove approximateSize check when method is gone
    return name[0] != '_' && name != 'approximateSize'
  }).every(function (name) {
    return typeof db[name] == 'function'
  })
}

module.exports = isLevelDOWN

},
"t13BK5xaFAWr3BUUvcdqTAcinVHiCcj+sA9voPbCVeM=":
function (require, module, exports, __dirname, __filename) {
var defer     = require('pull-defer')
var intersect = require('intersect')
var cont      = require('cont')
var pull      = require('pull-stream')
var ltgt      = require('ltgt')
var paramap   = require('pull-paramap')
var util      = require('../util')
//can use this strategy when there are multiple
//indexes that match the query.

module.exports = function (db, query, opts) {
  var valid = true

  if(query.length <= 1) return

  // check whether we have matching indexes for this query.
  var indexable = query.map(util.toIndexable).filter(Boolean)

  if(indexable.length <= 1) return

  var indexes = indexable.map(function (q) {
    var i = db.getIndex(q.path)
    if(!i) valid = false
    return i
  })


  if(!valid) return


  return {
    indexes: indexes,
    name: 'intersection',
    exec: function () {
      var stream = defer.source()

      var filter = require('../util').createFilter(query)

      //TODO: implement a streaming lookup
      //though this can be deprioritized until we have big enough
      //data that we are mostly using disk indexes.
      cont.para(
        indexes.map(function (index, i) {
          return function (cb) {
            pull(index.read(indexable[i]), pull.collect(cb))
          }
        })
      ) (function (err, ary) {

        stream.resolve(pull(
          pull.values(intersect(ary)),
          paramap(function (key, cb) {
            db.get(key, function (err, value) {
              cb(null, {key: key, value: value})
            })
          }),
          pull.filter(function (data) {
            return filter(data.value)
          })
        ))
      })

      return stream
    }
  }

}

},
"t6kB2z9SUdPBehkQHj1S0JQKPE2Dst5aWLqLQwfwDbs=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module parse-entities
 * @fileoverview Parse HTML character references: fast, spec-compliant,
 *   positional information.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Dependencies.
 */

var characterEntities = require('character-entities');
var legacy = require('character-entities-legacy');
var invalid = require('character-reference-invalid');

/*
 * Methods.
 */

var fromCharCode = String.fromCharCode;
var has = Object.prototype.hasOwnProperty;
var noop = Function.prototype;

/*
 * Reference types.
 */

var NAMED = 'named';
var HEXADECIMAL = 'hexadecimal';
var DECIMAL = 'decimal';

/*
 * Map of bases.
 */

var BASE = {};

BASE[HEXADECIMAL] = 16;
BASE[DECIMAL] = 10;

/*
 * Warning messages.
 */

var NUMERIC_REFERENCE = 'Numeric character references';
var NAMED_REFERENCE = 'Named character references';
var TERMINATED = ' must be terminated by a semicolon';
var VOID = ' cannot be empty';

var NAMED_NOT_TERMINATED = 1;
var NUMERIC_NOT_TERMINATED = 2;
var NAMED_EMPTY = 3;
var NUMERIC_EMPTY = 4;
var NAMED_UNKNOWN = 5;
var NUMERIC_DISALLOWED = 6;
var NUMERIC_PROHIBITED = 7;

var MESSAGES = {};

MESSAGES[NAMED_NOT_TERMINATED] = NAMED_REFERENCE + TERMINATED;
MESSAGES[NUMERIC_NOT_TERMINATED] = NUMERIC_REFERENCE + TERMINATED;
MESSAGES[NAMED_EMPTY] = NAMED_REFERENCE + VOID;
MESSAGES[NUMERIC_EMPTY] = NUMERIC_REFERENCE + VOID;
MESSAGES[NAMED_UNKNOWN] = NAMED_REFERENCE + ' must be known';
MESSAGES[NUMERIC_DISALLOWED] = NUMERIC_REFERENCE + ' cannot be disallowed';
MESSAGES[NUMERIC_PROHIBITED] = NUMERIC_REFERENCE + ' cannot be outside the ' +
    'permissible Unicode range';

/*
 * Characters.
 */

var REPLACEMENT = '\uFFFD';
var FORM_FEED = '\f';
var AMPERSAND = '&';
var OCTOTHORP = '#';
var SEMICOLON = ';';
var NEWLINE = '\n';
var X_LOWER = 'x';
var X_UPPER = 'X';
var SPACE = ' ';
var LESS_THAN = '<';
var EQUAL = '=';
var EMPTY = '';
var TAB = '\t';

/**
 * Get the character-code at the first indice in
 * `character`.
 *
 * @param {string} character - Value.
 * @return {number} - Character-code at the first indice
 *   in `character`.
 */
function charCode(character) {
    return character.charCodeAt(0);
}

/**
 * Check whether `character` is a decimal.
 *
 * @param {string} character - Value.
 * @return {boolean} - Whether `character` is a decimal.
 */
function isDecimal(character) {
    var code = charCode(character);

    return code >= 48 /* 0 */ && code <= 57 /* 9 */;
}

/**
 * Check whether `character` is a hexadecimal.
 *
 * @param {string} character - Value.
 * @return {boolean} - Whether `character` is a
 *   hexadecimal.
 */
function isHexadecimal(character) {
    var code = charCode(character);

    return (code >= 48 /* 0 */ && code <= 57 /* 9 */) ||
        (code >= 65 /* A */ && code <= 70 /* F */) ||
        (code >= 97 /* a */ && code <= 102 /* f */);
}

/**
 * Check whether `character` is an alphanumeric.
 *
 * @param {string} character - Value.
 * @return {boolean} - Whether `character` is an
 *   alphanumeric.
 */
function isAlphanumeric(character) {
    var code = charCode(character);

    return (code >= 48 /* 0 */ && code <= 57 /* 9 */) ||
        (code >= 65 /* A */ && code <= 90 /* Z */) ||
        (code >= 97 /* a */ && code <= 122 /* z */);
}

/**
 * Check whether `character` is outside the permissible
 * unicode range.
 *
 * @param {number} characterCode - Value.
 * @return {boolean} - Whether `character` is an
 *   outside the permissible unicode range.
 */
function isProhibited(characterCode) {
    return (characterCode >= 0xD800 && characterCode <= 0xDFFF) ||
        (characterCode > 0x10FFFF);
}

/**
 * Check whether `character` is disallowed.
 *
 * @param {number} characterCode - Value.
 * @return {boolean} - Whether `character` is disallowed.
 */
function isWarning(characterCode) {
    return (characterCode >= 0x0001 && characterCode <= 0x0008) ||
        (characterCode >= 0x000D && characterCode <= 0x001F) ||
        (characterCode >= 0x007F && characterCode <= 0x009F) ||
        (characterCode >= 0xFDD0 && characterCode <= 0xFDEF) ||
        characterCode === 0x000B ||
        characterCode === 0xFFFE ||
        characterCode === 0xFFFF ||
        characterCode === 0x1FFFE ||
        characterCode === 0x1FFFF ||
        characterCode === 0x2FFFE ||
        characterCode === 0x2FFFF ||
        characterCode === 0x3FFFE ||
        characterCode === 0x3FFFF ||
        characterCode === 0x4FFFE ||
        characterCode === 0x4FFFF ||
        characterCode === 0x5FFFE ||
        characterCode === 0x5FFFF ||
        characterCode === 0x6FFFE ||
        characterCode === 0x6FFFF ||
        characterCode === 0x7FFFE ||
        characterCode === 0x7FFFF ||
        characterCode === 0x8FFFE ||
        characterCode === 0x8FFFF ||
        characterCode === 0x9FFFE ||
        characterCode === 0x9FFFF ||
        characterCode === 0xAFFFE ||
        characterCode === 0xAFFFF ||
        characterCode === 0xBFFFE ||
        characterCode === 0xBFFFF ||
        characterCode === 0xCFFFE ||
        characterCode === 0xCFFFF ||
        characterCode === 0xDFFFE ||
        characterCode === 0xDFFFF ||
        characterCode === 0xEFFFE ||
        characterCode === 0xEFFFF ||
        characterCode === 0xFFFFE ||
        characterCode === 0xFFFFF ||
        characterCode === 0x10FFFE ||
        characterCode === 0x10FFFF;
}

/*
 * Map of types to tests. Each type of character reference
 * accepts different characters. This test is used to
 * detect whether a reference has ended (as the semicolon
 * is not strictly needed).
 */

var TESTS = {};

TESTS[NAMED] = isAlphanumeric;
TESTS[DECIMAL] = isDecimal;
TESTS[HEXADECIMAL] = isHexadecimal;

/**
 * Parse entities.
 *
 * @param {string} value - Value to tokenise.
 * @param {Object?} [settings] - Configuration.
 */
function parse(value, settings) {
    var additional = settings.additional;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = EMPTY;
    var result = [];
    var entityCharacters;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;

    /**
     * Get current position.
     *
     * @return {Object} - Positional information of a
     *   single point.
     */
    function now() {
        return {
            'line': line,
            'column': column,
            'offset': index + (pos.offset || 0)
        };
    }

    /**
     * Throw a parse-error: a warning.
     *
     * @param {number} code - Identifier of reason for
     *   failing.
     * @param {number} offset - Offset in characters from
     *   the current position point at which the
     *   parse-error ocurred, cannot point past newlines.
     */
    function parseError(code, offset) {
        var position = now();

        position.column += offset;
        position.offset += offset;

        handleWarning.call(warningContext, MESSAGES[code], position, code);
    }

    /**
     * Get character at position.
     *
     * @param {number} position - Indice of character in `value`.
     * @return {string} - Character at `position` in
     *   `value`.
     */
    function at(position) {
        return value.charAt(position);
    }

    /**
     * Flush `queue` (normal text). Macro invoked before
     * each entity and at the end of `value`.
     *
     * Does nothing when `queue` is empty.
     */
    function flush() {
        if (queue) {
            result.push(queue);

            if (handleText) {
                handleText.call(textContext, queue, {
                    'start': prev,
                    'end': now()
                });
            }

            queue = EMPTY;
        }
    }

    /*
     * Cache the current point.
     */

    prev = now();

    /*
     * Wrap `handleWarning`.
     */

    warning = handleWarning ? parseError : noop;

    /*
     * Ensure the algorithm walks over the first character
     * and the end (inclusive).
     */

    index--;
    length++;

    while (++index < length) {
        /*
         * If the previous character was a newline.
         */

        if (character === NEWLINE) {
            column = indent[lines] || 1;
        }

        character = at(index);

        /*
         * Handle anything other than an ampersand,
         * including newlines and EOF.
         */

        if (character !== AMPERSAND) {
            if (character === NEWLINE) {
                line++;
                lines++;
                column = 0;
            }

            if (character) {
                queue += character;
                column++;
            } else {
                flush();
            }
        } else {
            following = at(index + 1);

            /*
             * The behaviour depends on the identity of the next character.
             */

            if (
                following === TAB ||
                following === NEWLINE ||
                following === FORM_FEED ||
                following === SPACE ||
                following === LESS_THAN ||
                following === AMPERSAND ||
                following === EMPTY ||
                (additional && following === additional)
            ) {
                /*
                 * Not a character reference. No characters
                 * are consumed, and nothing is returned.
                 * This is not an error, either.
                 */

                queue += character;
                column++;

                continue;
            }

            start = begin = end = index + 1;

            /*
             * Numerical entity.
             */

            if (following !== OCTOTHORP) {
                type = NAMED;
            } else {
                end = ++begin;

                /*
                 * The behaviour further depends on the
                 * character after the U+0023 NUMBER SIGN.
                 */

                following = at(end);

                if (following === X_LOWER || following === X_UPPER) {
                    /*
                     * ASCII hex digits.
                     */

                    type = HEXADECIMAL;
                    end = ++begin;
                } else {
                    /*
                     * ASCII digits.
                     */

                    type = DECIMAL;
                }
            }

            entityCharacters = entity = characters = EMPTY;
            test = TESTS[type];
            end--;

            while (++end < length) {
                following = at(end);

                if (!test(following)) {
                    break;
                }

                characters += following;

                /*
                 * Check if we can match a legacy named
                 * reference.  If so, we cache that as the
                 * last viable named reference.  This
                 * ensures we do not need to walk backwards
                 * later.
                 */

                if (
                    type === NAMED &&
                    has.call(legacy, characters)
                ) {
                    entityCharacters = characters;
                    entity = legacy[characters];
                }
            }

            terminated = at(end) === SEMICOLON;

            if (terminated) {
                end++;

                if (
                    type === NAMED &&
                    has.call(characterEntities, characters)
                ) {
                    entityCharacters = characters;
                    entity = characterEntities[characters];
                }
            }

            diff = 1 + end - start;

            if (!characters) {
                /*
                 * An empty (possible) entity is valid, unless
                 * its numeric (thus an ampersand followed by
                 * an octothorp).
                 */

                if (type !== NAMED) {
                    warning(NUMERIC_EMPTY, diff);
                }
            } else if (type === NAMED) {
                /*
                 * An ampersand followed by anything
                 * unknown, and not terminated, is invalid.
                 */

                if (terminated && !entity) {
                    warning(NAMED_UNKNOWN, 1);
                } else {
                    /*
                     * If theres something after an entity
                     * name which is not known, cap the
                     * reference.
                     */

                    if (entityCharacters !== characters) {
                        end = begin + entityCharacters.length;
                        diff = 1 + end - begin;
                        terminated = false;
                    }

                    /*
                     * If the reference is not terminated,
                     * warn.
                     */

                    if (!terminated) {
                        reason = entityCharacters ?
                            NAMED_NOT_TERMINATED :
                            NAMED_EMPTY;

                        if (!settings.attribute) {
                            warning(reason, diff);
                        } else {
                            following = at(end);

                            if (following === EQUAL) {
                                warning(reason, diff);
                                entity = null;
                            } else if (isAlphanumeric(following)) {
                                entity = null;
                            } else {
                                warning(reason, diff);
                            }
                        }
                    }
                }

                reference = entity;
            } else {
                if (!terminated) {
                    /*
                     * All non-terminated numeric entities are
                     * not rendered, and trigger a warning.
                     */

                    warning(NUMERIC_NOT_TERMINATED, diff);
                }

                /*
                 * When terminated and number, parse as
                 * either hexadecimal or decimal.
                 */

                reference = parseInt(characters, BASE[type]);

                /*
                 * Trigger a warning when the parsed number
                 * is prohibited, and replace with
                 * replacement character.
                 */

                if (isProhibited(reference)) {
                    warning(NUMERIC_PROHIBITED, diff);

                    reference = REPLACEMENT;
                } else if (reference in invalid) {
                    /*
                     * Trigger a warning when the parsed number
                     * is disallowed, and replace by an
                     * alternative.
                     */

                    warning(NUMERIC_DISALLOWED, diff);

                    reference = invalid[reference];
                } else {
                    /*
                     * Parse the number.
                     */

                    output = EMPTY;

                    /*
                     * Trigger a warning when the parsed
                     * number should not be used.
                     */

                    if (isWarning(reference)) {
                        warning(NUMERIC_DISALLOWED, diff);
                    }

                    /*
                     * Stringify the number.
                     */

                    if (reference > 0xFFFF) {
                        reference -= 0x10000;
                        output += fromCharCode(
                            reference >>> 10 & 0x3FF | 0xD800
                        );

                        reference = 0xDC00 | reference & 0x3FF;
                    }

                    reference = output + fromCharCode(reference);
                }
            }

            /*
             * If we could not find a reference, queue the
             * checked characters (as normal characters),
             * and move the pointer to their end. This is
             * possible because we can be certain neither
             * newlines nor ampersands are included.
             */

            if (!reference) {
                characters = value.slice(start - 1, end);
                queue += characters;
                column += characters.length;
                index = end - 1;
            } else {
                /*
                 * Found it! First eat the queued
                 * characters as normal text, then eat
                 * an entity.
                 */

                flush();

                prev = now();
                index = end - 1;
                column += end - start + 1;
                result.push(reference);
                next = now();
                next.offset++;

                if (handleReference) {
                    handleReference.call(referenceContext, reference, {
                        'start': prev,
                        'end': next
                    }, value.slice(start - 1, end));
                }

                prev = next;
            }
        }
    }

    /*
     * Return the reduced nodes, and any possible warnings.
     */

    return result.join(EMPTY);
}

var defaults = {
    'warning': null,
    'reference': null,
    'text': null,
    'warningContext': null,
    'referenceContext': null,
    'textContext': null,
    'position': {},
    'additional': null,
    'attribute': false
};

/**
 * Wrap to ensure clean parameters are given to `parse`.
 *
 * @param {string} value - Value with entities.
 * @param {Object?} [options] - Configuration.
 */
function wrapper(value, options) {
    var settings = {};
    var key;

    if (!options) {
        options = {};
    }

    for (key in defaults) {
        settings[key] = options[key] || defaults[key];
    }

    if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
    }

    return parse(value, settings);
}

/*
 * Expose.
 */

module.exports = wrapper;

},
"t7uJRuDop5vyV48/YqqWK6g8n8YtIMp3B8sa2uv2+wg=":
function (require, module, exports, __dirname, __filename) {

var inRange = require('./range')

module.exports = function (compare) {
  var hooks = []

  return {
    add: function (range, hook) {
      var m = {range: range, hook: hook}
      hooks.push(m)
      //call this to remove
      return function () {
        var i = hooks.indexOf(m)
        if(~i) return hooks.splice(i, 1)
      }

    },

    //remove all listeners within a range.
    //this will be used to close a sublevel.
    removeAll: function (range) {
      throw new Error('not implemented')
    },

    trigger: function (key, args) {
      for(var i = 0; i < hooks.length; i++) {
        var test = hooks[i]
        if(inRange(test.range, key, compare))
          test.hook.apply(this, args)
      }
    }
  }
}

},
"tDbAs49j9ovwfXFefks6g8aVeNAXPhjqvvI76klcL8w=":
function (require, module, exports, __dirname, __filename) {
var fs         = require('fs')
var mkdirp     = require('mkdirp')
var path       = require('path')
var deepEqual  = require('deep-equal')

var crypto     = require('crypto')
var createHmac = require('hmac')

var sodium     = require('chloride')
var ssbref     = require('ssb-ref')

var pb         = require('private-box')

var isBuffer = Buffer.isBuffer

function isString (s) {
  return 'string' === typeof s
}
//UTILS

function clone (obj) {
  var _obj = {}
  for(var k in obj) {
    if(Object.hasOwnProperty.call(obj, k))
      _obj[k] = obj[k]
  }
  return _obj
}

function hash (data, enc) {
  data = (
    'string' === typeof data && enc == null
  ? new Buffer(data, 'binary')
  : new Buffer(data, enc)
  )
  return crypto.createHash('sha256').update(data).digest('base64')+'.sha256'
}

var isLink = ssbref.isLink
var isFeedId = ssbref.isFeedId

exports.hash = hash

function isObject (o) {
  return 'object' === typeof o
}

function isFunction (f) {
  return 'function' === typeof f
}

function isString(s) {
  return 'string' === typeof s
}

function hasSigil (s) {
  return /^(@|%|&)/.test(s)
}

function empty(v) { return !!v }

function toBuffer(buf) {
  if(buf == null) return buf
  if(Buffer.isBuffer(buf)) throw new Error('already a buffer')
  var i = buf.indexOf('.')
  var start = (hasSigil(buf)) ? 1 : 0
  return new Buffer(buf.substring(start, ~i ? i : buf.length), 'base64')
}

function toUint8(buf) {
  return new Uint8Array(toBuffer(buf))
}

function getTag (string) {
  var i = string.indexOf('.')
  return string.substring(i+1)
}

exports.getTag = getTag

function tag (key, tag) {
  if(!tag) throw new Error('no tag for:' + key.toString('base64'))
  return key.toString('base64')+'.' + tag.replace(/^\./, '')
}

function keysToJSON(keys, curve) {
  curve = (keys.curve || curve)

  var pub = tag(keys.public.toString('base64'), curve)
  return {
    curve: curve,
    public: pub,
    private: keys.private ? tag(keys.private.toString('base64'), curve) : undefined,
    id: '@'+(curve === 'ed25519' ? pub : hash(pub))
  }
}

//(DE)SERIALIZE KEYS

function constructKeys(keys, legacy) {
  if(!keys) throw new Error('*must* pass in keys') 

  return [
  '# this is your SECRET name.',
  '# this name gives you magical powers.',
  '# with it you can mark your messages so that your friends can verify',
  '# that they really did come from you.',
  '#',
  '# if any one learns this name, they can use it to destroy your identity',
  '# NEVER show this to anyone!!!',
  '',
  legacy ? keys.private : JSON.stringify(keys, null, 2),
  '',
  '# WARNING! It\'s vital that you DO NOT edit OR share your secret name',
  '# instead, share your public name',
  '# your public name: ' + keys.id
  ].join('\n')
}

function reconstructKeys(keyfile) {
  var private = keyfile
    .replace(/\s*\#[^\n]*/g, '')
    .split('\n').filter(empty).join('')

  //if the key is in JSON format, we are good.
  try {
    var keys = JSON.parse(private)
    if(!hasSigil(keys.id)) keys.id = '@' + keys.public
    return keys
  } catch (_) {}

  //else, reconstruct legacy curve...

  var curve = getTag(private)

  if(curve !== 'k256')
    throw new Error('expected legacy curve (k256) but found:' + curve)

  var ecc = require('./eccjs')

  return keysToJSON(ecc.restore(toBuffer(private)), 'k256')
}

var toNameFile = exports.toNameFile = function (namefile) {
  if(isObject(namefile))
    return path.join(namefile.path, 'secret')
  return namefile
}

exports.load = function(namefile, cb) {
  namefile = toNameFile(namefile)
  fs.readFile(namefile, 'ascii', function(err, privateKeyStr) {
    if (err) return cb(err)
    try { cb(null, reconstructKeys(privateKeyStr)) }
    catch (e) { cb(err) }
  })
}

exports.loadSync = function(namefile) {
  namefile = toNameFile(namefile)
  return reconstructKeys(fs.readFileSync(namefile, 'ascii'))
}

exports.create = function(namefile, curve, legacy, cb) {
  if(isFunction(legacy))
    cb = legacy, legacy = null
  if(isFunction(curve))
    cb = curve, curve = null

  namefile = toNameFile(namefile)
  var keys = exports.generate(curve)
  var keyfile = constructKeys(keys, legacy)
  mkdirp(path.dirname(namefile), function (err) {
    if(err) return cb(err)
    fs.writeFile(namefile, keyfile, function(err) {
      if (err) return cb(err)
      cb(null, keys)
    })
  })
}

exports.createSync = function(namefile, curve, legacy) {
  namefile = toNameFile(namefile)
  var keys = exports.generate(curve)
  var keyfile = constructKeys(keys, legacy)
  mkdirp.sync(path.dirname(namefile))
  fs.writeFileSync(namefile, keyfile)
  return keys
}

exports.loadOrCreate = function (namefile, cb) {
  namefile = toNameFile(namefile)
  exports.load(namefile, function (err, keys) {
    if(!err) return cb(null, keys)
    exports.create(namefile, cb)
  })
}

exports.loadOrCreateSync = function (namefile) {
  namefile = toNameFile(namefile)
  try {
    return exports.loadSync(namefile)
  } catch (err) {
    return exports.createSync(namefile)
  }
}


// DIGITAL SIGNATURES

var curves = {}
curves.ed25519 = require('./sodium')
try { curves.k256 = require('./eccjs') }
catch (_) {}

function getCurve(keys) {
  var curve = keys.curve

  if(!keys.curve && isString(keys.public))
    keys = keys.public

  if(!curve && isString(keys))
    curve = getTag(keys)

  if(!curves[curve]) {
    throw new Error(
      'unkown curve:' + curve +
      ' expected: '+Object.keys(curves)
    )
  }

  return curve
}

//this should return a key pair:
// {curve: curve, public: Buffer, private: Buffer}

exports.generate = function (curve, seed) {
  curve = curve || 'ed25519'

  if(!curves[curve])
    throw new Error('unknown curve:'+curve)

  return keysToJSON(curves[curve].generate(seed), curve)
}

//takes a public key and a hash and returns a signature.
//(a signature must be a node buffer)

exports.sign = function (keys, msg) {
  if(isString(msg))
    msg = new Buffer(msg)
  if(!isBuffer(msg))
    throw new Error('msg should be buffer')
  var curve = getCurve(keys)

  return curves[curve]
    .sign(toBuffer(keys.private || keys), msg)
    .toString('base64')+'.sig.'+curve

}

//takes a public key, signature, and a hash
//and returns true if the signature was valid.
exports.verify = function (keys, sig, msg) {
  if(isObject(sig))
    throw new Error('signature should be base64 string, did you mean verifyObj(public, signed_obj)')
  return curves[getCurve(keys)].verify(
    toBuffer(keys.public || keys),
    toBuffer(sig),
    isBuffer(msg) ? msg : new Buffer(msg)
  )
}

// OTHER CRYTPO FUNCTIONS

exports.hmac = function (data, key) {
  return createHmac(createHash, 64, key)
    .update(data).digest('base64')+'.sha256.hmac'
}

exports.signObj = function (keys, obj) {
  var _obj = clone(obj)
  var b = new Buffer(JSON.stringify(_obj, null, 2))
  _obj.signature = exports.sign(keys, b)
  return _obj
}

exports.verifyObj = function (keys, obj) {
  obj = clone(obj)
  var sig = obj.signature
  delete obj.signature
  var b = new Buffer(JSON.stringify(obj, null, 2))
  return exports.verify(keys, sig, b)
}

exports.box = function (msg, recipients) {
  msg = new Buffer(JSON.stringify(msg))

  recipients = recipients.map(function (keys) {
    var public = keys.public || keys
    return sodium.crypto_sign_ed25519_pk_to_curve25519(toBuffer(public))
  })

  //it's since the nonce is 24 bytes (a multiple of 3)
  //it's possible to concatenate the base64 strings
  //and still have a valid base64 string.
  return pb.multibox(msg, recipients).toString('base64')+'.box'
}

exports.unbox = function (boxed, keys) {
  boxed = toBuffer(boxed)
  var sk = sodium.crypto_sign_ed25519_sk_to_curve25519(toBuffer(keys.private || keys))

  var msg = pb.multibox_open(boxed, sk)
  if(msg) return JSON.parse(''+msg)
}



},
"tPweugl54351uRFBSjm53DVQaPV3jrUN0lGpxG3IyWQ=":
function (require, module, exports, __dirname, __filename) {
const util             = require('util')
    , AbstractIterator = require('abstract-leveldown').AbstractIterator
    , fastFuture       = require('fast-future')


function Iterator (db, options) {
  AbstractIterator.call(this, db)

  this.binding    = db.binding.iterator(options)
  this.cache      = null
  this.finished   = false
  this.fastFuture = fastFuture()
}

util.inherits(Iterator, AbstractIterator)

Iterator.prototype.seek = function (key) {
  if (typeof key !== 'string')
    throw new Error('seek requires a string key')
  this.cache = null
  this.binding.seek(key)
}

Iterator.prototype._next = function (callback) {
  var that = this
    , key
    , value

  if (this.cache && this.cache.length) {
    key   = this.cache.pop()
    value = this.cache.pop()

    this.fastFuture(function () {
      callback(null, key, value)
    })

  } else if (this.finished) {
    this.fastFuture(function () {
      callback()
    })
  } else {
    this.binding.next(function (err, array, finished) {
      if (err) return callback(err)

      that.cache    = array
      that.finished = finished
      that._next(callback)
    })
  }

  return this
}


Iterator.prototype._end = function (callback) {
  delete this.cache
  this.binding.end(callback)
}


module.exports = Iterator

},
"tiuKW7cxwl3Zxn3EOQgkNsLKM0Ab2Hk2pjuilaLNG/o=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module unist:util:visit
 * @fileoverview Recursively walk over unist nodes.
 */

'use strict';

/* eslint-env commonjs */

/**
 * Visit.
 *
 * @param {Node} tree - Root node
 * @param {string} [type] - Node type.
 * @param {function(node): boolean?} visitor - Invoked
 *   with each found node.  Can return `false` to stop.
 * @param {boolean} [reverse] - By default, `visit` will
 *   walk forwards, when `reverse` is `true`, `visit`
 *   walks backwards.
 */
function visit(tree, type, visitor, reverse) {
    if (typeof type === 'function') {
        reverse = visitor;
        visitor = type;
        type = null;
    }

    /**
     * Visit children in `parent`.
     *
     * @param {Array.<Node>} children - Children of `node`.
     * @param {Node?} parent - Parent of `node`.
     * @return {boolean?} - `false` if the visiting stopped.
     */
    function all(children, parent) {
        var step = reverse ? -1 : 1;
        var max = children.length;
        var min = -1;
        var index = (reverse ? max : min) + step;
        var child;

        while (index > min && index < max) {
            child = children[index];

            if (child && one(child, index, parent) === false) {
                return false;
            }

            index += step;
        }

        return true;
    }

    /**
     * Visit a single node.
     *
     * @param {Node} node - Node to visit.
     * @param {number?} [index] - Position of `node` in `parent`.
     * @param {Node?} [parent] - Parent of `node`.
     * @return {boolean?} - A result of invoking `visitor`.
     */
    function one(node, index, parent) {
        var result;

        index = index || (parent ? 0 : null);

        if (!type || node.type === type) {
            result = visitor(node, index, parent || null);
        }

        if (node.children && result !== false) {
            return all(node.children, node);
        }

        return result;
    }

    one(tree);
}

/*
 * Expose.
 */

module.exports = visit;

},
"tnbz8L8EtGjuxj9pHAAmytWBQczOjrfyA3ud1zNrXJk=":
function (require, module, exports, __dirname, __filename) {

//force to a valid range
var range = exports.range = function (obj) {
  return null == obj ? {} : 'string' === typeof range ? {
      min: range, max: range + '\xff'
    } :  obj
}

//turn into a sub range.
var prefix = exports.prefix = function (range, within, term) {
  range = exports.range(range)
  var _range = {}
  term = term || '\xff'
  if(range instanceof RegExp || 'function' == typeof range) {
    _range.min = within
    _range.max   = within + term,
    _range.inner = function (k) {
      var j = k.substring(within.length)
      if(range.test)
        return range.test(j)
      return range(j)
    }
  }
  else if('object' === typeof range) {
    _range.min = within + (range.min || range.start || '')
    _range.max = within + (range.max || range.end   || (term || '~'))
    _range.reverse = !!range.reverse
  }
  return _range
}

//return a function that checks a range
var checker = exports.checker = function (range) {
  if(!range) range = {}

  if ('string' === typeof range)
    return function (key) {
      return key.indexOf(range) == 0
    }
  else if(range instanceof RegExp)
    return function (key) {
      return range.test(key)
    }
  else if('object' === typeof range)
    return function (key) {
      var min = range.min || range.start
      var max = range.max || range.end

      // fixes keys passed as ints from sublevels
      key = String(key)

      return (
        !min || key >= min
      ) && (
        !max || key <= max
      ) && (
        !range.inner || (
          range.inner.test 
            ? range.inner.test(key)
            : range.inner(key)
        )
      )
    }
  else if('function' === typeof range)
    return range
}
//check if a key is within a range.
var satifies = exports.satisfies = function (key, range) {
  return checker(range)(key)
}



},
"uFW2bvxzxDyicyw7KzUXs8e1CYJ2HAWuaTREpO2QiQQ=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/level/levelup#contributing>
 * MIT License
 * <https://github.com/level/levelup/blob/master/LICENSE.md>
 */

var EventEmitter        = require('events').EventEmitter
  , inherits            = require('util').inherits
  , deprecate           = require('util').deprecate
  , extend              = require('xtend')
  , prr                 = require('prr')
  , DeferredLevelDOWN   = require('deferred-leveldown')
  , IteratorStream      = require('level-iterator-stream')

  , errors              = require('level-errors')
  , WriteError          = errors.WriteError
  , ReadError           = errors.ReadError
  , NotFoundError       = errors.NotFoundError
  , OpenError           = errors.OpenError
  , EncodingError       = errors.EncodingError
  , InitializationError = errors.InitializationError

  , util                = require('./util')
  , Batch               = require('./batch')
  , Codec               = require('level-codec')

  , getOptions          = util.getOptions
  , defaultOptions      = util.defaultOptions
  , getLevelDOWN        = util.getLevelDOWN
  , dispatchError       = util.dispatchError
  , isDefined           = util.isDefined

function getCallback (options, callback) {
  return typeof options == 'function' ? options : callback
}

// Possible LevelUP#_status values:
//  - 'new'     - newly created, not opened or closed
//  - 'opening' - waiting for the database to be opened, post open()
//  - 'open'    - successfully opened the database, available for use
//  - 'closing' - waiting for the database to be closed, post close()
//  - 'closed'  - database has been successfully closed, should not be
//                 used except for another open() operation

function LevelUP (location, options, callback) {
  if (!(this instanceof LevelUP))
    return new LevelUP(location, options, callback)

  var error

  EventEmitter.call(this)
  this.setMaxListeners(Infinity)

  if (typeof location == 'function') {
    options = typeof options == 'object' ? options : {}
    options.db = location
    location = null
  } else if (typeof location == 'object' && typeof location.db == 'function') {
    options = location
    location = null
  }


  if (typeof options == 'function') {
    callback = options
    options  = {}
  }

  if ((!options || typeof options.db != 'function') && typeof location != 'string') {
    error = new InitializationError(
        'Must provide a location for the database')
    if (callback) {
      return process.nextTick(function () {
        callback(error)
      })
    }
    throw error
  }

  options      = getOptions(options)
  this.options = extend(defaultOptions, options)
  this._codec = new Codec(this.options)
  this._status = 'new'
  // set this.location as enumerable but not configurable or writable
  prr(this, 'location', location, 'e')

  this.open(callback)
}

inherits(LevelUP, EventEmitter)

LevelUP.prototype.open = function (callback) {
  var self = this
    , dbFactory
    , db

  if (this.isOpen()) {
    if (callback)
      process.nextTick(function () { callback(null, self) })
    return this
  }

  if (this._isOpening()) {
    return callback && this.once(
        'open'
      , function () { callback(null, self) }
    )
  }

  this.emit('opening')

  this._status = 'opening'
  this.db      = new DeferredLevelDOWN(this.location)
  dbFactory    = this.options.db || getLevelDOWN()
  db           = dbFactory(this.location)

  db.open(this.options, function (err) {
    if (err) {
      return dispatchError(self, new OpenError(err), callback)
    } else {
      self.db.setDb(db)
      self.db = db
      self._status = 'open'
      if (callback)
        callback(null, self)
      self.emit('open')
      self.emit('ready')
    }
  })
}

LevelUP.prototype.close = function (callback) {
  var self = this

  if (this.isOpen()) {
    this._status = 'closing'
    this.db.close(function () {
      self._status = 'closed'
      self.emit('closed')
      if (callback)
        callback.apply(null, arguments)
    })
    this.emit('closing')
    this.db = new DeferredLevelDOWN(this.location)
  } else if (this._status == 'closed' && callback) {
    return process.nextTick(callback)
  } else if (this._status == 'closing' && callback) {
    this.once('closed', callback)
  } else if (this._isOpening()) {
    this.once('open', function () {
      self.close(callback)
    })
  }
}

LevelUP.prototype.isOpen = function () {
  return this._status == 'open'
}

LevelUP.prototype._isOpening = function () {
  return this._status == 'opening'
}

LevelUP.prototype.isClosed = function () {
  return (/^clos/).test(this._status)
}

function maybeError(db, options, callback) {
  if (!db._isOpening() && !db.isOpen()) {
    dispatchError(
        db
      , new ReadError('Database is not open')
      , callback
    )
    return true
  }
}

function writeError (db, message, callback) {
  dispatchError(
      db
     , new WriteError(message)
     , callback
  )
}

function readError (db, message, callback) {
  dispatchError(
      db
     , new ReadError(message)
     , callback
  )
}


LevelUP.prototype.get = function (key_, options, callback) {
  var self = this
    , key

  callback = getCallback(options, callback)

  if (maybeError(this, options, callback))
    return

  if (key_ === null || key_ === undefined || 'function' !== typeof callback)
    return readError(this
      , 'get() requires key and callback arguments', callback)

  options = util.getOptions(options)
  key = this._codec.encodeKey(key_, options)

  options.asBuffer = this._codec.valueAsBuffer(options)

  this.db.get(key, options, function (err, value) {
    if (err) {
      if ((/notfound/i).test(err) || err.notFound) {
        err = new NotFoundError(
            'Key not found in database [' + key_ + ']', err)
      } else {
        err = new ReadError(err)
      }
      return dispatchError(self, err, callback)
    }
    if (callback) {
      try {
        value = self._codec.decodeValue(value, options)
      } catch (e) {
        return callback(new EncodingError(e))
      }
      callback(null, value)
    }
  })
}

LevelUP.prototype.put = function (key_, value_, options, callback) {
  var self = this
    , key
    , value

  callback = getCallback(options, callback)

  if (key_ === null || key_ === undefined)
    return writeError(this, 'put() requires a key argument', callback)

  if (maybeError(this, options, callback))
    return

  options = getOptions(options)
  key     = this._codec.encodeKey(key_, options)
  value   = this._codec.encodeValue(value_, options)

  this.db.put(key, value, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('put', key_, value_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.del = function (key_, options, callback) {
  var self = this
    , key

  callback = getCallback(options, callback)

  if (key_ === null || key_ === undefined)
    return writeError(this, 'del() requires a key argument', callback)

  if (maybeError(this, options, callback))
    return

  options = getOptions(options)
  key     = this._codec.encodeKey(key_, options)

  this.db.del(key, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('del', key_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.batch = function (arr_, options, callback) {
  var self = this
    , keyEnc
    , valueEnc
    , arr

  if (!arguments.length)
    return new Batch(this, this._codec)

  callback = getCallback(options, callback)

  if (!Array.isArray(arr_))
    return writeError(this, 'batch() requires an array argument', callback)

  if (maybeError(this, options, callback))
    return

  options  = getOptions(options)
  arr      = self._codec.encodeBatch(arr_, options)
  arr      = arr.map(function (op) {
    if (!op.type && op.key !== undefined && op.value !== undefined)
      op.type = 'put'
    return op
  })

  this.db.batch(arr, options, function (err) {
    if (err) {
      return dispatchError(self, new WriteError(err), callback)
    } else {
      self.emit('batch', arr_)
      if (callback)
        callback()
    }
  })
}

LevelUP.prototype.approximateSize = deprecate(function (start_, end_, options, callback) {   
  var self = this    
    , start    
    , end    
   
  callback = getCallback(options, callback)    
   
  options = getOptions(options)    
   
  if (start_ === null || start_ === undefined    
        || end_ === null || end_ === undefined || 'function' !== typeof callback)    
    return readError(this, 'approximateSize() requires start, end and callback arguments', callback)   
   
  start = this._codec.encodeKey(start_, options)   
  end   = this._codec.encodeKey(end_, options)   
   
  this.db.approximateSize(start, end, function (err, size) {   
    if (err) {   
      return dispatchError(self, new OpenError(err), callback)   
    } else if (callback) {   
      callback(null, size)   
    }    
  })   
}, 'db.approximateSize() is deprecated. Use db.db.approximateSize() instead')

LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
  options = extend( {keys: true, values: true}, this.options, options)

  options.keyEncoding   = options.keyEncoding
  options.valueEncoding = options.valueEncoding

  options = this._codec.encodeLtgt(options);
  options.keyAsBuffer   = this._codec.keyAsBuffer(options)
  options.valueAsBuffer = this._codec.valueAsBuffer(options)

  if ('number' !== typeof options.limit)
    options.limit = -1

  return new IteratorStream(this.db.iterator(options), extend(options, {
    decoder: this._codec.createStreamDecoder(options)
  }))
}

LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
  return this.createReadStream(extend(options, { keys: true, values: false }))
}

LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
  return this.createReadStream(extend(options, { keys: false, values: true }))
}

LevelUP.prototype.toString = function () {
  return 'LevelUP'
}

function utilStatic (name) {
  return function (location, callback) {
    getLevelDOWN()[name](location, callback || function () {})
  }
}

module.exports         = LevelUP
module.exports.errors  = require('level-errors')
module.exports.destroy = deprecate(
    utilStatic('destroy')
  , 'levelup.destroy() is deprecated. Use leveldown.destroy() instead'
)
module.exports.repair  = deprecate(
    utilStatic('repair')
  , 'levelup.repair() is deprecated. Use leveldown.repair() instead'
)


},
"uNwDjIe0G/pqQkDX387KhuvYis119CPRrxqGUrYk+QY=":
function (require, module, exports, __dirname, __filename) {
// TODO: initialize and export a standard bytewise encoding, add hex and binary
module.exports = require('./encoding/')

},
"uSj7eDUYar0W4NZhq8LSlOIHmZYHsQBgtpBvpPYCbJQ=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var PSC          = require('packet-stream-codec')
var u            = require('./util')
var initStream   = require('./stream')
var createApi    = require('./api')
var createLocalCall = require('./local-api')

function createMuxrpc (remoteApi, localApi, local, id, perms, codec, legacy) {
  localApi = localApi || {}
  remoteApi = remoteApi || {}
  var emitter
  if(!codec) codec = PSC

  //pass the manifest to the permissions so that it can know
  //what something should be.

  var _cb, ws
  var context = {
      _emit: function (event, value) {
        emitter && emitter._emit(event, value)
        return context
      },
      id: id
    }

  var ws = initStream(
    createLocalCall(local, localApi, perms).bind(context),
    codec, function (err) {
      if(emitter.closed) return
      emitter.closed = true
      emitter.emit('closed')
      if(_cb) {
        var cb = _cb; _cb = null; cb(err)
      }
    }
  )

  emitter = createApi([], remoteApi, function (type, name, args, cb) {
    if(ws.closed) throw new Error('stream is closed')
    return ws.remoteCall(type, name, args, cb)
  })

  if(legacy) {
    Object.__defineGetter__.call(emitter, 'id', function () {
      return context.id
    })

    Object.__defineSetter__.call(emitter, 'id', function (value) {
      context.id =  value
    })

    var first = true

    emitter.createStream = function (cb) {
      _cb = cb
      if(first) {
        first = false; return ws
      }
      else
        throw new Error('one stream per rpc')
    }
  }
  else
    emitter.stream = ws

  emitter.closed = false

  emitter.close = function (err, cb) {
    ws.close(err, cb)
    return this
  }

  return emitter

}

module.exports = function (remoteApi, localApi, codec) {
  if(arguments.length > 3)
    return createMuxrpc.apply(this, arguments)
  return function (local, perms, id) {
    return createMuxrpc(remoteApi, localApi, local, id, perms, codec, true)
  }
}


},
"ueV14TYb2vubMwSE6QQsR8k4pHI7HJtoZ/MH8xEPh5A=":
function (require, module, exports, __dirname, __filename) {

var Reader = require('pull-reader')
var pull = require('pull-stream')
var deferred = require('pull-defer')
var Writer = require('pull-pushable')
var cat = require('pull-cat')
var pair = require('pull-pair')

function once (cb) {
  var called = 0
  return function (a, b, c) {
    if(called++) return
    cb(a, b, c)
  }
}

function isFunction (f) {
  return 'function' === typeof f
}

module.exports = function (opts, _cb) {
  if(isFunction(opts)) _cb = opts, opts = {}
  _cb = once(_cb)
  var reader = Reader(opts && opts.timeout || 5e3)
  var writer = Writer(function (err) {
    if(err) _cb(err)
  })

  var source = deferred.source()

  var p = pair()

  return {
    handshake: {
      read: reader.read,
      abort: function (err) {
        writer.end(err)
        reader.abort(err, function (err) {
        })
        _cb(err)
      },
      write: writer.push,
      rest: function () {
        writer.end()
        return {
          source: reader.read(),
          sink: p.sink
        }
      }
    },
    sink: reader,
    source: cat([writer, p.source])
  }
}


},
"uu/PIKun3T30MMa1POykU8ehBSAYm/yy0MbZoJOOkek=":
function (require, module, exports, __dirname, __filename) {
var pull = require('pull-stream')

module.exports = function (map, width) {
  //by default, do max 32 map calls in parallel
  //(because I am 32 years old ;)
  width = width || 32
  var reading = false, abort
  return function (read) {
    var i = 0, j = 0, last = 0
    var seen = [], started = false, ended = false, _cb, error

    function drain () {
      if(_cb) {
        var cb = _cb
        if(error) {
          _cb = null
          return cb(error)
        }
        if(Object.hasOwnProperty.call(seen, j)) {
          _cb = null
          var data = seen[j]; delete seen[j]; j++
          cb(null, data)
          if(width) start()
        } else if(j >= last && ended) {
          _cb = null
          cb(true)
        }
      }
    }

    function start () {
      started = true
      if(ended) return drain()
      if(reading || width && (i - width >= j)) return
      reading = true
      read(abort, function (end, data) {
        reading = false
        if(end) {
          last = i; ended = end
          drain()
        } else {
          var k = i++

          map(data, function (err, data) {
            seen[k] = data
            if(err) error = err
            drain()
          })

          if(!ended)
            start()

        }
      })
    }

    return function (_abort, cb) {
      if(_abort) {
        return read(ended = abort = _abort, function (err) {
          if(_cb) return cb(err)
        })
      }
      _cb = cb
      if(!started) start()
      drain()
    }
  }
}

},
"v1JJsvB84WMOaJeajnHp6rZ4y/7uHk4RMQQpWljccnM=":
function (require, module, exports, __dirname, __filename) {
module.exports = error

// error := (Error) => Continuable<void>
function error(err) {
    return function continuable(callback) {
        callback(err)
    }
}

},
"vCCyswnkw68noYLJnNBZVw2ZQQLOawUjvfksXoijw6g=":
function (require, module, exports, __dirname, __filename) {
var u = require('pull-core')
var prop = u.prop
var id   = u.id
var maybeSink = u.maybeSink

module.exports = function (pull) {

  var exports = {}
  var drain = pull.drain

  var find = 
  exports.find = function (test, cb) {
    return maybeSink(function (cb) {
      var ended = false
      if(!cb)
        cb = test, test = id
      else
        test = prop(test) || id

      return drain(function (data) {
        if(test(data)) {
          ended = true
          cb(null, data)
        return false
        }
      }, function (err) {
        if(ended) return //already called back
        cb(err === true ? null : err, null)
      })

    }, cb)
  }

  var reduce = exports.reduce = 
  function (reduce, acc, cb) {
    
    return maybeSink(function (cb) {
      return drain(function (data) {
        acc = reduce(acc, data)
      }, function (err) {
        cb(err, acc)
      })

    }, cb)
  }

  var collect = exports.collect = exports.writeArray =
  function (cb) {
    return reduce(function (arr, item) {
      arr.push(item)
      return arr
    }, [], cb)
  }

  return exports
}

},
"vR7TVxY4LwMBwimhAo3YCkC5+wD1uSJrD7HDCN6xXGo=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "_args": [
    [
      "levelup@~1.3.0",
      "/home/dominic/c/scuttlebot/node_modules/level-packager"
    ]
  ],
  "_from": "levelup@>=1.3.0 <1.4.0",
  "_id": "levelup@1.3.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/level-packager/levelup",
  "_nodeVersion": "4.2.2",
  "_npmUser": {
    "email": "ralphtheninja@riseup.net",
    "name": "ralphtheninja"
  },
  "_npmVersion": "3.5.0",
  "_phantomChildren": {},
  "_requested": {
    "name": "levelup",
    "raw": "levelup@~1.3.0",
    "rawSpec": "~1.3.0",
    "scope": null,
    "spec": ">=1.3.0 <1.4.0",
    "type": "range"
  },
  "_requiredBy": [
    "/level-packager"
  ],
  "_resolved": "https://registry.npmjs.org/levelup/-/levelup-1.3.1.tgz",
  "_shasum": "8030758bb1b1dafdb71bfb55fff0caa2740cb846",
  "_shrinkwrap": null,
  "_spec": "levelup@~1.3.0",
  "_where": "/home/dominic/c/scuttlebot/node_modules/level-packager",
  "browser": {
    "leveldown": false,
    "leveldown/package": false,
    "semver": false
  },
  "bugs": {
    "url": "https://github.com/level/levelup/issues"
  },
  "contributors": [
    {
      "name": "Julian Gruber",
      "email": "julian@juliangruber.com",
      "url": "https://github.com/juliangruber"
    },
    {
      "name": "Rod Vagg",
      "email": "r@va.gg",
      "url": "https://github.com/rvagg"
    },
    {
      "name": "Jake Verbaten",
      "email": "raynos2@gmail.com",
      "url": "https://github.com/raynos"
    },
    {
      "name": "Dominic Tarr",
      "email": "dominic.tarr@gmail.com",
      "url": "https://github.com/dominictarr"
    },
    {
      "name": "Max Ogden",
      "email": "max@maxogden.com",
      "url": "https://github.com/maxogden"
    },
    {
      "name": "Lars-Magnus Skog",
      "email": "ralphtheninja@riseup.net",
      "url": "https://github.com/ralphtheninja"
    },
    {
      "name": "David Bjrklund",
      "email": "david.bjorklund@gmail.com",
      "url": "https://github.com/kesla"
    },
    {
      "name": "John Chesley",
      "email": "john@chesl.es",
      "url": "https://github.com/chesles/"
    },
    {
      "name": "Paolo Fragomeni",
      "email": "paolo@async.ly",
      "url": "https://github.com/hij1nx"
    },
    {
      "name": "Anton Whalley",
      "email": "anton.whalley@nearform.com",
      "url": "https://github.com/No9"
    },
    {
      "name": "Matteo Collina",
      "email": "matteo.collina@gmail.com",
      "url": "https://github.com/mcollina"
    },
    {
      "name": "Pedro Teixeira",
      "email": "pedro.teixeira@gmail.com",
      "url": "https://github.com/pgte"
    },
    {
      "name": "James Halliday",
      "email": "mail@substack.net",
      "url": "https://github.com/substack"
    },
    {
      "name": "Jarrett Cruger",
      "email": "jcrugzz@gmail.com",
      "url": "https://github.com/jcrugzz"
    }
  ],
  "dependencies": {
    "deferred-leveldown": "~1.2.1",
    "level-codec": "~6.1.0",
    "level-errors": "~1.0.3",
    "level-iterator-stream": "~1.3.0",
    "prr": "~1.0.1",
    "semver": "~5.1.0",
    "xtend": "~4.0.0"
  },
  "description": "Fast & simple storage - a Node.js-style LevelDB wrapper",
  "devDependencies": {
    "async": "~1.5.0",
    "bustermove": "~1.0.0",
    "delayed": "~1.0.1",
    "faucet": "~0.0.1",
    "leveldown": "^1.1.0",
    "memdown": "~1.1.0",
    "msgpack-js": "~0.3.0",
    "referee": "~1.2.0",
    "rimraf": "~2.4.3",
    "slow-stream": "0.0.4",
    "tap": "~2.3.1",
    "tape": "~4.2.1"
  },
  "directories": {},
  "dist": {
    "shasum": "8030758bb1b1dafdb71bfb55fff0caa2740cb846",
    "tarball": "https://registry.npmjs.org/levelup/-/levelup-1.3.1.tgz"
  },
  "gitHead": "40bd66872974140c79a74d9411b992ddffa926a4",
  "homepage": "https://github.com/level/levelup",
  "keywords": [
    "database",
    "db",
    "json",
    "leveldb",
    "storage",
    "store",
    "stream"
  ],
  "license": "MIT",
  "main": "lib/levelup.js",
  "maintainers": [
    {
      "name": "rvagg",
      "email": "rod@vagg.org"
    },
    {
      "name": "ralphtheninja",
      "email": "ralphtheninja@riseup.net"
    },
    {
      "name": "juliangruber",
      "email": "julian@juliangruber.com"
    }
  ],
  "name": "levelup",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/level/levelup.git"
  },
  "scripts": {
    "test": "tape test/*-test.js | faucet"
  },
  "version": "1.3.1"
}

},
"vSnCkYyNYWpG+Ca+/u3Wy3YaNbZMh/X2xJ6m1zdpA7o=":
function (require, module, exports, __dirname, __filename) {
module.exports = [
    "article",
    "header",
    "aside",
    "hgroup",
    "blockquote",
    "hr",
    "iframe",
    "body",
    "li",
    "map",
    "button",
    "object",
    "canvas",
    "ol",
    "caption",
    "output",
    "col",
    "p",
    "colgroup",
    "pre",
    "dd",
    "progress",
    "div",
    "section",
    "dl",
    "table",
    "td",
    "dt",
    "tbody",
    "embed",
    "textarea",
    "fieldset",
    "tfoot",
    "figcaption",
    "th",
    "figure",
    "thead",
    "footer",
    "tr",
    "form",
    "ul",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "video",
    "script",
    "style"
]

},
"vceHTSge/cEMcrChFvL+g6XmIGQ8Dxn4EmCctXBpo6E=":
function (require, module, exports, __dirname, __filename) {
module.exports = Observable

function Observable(value) {
    var listeners = []
    value = value === undefined ? null : value

    observable.set = function (v) {
        value = v
        listeners.forEach(function (f) {
            f(v)
        })
    }

    return observable

    function observable(listener) {
        if (!listener) {
            return value
        }

        listeners.push(listener)

        return function remove() {
            listeners.splice(listeners.indexOf(listener), 1)
        }
    }
}

},
"vh8/I1rJ1h5zuSKqs2QQh5VmIfmKzWszQnMj8b6KZsA=":
function (require, module, exports, __dirname, __filename) {
(function (root, factory) {
	if (typeof process === "object" && typeof process.stdout === "undefined") {
		process.stderr = process.stdout = { write: function() { } };
	}
	if (typeof define === "function" && define.amd) {
		define(["exports", "libsodium"], factory);
	} else if (typeof exports !== "undefined") {
		factory(exports, require("libsodium"));
	} else {
		var cb = root.sodium && root.sodium.onload;
		factory((root.sodium = {}), root.libsodium);
		if (typeof cb === "function") {
			cb(root.sodium);
		}
	}
}(this, function (exports, libsodium) {
	"use strict";
	Object.defineProperty(exports, '__esModule', { value: true });

	var output_format = "uint8array";

	libsodium._sodium_init();

	// List of functions and constants defined in the wrapped libsodium
	function symbols() {
		return Object.keys(exports).sort();
	}

	function increment(bytes) {
		if (! bytes instanceof Uint8Array) {
			throw new TypeError("Only Uint8Array instances can be incremented");
		}
        var c = 1 << 8;
		for (var i = 0 | 0, j = bytes.length; i < j; i++) {
            c >>= 8;
            c += bytes[i];
			bytes[i] = c & 0xff;
		}
	}

	function memzero(bytes) {
		if (! bytes instanceof Uint8Array) {
			throw new TypeError("Only Uint8Array instances can be wiped");
		}
		for (var i = 0 | 0, j = bytes.length; i < j; i++) {
			bytes[i] = 0;
		}
	}

	function memcmp(b1, b2) {
		if (!(b1 instanceof Uint8Array && b2 instanceof Uint8Array)) {
			throw new TypeError("Only Uint8Array instances can be compared");
		}
		if (b1.length !== b2.length) {
			throw new TypeError("Only instances of identical length can be compared");
		}
		for (var d = 0 | 0, i = 0 | 0, j = b1.length; i < j; i++) {
			d |= b1[i] ^ b2[i];
		}
		return d === 0;
	}

	function compare(b1, b2) {
		if (!(b1 instanceof Uint8Array && b2 instanceof Uint8Array)) {
			throw new TypeError("Only Uint8Array instances can be compared");
		}
		if (b1.length !== b2.length) {
			throw new TypeError("Only instances of identical length can be compared");
		}
		for (var gt = 0 | 0, eq = 1 | 1, i = b1.length; i-- > 0;) {
			gt |= ((b2[i] - b1[i]) >> 8) & eq;
			eq &= ((b2[i] ^ b1[i]) - 1) >> 8;
		}
		return (gt + gt + eq) - 1;
	}

	//---------------------------------------------------------------------------
	// Codecs

	function from_string(str) {
		if (typeof TextEncoder === "function") {
			return new TextEncoder("utf-8").encode(str);
		}
		str = unescape(encodeURIComponent(str));
		var bytes = new Uint8Array(str.length);
		for (var i = 0; i < str.length; i++) {
			bytes[i] = str.charCodeAt(i);
		}
		return bytes;
	}

	function to_string(bytes) {
		if (typeof TextDecoder === "function") {
			return new TextDecoder("utf-8", {fatal: true}).decode(bytes);
		}

		try {
			return decodeURIComponent(escape(String.fromCharCode.apply(null, bytes)));
		}
		catch (_) {
			throw new TypeError("The encoded data was not valid.");
		}
	}

	function from_hex(str) {
		if (!is_hex(str)) throw new TypeError("The provided string doesn't look like hex data");
		var result = new Uint8Array(str.length / 2);
		for (var i = 0; i < str.length; i += 2) {
			result[i >>> 1] = parseInt(str.substr(i, 2), 16);
		}
		return result;
	}

	function to_hex(bytes) {
		var str = "", b, c, x;
		for (var i = 0; i < bytes.length; i++) {
			c = bytes[i] & 0xf;
			b = bytes[i] >>> 4;
			x = (87 + c + (((c - 10) >> 8) & ~38)) << 8 |
			    (87 + b + (((b - 10) >> 8) & ~38));
			str += String.fromCharCode(x & 0xff) + String.fromCharCode(x >>> 8);
		}
		return str;
	}

	function is_hex(str) {
		return (typeof str === "string" && /^[0-9a-f]+$/i.test(str) && str.length % 2 === 0);
	}

	function from_base64(sBase64, nBlocksSize) {
		function _b64ToUint6(nChr) {
			return nChr > 64 && nChr < 91 ?
				nChr - 65 : nChr > 96 && nChr < 123 ?
				nChr - 71 : nChr > 47 && nChr < 58 ?
				nChr + 4 : nChr === 43 ?
				62 : nChr === 47 ?
				63 :
				0;
		}
		var
			sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
			nInLen = sB64Enc.length,
			nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2,
			taBytes = new Uint8Array(nOutLen);
		for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
			nMod4 = nInIdx & 3;
			nUint24 |= _b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
			if (nMod4 === 3 || nInLen - nInIdx === 1) {
				for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
					taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
				}
				nUint24 = 0;
			}
		}
		return taBytes;
	}

	function to_base64(aBytes, noNewLine) {
		function _uint6ToB64(nUint6) {
			return nUint6 < 26 ?
				nUint6 + 65 : nUint6 < 52 ?
				nUint6 + 71 : nUint6 < 62 ?
				nUint6 - 4 : nUint6 === 62 ?
				43 : nUint6 === 63 ?
				47 :
				65;
		}
		if (typeof aBytes === "string") {
			throw new Exception("input has to be an array");
		}
		var nMod3 = 2,
			sB64Enc = "";
		for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
			nMod3 = nIdx % 3;
			if (nIdx > 0 && (nIdx * 4 / 3) % 76 === 0 && !noNewLine) {
				sB64Enc += "\r\n";
			}
			nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
			if (nMod3 === 2 || aBytes.length - nIdx === 1) {
				sB64Enc += String.fromCharCode(_uint6ToB64(nUint24 >>> 18 & 63), _uint6ToB64(nUint24 >>> 12 & 63), _uint6ToB64(nUint24 >>> 6 & 63), _uint6ToB64(nUint24 & 63));
				nUint24 = 0;
			}
		}
		return sB64Enc.substr(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
	}

	function output_formats() {
		return ["uint8array", "text", "hex", "base64"];
	}

	function _format_output(output, optionalOutputFormat) {
		var selectedOutputFormat = optionalOutputFormat || output_format;
		if (!_is_output_format(selectedOutputFormat)) throw new Error(selectedOutputFormat + " output format is not available");
		if (output instanceof AllocatedBuf) {
			if (selectedOutputFormat === "uint8array") return output.to_Uint8Array();
			else if (selectedOutputFormat === "text") return libsodium.Pointer_stringify(output.address, output.length);
			else if (selectedOutputFormat === "hex") return to_hex(output.to_Uint8Array());
			else if (selectedOutputFormat === "base64") return to_base64(output.to_Uint8Array());
			else throw new Error("What is output format \"" + selectedOutputFormat + "\"?");
		} else if (typeof output === "object") { //Composed output. Example : key pairs
			var props = Object.keys(output);
			var formattedOutput = {};
			for (var i = 0; i < props.length; i++) {
				formattedOutput[props[i]] = _format_output(output[props[i]], selectedOutputFormat);
			}
			return formattedOutput;
		} else if (typeof output === "string") {
			return output;
		} else {
			throw new TypeError("Cannot format output");
		}
	}

	function _is_output_format(format) {
		var formats = output_formats();
		for (var i = 0; i < formats.length; i++) {
			if (formats[i] === format) return true;
		}
		return false;
	}

	function _check_output_format(format) {
		if (!format) {
			return;
		} else if (typeof format !== "string") {
			throw new TypeError("When defined, the output format must be a string");
		} else if (!_is_output_format(format)) {
			throw new Error(format + " is not a supported output format");
		}
	}

	//---------------------------------------------------------------------------
	// Memory management

	// AllocatedBuf: address allocated using _malloc() + length
	function AllocatedBuf(length) {
		this.length = length;
		this.address = _malloc(length);
	}

	// Copy the content of a AllocatedBuf (_malloc()'d memory) into a Uint8Array
	AllocatedBuf.prototype.to_Uint8Array = function () {
		var result = new Uint8Array(this.length);
		result.set(libsodium.HEAPU8.subarray(this.address, this.address + this.length));
		return result;
	};

	// _malloc() a region and initialize it with the content of a Uint8Array
	function _to_allocated_buf_address(bytes) {
		var address = _malloc(bytes.length);
		libsodium.HEAPU8.set(bytes, address);
		return address;
	}

	function _malloc(length) {
		var result = libsodium._malloc(length);
		if (result === 0) {
			throw {
				message: "_malloc() failed",
				length: length
			};
		}
		return result;
	}

	function _free(address) {
		libsodium._free(address);
	}

	function _free_all(addresses) {
		for (var i = 0; i < addresses.length; i++) {
			_free(addresses[i]);
		}
	}

	function _free_and_throw_error(address_pool, err) {
		_free_all(address_pool);
		throw new Error(err);
	}

	function _free_and_throw_type_error(address_pool, err) {
		_free_all(address_pool);
		throw new TypeError(err);
	}

	function _require_defined(address_pool, varValue, varName) {
		if (varValue == undefined) {
			_free_and_throw_type_error(address_pool, varName + " cannot be null or undefined");
		}
	}

	function _any_to_Uint8Array(address_pool, varValue, varName) {
		_require_defined(address_pool, varValue, varName);
		if (varValue instanceof Uint8Array) {
			return varValue;
		} else if (typeof varValue === "string") {
			return from_string(varValue);
		}
		_free_and_throw_type_error(address_pool, "unsupported input type for " + varName);
	}

	
	function crypto_aead_chacha20poly1305_decrypt(secret_nonce, ciphertext, additional_data, public_nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: secret_nonce (unsized_buf_optional)
		
		var secret_nonce_address = null, secret_nonce_length = 0;
		if (secret_nonce != undefined) {
			secret_nonce = _any_to_Uint8Array(address_pool, secret_nonce, "secret_nonce");
			secret_nonce_address = _to_allocated_buf_address(secret_nonce);
			secret_nonce_length = secret_nonce.length;
			address_pool.push(secret_nonce_address);
		}
		
		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: additional_data (unsized_buf_optional)
		
		var additional_data_address = null, additional_data_length = 0;
		if (additional_data != undefined) {
			additional_data = _any_to_Uint8Array(address_pool, additional_data, "additional_data");
			additional_data_address = _to_allocated_buf_address(additional_data);
			additional_data_length = additional_data.length;
			address_pool.push(additional_data_address);
		}
		
		// ---------- input: public_nonce (buf)
		
		public_nonce = _any_to_Uint8Array(address_pool, public_nonce, "public_nonce");
		var public_nonce_address, public_nonce_length = (libsodium._crypto_aead_chacha20poly1305_npubbytes()) | 0;
		if (public_nonce.length !== public_nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid public_nonce length");
		}
		public_nonce_address = _to_allocated_buf_address(public_nonce);
		address_pool.push(public_nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_aead_chacha20poly1305_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output message (buf)
		
		var message_length = (ciphertext_length - libsodium._crypto_aead_chacha20poly1305_abytes()) | 0,
		    message = new AllocatedBuf(message_length),
		    message_address = message.address;
		
		address_pool.push(message_address);
		
		if ((libsodium._crypto_aead_chacha20poly1305_decrypt(message_address, null, secret_nonce_address, ciphertext_address, ciphertext_length, 0, additional_data_address, additional_data_length, 0, public_nonce_address, key_address)) === 0) {
			var ret = _format_output(message, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_aead_chacha20poly1305_encrypt(message, additional_data, secret_nonce, public_nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: additional_data (unsized_buf_optional)
		
		var additional_data_address = null, additional_data_length = 0;
		if (additional_data != undefined) {
			additional_data = _any_to_Uint8Array(address_pool, additional_data, "additional_data");
			additional_data_address = _to_allocated_buf_address(additional_data);
			additional_data_length = additional_data.length;
			address_pool.push(additional_data_address);
		}
		
		// ---------- input: secret_nonce (unsized_buf_optional)
		
		var secret_nonce_address = null, secret_nonce_length = 0;
		if (secret_nonce != undefined) {
			secret_nonce = _any_to_Uint8Array(address_pool, secret_nonce, "secret_nonce");
			secret_nonce_address = _to_allocated_buf_address(secret_nonce);
			secret_nonce_length = secret_nonce.length;
			address_pool.push(secret_nonce_address);
		}
		
		// ---------- input: public_nonce (buf)
		
		public_nonce = _any_to_Uint8Array(address_pool, public_nonce, "public_nonce");
		var public_nonce_address, public_nonce_length = (libsodium._crypto_aead_chacha20poly1305_npubbytes()) | 0;
		if (public_nonce.length !== public_nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid public_nonce length");
		}
		public_nonce_address = _to_allocated_buf_address(public_nonce);
		address_pool.push(public_nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_aead_chacha20poly1305_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output ciphertext (buf)
		
		var ciphertext_length = (message_length + libsodium._crypto_aead_chacha20poly1305_abytes()) | 0,
		    ciphertext = new AllocatedBuf(ciphertext_length),
		    ciphertext_address = ciphertext.address;
		
		address_pool.push(ciphertext_address);
		
		if ((libsodium._crypto_aead_chacha20poly1305_encrypt(ciphertext_address, null, message_address, message_length, 0, additional_data_address, additional_data_length, 0, secret_nonce_address, public_nonce_address, key_address)) === 0) {
			var ret = _format_output(ciphertext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_aead_chacha20poly1305_ietf_decrypt(secret_nonce, ciphertext, additional_data, public_nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: secret_nonce (unsized_buf_optional)
		
		var secret_nonce_address = null, secret_nonce_length = 0;
		if (secret_nonce != undefined) {
			secret_nonce = _any_to_Uint8Array(address_pool, secret_nonce, "secret_nonce");
			secret_nonce_address = _to_allocated_buf_address(secret_nonce);
			secret_nonce_length = secret_nonce.length;
			address_pool.push(secret_nonce_address);
		}
		
		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: additional_data (unsized_buf_optional)
		
		var additional_data_address = null, additional_data_length = 0;
		if (additional_data != undefined) {
			additional_data = _any_to_Uint8Array(address_pool, additional_data, "additional_data");
			additional_data_address = _to_allocated_buf_address(additional_data);
			additional_data_length = additional_data.length;
			address_pool.push(additional_data_address);
		}
		
		// ---------- input: public_nonce (buf)
		
		public_nonce = _any_to_Uint8Array(address_pool, public_nonce, "public_nonce");
		var public_nonce_address, public_nonce_length = (libsodium._crypto_aead_chacha20poly1305_ietf_npubbytes()) | 0;
		if (public_nonce.length !== public_nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid public_nonce length");
		}
		public_nonce_address = _to_allocated_buf_address(public_nonce);
		address_pool.push(public_nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_aead_chacha20poly1305_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output message (buf)
		
		var message_length = (ciphertext_length - libsodium._crypto_aead_chacha20poly1305_abytes()) | 0,
		    message = new AllocatedBuf(message_length),
		    message_address = message.address;
		
		address_pool.push(message_address);
		
		if ((libsodium._crypto_aead_chacha20poly1305_ietf_decrypt(message_address, null, secret_nonce_address, ciphertext_address, ciphertext_length, 0, additional_data_address, additional_data_length, 0, public_nonce_address, key_address)) === 0) {
			var ret = _format_output(message, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_aead_chacha20poly1305_ietf_encrypt(message, additional_data, secret_nonce, public_nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: additional_data (unsized_buf_optional)
		
		var additional_data_address = null, additional_data_length = 0;
		if (additional_data != undefined) {
			additional_data = _any_to_Uint8Array(address_pool, additional_data, "additional_data");
			additional_data_address = _to_allocated_buf_address(additional_data);
			additional_data_length = additional_data.length;
			address_pool.push(additional_data_address);
		}
		
		// ---------- input: secret_nonce (unsized_buf_optional)
		
		var secret_nonce_address = null, secret_nonce_length = 0;
		if (secret_nonce != undefined) {
			secret_nonce = _any_to_Uint8Array(address_pool, secret_nonce, "secret_nonce");
			secret_nonce_address = _to_allocated_buf_address(secret_nonce);
			secret_nonce_length = secret_nonce.length;
			address_pool.push(secret_nonce_address);
		}
		
		// ---------- input: public_nonce (buf)
		
		public_nonce = _any_to_Uint8Array(address_pool, public_nonce, "public_nonce");
		var public_nonce_address, public_nonce_length = (libsodium._crypto_aead_chacha20poly1305_ietf_npubbytes()) | 0;
		if (public_nonce.length !== public_nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid public_nonce length");
		}
		public_nonce_address = _to_allocated_buf_address(public_nonce);
		address_pool.push(public_nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_aead_chacha20poly1305_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output ciphertext (buf)
		
		var ciphertext_length = (message_length + libsodium._crypto_aead_chacha20poly1305_abytes()) | 0,
		    ciphertext = new AllocatedBuf(ciphertext_length),
		    ciphertext_address = ciphertext.address;
		
		address_pool.push(ciphertext_address);
		
		if ((libsodium._crypto_aead_chacha20poly1305_ietf_encrypt(ciphertext_address, null, message_address, message_length, 0, additional_data_address, additional_data_length, 0, secret_nonce_address, public_nonce_address, key_address)) === 0) {
			var ret = _format_output(ciphertext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_auth(message, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_auth_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output tag (buf)
		
		var tag_length = (libsodium._crypto_auth_bytes()) | 0,
		    tag = new AllocatedBuf(tag_length),
		    tag_address = tag.address;
		
		address_pool.push(tag_address);
		
		if ((libsodium._crypto_auth(tag_address, message_address, message_length, 0, key_address) | 0) === 0) {
			var ret = _format_output(tag, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_auth_hmacsha256(message, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_auth_hmacsha256_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_auth_hmacsha256_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_auth_hmacsha256(hash_address, message_address, message_length, 0, key_address) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_auth_hmacsha256_verify(tag, message, key) {
		var address_pool = [];

		// ---------- input: tag (buf)
		
		tag = _any_to_Uint8Array(address_pool, tag, "tag");
		var tag_address, tag_length = (libsodium._crypto_auth_hmacsha256_bytes()) | 0;
		if (tag.length !== tag_length) {
			_free_and_throw_type_error(address_pool, "invalid tag length");
		}
		tag_address = _to_allocated_buf_address(tag);
		address_pool.push(tag_address);
		
		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_auth_hmacsha256_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		var result = libsodium._crypto_auth_hmacsha256_verify(tag_address, message_address, message_length, 0, key_address) | 0;
		var ret = (result === 0);
		_free_all(address_pool);
		return ret;
		
	}

	function crypto_auth_hmacsha512(message, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_auth_hmacsha512_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_auth_hmacsha512_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_auth_hmacsha512(hash_address, message_address, message_length, 0, key_address) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_auth_hmacsha512_verify(tag, message, key) {
		var address_pool = [];

		// ---------- input: tag (buf)
		
		tag = _any_to_Uint8Array(address_pool, tag, "tag");
		var tag_address, tag_length = (libsodium._crypto_auth_hmacsha512_bytes()) | 0;
		if (tag.length !== tag_length) {
			_free_and_throw_type_error(address_pool, "invalid tag length");
		}
		tag_address = _to_allocated_buf_address(tag);
		address_pool.push(tag_address);
		
		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_auth_hmacsha512_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		var result = libsodium._crypto_auth_hmacsha512_verify(tag_address, message_address, message_length, 0, key_address) | 0;
		var ret = (result === 0);
		_free_all(address_pool);
		return ret;
		
	}

	function crypto_auth_verify(tag, message, key) {
		var address_pool = [];

		// ---------- input: tag (buf)
		
		tag = _any_to_Uint8Array(address_pool, tag, "tag");
		var tag_address, tag_length = (libsodium._crypto_auth_bytes()) | 0;
		if (tag.length !== tag_length) {
			_free_and_throw_type_error(address_pool, "invalid tag length");
		}
		tag_address = _to_allocated_buf_address(tag);
		address_pool.push(tag_address);
		
		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_auth_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		var result = libsodium._crypto_auth_verify(tag_address, message_address, message_length, 0, key_address) | 0;
		var ret = (result === 0);
		_free_all(address_pool);
		return ret;
		
	}

	function crypto_box_beforenm(publicKey, secretKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- input: secretKey (buf)
		
		secretKey = _any_to_Uint8Array(address_pool, secretKey, "secretKey");
		var secretKey_address, secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0;
		if (secretKey.length !== secretKey_length) {
			_free_and_throw_type_error(address_pool, "invalid secretKey length");
		}
		secretKey_address = _to_allocated_buf_address(secretKey);
		address_pool.push(secretKey_address);
		
		// ---------- output sharedKey (buf)
		
		var sharedKey_length = (libsodium._crypto_box_beforenmbytes()) | 0,
		    sharedKey = new AllocatedBuf(sharedKey_length),
		    sharedKey_address = sharedKey.address;
		
		address_pool.push(sharedKey_address);
		
		if ((libsodium._crypto_box_beforenm(sharedKey_address, publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output(sharedKey, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_detached(message, nonce, publicKey, secretKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_box_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- input: secretKey (buf)
		
		secretKey = _any_to_Uint8Array(address_pool, secretKey, "secretKey");
		var secretKey_address, secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0;
		if (secretKey.length !== secretKey_length) {
			_free_and_throw_type_error(address_pool, "invalid secretKey length");
		}
		secretKey_address = _to_allocated_buf_address(secretKey);
		address_pool.push(secretKey_address);
		
		// ---------- output ciphertext (buf)
		
		var ciphertext_length = (message_length) | 0,
		    ciphertext = new AllocatedBuf(ciphertext_length),
		    ciphertext_address = ciphertext.address;
		
		address_pool.push(ciphertext_address);
		
		// ---------- output mac (buf)
		
		var mac_length = (libsodium._crypto_box_macbytes()) | 0,
		    mac = new AllocatedBuf(mac_length),
		    mac_address = mac.address;
		
		address_pool.push(mac_address);
		
		if ((libsodium._crypto_box_detached(ciphertext_address, mac_address, message_address, message_length, 0, nonce_address, publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output({ciphertext: ciphertext, mac: mac}, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_easy(message, nonce, publicKey, secretKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_box_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- input: secretKey (buf)
		
		secretKey = _any_to_Uint8Array(address_pool, secretKey, "secretKey");
		var secretKey_address, secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0;
		if (secretKey.length !== secretKey_length) {
			_free_and_throw_type_error(address_pool, "invalid secretKey length");
		}
		secretKey_address = _to_allocated_buf_address(secretKey);
		address_pool.push(secretKey_address);
		
		// ---------- output ciphertext (buf)
		
		var ciphertext_length = (message_length + libsodium._crypto_box_macbytes()) | 0,
		    ciphertext = new AllocatedBuf(ciphertext_length),
		    ciphertext_address = ciphertext.address;
		
		address_pool.push(ciphertext_address);
		
		if ((libsodium._crypto_box_easy(ciphertext_address, message_address, message_length, 0, nonce_address, publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output(ciphertext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_easy_afternm(message, nonce, sharedKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_box_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: sharedKey (buf)
		
		sharedKey = _any_to_Uint8Array(address_pool, sharedKey, "sharedKey");
		var sharedKey_address, sharedKey_length = (libsodium._crypto_box_beforenmbytes()) | 0;
		if (sharedKey.length !== sharedKey_length) {
			_free_and_throw_type_error(address_pool, "invalid sharedKey length");
		}
		sharedKey_address = _to_allocated_buf_address(sharedKey);
		address_pool.push(sharedKey_address);
		
		// ---------- output ciphertext (buf)
		
		var ciphertext_length = (message_length + libsodium._crypto_box_macbytes()) | 0,
		    ciphertext = new AllocatedBuf(ciphertext_length),
		    ciphertext_address = ciphertext.address;
		
		address_pool.push(ciphertext_address);
		
		if ((libsodium._crypto_box_easy_afternm(ciphertext_address, message_address, message_length, 0, nonce_address, sharedKey_address) | 0) === 0) {
			var ret = _format_output(ciphertext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_keypair(outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- output publicKey (buf)
		
		var publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0,
		    publicKey = new AllocatedBuf(publicKey_length),
		    publicKey_address = publicKey.address;
		
		address_pool.push(publicKey_address);
		
		// ---------- output secretKey (buf)
		
		var secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0,
		    secretKey = new AllocatedBuf(secretKey_length),
		    secretKey_address = secretKey.address;
		
		address_pool.push(secretKey_address);
		
		if ((libsodium._crypto_box_keypair(publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output({publicKey: publicKey, privateKey: secretKey, keyType: "curve25519"}, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_open_detached(ciphertext, mac, nonce, publicKey, secretKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: mac (buf)
		
		mac = _any_to_Uint8Array(address_pool, mac, "mac");
		var mac_address, mac_length = (libsodium._crypto_box_macbytes()) | 0;
		if (mac.length !== mac_length) {
			_free_and_throw_type_error(address_pool, "invalid mac length");
		}
		mac_address = _to_allocated_buf_address(mac);
		address_pool.push(mac_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_box_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- input: secretKey (buf)
		
		secretKey = _any_to_Uint8Array(address_pool, secretKey, "secretKey");
		var secretKey_address, secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0;
		if (secretKey.length !== secretKey_length) {
			_free_and_throw_type_error(address_pool, "invalid secretKey length");
		}
		secretKey_address = _to_allocated_buf_address(secretKey);
		address_pool.push(secretKey_address);
		
		// ---------- output plaintext (buf)
		
		var plaintext_length = (ciphertext_length) | 0,
		    plaintext = new AllocatedBuf(plaintext_length),
		    plaintext_address = plaintext.address;
		
		address_pool.push(plaintext_address);
		
		if ((libsodium._crypto_box_open_detached(plaintext_address, ciphertext_address, mac_address, ciphertext_length, 0, nonce_address, publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output(plaintext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_open_easy(ciphertext, nonce, publicKey, secretKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_box_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- input: secretKey (buf)
		
		secretKey = _any_to_Uint8Array(address_pool, secretKey, "secretKey");
		var secretKey_address, secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0;
		if (secretKey.length !== secretKey_length) {
			_free_and_throw_type_error(address_pool, "invalid secretKey length");
		}
		secretKey_address = _to_allocated_buf_address(secretKey);
		address_pool.push(secretKey_address);
		
		// ---------- output plaintext (buf)
		
		var plaintext_length = (ciphertext_length - libsodium._crypto_box_macbytes()) | 0,
		    plaintext = new AllocatedBuf(plaintext_length),
		    plaintext_address = plaintext.address;
		
		address_pool.push(plaintext_address);
		
		if ((libsodium._crypto_box_open_easy(plaintext_address, ciphertext_address, ciphertext_length, 0, nonce_address, publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output(plaintext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_open_easy_afternm(ciphertext, nonce, sharedKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_box_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: sharedKey (buf)
		
		sharedKey = _any_to_Uint8Array(address_pool, sharedKey, "sharedKey");
		var sharedKey_address, sharedKey_length = (libsodium._crypto_box_beforenmbytes()) | 0;
		if (sharedKey.length !== sharedKey_length) {
			_free_and_throw_type_error(address_pool, "invalid sharedKey length");
		}
		sharedKey_address = _to_allocated_buf_address(sharedKey);
		address_pool.push(sharedKey_address);
		
		// ---------- output plaintext (buf)
		
		var plaintext_length = (ciphertext_length - libsodium._crypto_box_macbytes()) | 0,
		    plaintext = new AllocatedBuf(plaintext_length),
		    plaintext_address = plaintext.address;
		
		address_pool.push(plaintext_address);
		
		if ((libsodium._crypto_box_open_easy_afternm(plaintext_address, ciphertext_address, ciphertext_length, 0, nonce_address, sharedKey_address) | 0) === 0) {
			var ret = _format_output(plaintext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_seal(message, publicKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- output ciphertext (buf)
		
		var ciphertext_length = (message_length + libsodium._crypto_box_sealbytes()) | 0,
		    ciphertext = new AllocatedBuf(ciphertext_length),
		    ciphertext_address = ciphertext.address;
		
		address_pool.push(ciphertext_address);
		
		if ((libsodium._crypto_box_seal(ciphertext_address, message_address, message_length, 0, publicKey_address) | 0) === 0) {
			var ret = _format_output(ciphertext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_seal_open(ciphertext, publicKey, secretKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- input: secretKey (buf)
		
		secretKey = _any_to_Uint8Array(address_pool, secretKey, "secretKey");
		var secretKey_address, secretKey_length = (libsodium._crypto_box_secretkeybytes()) | 0;
		if (secretKey.length !== secretKey_length) {
			_free_and_throw_type_error(address_pool, "invalid secretKey length");
		}
		secretKey_address = _to_allocated_buf_address(secretKey);
		address_pool.push(secretKey_address);
		
		// ---------- output plaintext (buf)
		
		var plaintext_length = (ciphertext_length - libsodium._crypto_box_sealbytes()) | 0,
		    plaintext = new AllocatedBuf(plaintext_length),
		    plaintext_address = plaintext.address;
		
		address_pool.push(plaintext_address);
		
		if ((libsodium._crypto_box_seal_open(plaintext_address, ciphertext_address, ciphertext_length, 0, publicKey_address, secretKey_address) | 0) === 0) {
			var ret = _format_output(plaintext, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_box_seed_keypair(seed, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: seed (buf)
		
		seed = _any_to_Uint8Array(address_pool, seed, "seed");
		var seed_address, seed_length = (libsodium._crypto_box_seedbytes()) | 0;
		if (seed.length !== seed_length) {
			_free_and_throw_type_error(address_pool, "invalid seed length");
		}
		seed_address = _to_allocated_buf_address(seed);
		address_pool.push(seed_address);
		
		// ---------- output publicKey (buf)
		
		var publicKey_length = (libsodium._crypto_box_publickeybytes()) | 0,
		    publicKey = new AllocatedBuf(publicKey_length),
		    publicKey_address = publicKey.address;
		
		address_pool.push(publicKey_address);
		
		// ---------- output privateKey (buf)
		
		var privateKey_length = (libsodium._crypto_box_secretkeybytes()) | 0,
		    privateKey = new AllocatedBuf(privateKey_length),
		    privateKey_address = privateKey.address;
		
		address_pool.push(privateKey_address);
		
		if ((libsodium._crypto_box_seed_keypair(publicKey_address, privateKey_address, seed_address) | 0) === 0) {
			var ret = _format_output({publicKey: publicKey, privateKey: privateKey}, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_generichash(hash_length, message, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: hash_length (uint)
		
		_require_defined(address_pool, hash_length, "hash_length");
		
		if (!(typeof hash_length === "number" && (hash_length | 0) === hash_length) && (hash_length | 0) > 0) {
			_free_and_throw_type_error(address_pool, "hash_length must be an unsigned integer");
		}
		
		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (unsized_buf_optional)
		
		var key_address = null, key_length = 0;
		if (key != undefined) {
			key = _any_to_Uint8Array(address_pool, key, "key");
			key_address = _to_allocated_buf_address(key);
			key_length = key.length;
			address_pool.push(key_address);
		}
		
		// ---------- output hash (buf)
		
		var hash_length = (hash_length) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_generichash(hash_address, hash_length, message_address, message_length, 0, key_address, key_length) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_generichash_final(state_address, hash_length, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: state_address (generichash_state_address)
		
		_require_defined(address_pool, state_address, "state_address");
		
		// ---------- input: hash_length (uint)
		
		_require_defined(address_pool, hash_length, "hash_length");
		
		if (!(typeof hash_length === "number" && (hash_length | 0) === hash_length) && (hash_length | 0) > 0) {
			_free_and_throw_type_error(address_pool, "hash_length must be an unsigned integer");
		}
		
		// ---------- output hash (buf)
		
		var hash_length = (hash_length) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_generichash_final(state_address, hash_address, hash_length) | 0) === 0) {
			var ret = (libsodium._free(state_address), _format_output(hash, outputFormat));
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_generichash_init(key, hash_length, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: key (unsized_buf_optional)
		
		var key_address = null, key_length = 0;
		if (key != undefined) {
			key = _any_to_Uint8Array(address_pool, key, "key");
			key_address = _to_allocated_buf_address(key);
			key_length = key.length;
			address_pool.push(key_address);
		}
		
		// ---------- input: hash_length (uint)
		
		_require_defined(address_pool, hash_length, "hash_length");
		
		if (!(typeof hash_length === "number" && (hash_length | 0) === hash_length) && (hash_length | 0) > 0) {
			_free_and_throw_type_error(address_pool, "hash_length must be an unsigned integer");
		}
		
		// ---------- output state (generichash_state)
		
		var state_address = new AllocatedBuf(357).address;
		
		if ((libsodium._crypto_generichash_init(state_address, key_address, key_length, hash_length) | 0) === 0) {
			var ret = state_address;
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_generichash_update(state_address, message_chunk, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: state_address (generichash_state_address)
		
		_require_defined(address_pool, state_address, "state_address");
		
		// ---------- input: message_chunk (unsized_buf)
		
		message_chunk = _any_to_Uint8Array(address_pool, message_chunk, "message_chunk");
		var message_chunk_address = _to_allocated_buf_address(message_chunk),
		    message_chunk_length = message_chunk.length;
		address_pool.push(message_chunk_address);
		
		if ((libsodium._crypto_generichash_update(state_address, message_chunk_address, message_chunk_length) | 0) === 0) {
			_free_all(address_pool);
			return;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_hash(message, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_hash_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_hash(hash_address, message_address, message_length, 0) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_hash_sha256(message, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_hash_sha256_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_hash_sha256(hash_address, message_address, message_length, 0) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_hash_sha512(message, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_hash_sha512_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_hash_sha512(hash_address, message_address, message_length, 0) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_onetimeauth(message, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_onetimeauth_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_onetimeauth_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_onetimeauth(hash_address, message_address, message_length, 0, key_address) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_onetimeauth_final(state_address, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: state_address (onetimeauth_state_address)
		
		_require_defined(address_pool, state_address, "state_address");
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_onetimeauth_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_onetimeauth_final(state_address, hash_address) | 0) === 0) {
			var ret = (libsodium._free(state_address), _format_output(hash, outputFormat));
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_onetimeauth_init(key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: key (unsized_buf_optional)
		
		var key_address = null, key_length = 0;
		if (key != undefined) {
			key = _any_to_Uint8Array(address_pool, key, "key");
			key_address = _to_allocated_buf_address(key);
			key_length = key.length;
			address_pool.push(key_address);
		}
		
		// ---------- output state (onetimeauth_state)
		
		var state_address = new AllocatedBuf(144).address;
		
		if ((libsodium._crypto_onetimeauth_init(state_address, key_address) | 0) === 0) {
			var ret = state_address;
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_onetimeauth_update(state_address, message_chunk, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: state_address (onetimeauth_state_address)
		
		_require_defined(address_pool, state_address, "state_address");
		
		// ---------- input: message_chunk (unsized_buf)
		
		message_chunk = _any_to_Uint8Array(address_pool, message_chunk, "message_chunk");
		var message_chunk_address = _to_allocated_buf_address(message_chunk),
		    message_chunk_length = message_chunk.length;
		address_pool.push(message_chunk_address);
		
		if ((libsodium._crypto_onetimeauth_update(state_address, message_chunk_address, message_chunk_length) | 0) === 0) {
			_free_all(address_pool);
			return;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_onetimeauth_verify(hash, message, key) {
		var address_pool = [];

		// ---------- input: hash (buf)
		
		hash = _any_to_Uint8Array(address_pool, hash, "hash");
		var hash_address, hash_length = (libsodium._crypto_onetimeauth_bytes()) | 0;
		if (hash.length !== hash_length) {
			_free_and_throw_type_error(address_pool, "invalid hash length");
		}
		hash_address = _to_allocated_buf_address(hash);
		address_pool.push(hash_address);
		
		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_onetimeauth_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		var result = libsodium._crypto_onetimeauth_verify(hash_address, message_address, message_length, 0, key_address) | 0;
		var ret = (result === 0);
		_free_all(address_pool);
		return ret;
		
	}

	function crypto_pwhash_scryptsalsa208sha256(password, salt, opsLimit, memLimit, keyLength, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: password (unsized_buf)
		
		password = _any_to_Uint8Array(address_pool, password, "password");
		var password_address = _to_allocated_buf_address(password),
		    password_length = password.length;
		address_pool.push(password_address);
		
		// ---------- input: salt (buf)
		
		salt = _any_to_Uint8Array(address_pool, salt, "salt");
		var salt_address, salt_length = (libsodium._crypto_pwhash_scryptsalsa208sha256_saltbytes()) | 0;
		if (salt.length !== salt_length) {
			_free_and_throw_type_error(address_pool, "invalid salt length");
		}
		salt_address = _to_allocated_buf_address(salt);
		address_pool.push(salt_address);
		
		// ---------- input: opsLimit (uint)
		
		_require_defined(address_pool, opsLimit, "opsLimit");
		
		if (!(typeof opsLimit === "number" && (opsLimit | 0) === opsLimit) && (opsLimit | 0) > 0) {
			_free_and_throw_type_error(address_pool, "opsLimit must be an unsigned integer");
		}
		
		// ---------- input: memLimit (uint)
		
		_require_defined(address_pool, memLimit, "memLimit");
		
		if (!(typeof memLimit === "number" && (memLimit | 0) === memLimit) && (memLimit | 0) > 0) {
			_free_and_throw_type_error(address_pool, "memLimit must be an unsigned integer");
		}
		
		// ---------- input: keyLength (uint)
		
		_require_defined(address_pool, keyLength, "keyLength");
		
		if (!(typeof keyLength === "number" && (keyLength | 0) === keyLength) && (keyLength | 0) > 0) {
			_free_and_throw_type_error(address_pool, "keyLength must be an unsigned integer");
		}
		
		// ---------- output derivedKey (buf)
		
		var derivedKey_length = (keyLength) | 0,
		    derivedKey = new AllocatedBuf(derivedKey_length),
		    derivedKey_address = derivedKey.address;
		
		address_pool.push(derivedKey_address);
		
		if ((libsodium._crypto_pwhash_scryptsalsa208sha256(derivedKey_address, keyLength, 0, password_address, password_length, 0, salt_address, opsLimit, 0, memLimit) | 0) === 0) {
			var ret = _format_output(derivedKey, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_pwhash_scryptsalsa208sha256_ll(password, salt, opsLimit, r, p, keyLength, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: password (unsized_buf)
		
		password = _any_to_Uint8Array(address_pool, password, "password");
		var password_address = _to_allocated_buf_address(password),
		    password_length = password.length;
		address_pool.push(password_address);
		
		// ---------- input: salt (unsized_buf)
		
		salt = _any_to_Uint8Array(address_pool, salt, "salt");
		var salt_address = _to_allocated_buf_address(salt),
		    salt_length = salt.length;
		address_pool.push(salt_address);
		
		// ---------- input: opsLimit (uint)
		
		_require_defined(address_pool, opsLimit, "opsLimit");
		
		if (!(typeof opsLimit === "number" && (opsLimit | 0) === opsLimit) && (opsLimit | 0) > 0) {
			_free_and_throw_type_error(address_pool, "opsLimit must be an unsigned integer");
		}
		
		// ---------- input: r (uint)
		
		_require_defined(address_pool, r, "r");
		
		if (!(typeof r === "number" && (r | 0) === r) && (r | 0) > 0) {
			_free_and_throw_type_error(address_pool, "r must be an unsigned integer");
		}
		
		// ---------- input: p (uint)
		
		_require_defined(address_pool, p, "p");
		
		if (!(typeof p === "number" && (p | 0) === p) && (p | 0) > 0) {
			_free_and_throw_type_error(address_pool, "p must be an unsigned integer");
		}
		
		// ---------- input: keyLength (uint)
		
		_require_defined(address_pool, keyLength, "keyLength");
		
		if (!(typeof keyLength === "number" && (keyLength | 0) === keyLength) && (keyLength | 0) > 0) {
			_free_and_throw_type_error(address_pool, "keyLength must be an unsigned integer");
		}
		
		// ---------- output derivedKey (buf)
		
		var derivedKey_length = (keyLength) | 0,
		    derivedKey = new AllocatedBuf(derivedKey_length),
		    derivedKey_address = derivedKey.address;
		
		address_pool.push(derivedKey_address);
		
		if ((libsodium._crypto_pwhash_scryptsalsa208sha256_ll(password_address, password_length, salt_address, salt_length, opsLimit, 0, r, p, derivedKey_address, keyLength) | 0) === 0) {
			var ret = _format_output(derivedKey, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_pwhash_scryptsalsa208sha256_str(password, opsLimit, memLimit, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: password (unsized_buf)
		
		password = _any_to_Uint8Array(address_pool, password, "password");
		var password_address = _to_allocated_buf_address(password),
		    password_length = password.length;
		address_pool.push(password_address);
		
		// ---------- input: opsLimit (uint)
		
		_require_defined(address_pool, opsLimit, "opsLimit");
		
		if (!(typeof opsLimit === "number" && (opsLimit | 0) === opsLimit) && (opsLimit | 0) > 0) {
			_free_and_throw_type_error(address_pool, "opsLimit must be an unsigned integer");
		}
		
		// ---------- input: memLimit (uint)
		
		_require_defined(address_pool, memLimit, "memLimit");
		
		if (!(typeof memLimit === "number" && (memLimit | 0) === memLimit) && (memLimit | 0) > 0) {
			_free_and_throw_type_error(address_pool, "memLimit must be an unsigned integer");
		}
		
		// ---------- output hashed_password (buf)
		
		var hashed_password_length = (libsodium._crypto_pwhash_scryptsalsa208sha256_strbytes()) | 0,
		    hashed_password = new AllocatedBuf(hashed_password_length),
		    hashed_password_address = hashed_password.address;
		
		address_pool.push(hashed_password_address);
		
		if ((libsodium._crypto_pwhash_scryptsalsa208sha256_str(hashed_password_address, password_address, password_length, 0, opsLimit, 0, memLimit) | 0) === 0) {
			var ret = libsodium.Pointer_stringify(hashed_password_address);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_pwhash_scryptsalsa208sha256_str_verify(hashed_password, password, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: hashed_password (string)
		
		hashed_password = from_string(hashed_password + "\0");
		var hashed_password_address = _to_allocated_buf_address(hashed_password),
		    hashed_password_length = hashed_password.length - 1;
		address_pool.push(hashed_password_address);
		
		// ---------- input: password (unsized_buf)
		
		password = _any_to_Uint8Array(address_pool, password, "password");
		var password_address = _to_allocated_buf_address(password),
		    password_length = password.length;
		address_pool.push(password_address);
		
		var result = libsodium._crypto_pwhash_scryptsalsa208sha256_str_verify(hashed_password_address, password_address, password_length, 0) | 0;
		var ret = (result === 0);
		_free_all(address_pool);
		return ret;
		
	}

	function crypto_scalarmult(privateKey, publicKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: privateKey (buf)
		
		privateKey = _any_to_Uint8Array(address_pool, privateKey, "privateKey");
		var privateKey_address, privateKey_length = (libsodium._crypto_scalarmult_scalarbytes()) | 0;
		if (privateKey.length !== privateKey_length) {
			_free_and_throw_type_error(address_pool, "invalid privateKey length");
		}
		privateKey_address = _to_allocated_buf_address(privateKey);
		address_pool.push(privateKey_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_scalarmult_scalarbytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- output sharedSecret (buf)
		
		var sharedSecret_length = (libsodium._crypto_scalarmult_bytes()) | 0,
		    sharedSecret = new AllocatedBuf(sharedSecret_length),
		    sharedSecret_address = sharedSecret.address;
		
		address_pool.push(sharedSecret_address);
		
		if ((libsodium._crypto_scalarmult(sharedSecret_address, privateKey_address, publicKey_address) | 0) === 0) {
			var ret = _format_output(sharedSecret, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_scalarmult_base(privateKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: privateKey (buf)
		
		privateKey = _any_to_Uint8Array(address_pool, privateKey, "privateKey");
		var privateKey_address, privateKey_length = (libsodium._crypto_scalarmult_scalarbytes()) | 0;
		if (privateKey.length !== privateKey_length) {
			_free_and_throw_type_error(address_pool, "invalid privateKey length");
		}
		privateKey_address = _to_allocated_buf_address(privateKey);
		address_pool.push(privateKey_address);
		
		// ---------- output publicKey (buf)
		
		var publicKey_length = (libsodium._crypto_scalarmult_scalarbytes()) | 0,
		    publicKey = new AllocatedBuf(publicKey_length),
		    publicKey_address = publicKey.address;
		
		address_pool.push(publicKey_address);
		
		if ((libsodium._crypto_scalarmult_base(publicKey_address, privateKey_address) | 0) === 0) {
			var ret = _format_output(publicKey, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_secretbox_detached(message, nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_secretbox_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_secretbox_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output cipher (buf)
		
		var cipher_length = (message_length) | 0,
		    cipher = new AllocatedBuf(cipher_length),
		    cipher_address = cipher.address;
		
		address_pool.push(cipher_address);
		
		// ---------- output mac (buf)
		
		var mac_length = (libsodium._crypto_secretbox_macbytes()) | 0,
		    mac = new AllocatedBuf(mac_length),
		    mac_address = mac.address;
		
		address_pool.push(mac_address);
		
		if ((libsodium._crypto_secretbox_detached(cipher_address, mac_address, message_address, message_length, 0, nonce_address, key_address) | 0) === 0) {
			var ret = _format_output({mac: mac, cipher: cipher}, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_secretbox_easy(message, nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_secretbox_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_secretbox_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output cipher (buf)
		
		var cipher_length = (message_length + libsodium._crypto_secretbox_macbytes()) | 0,
		    cipher = new AllocatedBuf(cipher_length),
		    cipher_address = cipher.address;
		
		address_pool.push(cipher_address);
		
		if ((libsodium._crypto_secretbox_easy(cipher_address, message_address, message_length, 0, nonce_address, key_address) | 0) === 0) {
			var ret = _format_output(cipher, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_secretbox_open_detached(ciphertext, mac, nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: mac (buf)
		
		mac = _any_to_Uint8Array(address_pool, mac, "mac");
		var mac_address, mac_length = (libsodium._crypto_secretbox_macbytes()) | 0;
		if (mac.length !== mac_length) {
			_free_and_throw_type_error(address_pool, "invalid mac length");
		}
		mac_address = _to_allocated_buf_address(mac);
		address_pool.push(mac_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_secretbox_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_secretbox_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output message (buf)
		
		var message_length = (ciphertext_length) | 0,
		    message = new AllocatedBuf(message_length),
		    message_address = message.address;
		
		address_pool.push(message_address);
		
		if ((libsodium._crypto_secretbox_open_detached(message_address, ciphertext_address, mac_address, ciphertext_length, 0, nonce_address, key_address) | 0) === 0) {
			var ret = _format_output(message, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_secretbox_open_easy(ciphertext, nonce, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: ciphertext (unsized_buf)
		
		ciphertext = _any_to_Uint8Array(address_pool, ciphertext, "ciphertext");
		var ciphertext_address = _to_allocated_buf_address(ciphertext),
		    ciphertext_length = ciphertext.length;
		address_pool.push(ciphertext_address);
		
		// ---------- input: nonce (buf)
		
		nonce = _any_to_Uint8Array(address_pool, nonce, "nonce");
		var nonce_address, nonce_length = (libsodium._crypto_secretbox_noncebytes()) | 0;
		if (nonce.length !== nonce_length) {
			_free_and_throw_type_error(address_pool, "invalid nonce length");
		}
		nonce_address = _to_allocated_buf_address(nonce);
		address_pool.push(nonce_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_secretbox_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output message (buf)
		
		var message_length = (ciphertext_length - libsodium._crypto_secretbox_macbytes()) | 0,
		    message = new AllocatedBuf(message_length),
		    message_address = message.address;
		
		address_pool.push(message_address);
		
		if ((libsodium._crypto_secretbox_open_easy(message_address, ciphertext_address, ciphertext_length, 0, nonce_address, key_address) | 0) === 0) {
			var ret = _format_output(message, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_shorthash(message, key, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: key (buf)
		
		key = _any_to_Uint8Array(address_pool, key, "key");
		var key_address, key_length = (libsodium._crypto_shorthash_keybytes()) | 0;
		if (key.length !== key_length) {
			_free_and_throw_type_error(address_pool, "invalid key length");
		}
		key_address = _to_allocated_buf_address(key);
		address_pool.push(key_address);
		
		// ---------- output hash (buf)
		
		var hash_length = (libsodium._crypto_shorthash_bytes()) | 0,
		    hash = new AllocatedBuf(hash_length),
		    hash_address = hash.address;
		
		address_pool.push(hash_address);
		
		if ((libsodium._crypto_shorthash(hash_address, message_address, message_length, 0, key_address) | 0) === 0) {
			var ret = _format_output(hash, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign(message, privateKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: privateKey (buf)
		
		privateKey = _any_to_Uint8Array(address_pool, privateKey, "privateKey");
		var privateKey_address, privateKey_length = (libsodium._crypto_sign_secretkeybytes()) | 0;
		if (privateKey.length !== privateKey_length) {
			_free_and_throw_type_error(address_pool, "invalid privateKey length");
		}
		privateKey_address = _to_allocated_buf_address(privateKey);
		address_pool.push(privateKey_address);
		
		// ---------- output signature (buf)
		
		var signature_length = (message.length + libsodium._crypto_sign_bytes()) | 0,
		    signature = new AllocatedBuf(signature_length),
		    signature_address = signature.address;
		
		address_pool.push(signature_address);
		
		if ((libsodium._crypto_sign(signature_address, null, message_address, message_length, 0, privateKey_address) | 0) === 0) {
			var ret = _format_output(signature, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_detached(message, privateKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: privateKey (buf)
		
		privateKey = _any_to_Uint8Array(address_pool, privateKey, "privateKey");
		var privateKey_address, privateKey_length = (libsodium._crypto_sign_secretkeybytes()) | 0;
		if (privateKey.length !== privateKey_length) {
			_free_and_throw_type_error(address_pool, "invalid privateKey length");
		}
		privateKey_address = _to_allocated_buf_address(privateKey);
		address_pool.push(privateKey_address);
		
		// ---------- output signature (buf)
		
		var signature_length = (libsodium._crypto_sign_bytes()) | 0,
		    signature = new AllocatedBuf(signature_length),
		    signature_address = signature.address;
		
		address_pool.push(signature_address);
		
		if ((libsodium._crypto_sign_detached(signature_address, null, message_address, message_length, 0, privateKey_address) | 0) === 0) {
			var ret = _format_output(signature, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_ed25519_pk_to_curve25519(edPk, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: edPk (buf)
		
		edPk = _any_to_Uint8Array(address_pool, edPk, "edPk");
		var edPk_address, edPk_length = (libsodium._crypto_sign_publickeybytes()) | 0;
		if (edPk.length !== edPk_length) {
			_free_and_throw_type_error(address_pool, "invalid edPk length");
		}
		edPk_address = _to_allocated_buf_address(edPk);
		address_pool.push(edPk_address);
		
		// ---------- output cPk (buf)
		
		var cPk_length = (libsodium._crypto_scalarmult_scalarbytes()) | 0,
		    cPk = new AllocatedBuf(cPk_length),
		    cPk_address = cPk.address;
		
		address_pool.push(cPk_address);
		
		if ((libsodium._crypto_sign_ed25519_pk_to_curve25519(cPk_address, edPk_address) | 0) === 0) {
			var ret = _format_output(cPk, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_ed25519_sk_to_curve25519(edSk, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: edSk (buf)
		
		edSk = _any_to_Uint8Array(address_pool, edSk, "edSk");
		var edSk_address, edSk_length = (libsodium._crypto_sign_secretkeybytes()) | 0;
		if (edSk.length !== edSk_length) {
			_free_and_throw_type_error(address_pool, "invalid edSk length");
		}
		edSk_address = _to_allocated_buf_address(edSk);
		address_pool.push(edSk_address);
		
		// ---------- output cSk (buf)
		
		var cSk_length = (libsodium._crypto_scalarmult_scalarbytes()) | 0,
		    cSk = new AllocatedBuf(cSk_length),
		    cSk_address = cSk.address;
		
		address_pool.push(cSk_address);
		
		if ((libsodium._crypto_sign_ed25519_sk_to_curve25519(cSk_address, edSk_address) | 0) === 0) {
			var ret = _format_output(cSk, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_ed25519_sk_to_pk(privateKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: privateKey (buf)
		
		privateKey = _any_to_Uint8Array(address_pool, privateKey, "privateKey");
		var privateKey_address, privateKey_length = (libsodium._crypto_sign_secretkeybytes()) | 0;
		if (privateKey.length !== privateKey_length) {
			_free_and_throw_type_error(address_pool, "invalid privateKey length");
		}
		privateKey_address = _to_allocated_buf_address(privateKey);
		address_pool.push(privateKey_address);
		
		// ---------- output publicKey (buf)
		
		var publicKey_length = (libsodium._crypto_sign_publickeybytes()) | 0,
		    publicKey = new AllocatedBuf(publicKey_length),
		    publicKey_address = publicKey.address;
		
		address_pool.push(publicKey_address);
		
		if ((libsodium._crypto_sign_ed25519_sk_to_pk(publicKey_address, privateKey_address) | 0) === 0) {
			var ret = _format_output(publicKey, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_ed25519_sk_to_seed(privateKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: privateKey (buf)
		
		privateKey = _any_to_Uint8Array(address_pool, privateKey, "privateKey");
		var privateKey_address, privateKey_length = (libsodium._crypto_sign_secretkeybytes()) | 0;
		if (privateKey.length !== privateKey_length) {
			_free_and_throw_type_error(address_pool, "invalid privateKey length");
		}
		privateKey_address = _to_allocated_buf_address(privateKey);
		address_pool.push(privateKey_address);
		
		// ---------- output seed (buf)
		
		var seed_length = (libsodium._crypto_sign_seedbytes()) | 0,
		    seed = new AllocatedBuf(seed_length),
		    seed_address = seed.address;
		
		address_pool.push(seed_address);
		
		if ((libsodium._crypto_sign_ed25519_sk_to_seed(seed_address, privateKey_address) | 0) === 0) {
			var ret = _format_output(seed, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_keypair(outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- output publicKey (buf)
		
		var publicKey_length = (libsodium._crypto_sign_publickeybytes()) | 0,
		    publicKey = new AllocatedBuf(publicKey_length),
		    publicKey_address = publicKey.address;
		
		address_pool.push(publicKey_address);
		
		// ---------- output privateKey (buf)
		
		var privateKey_length = (libsodium._crypto_sign_secretkeybytes()) | 0,
		    privateKey = new AllocatedBuf(privateKey_length),
		    privateKey_address = privateKey.address;
		
		address_pool.push(privateKey_address);
		
		if ((libsodium._crypto_sign_keypair(publicKey_address, privateKey_address) | 0) === 0) {
			var ret = _format_output({publicKey: publicKey, privateKey: privateKey, keyType: 'ed25519'}, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_open(signedMessage, publicKey, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: signedMessage (unsized_buf)
		
		signedMessage = _any_to_Uint8Array(address_pool, signedMessage, "signedMessage");
		var signedMessage_address = _to_allocated_buf_address(signedMessage),
		    signedMessage_length = signedMessage.length;
		address_pool.push(signedMessage_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_sign_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		// ---------- output message (buf)
		
		var message_length = (signedMessage_length - libsodium._crypto_sign_bytes()) | 0,
		    message = new AllocatedBuf(message_length),
		    message_address = message.address;
		
		address_pool.push(message_address);
		
		if ((libsodium._crypto_sign_open(message_address, null, signedMessage_address, signedMessage_length, 0, publicKey_address) | 0) === 0) {
			var ret = _format_output(message, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_seed_keypair(seed, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: seed (buf)
		
		seed = _any_to_Uint8Array(address_pool, seed, "seed");
		var seed_address, seed_length = (libsodium._crypto_sign_seedbytes()) | 0;
		if (seed.length !== seed_length) {
			_free_and_throw_type_error(address_pool, "invalid seed length");
		}
		seed_address = _to_allocated_buf_address(seed);
		address_pool.push(seed_address);
		
		// ---------- output publicKey (buf)
		
		var publicKey_length = (libsodium._crypto_sign_publickeybytes()) | 0,
		    publicKey = new AllocatedBuf(publicKey_length),
		    publicKey_address = publicKey.address;
		
		address_pool.push(publicKey_address);
		
		// ---------- output privateKey (buf)
		
		var privateKey_length = (libsodium._crypto_sign_secretkeybytes()) | 0,
		    privateKey = new AllocatedBuf(privateKey_length),
		    privateKey_address = privateKey.address;
		
		address_pool.push(privateKey_address);
		
		if ((libsodium._crypto_sign_seed_keypair(publicKey_address, privateKey_address, seed_address) | 0) === 0) {
			var ret = _format_output({publicKey: publicKey, privateKey: privateKey, keyType: "ed25519"}, outputFormat);
			_free_all(address_pool);
			return ret;
		}
		_free_and_throw_error(address_pool);
		
	}

	function crypto_sign_verify_detached(signature, message, publicKey) {
		var address_pool = [];

		// ---------- input: signature (buf)
		
		signature = _any_to_Uint8Array(address_pool, signature, "signature");
		var signature_address, signature_length = (libsodium._crypto_sign_bytes()) | 0;
		if (signature.length !== signature_length) {
			_free_and_throw_type_error(address_pool, "invalid signature length");
		}
		signature_address = _to_allocated_buf_address(signature);
		address_pool.push(signature_address);
		
		// ---------- input: message (unsized_buf)
		
		message = _any_to_Uint8Array(address_pool, message, "message");
		var message_address = _to_allocated_buf_address(message),
		    message_length = message.length;
		address_pool.push(message_address);
		
		// ---------- input: publicKey (buf)
		
		publicKey = _any_to_Uint8Array(address_pool, publicKey, "publicKey");
		var publicKey_address, publicKey_length = (libsodium._crypto_sign_publickeybytes()) | 0;
		if (publicKey.length !== publicKey_length) {
			_free_and_throw_type_error(address_pool, "invalid publicKey length");
		}
		publicKey_address = _to_allocated_buf_address(publicKey);
		address_pool.push(publicKey_address);
		
		var verificationResult = libsodium._crypto_sign_verify_detached(signature_address, message_address, message_length, 0, publicKey_address) | 0;
		var ret = (verificationResult === 0);
		_free_all(address_pool);
		return ret;
		
	}

	function randombytes_buf(length, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: length (uint)
		
		_require_defined(address_pool, length, "length");
		
		if (!(typeof length === "number" && (length | 0) === length) && (length | 0) > 0) {
			_free_and_throw_type_error(address_pool, "length must be an unsigned integer");
		}
		
		// ---------- output output (buf)
		
		var output_length = (length) | 0,
		    output = new AllocatedBuf(output_length),
		    output_address = output.address;
		
		address_pool.push(output_address);
		
		libsodium._randombytes_buf(output_address, length);
		var ret = (_format_output(output, outputFormat));
		_free_all(address_pool);
		return ret;
		
	}

	function randombytes_close(outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		libsodium._randombytes_close();
		
	}

	function randombytes_random(outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		var random_value = libsodium._randombytes_random() >>> 0;
		var ret = (random_value);
		_free_all(address_pool);
		return ret;
		
	}

	function randombytes_set_implementation(implementation, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: implementation (randombytes_implementation)
		
		var implementation_address = libsodium._malloc(6 * 4);
		for (var i = 0; i < 6; i++) {
			libsodium.setValue(implementation_address + i * 4,
			    libsodium.Runtime.addFunction(implementation
			    [["implementation_name", "random", "stir", "uniform", "buf", "close"][i]]),
			    "i32");
		}
		
		if ((libsodium._randombytes_set_implementation(implementation_address) | 0) === 0) {
			_free_all(address_pool);
			return;
		}
		_free_and_throw_error(address_pool);
		
	}

	function randombytes_stir(outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		libsodium._randombytes_stir();
		
	}

	function randombytes_uniform(upper_bound, outputFormat) {
		var address_pool = [];
		_check_output_format(outputFormat);

		// ---------- input: upper_bound (uint)
		
		_require_defined(address_pool, upper_bound, "upper_bound");
		
		if (!(typeof upper_bound === "number" && (upper_bound | 0) === upper_bound) && (upper_bound | 0) > 0) {
			_free_and_throw_type_error(address_pool, "upper_bound must be an unsigned integer");
		}
		
		var random_value = libsodium._randombytes_uniform(upper_bound) >>> 0;
		var ret = (random_value);
		_free_all(address_pool);
		return ret;
		
	}

	function sodium_version_string() {
		var address_pool = [];

		var version = libsodium._sodium_version_string();
		var ret = (libsodium.Pointer_stringify(version));
		_free_all(address_pool);
		return ret;
		
	}


	exports.compare = compare;
	exports.from_base64 = from_base64;
	exports.from_hex = from_hex;
	exports.from_string = from_string;
	exports.increment = increment;
	exports.libsodium = libsodium;
	exports.memcmp = memcmp;
	exports.memzero = memzero;
	exports.output_formats = output_formats;
	exports.symbols = symbols;
	exports.to_base64 = to_base64;
	exports.to_hex = to_hex;
	exports.to_string = to_string;

	
	var exported_functions = ["crypto_aead_chacha20poly1305_decrypt", "crypto_aead_chacha20poly1305_encrypt", "crypto_aead_chacha20poly1305_ietf_decrypt", "crypto_aead_chacha20poly1305_ietf_encrypt", "crypto_auth", "crypto_auth_hmacsha256", "crypto_auth_hmacsha256_verify", "crypto_auth_hmacsha512", "crypto_auth_hmacsha512_verify", "crypto_auth_verify", "crypto_box_beforenm", "crypto_box_detached", "crypto_box_easy", "crypto_box_easy_afternm", "crypto_box_keypair", "crypto_box_open_detached", "crypto_box_open_easy", "crypto_box_open_easy_afternm", "crypto_box_seal", "crypto_box_seal_open", "crypto_box_seed_keypair", "crypto_generichash", "crypto_generichash_final", "crypto_generichash_init", "crypto_generichash_update", "crypto_hash", "crypto_hash_sha256", "crypto_hash_sha512", "crypto_onetimeauth", "crypto_onetimeauth_final", "crypto_onetimeauth_init", "crypto_onetimeauth_update", "crypto_onetimeauth_verify", "crypto_pwhash_scryptsalsa208sha256", "crypto_pwhash_scryptsalsa208sha256_ll", "crypto_pwhash_scryptsalsa208sha256_str", "crypto_pwhash_scryptsalsa208sha256_str_verify", "crypto_scalarmult", "crypto_scalarmult_base", "crypto_secretbox_detached", "crypto_secretbox_easy", "crypto_secretbox_open_detached", "crypto_secretbox_open_easy", "crypto_shorthash", "crypto_sign", "crypto_sign_detached", "crypto_sign_ed25519_pk_to_curve25519", "crypto_sign_ed25519_sk_to_curve25519", "crypto_sign_ed25519_sk_to_pk", "crypto_sign_ed25519_sk_to_seed", "crypto_sign_keypair", "crypto_sign_open", "crypto_sign_seed_keypair", "crypto_sign_verify_detached", "randombytes_buf", "randombytes_close", "randombytes_random", "randombytes_set_implementation", "randombytes_stir", "randombytes_uniform", "sodium_version_string"],
		functions = [crypto_aead_chacha20poly1305_decrypt, crypto_aead_chacha20poly1305_encrypt, crypto_aead_chacha20poly1305_ietf_decrypt, crypto_aead_chacha20poly1305_ietf_encrypt, crypto_auth, crypto_auth_hmacsha256, crypto_auth_hmacsha256_verify, crypto_auth_hmacsha512, crypto_auth_hmacsha512_verify, crypto_auth_verify, crypto_box_beforenm, crypto_box_detached, crypto_box_easy, crypto_box_easy_afternm, crypto_box_keypair, crypto_box_open_detached, crypto_box_open_easy, crypto_box_open_easy_afternm, crypto_box_seal, crypto_box_seal_open, crypto_box_seed_keypair, crypto_generichash, crypto_generichash_final, crypto_generichash_init, crypto_generichash_update, crypto_hash, crypto_hash_sha256, crypto_hash_sha512, crypto_onetimeauth, crypto_onetimeauth_final, crypto_onetimeauth_init, crypto_onetimeauth_update, crypto_onetimeauth_verify, crypto_pwhash_scryptsalsa208sha256, crypto_pwhash_scryptsalsa208sha256_ll, crypto_pwhash_scryptsalsa208sha256_str, crypto_pwhash_scryptsalsa208sha256_str_verify, crypto_scalarmult, crypto_scalarmult_base, crypto_secretbox_detached, crypto_secretbox_easy, crypto_secretbox_open_detached, crypto_secretbox_open_easy, crypto_shorthash, crypto_sign, crypto_sign_detached, crypto_sign_ed25519_pk_to_curve25519, crypto_sign_ed25519_sk_to_curve25519, crypto_sign_ed25519_sk_to_pk, crypto_sign_ed25519_sk_to_seed, crypto_sign_keypair, crypto_sign_open, crypto_sign_seed_keypair, crypto_sign_verify_detached, randombytes_buf, randombytes_close, randombytes_random, randombytes_set_implementation, randombytes_stir, randombytes_uniform, sodium_version_string];
	for (var i = 0; i < functions.length; i++) {
		if (typeof libsodium["_" + exported_functions[i]] === "function") {
			exports[exported_functions[i]] = functions[i];
		}
	}
	var constants = ["SODIUM_LIBRARY_VERSION_MAJOR", "SODIUM_LIBRARY_VERSION_MINOR", "crypto_aead_chacha20poly1305_ABYTES", "crypto_aead_chacha20poly1305_KEYBYTES", "crypto_aead_chacha20poly1305_NPUBBYTES", "crypto_aead_chacha20poly1305_NSECBYTES", "crypto_aead_chacha20poly1305_ietf_NPUBBYTES", "crypto_auth_BYTES", "crypto_auth_KEYBYTES", "crypto_auth_hmacsha256_BYTES", "crypto_auth_hmacsha256_KEYBYTES", "crypto_auth_hmacsha512_BYTES", "crypto_auth_hmacsha512_KEYBYTES", "crypto_box_BEFORENMBYTES", "crypto_box_MACBYTES", "crypto_box_NONCEBYTES", "crypto_box_PUBLICKEYBYTES", "crypto_box_SEALBYTES", "crypto_box_SECRETKEYBYTES", "crypto_box_SEEDBYTES", "crypto_generichash_BYTES", "crypto_generichash_BYTES_MAX", "crypto_generichash_BYTES_MIN", "crypto_generichash_KEYBYTES", "crypto_generichash_KEYBYTES_MAX", "crypto_generichash_KEYBYTES_MIN", "crypto_hash_BYTES", "crypto_onetimeauth_BYTES", "crypto_onetimeauth_KEYBYTES", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE", "crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE", "crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE", "crypto_pwhash_scryptsalsa208sha256_SALTBYTES", "crypto_pwhash_scryptsalsa208sha256_STRBYTES", "crypto_pwhash_scryptsalsa208sha256_STR_VERIFY", "crypto_scalarmult_BYTES", "crypto_scalarmult_SCALARBYTES", "crypto_secretbox_KEYBYTES", "crypto_secretbox_MACBYTES", "crypto_secretbox_NONCEBYTES", "crypto_shorthash_BYTES", "crypto_shorthash_KEYBYTES", "crypto_sign_BYTES", "crypto_sign_PUBLICKEYBYTES", "crypto_sign_SECRETKEYBYTES", "crypto_sign_SEEDBYTES"];
	for (var i = 0; i < constants.length; i++) {
		var raw = libsodium["_" + constants[i].toLowerCase()];
		if (typeof raw === "function") exports[constants[i]] = raw()|0;
	}
	var constants_str = ["SODIUM_VERSION_STRING", "crypto_pwhash_scryptsalsa208sha256_STRPREFIX"];
	for (var i = 0; i < constants_str.length; i++) {
		var raw = libsodium["_" + constants_str[i].toLowerCase()];
		if (typeof raw === "function") exports[constants_str[i]] = libsodium.Pointer_stringify(raw());
	}

	return exports;
}));

},
"w88qquc08WFFsUzEn0tqyqr4GGbjxOffPchua/7v0HQ=":
function (require, module, exports, __dirname, __filename) {
module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {} };
    
    [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true;
    });
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function setArg (key, val) {
        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }
    
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            setArg(m[1], m[2]);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                setArg(key, next);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true');
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2));
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !flags.bools[aliases[key]] : true)) {
                    setArg(key, args[i+1]);
                    i++;
                }
                else if (args[i+1] && /true|false/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true');
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true);
                }
            }
        }
        else {
            argv._.push(
                flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
            );
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    notFlags.forEach(function(key) {
        argv._.push(key);
    });

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function setKey (obj, keys, value) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        if (o[key] === undefined) o[key] = {};
        o = o[key];
    });
    
    var key = keys[keys.length - 1];
    if (o[key] === undefined || typeof o[key] === 'boolean') {
        o[key] = value;
    }
    else if (Array.isArray(o[key])) {
        o[key].push(value);
    }
    else {
        o[key] = [ o[key], value ];
    }
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


},
"w8Yiat41Gm+aC99EpaeinBBOcb1lFSoDubsJDL/koro=":
function (require, module, exports, __dirname, __filename) {

/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co;

/**
 * Wrap the given generator `fn` and
 * return a thunk.
 *
 * @param {Function} fn
 * @return {Function}
 * @api public
 */

function co(fn) {
  var isGenFun = isGeneratorFunction(fn);

  return function (done) {
    var ctx = this;

    // in toThunk() below we invoke co()
    // with a generator, so optimize for
    // this case
    var gen = fn;

    // we only need to parse the arguments
    // if gen is a generator function.
    if (isGenFun) {
      var args = slice.call(arguments), len = args.length;
      var hasCallback = len && 'function' == typeof args[len - 1];
      done = hasCallback ? args.pop() : error;
      gen = fn.apply(this, args);
    } else {
      done = done || error;
    }

    next();

    // #92
    // wrap the callback in a setImmediate
    // so that any of its errors aren't caught by `co`
    function exit(err, res) {
      setImmediate(function(){
        done.call(ctx, err, res);
      });
    }

    function next(err, res) {
      var ret;

      // multiple args
      if (arguments.length > 2) res = slice.call(arguments, 1);

      // error
      if (err) {
        try {
          ret = gen.throw(err);
        } catch (e) {
          return exit(e);
        }
      }

      // ok
      if (!err) {
        try {
          ret = gen.next(res);
        } catch (e) {
          return exit(e);
        }
      }

      // done
      if (ret.done) return exit(null, ret.value);

      // normalize
      ret.value = toThunk(ret.value, ctx);

      // run
      if ('function' == typeof ret.value) {
        var called = false;
        try {
          ret.value.call(ctx, function(){
            if (called) return;
            called = true;
            next.apply(ctx, arguments);
          });
        } catch (e) {
          setImmediate(function(){
            if (called) return;
            called = true;
            next(e);
          });
        }
        return;
      }

      // invalid
      next(new TypeError('You may only yield a function, promise, generator, array, or object, '
        + 'but the following was passed: "' + String(ret.value) + '"'));
    }
  }
}

/**
 * Convert `obj` into a normalized thunk.
 *
 * @param {Mixed} obj
 * @param {Mixed} ctx
 * @return {Function}
 * @api private
 */

function toThunk(obj, ctx) {

  if (isGeneratorFunction(obj)) {
    return co(obj.call(ctx));
  }

  if (isGenerator(obj)) {
    return co(obj);
  }

  if (isPromise(obj)) {
    return promiseToThunk(obj);
  }

  if ('function' == typeof obj) {
    return obj;
  }

  if (isObject(obj) || Array.isArray(obj)) {
    return objectToThunk.call(ctx, obj);
  }

  return obj;
}

/**
 * Convert an object of yieldables to a thunk.
 *
 * @param {Object} obj
 * @return {Function}
 * @api private
 */

function objectToThunk(obj){
  var ctx = this;
  var isArray = Array.isArray(obj);

  return function(done){
    var keys = Object.keys(obj);
    var pending = keys.length;
    var results = isArray
      ? new Array(pending) // predefine the array length
      : new obj.constructor();
    var finished;

    if (!pending) {
      setImmediate(function(){
        done(null, results)
      });
      return;
    }

    // prepopulate object keys to preserve key ordering
    if (!isArray) {
      for (var i = 0; i < pending; i++) {
        results[keys[i]] = undefined;
      }
    }

    for (var i = 0; i < keys.length; i++) {
      run(obj[keys[i]], keys[i]);
    }

    function run(fn, key) {
      if (finished) return;
      try {
        fn = toThunk(fn, ctx);

        if ('function' != typeof fn) {
          results[key] = fn;
          return --pending || done(null, results);
        }

        fn.call(ctx, function(err, res){
          if (finished) return;

          if (err) {
            finished = true;
            return done(err);
          }

          results[key] = res;
          --pending || done(null, results);
        });
      } catch (err) {
        finished = true;
        done(err);
      }
    }
  }
}

/**
 * Convert `promise` to a thunk.
 *
 * @param {Object} promise
 * @return {Function}
 * @api private
 */

function promiseToThunk(promise) {
  return function(fn){
    promise.then(function(res) {
      fn(null, res);
    }, fn);
  }
}

/**
 * Check if `obj` is a promise.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isPromise(obj) {
  return obj && 'function' == typeof obj.then;
}

/**
 * Check if `obj` is a generator.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGenerator(obj) {
  return obj && 'function' == typeof obj.next && 'function' == typeof obj.throw;
}

/**
 * Check if `obj` is a generator function.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGeneratorFunction(obj) {
  return obj && obj.constructor && 'GeneratorFunction' == obj.constructor.name;
}

/**
 * Check for plain object.
 *
 * @param {Mixed} val
 * @return {Boolean}
 * @api private
 */

function isObject(val) {
  return val && Object == val.constructor;
}

/**
 * Throw `err` in a new stack.
 *
 * This is used when co() is invoked
 * without supplying a callback, which
 * should only be for demonstrational
 * purposes.
 *
 * @param {Error} err
 * @api private
 */

function error(err) {
  if (!err) return;
  setImmediate(function(){
    throw err;
  });
}

},
"w9xQZduclE0p2TaxGrvcL8dI3BWAXf9Cn0ryLsRFNfg=":
function (require, module, exports, __dirname, __filename) {
/* This script was generated by `script/generate-expression.js` */

'use strict';

/* eslint-env commonjs */
/* eslint-disable no-irregular-whitespace */

module.exports = /[]/g;

},
"wHEl+1S4GoCZlQLhMS8W20HJanQwoT+5dNDPuzDCJfk=":
function (require, module, exports, __dirname, __filename) {
var pull     = require('pull-stream')
var toPull   = require('stream-to-pull-stream')
var pushable = require('pull-pushable')
var cat      = require('pull-cat')
var pw       = require('pull-window')
var post     = require('level-post')

function read(db, opts) {
  return toPull.read1(db.createReadStream(opts))
}

var live =
exports.live =
function (db, opts) {
  opts = opts || {}

  var l = pushable(function (err) {
    if(opts.onAbort) opts.onAbort(err)
    cleanup()
  })

  var cleanup = post(db, opts, function (ch) {
    if(opts.keys === false)
      l.push(ch.value)
    else if(opts.values === false)
      l.push(ch.key)
    else
      l.push(ch)
  })

  return l

}

exports.read =
exports.readStream =
exports.createReadStream = function (db, opts) {
  opts = opts || {}
  if(!(opts.tail || opts.live))
    return read(db, opts)

  //optionally notify when we switch from reading history to realtime
  var sync = opts.onSync && function (abort, cb) {
      opts.onSync(abort); cb(abort || true)
    }

  if(opts.onSync === true || opts.sync === true)
    sync = pull.values([{sync: true}])

  return cat([read(db, opts), sync, live(db, opts)])
}

exports.write =
exports.writeStream =
exports.createWriteStream = function (db, opts, done) {
  if('function' === typeof opts)
    done = opts, opts = null
  opts = opts || {}
  return pull(
    pull.map(function (e) {
      if(e.type) return e
      return {
        key   : e.key, 
        value : e.value,
        type  : e.value == null ? 'del' : 'put'
      }
    }),
    pw.recent(opts.windowSize, opts.windowTime),
    pull.asyncMap(function (batch, cb) {
      db.batch(batch, cb)
    }),
    pull.drain(null, done)
  )
}


},
"wN2QfLDeSzhULjYQgNMYCgTr22/UeKFL9cXs/X9USbc=":
function (require, module, exports, __dirname, __filename) {

exports.source = require('./source')
exports.through = require('./through')
exports.sink = require('./sink')

},
"wdsdP/Kstw3RXP4Ua3U0oCMOIDlD6rDhdbKYiYyAKog=":
function (require, module, exports, __dirname, __filename) {
var u = require('pull-core')
var prop = u.prop
var id   = u.id
var maybeSink = u.maybeSink

module.exports = function (pull) {

  var exports = {}
  var drain = pull.drain

  var find = 
  exports.find = function (test, cb) {
    return maybeSink(function (cb) {
      var ended = false
      if(!cb)
        cb = test, test = id
      else
        test = prop(test) || id

      return drain(function (data) {
        if(test(data)) {
          ended = true
          cb(null, data)
        return false
        }
      }, function (err) {
        if(ended) return //already called back
        cb(err === true ? null : err, null)
      })

    }, cb)
  }

  var reduce = exports.reduce = 
  function (reduce, acc, cb) {
    
    return maybeSink(function (cb) {
      return drain(function (data) {
        acc = reduce(acc, data)
      }, function (err) {
        cb(err, acc)
      })

    }, cb)
  }

  var collect = exports.collect = exports.writeArray =
  function (cb) {
    return reduce(function (arr, item) {
      arr.push(item)
      return arr
    }, [], cb)
  }

  var concat = exports.concat =
  function (cb) {
    return reduce(function (a, b) {
      return a + b
    }, '', cb)
  }

  return exports
}

},
"wquF+8lbW7WDFMNIeOHz1jFucpFNxMnALj0MvFANFDU=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "_args": [
    [
      "secure-scuttlebutt@^15.0.4",
      "/home/dominic/c/scuttlebot"
    ]
  ],
  "_from": "secure-scuttlebutt@>=15.0.4 <16.0.0",
  "_id": "secure-scuttlebutt@15.0.5",
  "_inCache": true,
  "_installable": true,
  "_location": "/secure-scuttlebutt",
  "_nodeVersion": "5.6.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/secure-scuttlebutt-15.0.5.tgz_1459454194171_0.8798535864334553"
  },
  "_npmUser": {
    "email": "dominic.tarr@gmail.com",
    "name": "dominictarr"
  },
  "_npmVersion": "3.6.0",
  "_phantomChildren": {
    "bytewise-core": "1.2.3",
    "level-post": "1.0.4",
    "levelup": "0.19.1",
    "pull-cat": "1.1.9",
    "pull-core": "1.0.0",
    "pull-window": "2.1.3",
    "stream-to-pull-stream": "1.6.7",
    "typewise": "1.0.3",
    "typewiselite": "1.0.0",
    "xtend": "4.0.1"
  },
  "_requested": {
    "name": "secure-scuttlebutt",
    "raw": "secure-scuttlebutt@^15.0.4",
    "rawSpec": "^15.0.4",
    "scope": null,
    "spec": ">=15.0.4 <16.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_shasum": "922d09bc4d03d60edb0a79d88c31a7a578ad8ae2",
  "_shrinkwrap": null,
  "_spec": "secure-scuttlebutt@^15.0.4",
  "_where": "/home/dominic/c/scuttlebot",
  "author": {
    "email": "dominic.tarr@gmail.com",
    "name": "Dominic Tarr",
    "url": "http://dominictarr.com"
  },
  "bugs": {
    "url": "https://github.com/ssbc/secure-scuttlebutt/issues"
  },
  "dependencies": {
    "cont": "~1.0.0",
    "deep-equal": "~0.2.1",
    "explain-error": "~1.0.1",
    "level": "^1.3.0",
    "level-sublevel": "^6.5.2",
    "ltgt": "~2.0.0",
    "monotonic-timestamp": "~0.0.8",
    "mynosql": "~2.3.1",
    "pull-cat": "~1.1.5",
    "pull-level": "~1.4.0",
    "pull-paramap": "~1.1.3",
    "pull-stream": "~2.24.1",
    "ssb-feed": "^2.0.0",
    "ssb-keys": "^5.0.0",
    "ssb-msgs": "^5.0.0",
    "ssb-ref": "^2.0.0"
  },
  "description": "a secure, replicatable database",
  "devDependencies": {
    "deep-equal": "^0.2.1",
    "hexpp": "~1.1.3",
    "level-test": "^2.0.1",
    "multicb": "~0.0.2",
    "pull-abortable": "~4.1.0",
    "pull-randomly-split": "~1.0.4",
    "rimraf": "~2.2.8",
    "tape": "^4.2.2",
    "typewiselite": "~1.0.0"
  },
  "directories": {},
  "dist": {
    "shasum": "922d09bc4d03d60edb0a79d88c31a7a578ad8ae2",
    "tarball": "https://registry.npmjs.org/secure-scuttlebutt/-/secure-scuttlebutt-15.0.5.tgz"
  },
  "gitHead": "558f4a95eb75eb0c3cea11d34bc7c93c6627a8b1",
  "homepage": "https://github.com/ssbc/secure-scuttlebutt",
  "license": "MIT",
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    },
    {
      "name": "pfraze",
      "email": "pfrazee@gmail.com"
    }
  ],
  "name": "secure-scuttlebutt",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git://github.com/ssbc/secure-scuttlebutt.git"
  },
  "scripts": {
    "prepublish": "npm ls && npm test",
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "testling": {
    "browsers": [
      "chrome/22..latest",
      "chrome/canary",
      "firefox/17..latest",
      "firefox/nightly",
      "ie/8..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest"
    ],
    "files": "test/defaults.js"
  },
  "version": "15.0.5"
}

},
"wvIKyiNwquHNmx3Lif9MGBGUmlX9yDNddMFQ3F8NYN0=":
function (require, module, exports, __dirname, __filename) {
'use strict'
var pull = require('pull-stream')
// wrap pull streams around packet-stream's weird streams.

function once (fn) {
  var done = false
  return function (err, val) {
    if(done) return
    done = true
    fn(err, val)
  }
}

module.exports = function (weird, _done) {
  var buffer = [], ended = false, waiting, abort

  var done = once(function (err, v) {
    _done && _done(err, v)
    // deallocate
    weird = null
    _done = null    
    waiting = null

    if(abort) abort(err || true, function () {})
  })

  weird.read = function (data, end) {
    ended = ended || end

    if(waiting) {
      var cb = waiting
      waiting = null
      cb(ended, data)
    }
    else if(!ended) buffer.push(data)

    if(ended) done(ended !== true ? ended : null)
  }

  return {
    source: function (abort, cb) {
      if(abort) {
        weird && weird.write(null, abort)
        cb(abort); done(abort !== true ? abort : null)
      }
      else if(buffer.length) cb(null, buffer.shift())
      else if(ended) cb(ended)
      else waiting = cb
    },
    sink  : function (read) {
      if(ended) return read(ended, function () {}), abort = null
      abort = read
      pull.drain(function (data) {
        //TODO: make this should only happen on a UNIPLEX stream.
        if(ended) return false
        weird.write(data)
      }, function (err) {
        if(weird && !weird.writeEnd) weird.write(null, err || true)
        done && done(err)
      })
      (read)
    }
  }
}

function uniplex (s, done) {
  return module.exports(s, function (err) {
    if(!s.writeEnd) s.write(null, err || true)
    if(done) done(err)
  })
}

module.exports.source = function (s) {
  return uniplex(s).source
}
module.exports.sink = function (s, done) {
  return uniplex(s, done).sink
}

module.exports.duplex = module.exports

},
"wy0OCu12PqxOPX0hYNlLnTDcHA8RAYP3l/jgdquE+q0=":
function (require, module, exports, __dirname, __filename) {
var os = require('os')
var ip = require('ip')
//pick the first reasonable looking host.
//this should *just work* when running on a vps.

var isPrivate = ip.isPrivate

function isNonPrivate (e) {
  return !isPrivate(e)
}


module.exports = function (inter, filter) {
  inter = inter || os.networkInterfaces()
  filter = filter || isNonPrivate
  for(var k in inter) {
    for(var i in inter[k]) {
      var e = inter[k][i]
      // find a reasonable looking address
      if(!e.internal && filter(e.address))
          return e.address
    }
  }
}

module.exports.private = function (inter) {
  return module.exports(inter, isPrivate)
}

if(!module.parent) {
  var h = module.exports()
  if(!h) {
    console.error('no non-private address')
    console.error('private:', module.exports.private())
    process.exit(1)
  }
  console.log(h)
}

},
"wyotRMgiBLpCa4fOOHKmOoVgVKMkmJhaCywMPXvnkvg=":
function (require, module, exports, __dirname, __filename) {
var ssbKeys = require('ssb-keys')
var explain = require('explain-error')
var mdm = require('mdmanifest')
var valid = require('../lib/validators')
var apidoc = require('../lib/apidocs').private

module.exports = {
  name: 'private',
  version: '0.0.0',
  manifest: mdm.manifest(apidoc),
  permissions: {
    anonymous: {},
  },
  init: function (sbot, opts) {
    return {
      publish: valid.async(function (data, recps, cb) {
        var ciphertext
        try { ciphertext = ssbKeys.box(data, recps) }
        catch (e) { return cb(explain(e, 'failed to encrypt')) }

        sbot.publish(ciphertext, cb)
      }, 'string|object', 'array'),
      unbox: valid.sync(function (ciphertext) {
        var data
        try { data = ssbKeys.unbox(ciphertext, sbot.keys.private) }
        catch (e) { throw explain(e, 'failed to decrypt') }
        return data
      }, 'string')
    }
  }
}
},
"x6TQk/db5Vyx+e81teKg+4ft20ZkkF6RXGJfLb9QD0s=":
function (require, module, exports, __dirname, __filename) {

function def(op, value) {
  return op == null ? value : op
}
module.exports = function stringify (op, cl, sp, indent, stringify) {
  stringify = stringify || JSON.stringify

  op     = def(op, '[')
  cl     = def(cl, ']\n')
  sp     = def(sp, ',\n')
  indent = def(indent, 2)

  var first = true, ended
  return function (read) {
    return function (end, cb) {
      if(ended) return cb(ended)
      read(null, function (end, data) {
        if(!end) {
          var f = first
          first = false
          cb(null, (f ? op : sp)+ stringify(data, null, indent))
        }
        else {
          ended = end
          if(ended !== true) return cb(ended)
          cb(null, first ? op+cl : cl)
        }
      })
    }
  }
}

module.exports.lines =
module.exports.ldjson = function (stringify) {
  return module.exports('','\n','\n', 0, stringify)
}

},
"xSCQXbOC3qkuawgva0ywsnQjwkHUiheDkyJhbnlaLok=":
function (require, module, exports, __dirname, __filename) {
var isDomain = require('is-valid-domain')
var rx = require('ip-regex')({exact: true})
var isIP = rx.test.bind(rx)

var isInteger = Number.isInteger

function isString(s) {
  return 'string' === typeof s
}

var isLink = exports.isLink =
  function (data) {
    return isString(data) && /^(@|%|&)[A-Za-z0-9\/+]{43}=\.[\w\d]+$/.test(data)
  }

var isFeedId = exports.isFeed = exports.isFeedId =
  function (data) {
    return isString(data) && /^@[A-Za-z0-9\/+]{43}=\.(?:sha256|ed25519)$/.test(data)
  }

var isMsgId = exports.isMsg = exports.isMsgId =
  function (data) {
    return isString(data) && /^%[A-Za-z0-9\/+]{43}=\.sha256$/.test(data)
  }

var isBlobId = exports.isBlob = exports.isBlobId =
  function (data) {
    return isString(data) && /^&[A-Za-z0-9\/+]{43}=\.sha256$/.test(data)
  }

var isAddress = exports.isAddress =
  function (data) {
    if(!isString(data)) return false
  var parts = data.split(':')
  var id = parts.pop(), port = parts.pop(), addr = parts.join(':')
  return (
    isFeedId(id) && isInteger(+port)
    && (isIP(addr) || isDomain(addr) || addr === 'localhost')
  )
}

var isInvite = exports.isInvite =
  function (data) {
    if(!isString(data)) return false
    var parts = data.split('~')
    //console.log(parts, isAddress(parts[0]), /^[A-Za-z0-9\/+]{43}=$/.test(parts[1]))
    return parts.length == 2 && isAddress(parts[0]) && /^[A-Za-z0-9\/+]{43}=$/.test(parts[1])
  }

exports.type =
  function (id) {
    if(!isString(id)) return false
    var c = id.charAt(0)
    if (c == '@' && isFeedId(id))
      return 'feed'
    else if (c == '%' && isMsgId(id))
      return 'msg'
    else if (c == '&' && isBlobId(id))
      return 'blob'
    else if(isAddress(id)) return 'address'
    else if(isInvite(id)) return 'invite'
    else
    return false
  }

exports.extract =
  function (data) {
    if (!isString(data))
      return false

    var _data = data
    try { _data = decodeURIComponent(data) }
    catch (e) {} // this may fail if it's not encoded, so don't worry if it does
    _data = _data.replace(/&amp;/g, '&')

    var res = /([@%&][A-Za-z0-9\/+]{43}=\.[\w\d]+)/.exec(_data)
    return res && res[0]
  }
},
"xYiGFKhLKuo/ApNWIopVfeMaHVBhSFyAbgdwNhsyplo=":
function (require, module, exports, __dirname, __filename) {
module.exports = balanced;
function balanced(a, b, str) {
  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i < str.length && i >= 0 && ! result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

},
"xhzjB9kvtafQZW074xYcey8fxAIzaOXRA11Px/gDlPc=":
function (require, module, exports, __dirname, __filename) {
module.exports = {
  "default": [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
  ],
  "gfm": [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">",
    "~",
    "|"
  ],
  "commonmark": [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">",
    "~",
    "|",
    "\n",
    "\"",
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
  ]
}

},
"y9bu6ooSJ4eTo3qLTOYHiygPQzsC5cIrHuZVk9FGhw4=":
function (require, module, exports, __dirname, __filename) {
module.exports = function series (continuables, callback) {
  if('function' === typeof continuables)
    return series([].slice.call(arguments))

  if (callback) {
    next(callback)
  } else {
    return next
  }

  function next (callback) {
    continuables.shift() (function (err, value) {
      if (err || !continuables.length)
        return callback(err, value)
      next (callback)
    })
  }
}

},
"yDkVK9+cJMb1IcfIms+o/oADQNTI6asJrc2HAyDR8QY=":
function (require, module, exports, __dirname, __filename) {
'use strict';
var isWindows = process.platform === 'win32';
var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;

// https://github.com/nodejs/io.js/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
module.exports = function () {
	var path;

	if (isWindows) {
		path = process.env.TEMP ||
			process.env.TMP ||
			(process.env.SystemRoot || process.env.windir) + '\\temp';
	} else {
		path = process.env.TMPDIR ||
			process.env.TMP ||
			process.env.TEMP ||
			'/tmp';
	}

	if (trailingSlashRe.test(path)) {
		path = path.slice(0, -1);
	}

	return path;
};

},
"yEJoEo5nWIxGBHGWDU3uw4ahLuNMPhIHA+K5+p3pg/E=":
function (require, module, exports, __dirname, __filename) {
var crypto = require('crypto')
var ssbKeys = require('ssb-keys')
var toAddress = require('../lib/util').toAddress
var cont = require('cont')
var explain = require('explain-error')
var ip = require('ip')
var mdm = require('mdmanifest')
var valid = require('../lib/validators')
var apidoc = require('../lib/apidocs').invite

// invite plugin
// adds methods for producing invite-codes,
// which peers can use to command your server to follow them.

function isFunction (f) {
  return 'function' === typeof f
}

function isString (s) {
  return 'string' === typeof s
}

module.exports = {
  name: 'invite',
  version: '1.0.0',
  manifest: mdm.manifest(apidoc),
  permissions: {
    master: {allow: ['create']},
    //temp: {allow: ['use']}
  },
  init: function (server, config) {
    var codes = {}
    var codesDB = server.sublevel('codes')

    var createClient = this.createClient

    //add an auth hook.
    server.auth.hook(function (fn, args) {
      var pubkey = args[0], cb = args[1]

      // run normal authentication
      fn(pubkey, function (err, auth) {
        if(err || auth) return cb(err, auth)

        // if no rights were already defined for this pubkey
        // check if the pubkey is one of our invite codes
        codesDB.get(pubkey, function (_, code) {
          return cb(null, code && code.permissions)
        })
      })
    })

    return {
      create: valid.async(function (n, cb) {
        var addr = server.getAddress()
        var host = toAddress(addr).host
        if(!config.allowPrivate && (ip.isPrivate(host) || 'localhost' === host))
          return cb(new Error('Server has no public ip address, '
                            + 'cannot create useable invitation'))

        //this stuff is SECURITY CRITICAL
        //so it should be moved into the main app.
        //there should be something that restricts what
        //permissions the plugin can create also:
        //it should be able to diminish it's own permissions.

        // generate a key-seed and its key
        var seed = crypto.randomBytes(32)
        var keyCap = ssbKeys.generate('ed25519', seed)

        // store metadata under the generated pubkey
        var owner = server.id
        codesDB.put(keyCap.id,  {
          id: keyCap.id,
          total: +n,
          used: 0,
          permissions: {allow: ['invite.use'], deny: null}
        }, function (err) {
          // emit the invite code: our server address, plus the key-seed
          if(err) cb(err)
          else cb(null, addr + '~' + seed.toString('base64'))
        })
      }, 'number'),
      use: valid.async(function (req, cb) {
        var rpc = this

        // fetch the code
        codesDB.get(rpc.id, function(err, invite) {
          if(err) return cb(err)

          // check if we're already following them
          server.friends.all('follow', function(err, follows) {
            if (follows && follows[server.id] && follows[server.id][req.feed])
              return cb(new Error('already following'))

            // although we already know the current feed
            // it's included so that request cannot be replayed.
            if(!req.feed)
              return cb(new Error('feed to follow is missing'))

            if(invite.used >= invite.total)
              return cb(new Error('invite has expired'))

            invite.used ++

            //never allow this to be used again
            if(invite.used >= invite.total)
              invite.permissions = {allow: [], deny: null}

            //TODO
            //okay so there is a small race condition here
            //if people use a code massively in parallel
            //then it may not be counted correctly...
            //this is not a big enough deal to fix though.
            //-dominic

            // update code metadata
            codesDB.put(rpc.id, invite, function (err) {
              server.emit('log:info', ['invite', rpc.id, 'use', req])

              // follow the user
              server.publish({
                type: 'contact',
                contact: req.feed,
                following: true,
                autofollow: true
              }, cb)
            })
          })
        })
      }, 'object'),
      accept: valid.async(function (invite, cb) {
        // remove surrounding quotes, if found
        if (invite.charAt(0) === '"' && invite.charAt(invite.length - 1) === '"')
          invite = invite.slice(1, -1)

        // connect to the address in the invite code
        // using a keypair generated from the key-seed in the invite code

        var parts = invite.split('~')
        var addr = toAddress(parts[0])

        createClient({ seed: parts[1] })
        (addr, function (err, rpc) {
          if(err) return cb(explain(err, 'could not connect to server'))

          // command the peer to follow me
          rpc.invite.use({ feed: server.id }, function (err, msg) {
            if(err) return cb(explain(err, 'invite not accepted'))
            
            // follow and announce the pub
            cont.para([
              server.publish({
                type: 'contact',
                following: true,
                autofollow: true,
                contact: addr.link || addr.key
              }),
              server.publish({
                type: 'pub',
                address: addr,
              })
            ])(function (err, results) {
              rpc.close()
              cb(err, results)
            })
          })
        })
      }, 'string')
    }
  }
}








},
"yFgr5ruSOE6cWQSe0eLQVKyZmkv1UcSoYTIHAl0sGlA=":
function (require, module, exports, __dirname, __filename) {
var u          = require('./util')
var Api        = require('./api')
var Muxrpc     = require('muxrpc')
var pull       = require('pull-stream')
var createNode = require('secret-handshake/net')
var nonPrivate = require('non-private-ip')
var Inactive   = require('pull-inactivity')

function isFunction (f) { return 'function' === typeof f }

function isString (s) { return 'string' === typeof s }

function each(obj, iter) {
  if(Array.isArray(obj)) return obj.forEach(iter)
  for(var k in obj) iter(obj[k], k, obj)
}

function toBuffer(base64) {
  if(Buffer.isBuffer(base64)) return base64
  var i = base64.indexOf('.')
  return new Buffer(~i ? base64.substring(0, i) : base64, 'base64')
}

function toSodiumKeys (keys) {
  if(!(isString(keys.public) && isString(keys.private)))
    return keys
  return {
    publicKey: toBuffer(keys.public),
    secretKey: toBuffer(keys.private)
  }
}

function coearseAddress (address) {
  if(isString(address)) address = u.parseAddress(address)
  if(isString(address.key))
    return {
      host: address.host, port: address.port,
      key: new Buffer(
        address.key
          .substring(1, address.key.indexOf('.')),
        'base64'
      )
    }
  return address
}

//opts must have appKey
module.exports = function (opts) {

  var appKey = opts.appKey
  var defaultTimeout = (
    opts.defaultTimeout || 5e3 // 5 seconds.
  )
  var timeout_handshake

  if(opts.timers && !isNaN(opts.timers.inactivity))
    defaultTimeout = opts.timers.inactivity
  if(opts.timers && !isNaN(opts.timers.handshake))
    timeout_handshake = opts.timers.handshake
  timeout_handshake = timeout_handshake || 5e3

  opts.permissions = opts.permissions || {}

  var create = Api(opts.permissions ? [{
    permissions: opts.permissions,
    init: function () {}
  }]: null)

  create.createClient = function (opts) {
    if(opts.keys) opts.keys = toSodiumKeys(opts.keys)
    if(opts.seed) opts.seed = toBuffer(opts.seed)
//    opts.appKey = toBuffer(opts.appKey || appKey)

    var snet = createNode({
      keys: opts.keys && toSodiumKeys(opts.keys),
      seed: opts.seed && toBuffer(opts.seed),
      appKey: toBuffer(opts.appKey || appKey),
      timeout: opts.timeout || (opts.timers && opts.timers.handshake) || 5e3
    })

    return function (address, cb) {
      address = coearseAddress(address)

      snet.connect(address, function (err, stream) {
        if(err) return cb(err)
        var rpc = Muxrpc(opts.manifest || create.manifest, {})({})
        pull(stream, rpc.createStream(), stream)
        cb(null, rpc)
      })
    }
  }

  return create.use({
    manifest: {
      auth: 'async',
      address: 'sync',
      manifest: 'sync',
    },
    init: function (api, opts, permissions, manifest) {
      var snet = createNode({
        keys: opts.keys && toSodiumKeys(opts.keys),
        seed: opts.seed,
        appKey: toBuffer(opts.appKey || appKey),

        //****************************************
        timeout: timeout_handshake,

        authenticate: function (pub, cb) {
          var id = '@'+u.toId(pub)
          api.auth(id, function (err, auth) {
            if(err) cb(err)
            else    cb(null, auth || create.permissions.anonymous)
          })
        }
      })

      //use configured port, or a random user port.
      var port = opts.port || 1024+(~~(Math.random()*(65536-1024)))
      var host = opts.host || nonPrivate.v4 || nonPrivate.private.v4 || '127.0.0.1'

      var peers = api.peers = {}

      var server = snet.createServer(setupRPC)
      server.listen(port)

      function setupRPC (stream, manf, isClient) {
        var rpc = Muxrpc(create.manifest, manf || create.manifest)(api, stream.auth)
        var timeout = opts.timeout == null ? defaultTimeout : opts.timeout
        var rpcStream = rpc.createStream()
        if(timeout > 0) rpcStream = Inactive(rpcStream, opts.timeout)

        pull(stream, rpcStream, stream)

        var id = rpc.id = '@'+u.toId(stream.remote)

        //keep track of current connections.
        if(!peers[id]) peers[id] = []
        peers[id].push(rpc)
        rpc.once('closed', function () {
          peers[id].splice(peers[id].indexOf(rpc), 1)
        })

        api.emit('rpc:connect', rpc, !!isClient)

        return rpc
      }

      return {
        //can be called remotely.
        publicKey: snet.publicKey,
        auth: function (pub, cb) { cb() },
        address: function () {
          return this.getAddress()
        },
        getAddress: function () {
          return [host, port, '@'+u.toId(snet.publicKey)].join(':')
        },
        manifest: function () {
          return create.manifest
        },
        getManifest: function () {
          return this.manifest()
        },
        //cannot be called remote.
        connect: function (address, cb) {
          address = coearseAddress(address)
          address.appKey = opts.appKey || appKey
          snet.connect(address, function (err, stream) {
            return err ? cb(err) : cb(null, setupRPC(stream, null, true))
          })
        },

        close: function (err, cb) {
          if(isFunction(err)) cb = err, err = null
          api.closed = true
          server.close(function (err) {
            api.emit('close', err)
            cb && cb(err)
          })

          if(err) {
            each(peers, function (connections, id) {
              each(connections, function (rpc) {
                rpc.close(err)
              })
            })
          }
        }
      }
    }
  })
}




},
"yXAabb7H6QZTQsr2s1hOIP/0Q1tLc6p8vAxHZwm05TY=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2013 Rod Vagg, MIT License */

function AbstractIterator (db) {
  this.db = db
  this._ended = false
  this._nexting = false
}

AbstractIterator.prototype.next = function (callback) {
  var self = this

  if (typeof callback != 'function')
    throw new Error('next() requires a callback argument')

  if (self._ended)
    return callback(new Error('cannot call next() after end()'))
  if (self._nexting)
    return callback(new Error('cannot call next() before previous next() has completed'))

  self._nexting = true
  if (typeof self._next == 'function') {
    return self._next(function () {
      self._nexting = false
      callback.apply(null, arguments)
    })
  }

  process.nextTick(function () {
    self._nexting = false
    callback()
  })
}

AbstractIterator.prototype.end = function (callback) {
  if (typeof callback != 'function')
    throw new Error('end() requires a callback argument')

  if (this._ended)
    return callback(new Error('end() already called on iterator'))

  this._ended = true

  if (typeof this._end == 'function')
    return this._end(callback)

  process.nextTick(callback)
}

module.exports = AbstractIterator

},
"ye+ksu2cIdpcqpBHIJFw7xPLQazJFOLgrJ2ki+cIEt4=":
function (require, module, exports, __dirname, __filename) {

var keys = exports.keys =
function (object) {
  return values(Object.keys(object))
}

function abortCb(cb, abort, onAbort) {
  cb(abort)
  onAbort && onAbort(abort === true ? null: abort)
  return
}

var once = exports.once =
function (value, onAbort) {
  return function (abort, cb) {
    if(abort)
      return abortCb(cb, abort, onAbort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}

var values = exports.values = exports.readArray =
function (array, onAbort) {
  if(!array)
    return function (abort, cb) {
      if(abort) return abortCb(cb, abort, onAbort)
      return cb(true)
    }
  if(!Array.isArray(array))
    array = Object.keys(array).map(function (k) {
      return array[k]
    })
  var i = 0
  return function (abort, cb) {
    if(abort)
      return abortCb(cb, abort, onAbort)
    cb(i >= array.length || null, array[i++])
  }
}


var count = exports.count =
function (max) {
  var i = 0; max = max || Infinity
  return function (end, cb) {
    if(end) return cb && cb(end)
    if(i > max)
      return cb(true)
    cb(null, i++)
  }
}

var infinite = exports.infinite =
function (generate) {
  generate = generate || Math.random
  return function (end, cb) {
    if(end) return cb && cb(end)
    return cb(null, generate())
  }
}

var defer = exports.defer = function () {
  var _read, cbs = [], _end

  var read = function (end, cb) {
    if(!_read) {
      _end = end
      cbs.push(cb)
    } 
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    while(cbs.length)
      _read(_end, cbs.shift())
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}

var empty = exports.empty = function () {
  return function (abort, cb) {
    cb(true)
  }
}

var error = exports.error = function (err) {
  return function (abort, cb) {
    cb(err)
  }
}

var depthFirst = exports.depthFirst =
function (start, createStream) {
  var reads = []

  reads.unshift(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        //if this stream has ended, go to the next queue
        reads.shift()
        return next(null, cb)
      }
      reads.unshift(createStream(data))
      cb(end, data)
    })
  }
}
//width first is just like depth first,
//but push each new stream onto the end of the queue
var widthFirst = exports.widthFirst =
function (start, createStream) {
  var reads = []

  reads.push(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        return next(null, cb)
      }
      reads.push(createStream(data))
      cb(end, data)
    })
  }
}

//this came out different to the first (strm)
//attempt at leafFirst, but it's still a valid
//topological sort.
var leafFirst = exports.leafFirst =
function (start, createStream) {
  var reads = []
  var output = []
  reads.push(once(start))

  return function next (end, cb) {
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        if(!output.length)
          return cb(true)
        return cb(null, output.shift())
      }
      reads.unshift(createStream(data))
      output.unshift(data)
      next(null, cb)
    })
  }
}


},
"yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=":
function (require, module, exports, __dirname, __filename) {

var keys = exports.keys =
function (object) {
  return values(Object.keys(object))
}

var once = exports.once =
function (value) {
  return function (abort, cb) {
    if(abort) return cb(abort)
    if(value != null) {
      var _value = value; value = null
      cb(null, _value)
    } else
      cb(true)
  }
}

var values = exports.values = exports.readArray =
function (array) {
  if(!Array.isArray(array))
    array = Object.keys(array).map(function (k) {
      return array[k]
    })
  var i = 0
  return function (end, cb) {
    if(end)
      return cb && cb(end)  
    cb(i >= array.length || null, array[i++])
  }
}


var count = exports.count = 
function (max) {
  var i = 0; max = max || Infinity
  return function (end, cb) {
    if(end) return cb && cb(end)
    if(i > max)
      return cb(true)
    cb(null, i++)
  }
}

var infinite = exports.infinite = 
function (generate) {
  generate = generate || Math.random
  return function (end, cb) {
    if(end) return cb && cb(end)
    return cb(null, generate())
  }
}

var defer = exports.defer = function () {
  var _read, cbs = [], _end

  var read = function (end, cb) {
    if(!_read) {
      _end = end
      cbs.push(cb)
    } 
    else _read(end, cb)
  }
  read.resolve = function (read) {
    if(_read) throw new Error('already resolved')
    _read = read
    if(!_read) throw new Error('no read cannot resolve!' + _read)
    while(cbs.length)
      _read(_end, cbs.shift())
  }
  read.abort = function(err) {
    read.resolve(function (_, cb) {
      cb(err || true)
    })
  }
  return read
}

var empty = exports.empty = function () {
  return function (abort, cb) {
    cb(true)
  }
}

var depthFirst = exports.depthFirst =
function (start, createStream) {
  var reads = []

  reads.unshift(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        //if this stream has ended, go to the next queue
        reads.shift()
        return next(null, cb)
      }
      reads.unshift(createStream(data))
      cb(end, data)
    })
  }
}
//width first is just like depth first,
//but push each new stream onto the end of the queue
var widthFirst = exports.widthFirst = 
function (start, createStream) {
  var reads = []

  reads.push(once(start))

  return function next (end, cb) {
    if(!reads.length)
      return cb(true)
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        return next(null, cb)
      }
      reads.push(createStream(data))
      cb(end, data)
    })
  }
}

//this came out different to the first (strm)
//attempt at leafFirst, but it's still a valid
//topological sort.
var leafFirst = exports.leafFirst = 
function (start, createStream) {
  var reads = []
  var output = []
  reads.push(once(start))
  
  return function next (end, cb) {
    reads[0](end, function (end, data) {
      if(end) {
        reads.shift()
        if(!output.length)
          return cb(true)
        return cb(null, output.shift())
      }
      reads.unshift(createStream(data))
      output.unshift(data)
      next(null, cb)
    })
  }
}


},
"z7vA5SZqno/yi7pbhGUpO2LM3r6ylPYg1BXZAAmnP1w=":
function (require, module, exports, __dirname, __filename) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

},
"z8y4jRit++cjRVT+LwIKCSRLrcBhqb09RBLXzoKzYcM=":
function (require, module, exports, __dirname, __filename) {
/* Copyright (c) 2012-2015 LevelUP contributors
 * See list at <https://github.com/rvagg/node-levelup#contributing>
 * MIT License
 * <https://github.com/rvagg/node-levelup/blob/master/LICENSE.md>
 */

var createError   = require('errno').create
  , LevelUPError  = createError('LevelUPError')
  , NotFoundError = createError('NotFoundError', LevelUPError)

NotFoundError.prototype.notFound = true
NotFoundError.prototype.status   = 404

module.exports = {
    LevelUPError        : LevelUPError
  , InitializationError : createError('InitializationError', LevelUPError)
  , OpenError           : createError('OpenError', LevelUPError)
  , ReadError           : createError('ReadError', LevelUPError)
  , WriteError          : createError('WriteError', LevelUPError)
  , NotFoundError       : NotFoundError
  , EncodingError       : createError('EncodingError', LevelUPError)
}

},
"zOcVwwzSymJLC+JtqJNe7iolAo2nXwGFK8RJ7fBOdF0=":
function (require, module, exports, __dirname, __filename) {
/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module character-entities-html4
 * @fileoverview HTML4 character entity information.
 */

'use strict';

/* eslint-env commonjs */

/*
 * Expose.
 */

module.exports = require('./index.json');

},
"zWtLg9p7uWPvfhP48jjb3bsKzmkCJ7x8LdDSu1nsduI=":
function (require, module, exports, __dirname, __filename) {
const util              = require('util')
    , AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN

    , binding           = require('./node_modules/leveldown/build/Release/leveldown.node').leveldown

    , ChainedBatch      = require('./chained-batch')
    , Iterator          = require('./iterator')


function LevelDOWN (location) {
  if (!(this instanceof LevelDOWN))
    return new LevelDOWN(location)

  AbstractLevelDOWN.call(this, location)
  this.binding = binding(location)
}

util.inherits(LevelDOWN, AbstractLevelDOWN)


LevelDOWN.prototype._open = function (options, callback) {
  this.binding.open(options, callback)
}


LevelDOWN.prototype._close = function (callback) {
  this.binding.close(callback)
}


LevelDOWN.prototype._put = function (key, value, options, callback) {
  this.binding.put(key, value, options, callback)
}


LevelDOWN.prototype._get = function (key, options, callback) {
  this.binding.get(key, options, callback)
}


LevelDOWN.prototype._del = function (key, options, callback) {
  this.binding.del(key, options, callback)
}


LevelDOWN.prototype._chainedBatch = function () {
  return new ChainedBatch(this)
}


LevelDOWN.prototype._batch = function (operations, options, callback) {
  return this.binding.batch(operations, options, callback)
}


LevelDOWN.prototype._approximateSize = function (start, end, callback) {
  this.binding.approximateSize(start, end, callback)
}


LevelDOWN.prototype.getProperty = function (property) {
  if (typeof property != 'string')
    throw new Error('getProperty() requires a valid `property` argument')

  return this.binding.getProperty(property)
}


LevelDOWN.prototype._iterator = function (options) {
  return new Iterator(this, options)
}


LevelDOWN.destroy = function (location, callback) {
  if (arguments.length < 2)
    throw new Error('destroy() requires `location` and `callback` arguments')

  if (typeof location != 'string')
    throw new Error('destroy() requires a location string argument')

  if (typeof callback != 'function')
    throw new Error('destroy() requires a callback function argument')

  binding.destroy(location, callback)
}


LevelDOWN.repair = function (location, callback) {
  if (arguments.length < 2)
    throw new Error('repair() requires `location` and `callback` arguments')

  if (typeof location != 'string')
    throw new Error('repair() requires a location string argument')

  if (typeof callback != 'function')
    throw new Error('repair() requires a callback function argument')

  binding.repair(location, callback)
}


module.exports = LevelDOWN

},
"zXiSEqjSjF1a8LhdARoR44gmjdICViuF8nex7tho8tY=":
function (require, module, exports, __dirname, __filename) {
// master plugin
// allows you to define "master" IDs in the config
// which are given the full rights of the local main ID
module.exports = function (api, opts) {
  var masters = [api.id].concat(opts.master).filter(Boolean)
  api.auth.hook(function (fn, args) {
    var id = args[0]
    var cb = args[1]
    cb(null, ~masters.indexOf(id) ? {allow: null, deny: null} : null)
  })
}

},
"zfsmtutXvQPMAYfmqcRHiMhjzi1w+iaez3nSMzOGU/c=":
function (require, module, exports, __dirname, __filename) {
var sodium = require('chloride')
var hash = sodium.crypto_hash_sha256
var pull = require('pull-stream')
var boxes = require('pull-box-stream')

var concat = Buffer.concat

module.exports = function (cb) {

  return function (err, stream, state) {
    if(err) return cb(err)

    var en_key = hash(concat([state.secret, state.remote.public]))
    var de_key = hash(concat([state.secret, state.local.public]))

    var en_nonce = state.remote.app_mac.slice(0, 24)
    var de_nonce = state.local.app_mac.slice(0, 24)

    cb(null, {
      remote: state.remote.public,
      //on the server, attach any metadata gathered
      //during `authorize` call
      auth: state.auth,
      source: pull(
        stream.source,
        boxes.createUnboxStream(de_key, de_nonce)
      ),
      sink: pull(
        boxes.createBoxStream(en_key, en_nonce),
        stream.sink
      )
    })
  }

}



},
"zv34BsCHL0COF77P/XL043c8r8Z3LIwM7pa43iCd3lc=":
function (require, module, exports, __dirname, __filename) {
var proto = {}
module.exports = proto

proto.from = require('./from.js')
proto.to = require('./to.js')
proto.is = require('./is.js')
proto.subarray = require('./subarray.js')
proto.join = require('./join.js')
proto.copy = require('./copy.js')
proto.create = require('./create.js')

mix(require('./read.js'), proto)
mix(require('./write.js'), proto)

function mix(from, into) {
  for(var key in from) {
    into[key] = from[key]
  }
}

},

}
,
{
  "bin.js": [
    "kpQf5YlD36spS2U7D4cMcVawxfNmToheCTJwTjgKre8=",
    {
      "./": "index.js",
      "./lib/cli-cmd-aliases": "lib/cli-cmd-aliases.js",
      "./package.json": "package.json",
      "./plugins/blobs": "plugins/blobs/index.js",
      "./plugins/block": "plugins/block.js",
      "./plugins/friends": "plugins/friends.js",
      "./plugins/gossip": "plugins/gossip/index.js",
      "./plugins/invite": "plugins/invite.js",
      "./plugins/local": "plugins/local.js",
      "./plugins/logging": "plugins/logging.js",
      "./plugins/master": "plugins/master.js",
      "./plugins/private": "plugins/private.js",
      "./plugins/replicate": "plugins/replicate.js",
      "explain-error": "node_modules/explain-error/index.js",
      "multiblob/util": "node_modules/multiblob/util.js",
      "muxrpcli": "node_modules/muxrpcli/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "pull-stringify": "node_modules/pull-stringify/index.js",
      "ssb-client": "node_modules/ssb-client/index.js",
      "ssb-config/inject": "node_modules/ssb-config/inject.js",
      "ssb-keys": "node_modules/ssb-keys/index.js",
      "stream-to-pull-stream": "node_modules/stream-to-pull-stream/index.js"
    }
  ],
  "index.js": [
    "Qkr+G+EkbtY6snDl3WUkMKM6fM5axK0aigO1ecfPfzU=",
    {
      "./lib/apidocs.js": "lib/apidocs.js",
      "./lib/cli-cmd-aliases": "lib/cli-cmd-aliases.js",
      "./lib/ssb-cap": "lib/ssb-cap.js",
      "./lib/validators": "lib/validators.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "mkdirp": "node_modules/mkdirp/index.js",
      "osenv": "node_modules/osenv/osenv.js",
      "rimraf": "node_modules/rimraf/rimraf.js",
      "secret-stack": "node_modules/secret-stack/index.js",
      "secure-scuttlebutt/create": "node_modules/secure-scuttlebutt/create.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "lib/apidocs.js": [
    "+wzpVyYMDn/9oAcjPgmjsmgzPwwnNlQheOn95A5CntY=",
    {}
  ],
  "lib/cli-cmd-aliases.js": [
    "mvnAF7M3/57EHitgTGHw2KPxotIOMvGBq3qiEBTTu8U=",
    {}
  ],
  "lib/ssb-cap.js": [
    "Y6cbT3Y4EA7HbMEu7Fz44pPPNcsjbpjVQfTH/KE98pA=",
    {}
  ],
  "lib/util.js": [
    "Koy6Upg+6tVpJ8fCj7jgeQeLrXxPjG6mXq8kx61qGtU=",
    {
      "ssb-ref": "node_modules/ssb-ref/index.js"
    }
  ],
  "lib/validators.js": [
    "RfPtNcdFUNPcsuSnAB6CmhEHT3CR8j3Lia/BOoDZqIQ=",
    {
      "muxrpc-validation": "node_modules/muxrpc-validation/index.js",
      "ssb-ref": "node_modules/ssb-ref/index.js",
      "zerr": "node_modules/zerr/index.js"
    }
  ],
  "node_modules/attach-ware/index.js": [
    "lMswXBQii9P/pfGzapgmMzlnSatBGkUCqq/dH5aFfr0=",
    {
      "unherit": "node_modules/unherit/index.js"
    }
  ],
  "node_modules/bail/index.js": [
    "kiKgwhC4zhbntG5eh1zfswPH1Bd6S7mVhx2GTYogAcE=",
    {}
  ],
  "node_modules/balanced-match/index.js": [
    "xYiGFKhLKuo/ApNWIopVfeMaHVBhSFyAbgdwNhsyplo=",
    {}
  ],
  "node_modules/bash-color/index.js": [
    "dTPouclBa8UNPDemLXOS7XGs5BZpoD3RzibOMvm3NPY=",
    {}
  ],
  "node_modules/binary-search/index.js": [
    "quxwChILv3+jFc11isLbWrWFYjcxftef8FE6U6bZg7o=",
    {}
  ],
  "node_modules/binary-sorted-set/index.js": [
    "CIDVcGPCFa+nEGez6vokCvNxNJKIA/mtRyEHrSLzgMo=",
    {
      "binary-search": "node_modules/binary-search/index.js",
      "ltgt": "node_modules/binary-sorted-set/node_modules/ltgt/index.js",
      "typewiselite": "node_modules/typewiselite/index.js"
    }
  ],
  "node_modules/binary-sorted-set/node_modules/ltgt/index.js": [
    "ndz8xysNLoh8RKpifx147rp7hLl4ISMEYRchRAY8Hq4=",
    {}
  ],
  "node_modules/blake2s/index.js": [
    "bhC0gmXSZmRC+aw7OypLcenR25uM+NIQdraXNT9EWsA=",
    {}
  ],
  "node_modules/bops/copy.js": [
    "mRlJcCnoEOlbSJXF9YOZpWm2s0wNMfmSY7VJqbq4++Y=",
    {}
  ],
  "node_modules/bops/create.js": [
    "qisTu/X0dmzjf7wjUr2/duoiq/mlHB/SLJ0gZmmRlUk=",
    {}
  ],
  "node_modules/bops/from.js": [
    "COrqk1kH+qgsFK+ITWPhd0ROLv1O41t0Pxasmi3ZqkU=",
    {}
  ],
  "node_modules/bops/index.js": [
    "zv34BsCHL0COF77P/XL043c8r8Z3LIwM7pa43iCd3lc=",
    {
      "./copy.js": "node_modules/bops/copy.js",
      "./create.js": "node_modules/bops/create.js",
      "./from.js": "node_modules/bops/from.js",
      "./is.js": "node_modules/bops/is.js",
      "./join.js": "node_modules/bops/join.js",
      "./read.js": "node_modules/bops/read.js",
      "./subarray.js": "node_modules/bops/subarray.js",
      "./to.js": "node_modules/bops/to.js",
      "./write.js": "node_modules/bops/write.js"
    }
  ],
  "node_modules/bops/is.js": [
    "KLt4rvLMI8kmsSqkDrC40OBTJnsaUVGF206qJWgXq/0=",
    {}
  ],
  "node_modules/bops/join.js": [
    "rrxGe8mGpBGFX5t7qxsIqkWpsh36MqWqwkXb1AuygB4=",
    {}
  ],
  "node_modules/bops/read.js": [
    "d6cv1s6pAyR8nN6Cy140raurSSAruTn8p2pokFargeE=",
    {}
  ],
  "node_modules/bops/subarray.js": [
    "dpb5/pv0fQ1ZoEZzQQ7eBYy5aYv4T8MK7dCNndAHvM8=",
    {}
  ],
  "node_modules/bops/to.js": [
    "reioqDzeG703e/zvg4J/MTLRGdlLnppYfOQTf+IfSCw=",
    {}
  ],
  "node_modules/bops/write.js": [
    "U2WijCKGwWcUA6JkyFmVMV2BBkppsRzwhAoaycsp0ys=",
    {}
  ],
  "node_modules/brace-expansion/index.js": [
    "bUb+wYxOM0+YvOoCWqSLdq3+rpm4/RFCxHx7vmWoBlc=",
    {
      "balanced-match": "node_modules/balanced-match/index.js",
      "concat-map": "node_modules/concat-map/index.js"
    }
  ],
  "node_modules/broadcast-stream/index.js": [
    "bLkkinq+cfH+K+vvafbEW9Pb1Xqndze6qheqOjJgGu8=",
    {}
  ],
  "node_modules/buffer-equal/index.js": [
    "nUxnF57qemY+Mdk07TDCLZixJU+ZvZEq59JlwazRQYY=",
    {}
  ],
  "node_modules/bytewise-core/base.js": [
    "mcGty7pSW6D6LnUrqJfOtYJxrh8HUx22eQtt/rXYgEY=",
    {
      "./codecs": "node_modules/bytewise-core/codecs.js",
      "./util": "node_modules/bytewise-core/util.js",
      "typewise-core/base": "node_modules/typewise-core/base.js"
    }
  ],
  "node_modules/bytewise-core/codecs.js": [
    "rFQTFWgU44ZunWD7LzMCjKPOqfvxcsYimn3q41vQzEE=",
    {
      "./util": "node_modules/bytewise-core/util.js"
    }
  ],
  "node_modules/bytewise-core/index.js": [
    "3/c/dHGL7b5sk6QLh7JdsthKwZLs/wQLgrqjVp8kVIA=",
    {
      "./base": "node_modules/bytewise-core/base.js",
      "./codecs": "node_modules/bytewise-core/codecs.js",
      "./util": "node_modules/bytewise-core/util.js"
    }
  ],
  "node_modules/bytewise-core/util.js": [
    "rXXYA2x9VEX66QDVrxljCKnFWifeueQAQojoYzUD3zI=",
    {
      "typewise-core/collation": "node_modules/typewise-core/collation.js"
    }
  ],
  "node_modules/bytewise/bytewise.js": [
    "ch3b4XdlyANbo95l1vTW6wtEx9xiH1YBtKit7ABCMoU=",
    {
      "bops": "node_modules/bops/index.js",
      "typewise": "node_modules/typewise/index.js"
    }
  ],
  "node_modules/ccount/index.js": [
    "iPuI5KqB2e09EXncyW4xp4GyK8WTemaPgHYnweyBhGA=",
    {}
  ],
  "node_modules/character-entities-html4/index.js": [
    "zOcVwwzSymJLC+JtqJNe7iolAo2nXwGFK8RJ7fBOdF0=",
    {
      "./index.json": "node_modules/character-entities-html4/index.json"
    }
  ],
  "node_modules/character-entities-html4/index.json": [
    "LxnHm5ibtd2DEXFCkxKC2J4C+AKlyJpgEo/GuuLsFzw=",
    {}
  ],
  "node_modules/character-entities-legacy/index.js": [
    "//LMwiTrBMm6Jh3IKHJrhBmroGwRCec1qby8gwJqBNs=",
    {
      "./index.json": "node_modules/character-entities-legacy/index.json"
    }
  ],
  "node_modules/character-entities-legacy/index.json": [
    "93bxujWOHqlWY3OdEKlVwvXxfFNRK92GepJN7l+Mfg4=",
    {}
  ],
  "node_modules/character-entities/index.js": [
    "5b630ED8lltBkoqSjEh5Aq7a+rWC0OXkntvOcJy7Ago=",
    {
      "./index.json": "node_modules/character-entities/index.json"
    }
  ],
  "node_modules/character-entities/index.json": [
    "L88a7VdTLTIGreE14E5zYY10SbMoiZ9SfC6axiGRDds=",
    {}
  ],
  "node_modules/character-reference-invalid/index.js": [
    "myVBC8npQvqz1ryIXXUrqfJZ1qY6+Q5EhZ7+1W43LBo=",
    {
      "./index.json": "node_modules/character-reference-invalid/index.json"
    }
  ],
  "node_modules/character-reference-invalid/index.json": [
    "OX9hSq+gLxYQEbVxgKeceVT7ZQFFSC5nfUw6imsdkg0=",
    {}
  ],
  "node_modules/chloride/bindings.js": [
    "Ed2Ny21B1gRjdGc84PA+uArK4XS0W3BuIKN0puLCqUI=",
    {}
  ],
  "node_modules/chloride/browser.js": [
    "Qu4l//F7UrFHfxoG1dj2ywQrbU0tezhIHB+N1dgocSw=",
    {
      "sodium-browserify": "node_modules/sodium-browserify/index.js"
    }
  ],
  "node_modules/chloride/index.js": [
    "SFofC9bpbqbfdY9juvX9g0bPGJ5h7/9vwHAb1F73Yxk=",
    {
      "./bindings": "node_modules/chloride/bindings.js",
      "./browser": "node_modules/chloride/browser.js"
    }
  ],
  "node_modules/clone/clone.js": [
    "loiUibNk8UcRLZ2jBFreyhfHe95Yz7IdjF8MPfoXuH8=",
    {}
  ],
  "node_modules/co/index.js": [
    "w8Yiat41Gm+aC99EpaeinBBOcb1lFSoDubsJDL/koro=",
    {}
  ],
  "node_modules/collapse-white-space/index.js": [
    "OWCgfT4DvjogMWRocC8BAVantZuLyjcsL2GZikdZ5mI=",
    {}
  ],
  "node_modules/concat-map/index.js": [
    "CRtl13gzdZnQFAs11TwDhgPRcy0nwzv+OeA4calpJrI=",
    {}
  ],
  "node_modules/cont/index.js": [
    "my3Mtk8msQFkFs5faZG4tS0EjwmtODFORzhSxcgleDM=",
    {
      "continuable": "node_modules/continuable/index.js",
      "continuable-para": "node_modules/continuable-para/index.js",
      "continuable-series": "node_modules/continuable-series/index.js"
    }
  ],
  "node_modules/continuable-hash/index.js": [
    "Ofp/3pHGnR/xhrB0q5TIvQrTtz5GW+A+PkWMdavBy0o=",
    {
      "continuable/maybe-callback": "node_modules/continuable-hash/node_modules/continuable/maybe-callback.js"
    }
  ],
  "node_modules/continuable-hash/node_modules/continuable/maybe-callback.js": [
    "pN128HmfxJd3AhJuZ6vuPPgWw3XLAKVTqj/gX8bFlno=",
    {}
  ],
  "node_modules/continuable-list/index.js": [
    "MZNAuf/Vk6btL7qAEyf1tKcUS0ojiXtWJ1bT9eyhPic=",
    {
      "continuable/maybe-callback": "node_modules/continuable-list/node_modules/continuable/maybe-callback.js"
    }
  ],
  "node_modules/continuable-list/node_modules/continuable/maybe-callback.js": [
    "pN128HmfxJd3AhJuZ6vuPPgWw3XLAKVTqj/gX8bFlno=",
    {}
  ],
  "node_modules/continuable-para/index.js": [
    "5cfvpgW0NF9XIpq727oLs8A9i4N5lZiBMtgMuvj2Ijk=",
    {
      "continuable-hash": "node_modules/continuable-hash/index.js",
      "continuable-list": "node_modules/continuable-list/index.js"
    }
  ],
  "node_modules/continuable-series/index.js": [
    "y9bu6ooSJ4eTo3qLTOYHiygPQzsC5cIrHuZVk9FGhw4=",
    {}
  ],
  "node_modules/continuable/both.js": [
    "MjvLr/xOseyqvTTmpIHI8bgRJsCpKTL5QuFJFStCwCs=",
    {}
  ],
  "node_modules/continuable/chain.js": [
    "Yu76t+DKfnA75RFAqcScJ3XCdzDeuPe8X0/wXqLI3ak=",
    {}
  ],
  "node_modules/continuable/either.js": [
    "Xz71w1g5FDlgcpQB1RsYHmnE9+BZfKrwfQyi9hcFlUM=",
    {
      "./of": "node_modules/continuable/of.js"
    }
  ],
  "node_modules/continuable/error.js": [
    "v1JJsvB84WMOaJeajnHp6rZ4y/7uHk4RMQQpWljccnM=",
    {}
  ],
  "node_modules/continuable/index.js": [
    "BPW+ohGOj+1TlKqaWFsfFn7zUbaW6USLAAF5Ln1+CLI=",
    {
      "./both.js": "node_modules/continuable/both.js",
      "./chain.js": "node_modules/continuable/chain.js",
      "./either.js": "node_modules/continuable/either.js",
      "./error.js": "node_modules/continuable/error.js",
      "./join.js": "node_modules/continuable/join.js",
      "./map-async.js": "node_modules/continuable/map-async.js",
      "./map.js": "node_modules/continuable/map.js",
      "./maybe-callback.js": "node_modules/continuable/maybe-callback.js",
      "./of.js": "node_modules/continuable/of.js",
      "./to.js": "node_modules/continuable/to.js"
    }
  ],
  "node_modules/continuable/join.js": [
    "D0nA59GBhKIX7Sc5Kwjc5GZ5UCdU/INt/J2cmRjCIAQ=",
    {}
  ],
  "node_modules/continuable/map-async.js": [
    "BAb8PtZjQg38fOfdP6kJel/Askmzk4LekGrQIq39Zbo=",
    {}
  ],
  "node_modules/continuable/map.js": [
    "8oVQAh3PHo5mQo4nNZARZxbXyIiufUbrNzi1vx0D53w=",
    {}
  ],
  "node_modules/continuable/maybe-callback.js": [
    "pN128HmfxJd3AhJuZ6vuPPgWw3XLAKVTqj/gX8bFlno=",
    {}
  ],
  "node_modules/continuable/of.js": [
    "AhGM13F38Ugmo+1/psfxxr/69gITlpyAFudfqUhCubg=",
    {}
  ],
  "node_modules/continuable/to.js": [
    "CYFjk0MA9cqunsqirN4JfopZp1rC3FTB21giVtLNJLQ=",
    {}
  ],
  "node_modules/core-util-is/lib/util.js": [
    "aRb/yDtQKWPdj2Gc5FenMcwXMOKqr3f6P4vLtgNFyp0=",
    {}
  ],
  "node_modules/deep-extend/lib/deep-extend.js": [
    "KSG+p01Q0K7rkgg4S+w8AXaj/V8Ydh5/v8kmumpWm/c=",
    {}
  ],
  "node_modules/defined/index.js": [
    "Vb6mMU0vc4x3R8riil6ujf6QXdnLhd83zDfmivCKls8=",
    {}
  ],
  "node_modules/detab/index.js": [
    "41/ZYVYna/Ec5ezAO+/dB5wM4KDiJjL6BiioOb6HNgw=",
    {
      "repeat-string": "node_modules/repeat-string/index.js"
    }
  ],
  "node_modules/errno/custom.js": [
    "oM8s3lAcPjewxN2ZNNDdK+k0CU4Pwi+98q5KWPxco68=",
    {
      "prr": "node_modules/prr/prr.js"
    }
  ],
  "node_modules/errno/errno.js": [
    "Hk6T3FVpUObSr+tQzzuU3LOQ2HC4cqsuS+qI19rk5aI=",
    {
      "./custom": "node_modules/errno/custom.js"
    }
  ],
  "node_modules/explain-error/index.js": [
    "GcTFTVnj+D5rDts8W8YkGHe4g560hWY5VxEZRbgK/Zw=",
    {}
  ],
  "node_modules/extend.js/index.js": [
    "YtwUE7q53jpxZqodrQL7wICJdflcYFqdRhowlP73ZpM=",
    {}
  ],
  "node_modules/extend/index.js": [
    "kK78KFK65pX98WPrreowhFqTeeX4ddqsf0xpMnhGAtc=",
    {}
  ],
  "node_modules/fast-future/fast-future.js": [
    "idXWOOU5aAkEbOfCXcUPMyRNoNKjdW2gb06E9CVy490=",
    {}
  ],
  "node_modules/graphmitter/algorithms.js": [
    "kRrAQeGOddupYmHHuAn1pFnw/kVrUzHbgZXAlM1B6kY=",
    {}
  ],
  "node_modules/graphmitter/index.js": [
    "3mp3S4LZnwPDKcUo4Q7bYe7pSb5qqd0S0t2xDcwqTLY=",
    {
      "./algorithms": "node_modules/graphmitter/algorithms.js"
    }
  ],
  "node_modules/hmac/index.js": [
    "n0vDNDOSZ6aL2orzwLIfZWWDdKmybPF++mfkW0Z6y4o=",
    {}
  ],
  "node_modules/hoox/index.js": [
    "rw6wQdeShnSEjU8e/YNtOxUjBtvczz3KxnDJvn1GGAY=",
    {}
  ],
  "node_modules/increment-buffer/index.js": [
    "drw4M9duI28aRjy8NYzMWkJ6ZLuyHEuyg+Fza07nqGU=",
    {}
  ],
  "node_modules/inflight/inflight.js": [
    "LiOnuzi4/BU48BjvK+3W7ivMOMV/Bj/UOVuqRv8jM74=",
    {
      "once": "node_modules/once/once.js",
      "wrappy": "node_modules/wrappy/wrappy.js"
    }
  ],
  "node_modules/inherits/inherits.js": [
    "ZEG4aHL+0usxgN0tnFuO+zMVRiJNCChiy42kLL1EyWc=",
    {}
  ],
  "node_modules/ini/ini.js": [
    "H6y6JY7lDTTrkj/x3BGLUvRIaMNKZCwbHk04Z/3ebtY=",
    {}
  ],
  "node_modules/intersect/index.js": [
    "8Ka+H0jT7owC0PUrgH54c1zPT66jkxs9uvoHT7hxpA4=",
    {}
  ],
  "node_modules/ip-regex/index.js": [
    "8K0wmtTFpEUACT5MxG6aQmwzk4ybG5nDuPEusbcZkfc=",
    {}
  ],
  "node_modules/ip/lib/ip.js": [
    "XC4OLRd/OAzztR25n7mdLXTuMI7irpLLHwoOFC/FbLo=",
    {}
  ],
  "node_modules/is-valid-domain/is-valid-domain.js": [
    "8SbFn01DiCcXOS01iCTY9gKj+vtWJ+X735dTPvOcT/8=",
    {}
  ],
  "node_modules/isarray/index.js": [
    "dKtews1S4sHvaZhZ+ceqemQI9/cjFXbbOwtWrx2X2WY=",
    {}
  ],
  "node_modules/level-codec/index.js": [
    "+02qUDKpzxY2anObpV8cxH7eZB6epx5qWv6WyvcAvcY=",
    {
      "./lib/encodings": "node_modules/level-codec/lib/encodings.js"
    }
  ],
  "node_modules/level-codec/lib/encodings.js": [
    "2UFIiuKkR2dNc7RiBRWVKGn/sBVzPDkoOR8f6XiEoAM=",
    {}
  ],
  "node_modules/level-errors/errors.js": [
    "z8y4jRit++cjRVT+LwIKCSRLrcBhqb09RBLXzoKzYcM=",
    {
      "errno": "node_modules/errno/errno.js"
    }
  ],
  "node_modules/level-iterator-stream/index.js": [
    "5yGyriLdISAp9467ucTTENN7k3wvCwjPOjKh5ZKExkE=",
    {
      "inherits": "node_modules/inherits/inherits.js",
      "level-errors": "node_modules/level-errors/errors.js",
      "readable-stream": "node_modules/readable-stream/readable.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/level-memview/index.js": [
    "JssbMjuxexnirfhxu+zGTuXhpF3BrL7FxznLcyk86Ls=",
    {
      "pull-level": "node_modules/pull-level/index.js",
      "pull-stream": "node_modules/level-memview/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/level-memview/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/level-memview/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/level-memview/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/level-memview/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/level-memview/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/level-memview/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/level-memview/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/level-memview/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/level-memview/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/level-memview/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/level-memview/node_modules/pull-stream/sources.js": [
    "VsEMAVfSnZ+1GDylFAK6HhnhGGV4I2xTkYWxF9t0KgY=",
    {}
  ],
  "node_modules/level-memview/node_modules/pull-stream/throughs.js": [
    "PZDoywImBDx0kqFuCBJoRMdJKdK18hRBHkLun3eTMJ4=",
    {
      "./sinks": "node_modules/level-memview/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/level-memview/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/level-memview/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/level-packager/level-packager.js": [
    "1NMiF4d3VSn1vGR25TOPKP81tu9/9wUCv/qXPAlCNdA=",
    {
      "levelup": "node_modules/level-packager/node_modules/levelup/lib/levelup.js"
    }
  ],
  "node_modules/level-packager/node_modules/abstract-leveldown/abstract-chained-batch.js": [
    "+GY0CaPCoELxgYaGnEBnCvJdrzBdN+ubns7nsax+Zjs=",
    {}
  ],
  "node_modules/level-packager/node_modules/abstract-leveldown/abstract-iterator.js": [
    "yXAabb7H6QZTQsr2s1hOIP/0Q1tLc6p8vAxHZwm05TY=",
    {}
  ],
  "node_modules/level-packager/node_modules/abstract-leveldown/abstract-leveldown.js": [
    "CjHN3zu/36TgA0eBoBkFFjR+bkoa1pUbdCVsIh5Ppqc=",
    {
      "./abstract-chained-batch": "node_modules/level-packager/node_modules/abstract-leveldown/abstract-chained-batch.js",
      "./abstract-iterator": "node_modules/level-packager/node_modules/abstract-leveldown/abstract-iterator.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/level-packager/node_modules/abstract-leveldown/index.js": [
    "j6aP6LD2tdvlAd5NtAw/vSzcYqhGdFQxdP6xrfT00i4=",
    {
      "./abstract-chained-batch": "node_modules/level-packager/node_modules/abstract-leveldown/abstract-chained-batch.js",
      "./abstract-iterator": "node_modules/level-packager/node_modules/abstract-leveldown/abstract-iterator.js",
      "./abstract-leveldown": "node_modules/level-packager/node_modules/abstract-leveldown/abstract-leveldown.js",
      "./is-leveldown": "node_modules/level-packager/node_modules/abstract-leveldown/is-leveldown.js"
    }
  ],
  "node_modules/level-packager/node_modules/abstract-leveldown/is-leveldown.js": [
    "sgrUsQaJii/+fVMF8OmANMsLjyzvxtngBdS2/y/fIUg=",
    {
      "./abstract-leveldown": "node_modules/level-packager/node_modules/abstract-leveldown/abstract-leveldown.js"
    }
  ],
  "node_modules/level-packager/node_modules/deferred-leveldown/deferred-iterator.js": [
    "DCz7NWqxOekMbHRmpp8ctQet00Bwrg9RRODkTgsGm6E=",
    {
      "abstract-leveldown": "node_modules/level-packager/node_modules/abstract-leveldown/index.js"
    }
  ],
  "node_modules/level-packager/node_modules/deferred-leveldown/deferred-leveldown.js": [
    "4zZh2+OQI3I7yONWheo4F2moOtVJQSUZfVPZRC4BdrE=",
    {
      "./deferred-iterator": "node_modules/level-packager/node_modules/deferred-leveldown/deferred-iterator.js",
      "abstract-leveldown": "node_modules/level-packager/node_modules/abstract-leveldown/index.js"
    }
  ],
  "node_modules/level-packager/node_modules/levelup/lib/batch.js": [
    "5kHPgK8/97AW2PCk9SYhRqPIw/ftwmbjaTS/FM500Vw=",
    {
      "./util": "node_modules/level-packager/node_modules/levelup/lib/util.js",
      "level-errors": "node_modules/level-errors/errors.js"
    }
  ],
  "node_modules/level-packager/node_modules/levelup/lib/levelup.js": [
    "uFW2bvxzxDyicyw7KzUXs8e1CYJ2HAWuaTREpO2QiQQ=",
    {
      "./batch": "node_modules/level-packager/node_modules/levelup/lib/batch.js",
      "./util": "node_modules/level-packager/node_modules/levelup/lib/util.js",
      "deferred-leveldown": "node_modules/level-packager/node_modules/deferred-leveldown/deferred-leveldown.js",
      "level-codec": "node_modules/level-codec/index.js",
      "level-errors": "node_modules/level-errors/errors.js",
      "level-iterator-stream": "node_modules/level-iterator-stream/index.js",
      "prr": "node_modules/level-packager/node_modules/prr/prr.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/level-packager/node_modules/levelup/lib/util.js": [
    "ZtU4268sTUITGLs2TBqdeEpFlar2N6nUb+xsMo+OUl4=",
    {
      "../package.json": "node_modules/level-packager/node_modules/levelup/package.json",
      "level-errors": "node_modules/level-errors/errors.js",
      "leveldown": "node_modules/leveldown/leveldown.js",
      "leveldown/package": "node_modules/leveldown/package.json",
      "semver": "node_modules/semver/semver.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/level-packager/node_modules/levelup/package.json": [
    "vR7TVxY4LwMBwimhAo3YCkC5+wD1uSJrD7HDCN6xXGo=",
    {}
  ],
  "node_modules/level-packager/node_modules/prr/prr.js": [
    "M2waEw6vcov0DK2BRKoWlCliMH8ZJJjGMyHW/1nZqqw=",
    {}
  ],
  "node_modules/level-post/index.js": [
    "g8DWzpBodxqzguiUewIJPfd9RQ42hGJAt32Ok6On0rA=",
    {
      "buffer-equal": "node_modules/buffer-equal/index.js",
      "defined": "node_modules/defined/index.js",
      "string-range": "node_modules/string-range/index.js"
    }
  ],
  "node_modules/level-sublevel/bytewise.js": [
    "9dGszbFmGhoAFuEBf9blmEOvPXNqI+M7op9HRB2B7Mo=",
    {
      "./codec/bytewise": "node_modules/level-sublevel/codec/bytewise.js",
      "./nut": "node_modules/level-sublevel/nut.js",
      "./shell": "node_modules/level-sublevel/shell.js",
      "levelup/lib/codec": "node_modules/levelup/lib/codec.js",
      "levelup/lib/read-stream": "node_modules/levelup/lib/read-stream.js",
      "typewiselite": "node_modules/typewiselite/index.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/level-sublevel/codec/bytewise.js": [
    "kHUk1iAy7Qi9Sc5XNIJ3nVD9jg1u0R2WIKJwmZF1au0=",
    {
      "bytewise": "node_modules/bytewise/bytewise.js"
    }
  ],
  "node_modules/level-sublevel/hooks.js": [
    "t7uJRuDop5vyV48/YqqWK6g8n8YtIMp3B8sa2uv2+wg=",
    {
      "./range": "node_modules/level-sublevel/range.js"
    }
  ],
  "node_modules/level-sublevel/nut.js": [
    "7RgQFGvTEv51ozIRCNYwjLryaoOVTXdszxkjzCRcOXw=",
    {
      "./hooks": "node_modules/level-sublevel/hooks.js",
      "ltgt": "node_modules/ltgt/index.js"
    }
  ],
  "node_modules/level-sublevel/package.json": [
    "dftqxcGO2g5pkgkngPYas9uqxLkZF7tQTr7upFrTqyA=",
    {}
  ],
  "node_modules/level-sublevel/range.js": [
    "EDJAH/R7NidIhBhI+SqQVti/ffEubSpQD++eiim866s=",
    {
      "ltgt": "node_modules/ltgt/index.js"
    }
  ],
  "node_modules/level-sublevel/shell.js": [
    "rC98x2QltpxXInWZPxaa9LZrWailB5Cjw3C/6pRatKA=",
    {
      "./package.json": "node_modules/level-sublevel/package.json",
      "./range": "node_modules/level-sublevel/range.js",
      "levelup/lib/errors": "node_modules/levelup/lib/errors.js"
    }
  ],
  "node_modules/level/level.js": [
    "jV3jk5AWI4ZrZK+xzgRd3HaURfDqGWeTbcsJiv/G7ag=",
    {
      "level-packager": "node_modules/level-packager/level-packager.js",
      "leveldown": "node_modules/leveldown/leveldown.js"
    }
  ],
  "node_modules/leveldown/chained-batch.js": [
    "pq9tHWt9lgwKW6IMcb/tWbAOxzeLT9AXi/Ih8FRq/P0=",
    {
      "abstract-leveldown": "node_modules/leveldown/node_modules/abstract-leveldown/index.js"
    }
  ],
  "node_modules/leveldown/iterator.js": [
    "tPweugl54351uRFBSjm53DVQaPV3jrUN0lGpxG3IyWQ=",
    {
      "abstract-leveldown": "node_modules/leveldown/node_modules/abstract-leveldown/index.js",
      "fast-future": "node_modules/fast-future/fast-future.js"
    }
  ],
  "node_modules/leveldown/leveldown.js": [
    "zWtLg9p7uWPvfhP48jjb3bsKzmkCJ7x8LdDSu1nsduI=",
    {
      "./chained-batch": "node_modules/leveldown/chained-batch.js",
      "./iterator": "node_modules/leveldown/iterator.js",
      "abstract-leveldown": "node_modules/leveldown/node_modules/abstract-leveldown/index.js"
    }
  ],
  "node_modules/leveldown/node_modules/abstract-leveldown/abstract-chained-batch.js": [
    "+GY0CaPCoELxgYaGnEBnCvJdrzBdN+ubns7nsax+Zjs=",
    {}
  ],
  "node_modules/leveldown/node_modules/abstract-leveldown/abstract-iterator.js": [
    "yXAabb7H6QZTQsr2s1hOIP/0Q1tLc6p8vAxHZwm05TY=",
    {}
  ],
  "node_modules/leveldown/node_modules/abstract-leveldown/abstract-leveldown.js": [
    "CjHN3zu/36TgA0eBoBkFFjR+bkoa1pUbdCVsIh5Ppqc=",
    {
      "./abstract-chained-batch": "node_modules/leveldown/node_modules/abstract-leveldown/abstract-chained-batch.js",
      "./abstract-iterator": "node_modules/leveldown/node_modules/abstract-leveldown/abstract-iterator.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/leveldown/node_modules/abstract-leveldown/index.js": [
    "j6aP6LD2tdvlAd5NtAw/vSzcYqhGdFQxdP6xrfT00i4=",
    {
      "./abstract-chained-batch": "node_modules/leveldown/node_modules/abstract-leveldown/abstract-chained-batch.js",
      "./abstract-iterator": "node_modules/leveldown/node_modules/abstract-leveldown/abstract-iterator.js",
      "./abstract-leveldown": "node_modules/leveldown/node_modules/abstract-leveldown/abstract-leveldown.js",
      "./is-leveldown": "node_modules/leveldown/node_modules/abstract-leveldown/is-leveldown.js"
    }
  ],
  "node_modules/leveldown/node_modules/abstract-leveldown/is-leveldown.js": [
    "sgrUsQaJii/+fVMF8OmANMsLjyzvxtngBdS2/y/fIUg=",
    {
      "./abstract-leveldown": "node_modules/leveldown/node_modules/abstract-leveldown/abstract-leveldown.js"
    }
  ],
  "node_modules/leveldown/package.json": [
    "Z6u3/pIaEWkm9xY7PmuyqbPY0G7rC3usowa0WV54KnI=",
    {}
  ],
  "node_modules/levelup/lib/codec.js": [
    "a9irYcSSS0gtnrygil3AqyBt6JgtdkZhBTNS4BEmO6I=",
    {
      "./encodings": "node_modules/levelup/lib/encodings.js"
    }
  ],
  "node_modules/levelup/lib/encodings.js": [
    "dSyQjl7jHQye3+fIwCpbUl0+ow/aj50QE4Hthzcp464=",
    {}
  ],
  "node_modules/levelup/lib/errors.js": [
    "OI4ldP9EFYFcCUmfhlS7Q4KHkjeiYfJ5lEewbwvxQ0E=",
    {
      "errno": "node_modules/errno/errno.js"
    }
  ],
  "node_modules/levelup/lib/read-stream.js": [
    "Zfyxlza+kGu/b36r2+mmQDgHZGLxocYERlAlfZwiMIY=",
    {
      "./errors": "node_modules/levelup/lib/errors.js",
      "./util": "node_modules/levelup/lib/util.js",
      "readable-stream": "node_modules/readable-stream/readable.js",
      "xtend": "node_modules/levelup/node_modules/xtend/index.js"
    }
  ],
  "node_modules/levelup/lib/util.js": [
    "8k8b5Uur+hOKD6B9zaLgcJYLm0jb3tRM/zhQ9DlfpYY=",
    {
      "../package.json": "node_modules/levelup/package.json",
      "./encodings": "node_modules/levelup/lib/encodings.js",
      "./errors": "node_modules/levelup/lib/errors.js",
      "leveldown": "node_modules/leveldown/leveldown.js",
      "leveldown/package": "node_modules/leveldown/package.json",
      "semver": "node_modules/semver/semver.js",
      "xtend": "node_modules/levelup/node_modules/xtend/index.js"
    }
  ],
  "node_modules/levelup/node_modules/xtend/index.js": [
    "5a1nO6vLB7FxjnzEAWFmNITSM/FiOQy22MEJS+/lCNw=",
    {}
  ],
  "node_modules/levelup/package.json": [
    "mSQ4yRnbqMg10zcg6EFgoql4VwcYGFxzLWHL5tTOgnA=",
    {}
  ],
  "node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js": [
    "vh8/I1rJ1h5zuSKqs2QQh5VmIfmKzWszQnMj8b6KZsA=",
    {
      "libsodium": "node_modules/libsodium/dist/modules/libsodium.js"
    }
  ],
  "node_modules/libsodium/dist/modules/libsodium.js": [
    "E+L4oEbFSnp++gSNtiqqzjpJ0zA9kB55PRQJNyO4610=",
    {}
  ],
  "node_modules/longest-streak/index.js": [
    "NiilpOW06Z8s3QFV4KAPadHb3+SjjljNaSnowOkYu7k=",
    {}
  ],
  "node_modules/looper/index.js": [
    "h1jrjtl3Kl6vXLm4kjf4kzLRRNPkpgIukEUI+VqJagE=",
    {}
  ],
  "node_modules/ltgt/index.js": [
    "p1ZmNIwXcmirDM5E1sjRaey+BX6wKdjHWAQ0TmZU7fw=",
    {}
  ],
  "node_modules/map-merge/index.js": [
    "WbGGkbXE072ELwpIugZuNTPk/+pFO11qXzmSHyh8Vls=",
    {}
  ],
  "node_modules/markdown-table/index.js": [
    "4bpPETYxNRvzB824hWbizJm5WTmXgTLgC1jaLakjLkw=",
    {}
  ],
  "node_modules/mdmanifest/index.js": [
    "BRyl1wpAIHYEkjXhofg3UElrJ9Zh3dzY2VLzYxEZqqI=",
    {
      "remark": "node_modules/remark/index.js",
      "remark-html": "node_modules/remark-html/index.js"
    }
  ],
  "node_modules/minimatch/minimatch.js": [
    "/U3+Qt2iBQEZft5c8aotkHMNJgoM0ZiyuAoO5GqGUt0=",
    {
      "brace-expansion": "node_modules/brace-expansion/index.js"
    }
  ],
  "node_modules/mkdirp/index.js": [
    "bk9dbSa68ZTPS7tNghEARu1iFSBbQSxXp7UJfcFiPqw=",
    {}
  ],
  "node_modules/monotonic-timestamp/index.js": [
    "0ctY+ep4+F5/Kvk7cLkYlpHMnljPFrV5iNuugfJJSU0=",
    {}
  ],
  "node_modules/multiblob/index.js": [
    "coegeFa4TmC7NW+WMdonAGyaTsOmLfMvl1usTNAkhyU=",
    {
      "./util": "node_modules/multiblob/util.js",
      "cont": "node_modules/cont/index.js",
      "explain-error": "node_modules/explain-error/index.js",
      "mkdirp": "node_modules/mkdirp/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-defer": "node_modules/pull-defer/index.js",
      "pull-glob": "node_modules/pull-glob/index.js",
      "pull-notify": "node_modules/multiblob/node_modules/pull-notify/index.js",
      "pull-paramap": "node_modules/pull-paramap/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "rimraf": "node_modules/multiblob/node_modules/rimraf/rimraf.js",
      "stream-to-pull-stream": "node_modules/stream-to-pull-stream/index.js"
    }
  ],
  "node_modules/multiblob/node_modules/pull-notify/index.js": [
    "P5Sjk+0rMJ4NE3vfN59/AWUdUiOr8/elhZRxx91MBQw=",
    {
      "pull-pushable": "node_modules/pull-pushable/index.js"
    }
  ],
  "node_modules/multiblob/node_modules/rimraf/rimraf.js": [
    "LTjjv1uG8PjDpE+u0OPBJ4Jh5aOxbTlBAN7hA+lR5W0=",
    {}
  ],
  "node_modules/multiblob/util.js": [
    "YxfZdrk91FH8ygDyPW9Y7gLxjR12usWzinKUekQp/dM=",
    {
      "blake2s": "node_modules/blake2s/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/muxrpc-validation/index.js": [
    "ddQSwKSorBAH2XLt15Ve7AfB+NHG68HpNmye+Er9PyA=",
    {
      "pull-stream": "node_modules/muxrpc-validation/node_modules/pull-stream/index.js",
      "zerr": "node_modules/zerr/index.js"
    }
  ],
  "node_modules/muxrpc-validation/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/muxrpc-validation/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/muxrpc-validation/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/muxrpc-validation/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/muxrpc-validation/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/muxrpc-validation/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/muxrpc-validation/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/muxrpc-validation/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/muxrpc-validation/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/muxrpc-validation/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/muxrpc-validation/node_modules/pull-stream/sources.js": [
    "ye+ksu2cIdpcqpBHIJFw7xPLQazJFOLgrJ2ki+cIEt4=",
    {}
  ],
  "node_modules/muxrpc-validation/node_modules/pull-stream/throughs.js": [
    "HfzSWv797N1jtOQ2zUPDxBqxGbPp2ud3U4nN1sk8o2o=",
    {
      "./sinks": "node_modules/muxrpc-validation/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/muxrpc-validation/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/muxrpc-validation/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/muxrpc/api.js": [
    "V7ZajPdslcM0uSAxCxMeAYZ+VZEGxAskmB9WAu40vvg=",
    {
      "./util": "node_modules/muxrpc/util.js",
      "explain-error": "node_modules/explain-error/index.js"
    }
  ],
  "node_modules/muxrpc/index.js": [
    "uSj7eDUYar0W4NZhq8LSlOIHmZYHsQBgtpBvpPYCbJQ=",
    {
      "./api": "node_modules/muxrpc/api.js",
      "./local-api": "node_modules/muxrpc/local-api.js",
      "./stream": "node_modules/muxrpc/stream.js",
      "./util": "node_modules/muxrpc/util.js",
      "packet-stream-codec": "node_modules/packet-stream-codec/index.js"
    }
  ],
  "node_modules/muxrpc/local-api.js": [
    "oANZggQag1BRYauWPN7sm0lFM6yYAjlxqO30C0yFMG8=",
    {
      "./permissions": "node_modules/muxrpc/permissions.js",
      "./util": "node_modules/muxrpc/util.js"
    }
  ],
  "node_modules/muxrpc/permissions.js": [
    "nyacTWgKKqZ1xKyMnxonZfo2TAyqiZGZntieAhdElXY=",
    {
      "./util": "node_modules/muxrpc/util.js"
    }
  ],
  "node_modules/muxrpc/pull-weird.js": [
    "wvIKyiNwquHNmx3Lif9MGBGUmlX9yDNddMFQ3F8NYN0=",
    {
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/muxrpc/stream.js": [
    "ABaqhxFHJZH1xI5+X4BnUWT81p3KpwRS6/RYR4GxkX8=",
    {
      "./pull-weird": "node_modules/muxrpc/pull-weird.js",
      "./util": "node_modules/muxrpc/util.js",
      "explain-error": "node_modules/explain-error/index.js",
      "packet-stream": "node_modules/packet-stream/index.js",
      "pull-goodbye": "node_modules/pull-goodbye/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/muxrpc/util.js": [
    "20LcHqLoZj06jjCwfxhvw4Gc6XjQwAQJLol4KLZ+X8M=",
    {
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/muxrpcli/index.js": [
    "JNYvwEQ/ohHKdqRUNcAb7KGtW5zqZ1RgE83gvseqnbs=",
    {
      "minimist": "node_modules/muxrpcli/node_modules/minimist/index.js",
      "pull-stream": "node_modules/muxrpcli/node_modules/pull-stream/index.js",
      "stream-to-pull-stream": "node_modules/stream-to-pull-stream/index.js",
      "word-wrap": "node_modules/word-wrap/index.js"
    }
  ],
  "node_modules/muxrpcli/node_modules/minimist/index.js": [
    "VeEkjVfnqryqbxUNCx17+zBHU1JEsoDbTRoFhNgl6sM=",
    {}
  ],
  "node_modules/muxrpcli/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/muxrpcli/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/muxrpcli/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/muxrpcli/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/muxrpcli/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/muxrpcli/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/muxrpcli/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/muxrpcli/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/muxrpcli/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/muxrpcli/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/muxrpcli/node_modules/pull-stream/sources.js": [
    "ye+ksu2cIdpcqpBHIJFw7xPLQazJFOLgrJ2ki+cIEt4=",
    {}
  ],
  "node_modules/muxrpcli/node_modules/pull-stream/throughs.js": [
    "HfzSWv797N1jtOQ2zUPDxBqxGbPp2ud3U4nN1sk8o2o=",
    {
      "./sinks": "node_modules/muxrpcli/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/muxrpcli/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/muxrpcli/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/index.js": [
    "HloXk/tRBEo+dy1TA9XKdvW6VuulkPBrdTlMnOCRxaw=",
    {
      "./indexes/disk": "node_modules/mynosql/indexes/disk.js",
      "./query/compound-index": "node_modules/mynosql/query/compound-index.js",
      "./query/filtered-index": "node_modules/mynosql/query/filtered-index.js",
      "./query/intersection": "node_modules/mynosql/query/intersection.js",
      "./query/scan": "node_modules/mynosql/query/scan.js",
      "./util": "node_modules/mynosql/util.js",
      "cont": "node_modules/cont/index.js",
      "deep-equal": "node_modules/mynosql/node_modules/deep-equal/index.js",
      "level-sublevel/bytewise": "node_modules/level-sublevel/bytewise.js",
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js",
      "monotonic-timestamp": "node_modules/monotonic-timestamp/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-defer": "node_modules/pull-defer/index.js",
      "pull-level": "node_modules/mynosql/node_modules/pull-level/index.js",
      "pull-paramap": "node_modules/pull-paramap/index.js",
      "pull-stream": "node_modules/mynosql/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/indexes/disk.js": [
    "b5zczG7/hQGGi3HW3ZFba0kyy4IyXtK2nDpdCZglylA=",
    {
      "../util": "node_modules/mynosql/util.js",
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js",
      "pull-level": "node_modules/mynosql/node_modules/pull-level/index.js",
      "pull-stream": "node_modules/mynosql/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/indexes/memory.js": [
    "jkPNb0YPMe0O38zouSK6lxbIYWStTMM7GQTKnLrKdgA=",
    {
      "../util": "node_modules/mynosql/util.js",
      "binary-sorted-set": "node_modules/binary-sorted-set/index.js",
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js",
      "pull-stream": "node_modules/mynosql/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/deep-equal/index.js": [
    "F0Hy3421FqiV544O5jyAgknHiyPqSjrY/NNPV6lKdfA=",
    {
      "./lib/is_arguments.js": "node_modules/mynosql/node_modules/deep-equal/lib/is_arguments.js",
      "./lib/keys.js": "node_modules/mynosql/node_modules/deep-equal/lib/keys.js"
    }
  ],
  "node_modules/mynosql/node_modules/deep-equal/lib/is_arguments.js": [
    "BaBU3XNYuC/dAjAHsmsNjoovvlJVJ9F8ErHT/fAfGqw=",
    {}
  ],
  "node_modules/mynosql/node_modules/deep-equal/lib/keys.js": [
    "iF+IIiN4G/UyyCNXe4oEivaRyrIDw/pgJAQCrp3pChw=",
    {}
  ],
  "node_modules/mynosql/node_modules/ltgt/index.js": [
    "ndz8xysNLoh8RKpifx147rp7hLl4ISMEYRchRAY8Hq4=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-level/index.js": [
    "wHEl+1S4GoCZlQLhMS8W20HJanQwoT+5dNDPuzDCJfk=",
    {
      "level-post": "node_modules/level-post/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-pushable": "node_modules/mynosql/node_modules/pull-pushable/index.js",
      "pull-stream": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/index.js",
      "pull-window": "node_modules/pull-window/index.js",
      "stream-to-pull-stream": "node_modules/stream-to-pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/index.js": [
    "fJcQ979xu3COBdOgCeVzEM9WPBS2p8E6kIqZjrNSkgY=",
    {
      "./pull": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/pull.js",
      "./sinks": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/throughs.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/pull.js": [
    "L95YTXfSPIo+UzYLicokHBJYqOXERzIwqqRVituYe40=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/sinks.js": [
    "lKhJ5Mmc+x+PNwTHz0XD/JoAgiZhX9ZDmte/WKmaSOY=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/sources.js": [
    "rkQ8ddGWXPYKU9rtSJEjLGMvOI45KX32dWOPe6Q0Hz4=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/throughs.js": [
    "JiDq3TTh72unEa8io/h4/K4spOUvqsx33q7DNNgh5o4=",
    {
      "./sinks": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/mynosql/node_modules/pull-level/node_modules/pull-stream/sources.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-pushable/index.js": [
    "i75Y/DjTsHGMRJlMRBKaTrGKTXTOYICtCylf/isTMgI=",
    {
      "pull-stream": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/index.js": [
    "sXcqHGGdcqeUvIykBuV04nx7TY7lIdjbV9lu4Tav99o=",
    {
      "./maybe": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/maybe.js": [
    "vCCyswnkw68noYLJnNBZVw2ZQQLOawUjvfksXoijw6g=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/mynosql/node_modules/pull-pushable/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/mynosql/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/mynosql/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/mynosql/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/mynosql/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/mynosql/node_modules/pull-stream/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/mynosql/node_modules/pull-stream/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/node_modules/pull-stream/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-stream/sources.js": [
    "VsEMAVfSnZ+1GDylFAK6HhnhGGV4I2xTkYWxF9t0KgY=",
    {}
  ],
  "node_modules/mynosql/node_modules/pull-stream/throughs.js": [
    "PZDoywImBDx0kqFuCBJoRMdJKdK18hRBHkLun3eTMJ4=",
    {
      "./sinks": "node_modules/mynosql/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/mynosql/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/mynosql/node_modules/pull-stream/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/mynosql/query/compound-index.js": [
    "g/YKZYeMdNHzmSh+69JS/7sQw1VVxrLt/PvGABttoys=",
    {
      "../util": "node_modules/mynosql/util.js",
      "deep-equal": "node_modules/mynosql/node_modules/deep-equal/index.js",
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js"
    }
  ],
  "node_modules/mynosql/query/filtered-index.js": [
    "hyvm6Uek+a6PxXC+Q0h1FJl1to0v2InXv0u8z0sXrco=",
    {
      "../util": "node_modules/mynosql/util.js",
      "deep-equal": "node_modules/mynosql/node_modules/deep-equal/index.js",
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js"
    }
  ],
  "node_modules/mynosql/query/intersection.js": [
    "t13BK5xaFAWr3BUUvcdqTAcinVHiCcj+sA9voPbCVeM=",
    {
      "../util": "node_modules/mynosql/util.js",
      "cont": "node_modules/cont/index.js",
      "intersect": "node_modules/intersect/index.js",
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js",
      "pull-defer": "node_modules/pull-defer/index.js",
      "pull-paramap": "node_modules/pull-paramap/index.js",
      "pull-stream": "node_modules/mynosql/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/query/scan.js": [
    "2XXXxab8wU2/aMB8qUaXjM5eMitPzHYrOm/liKVXJcE=",
    {
      "../indexes/memory": "node_modules/mynosql/indexes/memory.js",
      "../util": "node_modules/mynosql/util.js",
      "pull-stream": "node_modules/mynosql/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/mynosql/util.js": [
    "cN+YzkA5pxEnj0g9BajTh83qOdf3OsYkF6AlUW2Oa8U=",
    {
      "ltgt": "node_modules/mynosql/node_modules/ltgt/index.js"
    }
  ],
  "node_modules/non-private-ip/index.js": [
    "wy0OCu12PqxOPX0hYNlLnTDcHA8RAYP3l/jgdquE+q0=",
    {
      "ip": "node_modules/ip/lib/ip.js"
    }
  ],
  "node_modules/normalize-uri/index.js": [
    "X6726CvmbG5t9SZoxWAjT6CYOb4CoXkljoy39fGuGmk=",
    {}
  ],
  "node_modules/object-assign/index.js": [
    "Y5pw+kokySMDzz5F2Mt3RhXuxC1via/TEY/tLtGxrUI=",
    {}
  ],
  "node_modules/observ-debounce/index.js": [
    "mNQ0wNGLNSTSSsnIjBK2KJx9b/AAUfjQRmbBY9WfzcM=",
    {
      "observ": "node_modules/observ/index.js"
    }
  ],
  "node_modules/observ/index.js": [
    "vceHTSge/cEMcrChFvL+g6XmIGQ8Dxn4EmCctXBpo6E=",
    {}
  ],
  "node_modules/on-wakeup/index.js": [
    "mJ1Mb97wyF/JYKHtacPJzv4XFtJkBvQS68qNva21Y08=",
    {}
  ],
  "node_modules/once/once.js": [
    "eGzPlApArJ01UO391c8/heE+XpGnA7Ik6hxyUc/BT0k=",
    {
      "wrappy": "node_modules/wrappy/wrappy.js"
    }
  ],
  "node_modules/os-homedir/index.js": [
    "6+0EJUY6cZ+zYs2V8FcjxPdpC0MQXyTWQqJ40hix9aU=",
    {}
  ],
  "node_modules/os-tmpdir/index.js": [
    "yDkVK9+cJMb1IcfIms+o/oADQNTI6asJrc2HAyDR8QY=",
    {}
  ],
  "node_modules/osenv/osenv.js": [
    "KCsyZM1BSztba/sqbrPZbpOq4EmCWwlI89lAkPSClY4=",
    {
      "os-homedir": "node_modules/os-homedir/index.js",
      "os-tmpdir": "node_modules/os-tmpdir/index.js"
    }
  ],
  "node_modules/packet-stream-codec/index.js": [
    "1UZqa40nXIniHtC2j0Slwvi8ss2NOs9Hm0wDzIMRZOI=",
    {
      "pull-reader": "node_modules/pull-reader/index.js",
      "pull-through": "node_modules/pull-through/index.js"
    }
  ],
  "node_modules/packet-stream/index.js": [
    "TpjKcH6xji3EnvvaQOSp9pm3BnTU7mD46aVYP5wk+YM=",
    {}
  ],
  "node_modules/parse-entities/index.js": [
    "t6kB2z9SUdPBehkQHj1S0JQKPE2Dst5aWLqLQwfwDbs=",
    {
      "character-entities": "node_modules/character-entities/index.js",
      "character-entities-legacy": "node_modules/character-entities-legacy/index.js",
      "character-reference-invalid": "node_modules/character-reference-invalid/index.js"
    }
  ],
  "node_modules/path-is-absolute/index.js": [
    "5peXoNCgcMbQWXYWQsF8BBWmR11ctKOVpxL/IDyfubg=",
    {}
  ],
  "node_modules/private-box/index.js": [
    "N8LjoCvPlTO60kSpIIp1FXFWfnpbaIelthGBLQKWoC4=",
    {
      "chloride": "node_modules/chloride/index.js"
    }
  ],
  "node_modules/process-nextick-args/index.js": [
    "+tykN+nmNVsfl/5OqjVYt+sxLnNmg7FfBJFL7Clou+Y=",
    {}
  ],
  "node_modules/prr/prr.js": [
    "M2waEw6vcov0DK2BRKoWlCliMH8ZJJjGMyHW/1nZqqw=",
    {}
  ],
  "node_modules/pull-abortable/index.js": [
    "8awuKc7pKqrk8gvE3q1Yl+IrB12AY+YJoKIyW9haNcI=",
    {}
  ],
  "node_modules/pull-box-stream/index.js": [
    "kK+TXeMaBMqopUbJj5bVbF44Tt2B0dVdk3RTWVAsurs=",
    {
      "chloride": "node_modules/chloride/index.js",
      "increment-buffer": "node_modules/increment-buffer/index.js",
      "pull-reader": "node_modules/pull-reader/index.js",
      "pull-through": "node_modules/pull-through/index.js",
      "split-buffer": "node_modules/split-buffer/index.js"
    }
  ],
  "node_modules/pull-cat/index.js": [
    "FKVMw71gi1LIQLOsVV1rBVCqZv6A5NcsfiKOZf4E0MA=",
    {}
  ],
  "node_modules/pull-core/index.js": [
    "2lrTeDMPE2OHV8KOq9nAutm2aCTJ2KK63rGPVfPqEk4=",
    {}
  ],
  "node_modules/pull-defer/index.js": [
    "wN2QfLDeSzhULjYQgNMYCgTr22/UeKFL9cXs/X9USbc=",
    {
      "./sink": "node_modules/pull-defer/sink.js",
      "./source": "node_modules/pull-defer/source.js",
      "./through": "node_modules/pull-defer/through.js"
    }
  ],
  "node_modules/pull-defer/sink.js": [
    "Ivy4eD14ohiB5WII4inwQwBjGoTms6fLdvA0Zm53s78=",
    {}
  ],
  "node_modules/pull-defer/source.js": [
    "30c9v2utt2sCEhl0MtgnsAkPPbR0Lx8gzVQCLhit4o4=",
    {}
  ],
  "node_modules/pull-defer/through.js": [
    "bDJXRfHwQQgCZLXZdgjYSo4HwvJzGOortTI8nFRPCeA=",
    {}
  ],
  "node_modules/pull-fs/core.js": [
    "K8ZPcklseHPK+Tf4w92pBUTWsYxXAzMGizaTAz0XbnU=",
    {
      "pull-split": "node_modules/pull-split/index.js",
      "pull-stream": "node_modules/pull-fs/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-fs/index.js": [
    "ap3iIy8iwWqq+wjloxfLq1T76n5Jxge27khF9jPmU2s=",
    {
      "./core": "node_modules/pull-fs/core.js",
      "./util": "node_modules/pull-fs/util.js"
    }
  ],
  "node_modules/pull-fs/node_modules/pull-stream/index.js": [
    "UXIBpQcqu1norAR3+X3cgevzgHnsylA/WGFh9VKvirI=",
    {
      "./maybe": "node_modules/pull-fs/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-fs/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-fs/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-fs/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-fs/node_modules/pull-stream/maybe.js": [
    "wdsdP/Kstw3RXP4Ua3U0oCMOIDlD6rDhdbKYiYyAKog=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-fs/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/pull-fs/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/pull-fs/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/pull-fs/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-fs/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-fs/util.js": [
    "Crin1SD/SJUBSV8jaTX5xHAFry2C+21LbfHLQxpfrEc=",
    {
      "./core": "node_modules/pull-fs/core.js",
      "pull-split": "node_modules/pull-split/index.js",
      "pull-stream": "node_modules/pull-fs/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-glob/index.js": [
    "Fju9JulzJl7g9KUH8Ulfa7fcoCCWfPTWbDwcISRFMGE=",
    {
      "pull-fs": "node_modules/pull-fs/index.js",
      "pull-stream": "node_modules/pull-glob/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-glob/node_modules/pull-stream/index.js": [
    "UXIBpQcqu1norAR3+X3cgevzgHnsylA/WGFh9VKvirI=",
    {
      "./maybe": "node_modules/pull-glob/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-glob/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-glob/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-glob/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-glob/node_modules/pull-stream/maybe.js": [
    "wdsdP/Kstw3RXP4Ua3U0oCMOIDlD6rDhdbKYiYyAKog=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-glob/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/pull-glob/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/pull-glob/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/pull-glob/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-glob/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-goodbye/endable.js": [
    "MPt8C16/vEjBz4HvZWE4nL0TRrByiC2xv/wtHIxN044=",
    {}
  ],
  "node_modules/pull-goodbye/index.js": [
    "dJExb2QIXWVtCYEVjUZImSHXrDegUkHDIbJ8QrcZBWM=",
    {
      "./endable": "node_modules/pull-goodbye/endable.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-handshake/index.js": [
    "ueV14TYb2vubMwSE6QQsR8k4pHI7HJtoZ/MH8xEPh5A=",
    {
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-defer": "node_modules/pull-handshake/node_modules/pull-defer/index.js",
      "pull-pair": "node_modules/pull-pair/index.js",
      "pull-pushable": "node_modules/pull-pushable/index.js",
      "pull-reader": "node_modules/pull-reader/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-handshake/node_modules/pull-defer/duplex.js": [
    "an9dxouVGOFt+pPYLCmIvQ3cMN+eGDewAEmBPGhlX6s=",
    {
      "./sink": "node_modules/pull-handshake/node_modules/pull-defer/sink.js",
      "./source": "node_modules/pull-handshake/node_modules/pull-defer/source.js"
    }
  ],
  "node_modules/pull-handshake/node_modules/pull-defer/index.js": [
    "Ec94syWZ8ZehXUFpWXfxPzgEuSAFW53cQ5rrsxA9vDg=",
    {
      "./duplex": "node_modules/pull-handshake/node_modules/pull-defer/duplex.js",
      "./sink": "node_modules/pull-handshake/node_modules/pull-defer/sink.js",
      "./source": "node_modules/pull-handshake/node_modules/pull-defer/source.js",
      "./through": "node_modules/pull-handshake/node_modules/pull-defer/through.js"
    }
  ],
  "node_modules/pull-handshake/node_modules/pull-defer/sink.js": [
    "Ivy4eD14ohiB5WII4inwQwBjGoTms6fLdvA0Zm53s78=",
    {}
  ],
  "node_modules/pull-handshake/node_modules/pull-defer/source.js": [
    "72XVPy+VsgaBUFvX4hmVSkng1lKVA5wGIBkU87syh+U=",
    {}
  ],
  "node_modules/pull-handshake/node_modules/pull-defer/through.js": [
    "bDJXRfHwQQgCZLXZdgjYSo4HwvJzGOortTI8nFRPCeA=",
    {}
  ],
  "node_modules/pull-inactivity/index.js": [
    "DexsfBUFsq5FHMjez4Z9JtGCPLm5JDOvFd6UNZIu7Cs=",
    {
      "./rate": "node_modules/pull-inactivity/rate.js",
      "pull-abortable": "node_modules/pull-abortable/index.js",
      "pull-stream": "node_modules/pull-inactivity/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-inactivity/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/pull-inactivity/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/pull-inactivity/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-inactivity/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-inactivity/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-inactivity/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-inactivity/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-inactivity/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/pull-inactivity/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-inactivity/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/pull-inactivity/node_modules/pull-stream/sources.js": [
    "VsEMAVfSnZ+1GDylFAK6HhnhGGV4I2xTkYWxF9t0KgY=",
    {}
  ],
  "node_modules/pull-inactivity/node_modules/pull-stream/throughs.js": [
    "PZDoywImBDx0kqFuCBJoRMdJKdK18hRBHkLun3eTMJ4=",
    {
      "./sinks": "node_modules/pull-inactivity/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-inactivity/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-inactivity/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-inactivity/rate.js": [
    "i7hs1ROQ5c8UpROCVPsG/HxeXhdrV8iusVB8W5UPuvk=",
    {
      "pull-stream": "node_modules/pull-inactivity/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-level/index.js": [
    "OCUK+m/XMENrewhaAdti/9mYmufhgZNjVKR+LehBuNs=",
    {
      "level-post": "node_modules/level-post/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-pushable": "node_modules/pull-level/node_modules/pull-pushable/index.js",
      "pull-stream": "node_modules/pull-level/node_modules/pull-stream/index.js",
      "pull-window": "node_modules/pull-window/index.js",
      "stream-to-pull-stream": "node_modules/pull-level/node_modules/stream-to-pull-stream/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-pushable/index.js": [
    "i75Y/DjTsHGMRJlMRBKaTrGKTXTOYICtCylf/isTMgI=",
    {
      "pull-stream": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/index.js": [
    "sXcqHGGdcqeUvIykBuV04nx7TY7lIdjbV9lu4Tav99o=",
    {
      "./maybe": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/maybe.js": [
    "vCCyswnkw68noYLJnNBZVw2ZQQLOawUjvfksXoijw6g=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-level/node_modules/pull-pushable/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/pull-level/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-level/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-level/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-level/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-level/node_modules/pull-stream/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/pull-level/node_modules/pull-stream/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/pull-stream/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/pull-level/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/pull-level/node_modules/pull-stream/sources.js": [
    "ye+ksu2cIdpcqpBHIJFw7xPLQazJFOLgrJ2ki+cIEt4=",
    {}
  ],
  "node_modules/pull-level/node_modules/pull-stream/throughs.js": [
    "HfzSWv797N1jtOQ2zUPDxBqxGbPp2ud3U4nN1sk8o2o=",
    {
      "./sinks": "node_modules/pull-level/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-level/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-level/node_modules/pull-stream/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-level/node_modules/stream-to-pull-stream/index.js": [
    "hWA5jrXKjWIZGapjaLs5KFl/LxT17QJ2Q5Kgpkb46wk=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-many/index.js": [
    "RlPhdIphX7MUYy+8s1d9Iix0VU074O4LrgWpwz7yF+s=",
    {}
  ],
  "node_modules/pull-notify/index.js": [
    "P5Sjk+0rMJ4NE3vfN59/AWUdUiOr8/elhZRxx91MBQw=",
    {
      "pull-pushable": "node_modules/pull-notify/node_modules/pull-pushable/index.js"
    }
  ],
  "node_modules/pull-notify/node_modules/pull-pushable/index.js": [
    "i75Y/DjTsHGMRJlMRBKaTrGKTXTOYICtCylf/isTMgI=",
    {
      "pull-stream": "node_modules/pull-notify/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-notify/node_modules/pull-stream/index.js": [
    "sXcqHGGdcqeUvIykBuV04nx7TY7lIdjbV9lu4Tav99o=",
    {
      "./maybe": "node_modules/pull-notify/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-notify/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-notify/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-notify/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-notify/node_modules/pull-stream/maybe.js": [
    "vCCyswnkw68noYLJnNBZVw2ZQQLOawUjvfksXoijw6g=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-notify/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/pull-notify/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/pull-notify/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/pull-notify/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-notify/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-pair/index.js": [
    "8It9l0trLHjLwFy+Qv3oPWTAEoErwSDL9wH5UIDmgGE=",
    {}
  ],
  "node_modules/pull-paramap/index.js": [
    "uu/PIKun3T30MMa1POykU8ehBSAYm/yy0MbZoJOOkek=",
    {
      "pull-stream": "node_modules/pull-paramap/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/pull-paramap/node_modules/pull-stream/index.js": [
    "UXIBpQcqu1norAR3+X3cgevzgHnsylA/WGFh9VKvirI=",
    {
      "./maybe": "node_modules/pull-paramap/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/pull-paramap/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-paramap/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-paramap/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-paramap/node_modules/pull-stream/maybe.js": [
    "wdsdP/Kstw3RXP4Ua3U0oCMOIDlD6rDhdbKYiYyAKog=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-paramap/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/pull-paramap/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/pull-paramap/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/pull-paramap/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-paramap/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/pull-ping/index.js": [
    "Ygd/2ZmAGygm+d3qRvI/4hmD/6thxJIyWAni6iDRFjA=",
    {
      "pull-pushable": "node_modules/pull-pushable/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "statistics": "node_modules/statistics/index.js"
    }
  ],
  "node_modules/pull-pushable/index.js": [
    "eexK2bbiaGfRtB61rj+aXSrxmlbAX3QfMv9TVXs11hc=",
    {}
  ],
  "node_modules/pull-reader/bl-state.js": [
    "VZrm/qFKpUbpXLdOvQa9cQ4RuB8AWEl/R0FQZSTmu6A=",
    {
      "bl": "node_modules/pull-reader/node_modules/bl/bl.js"
    }
  ],
  "node_modules/pull-reader/index.js": [
    "/jE9RYl/ubsAARvJ0XhP6UB08/r8UReouf6eyg58vuo=",
    {
      "./bl-state": "node_modules/pull-reader/bl-state.js"
    }
  ],
  "node_modules/pull-reader/node_modules/bl/bl.js": [
    "OrYNToTYMBilUu07SzPoW1JZ+oG+KL+kXegvMV9CjCc=",
    {
      "readable-stream/duplex": "node_modules/pull-reader/node_modules/readable-stream/duplex.js"
    }
  ],
  "node_modules/pull-reader/node_modules/isarray/index.js": [
    "m4xpE3KALaeIycX04covHtC4irhyIXbCrqFeOOyG0kk=",
    {}
  ],
  "node_modules/pull-reader/node_modules/readable-stream/duplex.js": [
    "2eoijFIkYbFr3sV8Z/yKK6KysVsx4ka5ds4pJWR528M=",
    {
      "./lib/_stream_duplex.js": "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_duplex.js"
    }
  ],
  "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_duplex.js": [
    "EQUOWX7Pu1S73njemTStK3KnASkdpJLaqk1t4SZNbwk=",
    {
      "./_stream_readable": "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_readable.js",
      "./_stream_writable": "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_writable.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js",
      "process-nextick-args": "node_modules/process-nextick-args/index.js"
    }
  ],
  "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_readable.js": [
    "m6AS/RrVbNagk0yZ7VYepMxyzuqC7CquDGee4lQfXkc=",
    {
      "./_stream_duplex": "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_duplex.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js",
      "isarray": "node_modules/pull-reader/node_modules/isarray/index.js",
      "process-nextick-args": "node_modules/process-nextick-args/index.js",
      "string_decoder/": "node_modules/string_decoder/index.js"
    }
  ],
  "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_writable.js": [
    "VfDYCpgyAb8hjK+9Wv3YewTxwdW+yg71eiJ23r6jgi4=",
    {
      "./_stream_duplex": "node_modules/pull-reader/node_modules/readable-stream/lib/_stream_duplex.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js",
      "process-nextick-args": "node_modules/process-nextick-args/index.js",
      "util-deprecate": "node_modules/util-deprecate/node.js"
    }
  ],
  "node_modules/pull-split/index.js": [
    "djG/C5jBgtYsQnanf/GoixGB+vZCqiu/PJYMoshkYp0=",
    {
      "pull-through": "node_modules/pull-through/index.js"
    }
  ],
  "node_modules/pull-stream/index.js": [
    "fJcQ979xu3COBdOgCeVzEM9WPBS2p8E6kIqZjrNSkgY=",
    {
      "./pull": "node_modules/pull-stream/pull.js",
      "./sinks": "node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/pull-stream/throughs.js"
    }
  ],
  "node_modules/pull-stream/pull.js": [
    "L95YTXfSPIo+UzYLicokHBJYqOXERzIwqqRVituYe40=",
    {}
  ],
  "node_modules/pull-stream/sinks.js": [
    "lKhJ5Mmc+x+PNwTHz0XD/JoAgiZhX9ZDmte/WKmaSOY=",
    {}
  ],
  "node_modules/pull-stream/sources.js": [
    "rkQ8ddGWXPYKU9rtSJEjLGMvOI45KX32dWOPe6Q0Hz4=",
    {}
  ],
  "node_modules/pull-stream/throughs.js": [
    "JiDq3TTh72unEa8io/h4/K4spOUvqsx33q7DNNgh5o4=",
    {
      "./sinks": "node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/pull-stream/sources.js"
    }
  ],
  "node_modules/pull-stringify/index.js": [
    "x6TQk/db5Vyx+e81teKg+4ft20ZkkF6RXGJfLb9QD0s=",
    {}
  ],
  "node_modules/pull-through/index.js": [
    "nE3FfVy09zeoqtOb2QPPhqMDmYweZPnssE1SJZU42xk=",
    {
      "looper": "node_modules/pull-through/node_modules/looper/index.js"
    }
  ],
  "node_modules/pull-through/node_modules/looper/index.js": [
    "cmcRqa+IsEsc2DIUeGXoK+grYAXQPGL4p7ftDNw4G6g=",
    {}
  ],
  "node_modules/pull-window/index.js": [
    "bYNzYibpIaLtH8GoFR/x2iKSULNSpoTREns6fvCLx7A=",
    {
      "looper": "node_modules/looper/index.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/rc/index.js": [
    "Oa9cTT4VO6tbR1dj7/CoSgWsf8kuz2ckFSdcssWBtKA=",
    {
      "./lib/utils": "node_modules/rc/lib/utils.js",
      "deep-extend": "node_modules/deep-extend/lib/deep-extend.js",
      "minimist": "node_modules/rc/node_modules/minimist/index.js"
    }
  ],
  "node_modules/rc/lib/utils.js": [
    "PAaTzAYpPRSJewAOLaGmErjMkmyZdxw6kdC1T75dmCE=",
    {
      "ini": "node_modules/ini/ini.js",
      "strip-json-comments": "node_modules/strip-json-comments/strip-json-comments.js"
    }
  ],
  "node_modules/rc/node_modules/minimist/index.js": [
    "VeEkjVfnqryqbxUNCx17+zBHU1JEsoDbTRoFhNgl6sM=",
    {}
  ],
  "node_modules/readable-stream/lib/_stream_duplex.js": [
    "3lJwn25LRrm78pI+sFAifvDAzp/AqgWWJN9GdwiVHmE=",
    {
      "./_stream_readable": "node_modules/readable-stream/lib/_stream_readable.js",
      "./_stream_writable": "node_modules/readable-stream/lib/_stream_writable.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js"
    }
  ],
  "node_modules/readable-stream/lib/_stream_passthrough.js": [
    "7XUAtdaqCviCG2r8jXp3s7GOQFmR9KBSMGQSdKEmmcA=",
    {
      "./_stream_transform": "node_modules/readable-stream/lib/_stream_transform.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js"
    }
  ],
  "node_modules/readable-stream/lib/_stream_readable.js": [
    "z7vA5SZqno/yi7pbhGUpO2LM3r6ylPYg1BXZAAmnP1w=",
    {
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js",
      "isarray": "node_modules/isarray/index.js",
      "string_decoder/": "node_modules/string_decoder/index.js"
    }
  ],
  "node_modules/readable-stream/lib/_stream_transform.js": [
    "oHkDWghwnaZ/de95LP9aOHd5b0YNSmYLTmHW5w+ANwE=",
    {
      "./_stream_duplex": "node_modules/readable-stream/lib/_stream_duplex.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js"
    }
  ],
  "node_modules/readable-stream/lib/_stream_writable.js": [
    "YvTDcG4MPZeDJV/mDDjsaByNy1BxVNaoXiDKl1sRluU=",
    {
      "./_stream_duplex": "node_modules/readable-stream/lib/_stream_duplex.js",
      "core-util-is": "node_modules/core-util-is/lib/util.js",
      "inherits": "node_modules/inherits/inherits.js"
    }
  ],
  "node_modules/readable-stream/readable.js": [
    "iyZIQa9fpAJWi1LGhuCZRH4TMZQVAG3AAUfP4A6xmRM=",
    {
      "./lib/_stream_duplex.js": "node_modules/readable-stream/lib/_stream_duplex.js",
      "./lib/_stream_passthrough.js": "node_modules/readable-stream/lib/_stream_passthrough.js",
      "./lib/_stream_readable.js": "node_modules/readable-stream/lib/_stream_readable.js",
      "./lib/_stream_transform.js": "node_modules/readable-stream/lib/_stream_transform.js",
      "./lib/_stream_writable.js": "node_modules/readable-stream/lib/_stream_writable.js"
    }
  ],
  "node_modules/remark-html/index.js": [
    "CCG7VfnVJmjiqojU3hIcpvXR16wywNOzElEGQTO0gNI=",
    {
      "./lib/compilers": "node_modules/remark-html/lib/compilers.js",
      "./lib/transformer": "node_modules/remark-html/lib/transformer.js"
    }
  ],
  "node_modules/remark-html/lib/compilers.js": [
    "bDc8i7r6H4gyCnypTyBvGRbkEntFS9wthfMPAAlmTB8=",
    {
      "./h.js": "node_modules/remark-html/lib/h.js",
      "collapse-white-space": "node_modules/collapse-white-space/index.js",
      "detab": "node_modules/detab/index.js",
      "normalize-uri": "node_modules/normalize-uri/index.js",
      "trim": "node_modules/trim/index.js",
      "trim-lines": "node_modules/trim-lines/index.js",
      "unist-util-visit": "node_modules/unist-util-visit/index.js"
    }
  ],
  "node_modules/remark-html/lib/h.js": [
    "AFvCeNe811ygBqy8kVeCFHjQEwL3wFS9UExrdvFsdls=",
    {
      "object-assign": "node_modules/object-assign/index.js"
    }
  ],
  "node_modules/remark-html/lib/transformer.js": [
    "I2taVnO+Xnbts77NgNtcH7gMPIYTPZPQVatsmTMyoV4=",
    {
      "unist-util-visit": "node_modules/unist-util-visit/index.js"
    }
  ],
  "node_modules/remark/index.js": [
    "nBwtMvs4nZJN90rnUYQJEZmjs/XZdFEHFFFa3bbP8+8=",
    {
      "./lib/escape.json": "node_modules/remark/lib/escape.json",
      "./lib/parse.js": "node_modules/remark/lib/parse.js",
      "./lib/stringify.js": "node_modules/remark/lib/stringify.js",
      "unified": "node_modules/unified/index.js"
    }
  ],
  "node_modules/remark/lib/block-elements.json": [
    "vSnCkYyNYWpG+Ca+/u3Wy3YaNbZMh/X2xJ6m1zdpA7o=",
    {}
  ],
  "node_modules/remark/lib/defaults.js": [
    "R9ZuMFYKxjmmMSPDytmCGNTazrY44ybnKjnA7TKOyJk=",
    {}
  ],
  "node_modules/remark/lib/escape.json": [
    "xhzjB9kvtafQZW074xYcey8fxAIzaOXRA11Px/gDlPc=",
    {}
  ],
  "node_modules/remark/lib/parse.js": [
    "isVbQv3rY55XubiVQRFR7motFxY8BFaaKiEnoDv27ss=",
    {
      "./block-elements.json": "node_modules/remark/lib/block-elements.json",
      "./defaults.js": "node_modules/remark/lib/defaults.js",
      "./utilities.js": "node_modules/remark/lib/utilities.js",
      "extend.js": "node_modules/extend.js/index.js",
      "parse-entities": "node_modules/parse-entities/index.js",
      "repeat-string": "node_modules/repeat-string/index.js",
      "trim": "node_modules/trim/index.js",
      "trim-trailing-lines": "node_modules/trim-trailing-lines/index.js"
    }
  ],
  "node_modules/remark/lib/stringify.js": [
    "AGhN3UloVJCnXog8WMFp0UBsK79/zGQ13nCSa2m8DtE=",
    {
      "./defaults.js": "node_modules/remark/lib/defaults.js",
      "./utilities.js": "node_modules/remark/lib/utilities.js",
      "ccount": "node_modules/ccount/index.js",
      "extend.js": "node_modules/extend.js/index.js",
      "longest-streak": "node_modules/longest-streak/index.js",
      "markdown-table": "node_modules/markdown-table/index.js",
      "parse-entities": "node_modules/parse-entities/index.js",
      "repeat-string": "node_modules/repeat-string/index.js",
      "stringify-entities": "node_modules/stringify-entities/index.js"
    }
  ],
  "node_modules/remark/lib/utilities.js": [
    "EHrxS/FWHzi1hI96G0cZaw3H1JjiFalRujwe4JtRmdk=",
    {
      "collapse-white-space": "node_modules/collapse-white-space/index.js"
    }
  ],
  "node_modules/repeat-string/index.js": [
    "+4mXwdNKLdyzt4FrUCluwPtl/j1FxhZM1EnsfQFKGeI=",
    {}
  ],
  "node_modules/rimraf/node_modules/glob/common.js": [
    "NrgusNWSj+tC7T7mjNi3av4lHuSRS1RjTi0Miewg8Vo=",
    {
      "minimatch": "node_modules/minimatch/minimatch.js",
      "path-is-absolute": "node_modules/path-is-absolute/index.js"
    }
  ],
  "node_modules/rimraf/node_modules/glob/glob.js": [
    "X/czNPPP6SHtDdPmH8KUCH2AfW0cdVfTBqGr7zTty04=",
    {
      "./common.js": "node_modules/rimraf/node_modules/glob/common.js",
      "./sync.js": "node_modules/rimraf/node_modules/glob/sync.js",
      "inflight": "node_modules/inflight/inflight.js",
      "inherits": "node_modules/inherits/inherits.js",
      "minimatch": "node_modules/minimatch/minimatch.js",
      "once": "node_modules/once/once.js",
      "path-is-absolute": "node_modules/path-is-absolute/index.js"
    }
  ],
  "node_modules/rimraf/node_modules/glob/sync.js": [
    "P23qVKyabQwgczTjXPp9kSOS+Opd38HO7X1pA51LTuQ=",
    {
      "./common.js": "node_modules/rimraf/node_modules/glob/common.js",
      "./glob.js": "node_modules/rimraf/node_modules/glob/glob.js",
      "minimatch": "node_modules/minimatch/minimatch.js",
      "path-is-absolute": "node_modules/path-is-absolute/index.js"
    }
  ],
  "node_modules/rimraf/rimraf.js": [
    "TwN904Pbk2x8kf0U+1KbO6uCGct232JweCOA9nSkiw4=",
    {
      "glob": "node_modules/rimraf/node_modules/glob/glob.js"
    }
  ],
  "node_modules/secret-handshake/handshake.js": [
    "ZVphO2Wydam0lfVtLNjQwiFEGAriKimAucbSJ9g8jtQ=",
    {
      "./state": "node_modules/secret-handshake/state.js",
      "pull-handshake": "node_modules/pull-handshake/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/secret-handshake/index.js": [
    "idbi74ue9H5hk3c8+1GwVZF2gsB/ERXMoaB6X+f7bQw=",
    {
      "./handshake": "node_modules/secret-handshake/handshake.js",
      "./secure": "node_modules/secret-handshake/secure.js"
    }
  ],
  "node_modules/secret-handshake/net.js": [
    "W9ZK9jX9K5O0exf3Esv3FIc/4ANSX6+V8LGr9UNZi/Y=",
    {
      "./": "node_modules/secret-handshake/index.js",
      "chloride": "node_modules/chloride/index.js",
      "pull-defer/duplex": "node_modules/secret-handshake/node_modules/pull-defer/duplex.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "stream-to-pull-stream": "node_modules/stream-to-pull-stream/index.js"
    }
  ],
  "node_modules/secret-handshake/node_modules/pull-defer/duplex.js": [
    "an9dxouVGOFt+pPYLCmIvQ3cMN+eGDewAEmBPGhlX6s=",
    {
      "./sink": "node_modules/secret-handshake/node_modules/pull-defer/sink.js",
      "./source": "node_modules/secret-handshake/node_modules/pull-defer/source.js"
    }
  ],
  "node_modules/secret-handshake/node_modules/pull-defer/sink.js": [
    "Ivy4eD14ohiB5WII4inwQwBjGoTms6fLdvA0Zm53s78=",
    {}
  ],
  "node_modules/secret-handshake/node_modules/pull-defer/source.js": [
    "72XVPy+VsgaBUFvX4hmVSkng1lKVA5wGIBkU87syh+U=",
    {}
  ],
  "node_modules/secret-handshake/secure.js": [
    "zfsmtutXvQPMAYfmqcRHiMhjzi1w+iaez3nSMzOGU/c=",
    {
      "chloride": "node_modules/chloride/index.js",
      "pull-box-stream": "node_modules/pull-box-stream/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/secret-handshake/state.js": [
    "XO4i6x9dyK06H1BrvHImoaIKgJIAUnVCXRb6HJ+RYIs=",
    {
      "chloride": "node_modules/chloride/index.js"
    }
  ],
  "node_modules/secret-stack/api.js": [
    "j1iN1Piliy2Kq5ORPhCwG4YM8nGvW3dmRrITB22TfPo=",
    {
      "./util": "node_modules/secret-stack/util.js",
      "hoox": "node_modules/hoox/index.js"
    }
  ],
  "node_modules/secret-stack/index.js": [
    "yFgr5ruSOE6cWQSe0eLQVKyZmkv1UcSoYTIHAl0sGlA=",
    {
      "./api": "node_modules/secret-stack/api.js",
      "./util": "node_modules/secret-stack/util.js",
      "muxrpc": "node_modules/muxrpc/index.js",
      "non-private-ip": "node_modules/secret-stack/node_modules/non-private-ip/index.js",
      "pull-inactivity": "node_modules/pull-inactivity/index.js",
      "pull-stream": "node_modules/secret-stack/node_modules/pull-stream/index.js",
      "secret-handshake/net": "node_modules/secret-handshake/net.js"
    }
  ],
  "node_modules/secret-stack/node_modules/non-private-ip/index.js": [
    "Aiof4cwLPSta1X4eOgc9moqQX2P/I4sJUCAvGWgJico=",
    {
      "ip": "node_modules/ip/lib/ip.js"
    }
  ],
  "node_modules/secret-stack/node_modules/pull-core/index.js": [
    "bq8mzr4iOX3LIcF3ylAM6E52feSAoMuk7JUnJBK6Rtc=",
    {}
  ],
  "node_modules/secret-stack/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/secret-stack/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/secret-stack/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secret-stack/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/secret-stack/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/secret-stack/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secret-stack/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/secret-stack/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secret-stack/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/secret-stack/node_modules/pull-stream/sources.js": [
    "ye+ksu2cIdpcqpBHIJFw7xPLQazJFOLgrJ2ki+cIEt4=",
    {}
  ],
  "node_modules/secret-stack/node_modules/pull-stream/throughs.js": [
    "PZDoywImBDx0kqFuCBJoRMdJKdK18hRBHkLun3eTMJ4=",
    {
      "./sinks": "node_modules/secret-stack/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secret-stack/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/secret-stack/node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secret-stack/util.js": [
    "EY8v1o/+TvrcfwIMsMmLnhgGYs06G+gtDTeCSTgybV8=",
    {
      "map-merge": "node_modules/map-merge/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/codec.js": [
    "6MFG4hJ+gurDRhTfiWy0fpUjAPLgUD4DV8gUNVmWlGo=",
    {}
  ],
  "node_modules/secure-scuttlebutt/create.js": [
    "N8f/jIHdxf2l5Qph+qBh6oc5h7KzLv8Sy7rl2ZlbXQc=",
    {
      "./": "node_modules/secure-scuttlebutt/index.js",
      "./defaults": "node_modules/secure-scuttlebutt/defaults.js",
      "level": "node_modules/level/level.js",
      "level-sublevel/bytewise": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/bytewise.js"
    }
  ],
  "node_modules/secure-scuttlebutt/defaults.js": [
    "aZEQb5NsYMvQpWY1OvcEuO+5Sj1FAlDq0NM5q8OPZFg=",
    {
      "./codec": "node_modules/secure-scuttlebutt/codec.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/index.js": [
    "W6LTmT8UTvH92ky4b8BVj2NvF6KykPKHctl1BcSfXFI=",
    {
      "./package.json": "node_modules/secure-scuttlebutt/package.json",
      "cont": "node_modules/cont/index.js",
      "explain-error": "node_modules/explain-error/index.js",
      "ltgt": "node_modules/ltgt/index.js",
      "monotonic-timestamp": "node_modules/monotonic-timestamp/index.js",
      "mynosql": "node_modules/mynosql/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-level": "node_modules/secure-scuttlebutt/node_modules/pull-level/index.js",
      "pull-paramap": "node_modules/pull-paramap/index.js",
      "pull-stream": "node_modules/secure-scuttlebutt/node_modules/pull-stream/index.js",
      "ssb-feed": "node_modules/ssb-feed/index.js",
      "ssb-feed/validator": "node_modules/ssb-feed/validator.js",
      "ssb-keys": "node_modules/ssb-keys/index.js",
      "ssb-msgs": "node_modules/ssb-msgs/index.js",
      "ssb-ref": "node_modules/ssb-ref/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/bytewise/encoding/binary.js": [
    "L1KJLWYAj835nhUrdAjhiRrXoy4RjuY2oDQvpFoEIto=",
    {
      "bytewise-core": "node_modules/bytewise-core/index.js",
      "typewise": "node_modules/typewise/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/bytewise/encoding/index.js": [
    "2HyRSyRfLvbUskSdeq07Yj83d3wHbC/HYHhgVkKHaY4=",
    {
      "./binary": "node_modules/secure-scuttlebutt/node_modules/bytewise/encoding/binary.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/bytewise/index.js": [
    "uNwDjIe0G/pqQkDX387KhuvYis119CPRrxqGUrYk+QY=",
    {
      "./encoding/": "node_modules/secure-scuttlebutt/node_modules/bytewise/encoding/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/bytewise.js": [
    "9dGszbFmGhoAFuEBf9blmEOvPXNqI+M7op9HRB2B7Mo=",
    {
      "./codec/bytewise": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/codec/bytewise.js",
      "./nut": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/nut.js",
      "./shell": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/shell.js",
      "levelup/lib/codec": "node_modules/levelup/lib/codec.js",
      "levelup/lib/read-stream": "node_modules/levelup/lib/read-stream.js",
      "typewiselite": "node_modules/typewiselite/index.js",
      "xtend": "node_modules/xtend/immutable.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/codec/bytewise.js": [
    "kHUk1iAy7Qi9Sc5XNIJ3nVD9jg1u0R2WIKJwmZF1au0=",
    {
      "bytewise": "node_modules/secure-scuttlebutt/node_modules/bytewise/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/hooks.js": [
    "t7uJRuDop5vyV48/YqqWK6g8n8YtIMp3B8sa2uv2+wg=",
    {
      "./range": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/range.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/node_modules/ltgt/index.js": [
    "ndz8xysNLoh8RKpifx147rp7hLl4ISMEYRchRAY8Hq4=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/nut.js": [
    "Zqy0Lw2YKPXlFFGbs/oagyalzIQxiarMajOra0kmFnc=",
    {
      "./hooks": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/hooks.js",
      "ltgt": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/node_modules/ltgt/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/package.json": [
    "+VQA95D4MRv//xKDq/6L6SzDVQfX46dZxXN/C8E0JhY=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/range.js": [
    "qdzmw1u79vk3uHg1fctAnXUBDtlOHUz/rw2Lildcq0E=",
    {
      "ltgt": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/node_modules/ltgt/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/level-sublevel/shell.js": [
    "qredUlYsK1dX/qhYl1PuZ7TmndbtJuvjGBIS9b5kJfA=",
    {
      "./package.json": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/package.json",
      "./range": "node_modules/secure-scuttlebutt/node_modules/level-sublevel/range.js",
      "levelup/lib/errors": "node_modules/levelup/lib/errors.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-level/index.js": [
    "wHEl+1S4GoCZlQLhMS8W20HJanQwoT+5dNDPuzDCJfk=",
    {
      "level-post": "node_modules/level-post/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-pushable": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/index.js",
      "pull-stream": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/index.js",
      "pull-window": "node_modules/pull-window/index.js",
      "stream-to-pull-stream": "node_modules/stream-to-pull-stream/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/index.js": [
    "fJcQ979xu3COBdOgCeVzEM9WPBS2p8E6kIqZjrNSkgY=",
    {
      "./pull": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/pull.js",
      "./sinks": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/throughs.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/pull.js": [
    "L95YTXfSPIo+UzYLicokHBJYqOXERzIwqqRVituYe40=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/sinks.js": [
    "lKhJ5Mmc+x+PNwTHz0XD/JoAgiZhX9ZDmte/WKmaSOY=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/sources.js": [
    "rkQ8ddGWXPYKU9rtSJEjLGMvOI45KX32dWOPe6Q0Hz4=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/throughs.js": [
    "JiDq3TTh72unEa8io/h4/K4spOUvqsx33q7DNNgh5o4=",
    {
      "./sinks": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secure-scuttlebutt/node_modules/pull-level/node_modules/pull-stream/sources.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-pushable/index.js": [
    "i75Y/DjTsHGMRJlMRBKaTrGKTXTOYICtCylf/isTMgI=",
    {
      "pull-stream": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/index.js": [
    "sXcqHGGdcqeUvIykBuV04nx7TY7lIdjbV9lu4Tav99o=",
    {
      "./maybe": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/maybe.js": [
    "vCCyswnkw68noYLJnNBZVw2ZQQLOawUjvfksXoijw6g=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/sinks.js": [
    "0Nurz67jz2urLT09FGrGdaI2mnOqQzWRtLBrmSUjrv4=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/sources.js": [
    "yi7cVon+ICXtdePNMTNtixdTg6i1Nb4bcBGJ8fJEioA=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/throughs.js": [
    "Jl57UZCK+uI805H8tHyXha2G0wULGgqMqO44zuYV9Xs=",
    {
      "./sinks": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secure-scuttlebutt/node_modules/pull-pushable/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-stream/index.js": [
    "qc2z+ybrnxaDyYx9pD2EzaWEHsh4vxVnQHNQ1aIgX8A=",
    {
      "./maybe": "node_modules/secure-scuttlebutt/node_modules/pull-stream/maybe.js",
      "./sinks": "node_modules/secure-scuttlebutt/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secure-scuttlebutt/node_modules/pull-stream/sources.js",
      "./throughs": "node_modules/secure-scuttlebutt/node_modules/pull-stream/throughs.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-stream/maybe.js": [
    "6RJSQKDbqDnA3l5dkMjCf5M/hxeARuxtj/riQL0RvvM=",
    {
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-stream/sinks.js": [
    "3W4jNfPym/TbvUSBRi9TCHTix0RDPazjVeNCCFqW6mw=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-stream/sources.js": [
    "hUNFvfmbnlJ2x524uul60HpFKDeCDGGqcZhvf3ag4wY=",
    {}
  ],
  "node_modules/secure-scuttlebutt/node_modules/pull-stream/throughs.js": [
    "AqVGCNrxVxtp4LhJsi+BzEUKQnv2xXCUhkK7hqxssS0=",
    {
      "./sinks": "node_modules/secure-scuttlebutt/node_modules/pull-stream/sinks.js",
      "./sources": "node_modules/secure-scuttlebutt/node_modules/pull-stream/sources.js",
      "pull-core": "node_modules/pull-core/index.js"
    }
  ],
  "node_modules/secure-scuttlebutt/package.json": [
    "wquF+8lbW7WDFMNIeOHz1jFucpFNxMnALj0MvFANFDU=",
    {}
  ],
  "node_modules/semver/semver.js": [
    "fwl9OubEPda7w0QMbyTfcvjVp4cpGe2J3kRdqeAn+8U=",
    {}
  ],
  "node_modules/sha.js/hash.js": [
    "WmiMLAqhIyzZ49drQNtJW0XZQCEuEwxGmeTVaXHXucY=",
    {}
  ],
  "node_modules/sha.js/sha256.js": [
    "AUxu/Cmmc0FX3M7yXM88JLsjfwjSfPBegwTEWDwbJq8=",
    {
      "./hash": "node_modules/sha.js/hash.js",
      "inherits": "node_modules/inherits/inherits.js"
    }
  ],
  "node_modules/sodium-browserify/browser.js": [
    "QbBAnlKjGwS4ho0HyZrUU5KmmrwJIm/uHDHweItcF7g=",
    {
      "libsodium-wrappers": "node_modules/libsodium-wrappers/dist/modules/libsodium-wrappers.js",
      "sha.js/sha256": "node_modules/sha.js/sha256.js"
    }
  ],
  "node_modules/sodium-browserify/index.js": [
    "kMWctOiqLccORn8/pujjHJQiVNhIlqNemBGzyI0oCpg=",
    {
      "./browser": "node_modules/sodium-browserify/browser.js"
    }
  ],
  "node_modules/split-buffer/index.js": [
    "5X5j7KPAcgFaVohmaU/64/2n+E9hM1rokDb3tZfWKxQ=",
    {}
  ],
  "node_modules/ssb-client/index.js": [
    "3YcQRTxLx5px2zYMUwTwuDOEkyyIkPrrvxfWVLimIB4=",
    {
      "explain-error": "node_modules/explain-error/index.js",
      "secret-stack": "node_modules/secret-stack/index.js",
      "ssb-config": "node_modules/ssb-client/node_modules/ssb-config/index.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "node_modules/ssb-client/node_modules/minimist/index.js": [
    "w88qquc08WFFsUzEn0tqyqr4GGbjxOffPchua/7v0HQ=",
    {}
  ],
  "node_modules/ssb-client/node_modules/non-private-ip/index.js": [
    "Aiof4cwLPSta1X4eOgc9moqQX2P/I4sJUCAvGWgJico=",
    {
      "ip": "node_modules/ip/lib/ip.js"
    }
  ],
  "node_modules/ssb-client/node_modules/rc/index.js": [
    "6mN7qg2JTTHuyVf5+ktg0HZ1NoNM7Y1FIsSbo/vFEA0=",
    {
      "./lib/utils": "node_modules/ssb-client/node_modules/rc/lib/utils.js",
      "deep-extend": "node_modules/ssb-client/node_modules/rc/node_modules/deep-extend/index.js",
      "minimist": "node_modules/ssb-client/node_modules/minimist/index.js"
    }
  ],
  "node_modules/ssb-client/node_modules/rc/lib/utils.js": [
    "ib7Q4JzfN+w6M5eS/h54RLJGHRQSVr/IzcVHvYk7r8I=",
    {
      "ini": "node_modules/ini/ini.js",
      "strip-json-comments": "node_modules/ssb-client/node_modules/strip-json-comments/strip-json-comments.js"
    }
  ],
  "node_modules/ssb-client/node_modules/rc/node_modules/deep-extend/index.js": [
    "Y8SANSpzUvF0ZNG71Ty/9x68C4fLGcOM1udPmjA8kqk=",
    {}
  ],
  "node_modules/ssb-client/node_modules/ssb-config/index.js": [
    "iKqYDfFKbruxu0Fa25YLgqBHhATPnQLI2olH5KWXjsI=",
    {
      "./inject": "node_modules/ssb-client/node_modules/ssb-config/inject.js"
    }
  ],
  "node_modules/ssb-client/node_modules/ssb-config/inject.js": [
    "c3ID2FYTPmynJDt0D+aTeRypUW+XX8JUDD5RCi0H2rM=",
    {
      "deep-extend": "node_modules/deep-extend/lib/deep-extend.js",
      "non-private-ip": "node_modules/ssb-client/node_modules/non-private-ip/index.js",
      "osenv": "node_modules/osenv/osenv.js",
      "rc": "node_modules/ssb-client/node_modules/rc/index.js"
    }
  ],
  "node_modules/ssb-client/node_modules/strip-json-comments/strip-json-comments.js": [
    "OJC3Y+gKyIbkUu7nAeMXXz1olqbUwuDoqcbylaZ7b6g=",
    {}
  ],
  "node_modules/ssb-config/inject.js": [
    "2RC/elF2uATerE/39k8kB6DW5ppOJNq4dpc23HhSNRE=",
    {
      "deep-extend": "node_modules/deep-extend/lib/deep-extend.js",
      "non-private-ip": "node_modules/ssb-config/node_modules/non-private-ip/index.js",
      "osenv": "node_modules/osenv/osenv.js",
      "rc": "node_modules/rc/index.js"
    }
  ],
  "node_modules/ssb-config/node_modules/non-private-ip/index.js": [
    "Aiof4cwLPSta1X4eOgc9moqQX2P/I4sJUCAvGWgJico=",
    {
      "ip": "node_modules/ip/lib/ip.js"
    }
  ],
  "node_modules/ssb-feed/index.js": [
    "/QrpZ6kratD60EWF/gunkTu9GlUc3W4+orm8S0F3OGc=",
    {
      "./util": "node_modules/ssb-feed/util.js",
      "cont": "node_modules/cont/index.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "node_modules/ssb-feed/util.js": [
    "nJfRXfWgSTdls0FUO3x9xt3zlb50ClqCtlApOsTWlOk=",
    {
      "monotonic-timestamp": "node_modules/monotonic-timestamp/index.js",
      "ssb-keys": "node_modules/ssb-keys/index.js",
      "ssb-ref": "node_modules/ssb-ref/index.js"
    }
  ],
  "node_modules/ssb-feed/validator.js": [
    "jEVc+z0ZgqBUBZ96CTIjnGzsTmnKS5WkAzgSIBxk01g=",
    {
      "./util": "node_modules/ssb-feed/util.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "node_modules/ssb-keys/eccjs.js": [
    "ehYsXs5R0lABf+amJUYjvniXLwtEZnaSOYB7PqSVOoE=",
    {
      "blake2s": "node_modules/blake2s/index.js"
    }
  ],
  "node_modules/ssb-keys/index.js": [
    "tDbAs49j9ovwfXFefks6g8aVeNAXPhjqvvI76klcL8w=",
    {
      "./eccjs": "node_modules/ssb-keys/eccjs.js",
      "./sodium": "node_modules/ssb-keys/sodium.js",
      "chloride": "node_modules/chloride/index.js",
      "deep-equal": "node_modules/ssb-keys/node_modules/deep-equal/index.js",
      "hmac": "node_modules/hmac/index.js",
      "mkdirp": "node_modules/mkdirp/index.js",
      "private-box": "node_modules/private-box/index.js",
      "ssb-ref": "node_modules/ssb-ref/index.js"
    }
  ],
  "node_modules/ssb-keys/node_modules/deep-equal/index.js": [
    "F0Hy3421FqiV544O5jyAgknHiyPqSjrY/NNPV6lKdfA=",
    {
      "./lib/is_arguments.js": "node_modules/ssb-keys/node_modules/deep-equal/lib/is_arguments.js",
      "./lib/keys.js": "node_modules/ssb-keys/node_modules/deep-equal/lib/keys.js"
    }
  ],
  "node_modules/ssb-keys/node_modules/deep-equal/lib/is_arguments.js": [
    "BaBU3XNYuC/dAjAHsmsNjoovvlJVJ9F8ErHT/fAfGqw=",
    {}
  ],
  "node_modules/ssb-keys/node_modules/deep-equal/lib/keys.js": [
    "iF+IIiN4G/UyyCNXe4oEivaRyrIDw/pgJAQCrp3pChw=",
    {}
  ],
  "node_modules/ssb-keys/sodium.js": [
    "6Cg83+tLiKtzu8++RwJc5ldk4w9G0yFc9U3W5YhJBXI=",
    {
      "chloride": "node_modules/chloride/index.js"
    }
  ],
  "node_modules/ssb-msgs/index.js": [
    "+eH9RChpQsBjv3By+lqFL3GP9hPkFjCAAoDQOfTF1Rs=",
    {
      "ssb-ref": "node_modules/ssb-ref/index.js"
    }
  ],
  "node_modules/ssb-ref/index.js": [
    "xSCQXbOC3qkuawgva0ywsnQjwkHUiheDkyJhbnlaLok=",
    {
      "ip-regex": "node_modules/ip-regex/index.js",
      "is-valid-domain": "node_modules/is-valid-domain/is-valid-domain.js"
    }
  ],
  "node_modules/statistics/index.js": [
    "aolUdv936jEVloODMTkigCDeZ1Olo7Qddu4mXyVZvws=",
    {}
  ],
  "node_modules/stream-to-pull-stream/index.js": [
    "hlg3SRSmw8Ur6dO6z2g3mgrBIM7GhPeh8oJDe6IHncU=",
    {
      "pull-stream/pull": "node_modules/pull-stream/pull.js"
    }
  ],
  "node_modules/string-range/index.js": [
    "tnbz8L8EtGjuxj9pHAAmytWBQczOjrfyA3ud1zNrXJk=",
    {}
  ],
  "node_modules/string_decoder/index.js": [
    "gKIYnJimHqSYfOZjXfjIaFBUqidMZy30uxz/AjsG+3Q=",
    {}
  ],
  "node_modules/stringify-entities/index.js": [
    "otM8QvULyYVzMFI9XM23DlX6C90Foz3Pk5mLi1pqvLc=",
    {
      "./lib/expression.js": "node_modules/stringify-entities/lib/expression.js",
      "character-entities-html4": "node_modules/character-entities-html4/index.js"
    }
  ],
  "node_modules/stringify-entities/lib/expression.js": [
    "w9xQZduclE0p2TaxGrvcL8dI3BWAXf9Cn0ryLsRFNfg=",
    {}
  ],
  "node_modules/strip-json-comments/strip-json-comments.js": [
    "Vxc0K5KObuGi8t/7fV9bw76ZJDNNL4NNbupciAiIgGk=",
    {}
  ],
  "node_modules/trim-lines/index.js": [
    "lnFYescKStjZ7BMzbQUuwmNMK7HQr3MAa1kNYcckMv4=",
    {}
  ],
  "node_modules/trim-trailing-lines/index.js": [
    "SgzHYHyCtp8nabeDFLt/quzO1EOBnJL8HcvdClUzNuE=",
    {}
  ],
  "node_modules/trim/index.js": [
    "mmieKglJNpsadwM4iSgXEayIyhxEIUwZxPXDnDXg6zQ=",
    {}
  ],
  "node_modules/typewise-core/base.js": [
    "kyqeUFNTWjvVxavKOw5LOdz8g5QWMXv3p8S6xZS7cTo=",
    {
      "./collation": "node_modules/typewise-core/collation.js"
    }
  ],
  "node_modules/typewise-core/collation.js": [
    "MQVuDgrI76qntvQrqUTYlK4JBM1Gi8RGICgtMySbaog=",
    {}
  ],
  "node_modules/typewise/base.js": [
    "NTk6rNF2KaxspTPm2FuaEhe+GLQf12wOpIeatNSqwYg=",
    {
      "./collation": "node_modules/typewise/collation.js",
      "typewise-core/base": "node_modules/typewise-core/base.js"
    }
  ],
  "node_modules/typewise/collation.js": [
    "cUUx3xsGWn1/AacfQFVmqU7IqYBZhB/mOgmOeGtwMVQ=",
    {
      "typewise-core/collation": "node_modules/typewise-core/collation.js"
    }
  ],
  "node_modules/typewise/index.js": [
    "kjwiLuBIqcfA8RLq2UMSLPUO0lKtt3Z5eU95+NY5wlM=",
    {
      "./base": "node_modules/typewise/base.js"
    }
  ],
  "node_modules/typewiselite/index.js": [
    "3TZB2m/ZDk8f7T/1Yp66wuhMydajJoY6l2d0tEc5axk=",
    {}
  ],
  "node_modules/unherit/index.js": [
    "ebjtEBu1j2MDcqBglWUZnTjrsjGA/EpV1DmPR9ynwUI=",
    {
      "clone": "node_modules/clone/clone.js",
      "inherits": "node_modules/inherits/inherits.js"
    }
  ],
  "node_modules/unified/index.js": [
    "7AG6LenLiaAQo3pWlVjhtoxeri4Fsohwfw54YAtJhKo=",
    {
      "attach-ware": "node_modules/attach-ware/index.js",
      "bail": "node_modules/bail/index.js",
      "extend": "node_modules/extend/index.js",
      "unherit": "node_modules/unherit/index.js",
      "vfile": "node_modules/vfile/index.js",
      "ware": "node_modules/ware/lib/index.js"
    }
  ],
  "node_modules/unist-util-visit/index.js": [
    "tiuKW7cxwl3Zxn3EOQgkNsLKM0Ab2Hk2pjuilaLNG/o=",
    {}
  ],
  "node_modules/util-deprecate/node.js": [
    "moain6NKmbhh5wc0X7HR4uVabCPtuPmSvtV8xgf0LY4=",
    {}
  ],
  "node_modules/vfile/index.js": [
    "6SOB1EXRn1YZyG1xe1IcfW4hTT6etRjZZ6ugaBu+rEs=",
    {}
  ],
  "node_modules/ware/lib/index.js": [
    "OxrH6ISJxYUK85T47M9jPqLrR9SEojc1uXgKH2NDTHA=",
    {
      "wrap-fn": "node_modules/wrap-fn/index.js"
    }
  ],
  "node_modules/word-wrap/index.js": [
    "LMQxJicX49Ft3e9Rk6mjx04nKVIZInlSC0ovJ7iarMk=",
    {}
  ],
  "node_modules/wrap-fn/index.js": [
    "/DGy1muQpyr4d4O3oag8dsE6CDHRiBeH/B+qRvYKFZ4=",
    {
      "co": "node_modules/co/index.js"
    }
  ],
  "node_modules/wrappy/wrappy.js": [
    "FTRTxNhKPC8TWJw3BVp9r/YdSEddzOVU9+7a0V/Hs+U=",
    {}
  ],
  "node_modules/xtend/immutable.js": [
    "BJhvFouPFvTyUjfQYIzfV7bKFPEA/tYsApW9olWasks=",
    {}
  ],
  "node_modules/zerr/index.js": [
    "ifH0V1MmKcBhIyGfGe4MmbZlvz9DhamKNbgsS9M4TD4=",
    {}
  ],
  "package.json": [
    "e65U0US9WQREHH2+n3aFvYJVSCSGiBdA8QmnvN+VxBk=",
    {}
  ],
  "plugins/blobs/index.js": [
    "Ahj5MOWAc3zLSPmCu+tk09wAk00L3ACy/9cMQiayvUg=",
    {
      "../../lib/apidocs": "lib/apidocs.js",
      "../../lib/validators": "lib/validators.js",
      "./quota": "plugins/blobs/quota.js",
      "./replication": "plugins/blobs/replication.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "multiblob": "node_modules/multiblob/index.js",
      "pull-notify": "node_modules/pull-notify/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "ssb-ref": "node_modules/ssb-ref/index.js"
    }
  ],
  "plugins/blobs/queue.js": [
    "sYYh8iTlgmQnvaj5q28F3GpYLhBlvNuOJCz1FSRsRL8=",
    {}
  ],
  "plugins/blobs/quota.js": [
    "YvXzIl17mGQOhwd/k52N/lK3o/e2qw3npQdBLvbjdu4=",
    {
      "pull-paramap": "node_modules/pull-paramap/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "plugins/blobs/replication.js": [
    "AbPXrX3k5ewZpKfUv2eCaF2LR8rtRdZZE+blrCXeo9o=",
    {
      "./queue": "plugins/blobs/queue.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "plugins/block.js": [
    "ASDCxahJ+Or7CgLG3GNNAJoIL7PCdeAgI6EXsMNVwck=",
    {
      "../lib/validators": "lib/validators.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "plugins/friends.js": [
    "dExQ/iUTH58eRBQlgKuvDTqkq6YXtil9WVSvlx4tbs8=",
    {
      "../lib/apidocs": "lib/apidocs.js",
      "../lib/validators": "lib/validators.js",
      "graphmitter": "node_modules/graphmitter/index.js",
      "level-memview": "node_modules/level-memview/index.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "pull-pushable": "node_modules/pull-pushable/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "ssb-msgs": "node_modules/ssb-msgs/index.js"
    }
  ],
  "plugins/gossip/index.js": [
    "o5GlwujrnSLBqr/E1nzhxZiDaueCM5Clg2I7lg6QaHc=",
    {
      "../../lib/apidocs": "lib/apidocs.js",
      "../../lib/util": "lib/util.js",
      "../../lib/validators": "lib/validators.js",
      "./init": "plugins/gossip/init.js",
      "./schedule": "plugins/gossip/schedule.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "pull-notify": "node_modules/pull-notify/index.js",
      "pull-ping": "node_modules/pull-ping/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "statistics": "node_modules/statistics/index.js"
    }
  ],
  "plugins/gossip/init.js": [
    "p7QKOhmTGfBiDlhaPpzaNJvNy31EUOIzmap7gRRyYo0=",
    {
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ],
  "plugins/gossip/schedule.js": [
    "hTH3Xn8niO+dYBJysjbstnudz8KRtu4AGmheqk/DxAs=",
    {
      "../../lib/util": "lib/util.js",
      "ip": "node_modules/ip/lib/ip.js",
      "non-private-ip": "node_modules/non-private-ip/index.js",
      "on-wakeup": "node_modules/on-wakeup/index.js",
      "pull-stream": "node_modules/pull-stream/index.js",
      "statistics": "node_modules/statistics/index.js"
    }
  ],
  "plugins/invite.js": [
    "yEJoEo5nWIxGBHGWDU3uw4ahLuNMPhIHA+K5+p3pg/E=",
    {
      "../lib/apidocs": "lib/apidocs.js",
      "../lib/util": "lib/util.js",
      "../lib/validators": "lib/validators.js",
      "cont": "node_modules/cont/index.js",
      "explain-error": "node_modules/explain-error/index.js",
      "ip": "node_modules/ip/lib/ip.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "plugins/local.js": [
    "2dZpnXaBuFy0yVSQdKMtPSMDtfIh2XYk0nENBqp17Zg=",
    {
      "broadcast-stream": "node_modules/broadcast-stream/index.js"
    }
  ],
  "plugins/logging.js": [
    "O3u8m0ktqGMfJKI7Vof4O4v8UpFgpqewAc8X5/68m6Y=",
    {
      "bash-color": "node_modules/bash-color/index.js"
    }
  ],
  "plugins/master.js": [
    "zXiSEqjSjF1a8LhdARoR44gmjdICViuF8nex7tho8tY=",
    {}
  ],
  "plugins/private.js": [
    "wyotRMgiBLpCa4fOOHKmOoVgVKMkmJhaCywMPXvnkvg=",
    {
      "../lib/apidocs": "lib/apidocs.js",
      "../lib/validators": "lib/validators.js",
      "explain-error": "node_modules/explain-error/index.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "ssb-keys": "node_modules/ssb-keys/index.js"
    }
  ],
  "plugins/replicate.js": [
    "7UsKlENzswR8cwTI8PFKkhEi8//PslbP4O7DAr9pKpQ=",
    {
      "../lib/apidocs": "lib/apidocs.js",
      "mdmanifest": "node_modules/mdmanifest/index.js",
      "observ": "node_modules/observ/index.js",
      "observ-debounce": "node_modules/observ-debounce/index.js",
      "pull-abortable": "node_modules/pull-abortable/index.js",
      "pull-cat": "node_modules/pull-cat/index.js",
      "pull-many": "node_modules/pull-many/index.js",
      "pull-notify": "node_modules/pull-notify/index.js",
      "pull-paramap": "node_modules/pull-paramap/index.js",
      "pull-stream": "node_modules/pull-stream/index.js"
    }
  ]
},
"bin.js")
